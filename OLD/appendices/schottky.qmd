

# Schottky Groups, Möbius Maps, and GLSL



## 1. Schottky groups in one picture

A (classical) Schottky group of rank $g$ is built from $2g$ disjoint Jordan curves (we use circles) on the Riemann sphere. We pair them up $(C_1, C_1'), \dots, (C_g, C_g')$, and for each pair we choose a Möbius map that sends the exterior of $C_i$ to the interior of $C_i'$. The group generated by these $g$ maps is free and discrete.

So the fundamental move is:

* pick two circles,
* send exterior of the first to interior of the second,
* (optionally) rotate inside the second.

That is exactly the move we will encode in GLSL.

<!-- ![Mapping the exterior of one circle to the interior of another](figs/schottky_geometry_two_circles.png) -->

---

## 2. The geometry: from two circles to a Möbius map

Let

* Circle 1: center $c_1 \in \mathbb C$, radius $r_1 > 0$
* Circle 2: center $c_2 \in \mathbb C$, radius $r_2 > 0$

We want a Möbius map $f$ with the property

* if $|z - c_1| > r_1$ (outside circle 1) then $|f(z) - c_2| < r_2$ (inside circle 2).

There is a standard 3-step recipe:

1. Normalize circle 1 to the unit circle:
   $$
   T_1(z) = \frac{z - c_1}{r_1}.
   $$

2. Invert in the unit circle (this swaps inside and outside):
   $$
   J(w) = \frac{1}{w}.
   $$

3. Denormalize to circle 2:
   $$
   T_2^{-1}(w) = c_2 + r_2 w.
   $$

So the Möbius map is
$$
f(z) = T_2^{-1}( J( T_1(z) ) ) = c_2 + \frac{r_1 r_2}{z - c_1}.
$$

This is already in closed form:

$$
\boxed{ f(z) = c_2 + \frac{r_1 r_2}{z - c_1} }.
$$

You can check: if $|z - c_1| > r_1$ then $\left| \frac{r_1}{z - c_1} \right| < 1$ so $|f(z) - c_2| = r_2 \left|\frac{r_1}{z - c_1}\right| < r_2$.

---

## 3. Complex numbers and circles in GLSL

GLSL doesn’t have complex numbers, so we’ll use `vec2` everywhere. We *do* want to write things in complex style (multiply, divide, take sqrt), so let’s define those once.

```glsl
// -----------------------------------------
// complex helpers
// -----------------------------------------
vec2 cadd(vec2 a, vec2 b) { return a + b; }
vec2 csub(vec2 a, vec2 b) { return a - b; }

vec2 cmul(vec2 a, vec2 b) {
    // (a.x + i a.y)(b.x + i b.y)
    return vec2(a.x*b.x - a.y*b.y,
                a.x*b.y + a.y*b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    // a / b = a * conj(b) / |b|^2
    float d = dot(b, b);
    return vec2( (a.x*b.x + a.y*b.y) / d,
                 (a.y*b.x - a.x*b.y) / d );
}

vec2 cfloat(float x) {
    return vec2(x, 0.0);
}
```

Let’s also define a circle struct:

```glsl
// -----------------------------------------
// circle data
// -----------------------------------------
struct Circle {
    vec2 center;
    float radius;
};
```

We will carry this struct through the whole document.

---

## 4. The geometric Schottky map in GLSL

Let’s translate the exact 3-step recipe:

1. circle → unit circle,
2. invert in unit circle,
3. unit circle → circle.

We also add a rotation at the end (useful in Schottky generators).

```glsl
// map arbitrary circle to unit circle
vec2 toUnitCircle(vec2 z, Circle c) {
    return (z - c.center) / c.radius;
}

// map unit circle to arbitrary circle
vec2 fromUnitCircle(vec2 w, Circle c) {
    return c.radius * w + c.center;
}

// inversion in unit circle
vec2 invertUnit(vec2 w) {
    return cdiv(vec2(1.0, 0.0), w);
}
```

Now the Schottky generator:

```glsl
// schottky-like map: exterior(A) -> interior(B)
// rotation is angle in radians applied INSIDE B
// scale is an inout used for distance estimation later
vec2 schottkyMap(vec2 z, Circle A, Circle B, float rotation, inout float scale) {
    // step 1: normalize to A
    vec2 zA = toUnitCircle(z, A);

    // derivative of inversion: |d(1/z)| = 1/|z|^2
    float inversionScale = 1.0 / dot(zA, zA);

    // step 2: invert
    vec2 inv = invertUnit(zA);

    // step 3: map to B
    vec2 inB = fromUnitCircle(inv, B);

    // total radius scale = r2 / r1
    float radiusScale = B.radius / A.radius;
    scale *= inversionScale * radiusScale;

    // step 4: rotate inside B
    vec2 unitB = (inB - B.center) / B.radius;
    float c = cos(rotation);
    float s = sin(rotation);
    vec2 rotated = vec2(c*unitB.x - s*unitB.y,
                        s*unitB.x + c*unitB.y);

    return B.center + B.radius * rotated;
}
```

This is the pedagogical version: each line corresponds to something we can draw on the board.

---

## 5. Fixed points and the loxodromic axis

Given
$$
f(z) = c_2 + \frac{r_1 r_2}{z - c_1},
$$
solve $f(z) = z$:

[
(z - c_1)(z - c_2) = r_1 r_2
]
[
z^2 - (c_1 + c_2)z + c_1 c_2 - r_1 r_2 = 0.
]

So
$$
z = \frac{c_1 + c_2 \pm \sqrt{(c_1 - c_2)^2 + 4 r_1 r_2}}{2}.
$$

Those two solutions are the endpoints of the axis — in $\widehat{\mathbb C}$ these are just two points, but in $\mathbb H^3$ they determine the unique geodesic the map acts along.

We need a complex sqrt:

```glsl
// principal complex square root
vec2 csqrt(vec2 z) {
    float r = length(z);
    float t = sqrt(0.5*(r + z.x));
    float s = (z.y >= 0.0)
        ? sqrt(0.5*(r - z.x))
        : -sqrt(0.5*(r - z.x));
    return vec2(t, s);
}
```

Now the fixed points:

```glsl
void schottkyEndpoints(Circle A, Circle B,
                       out vec2 zPlus, out vec2 zMinus, out vec2 Delta)
{
    vec2 c1 = A.center;
    vec2 c2 = B.center;
    float r1 = A.radius;
    float r2 = B.radius;

    vec2 sum   = c1 + c2;
    vec2 diff  = c1 - c2;
    vec2 diff2 = cmul(diff, diff);

    Delta = csqrt( diff2 + cfloat(4.0 * r1 * r2) );

    zPlus  = 0.5 * (sum + Delta);
    zMinus = 0.5 * (sum - Delta);
}
```

We’ll call these `pPlus` and `pMinus` or `p_+`, `p_-`.

---

## 6. Conjugation and the 1-parameter flow

Every loxodromic Möbius transformation with fixed points $p_-$ and $p_+$ can be conjugated to $w \mapsto \lambda w$, i.e. a pure dilation/spiral fixing $0$ and $\infty$.

Define
$$
h(z) = \frac{z - p_-}{z - p_+}.
$$

Then
$$
g = h \circ f \circ h^{-1}
$$
fixes $0$ and $\infty$, so $g(w) = \lambda w$ for some $\lambda \in \mathbb C^\times$.

To animate, define
$$
g_t(w) = \lambda^t w, \quad f_t = h^{-1} \circ g_t \circ h.
$$

So the movie is
$$
f_t(z) = h^{-1}( \lambda^t h(z) ).
$$

We already wrote `csqrt`. Now write the conjugators and complex log/exp:

```glsl
vec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {
    return cdiv(z - pMinus, z - pPlus);
}

vec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {
    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));
}

// complex log
vec2 clogc(vec2 z) {
    float r = length(z);
    float th = atan(z.y, z.x);
    return vec2(log(r), th);
}

// complex exp
vec2 cexpc(vec2 z) {
    float ex = exp(z.x);
    return vec2(ex * cos(z.y), ex * sin(z.y));
}
```

We also need the multiplier. From the derivation:

$$
\lambda = - \frac{4 r_1 r_2}{(c_2 - c_1 - \Delta)^2}
$$

so

```glsl
vec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {
    vec2 c1 = A.center;
    vec2 c2 = B.center;
    float r1 = A.radius;
    float r2 = B.radius;

    vec2 denom  = (c2 - c1) - Delta;
    vec2 denom2 = cmul(denom, denom);
    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);
    return cdiv(num, denom2);
}
```

Finally the flow:

```glsl
vec2 schottkyFlow(vec2 z,
                  vec2 pPlus, vec2 pMinus,
                  vec2 lambda,
                  float t)
{
    // lambda^t = exp(t * log(lambda))
    vec2 loglam = clogc(lambda);
    vec2 lam_t  = cexpc(t * loglam);

    vec2 w  = hMap(z, pPlus, pMinus);
    vec2 w2 = cmul(lam_t, w);
    return hInv(w2, pPlus, pMinus);
}
```

So now we have every mathematical piece.

---

## 7. Full shader 1: animated single identification

This is a complete Shadertoy-style fragment shader that:

* defines two circles;
* computes their loxodromic map;
* finds the fixed points;
* animates the identification by applying $f_t$ to sample points on circle 1;
* draws the circles and the fixed points.

You can paste this as-is into Shadertoy.

```glsl
// =========================================
// Shader 1: animated Schottky identification
// =========================================

struct Circle {
    vec2 center;
    float radius;
};

vec2 cadd(vec2 a, vec2 b) { return a + b; }
vec2 csub(vec2 a, vec2 b) { return a - b; }
vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
}
vec2 cdiv(vec2 a, vec2 b) {
    float d = dot(b, b);
    return vec2((a.x*b.x + a.y*b.y)/d,
                (a.y*b.x - a.x*b.y)/d);
}
vec2 cfloat(float x) { return vec2(x,0.0); }

vec2 csqrt(vec2 z) {
    float r = length(z);
    float t = sqrt(0.5*(r + z.x));
    float s = (z.y >= 0.0) ? sqrt(0.5*(r - z.x)) : -sqrt(0.5*(r - z.x));
    return vec2(t, s);
}

void schottkyEndpoints(Circle A, Circle B,
                       out vec2 pPlus, out vec2 pMinus, out vec2 Delta)
{
    vec2 c1 = A.center;
    vec2 c2 = B.center;
    float r1 = A.radius;
    float r2 = B.radius;
    vec2 sum   = c1 + c2;
    vec2 diff  = c1 - c2;
    vec2 diff2 = cmul(diff, diff);
    Delta  = csqrt( diff2 + cfloat(4.0 * r1 * r2) );
    pPlus  = 0.5 * (sum + Delta);
    pMinus = 0.5 * (sum - Delta);
}

vec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {
    vec2 c1 = A.center;
    vec2 c2 = B.center;
    float r1 = A.radius;
    float r2 = B.radius;
    vec2 denom  = (c2 - c1) - Delta;
    vec2 denom2 = cmul(denom, denom);
    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);
    return cdiv(num, denom2);
}

vec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {
    return cdiv(z - pMinus, z - pPlus);
}
vec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {
    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));
}
vec2 clogc(vec2 z) {
    float r = length(z);
    float th = atan(z.y, z.x);
    return vec2(log(r), th);
}
vec2 cexpc(vec2 z) {
    float ex = exp(z.x);
    return vec2(ex * cos(z.y), ex * sin(z.y));
}
vec2 schottkyFlow(vec2 z, vec2 pPlus, vec2 pMinus, vec2 lambda, float t) {
    vec2 loglam = clogc(lambda);
    vec2 lam_t  = cexpc(t * loglam);
    vec2 w  = hMap(z, pPlus, pMinus);
    vec2 w2 = cmul(lam_t, w);
    return hInv(w2, pPlus, pMinus);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // map screen to complex plane
    vec2 uv = fragCoord / iResolution.xy;
    float aspect = iResolution.x / iResolution.y;
    float zoom = 1.8;
    vec2 z = vec2(
        (uv.x - 0.5) * 2.0 * zoom * aspect,
        (uv.y - 0.5) * 2.0 * zoom
    );

    // define two circles
    Circle A;
    A.center = vec2(-0.6, 0.1);
    A.radius = 0.35;

    Circle B;
    B.center = vec2(0.7, -0.15);
    B.radius = 0.45;

    // fixed points and lambda
    vec2 pPlus, pMinus, Delta;
    schottkyEndpoints(A, B, pPlus, pMinus, Delta);
    vec2 lambda = schottkyLambda(A, B, Delta);

    // time parameter in [0,1]
    float t = 0.5 + 0.5 * sin(iTime * 0.7);

    // background
    vec3 col = vec3(0.95);

    // draw circles
    float dA = abs(length(z - A.center) - A.radius);
    float dB = abs(length(z - B.center) - B.radius);
    col = mix(col, vec3(0.1,0.3,0.9), smoothstep(0.005, 0.0, dA));
    col = mix(col, vec3(0.9,0.2,0.2), smoothstep(0.005, 0.0, dB));

    // draw fixed points
    float f1 = smoothstep(0.03, 0.0, length(z - pPlus));
    float f2 = smoothstep(0.03, 0.0, length(z - pMinus));
    col = mix(col, vec3(1.0,0.8,0.0), f1);
    col = mix(col, vec3(0.0,0.8,0.2), f2);

    // draw moving image of circle A as dots
    float imgMask = 0.0;
    const int N = 80;
    for (int i = 0; i < N; i++) {
        float ang = 6.2831853 * float(i) / float(N);
        vec2 pt = A.center + A.radius * vec2(cos(ang), sin(ang));
        vec2 imgPt = schottkyFlow(pt, pPlus, pMinus, lambda, t);
        float m = smoothstep(0.03, 0.0, length(z - imgPt));
        imgMask = max(imgMask, m);
    }
    col = mix(col, vec3(0.35, 0.05, 0.6), imgMask);

    fragColor = vec4(col, 1.0);
}
```

That’s a complete first shader.


## Drawing the Limit Set of a Schottky Group

These notes continue our exploration of Möbius transformations in GLSL, now focusing on **Schottky groups**—the simplest discrete groups of Möbius transformations—and how to visualize their **limit sets** using shader iteration.

Our audience is assumed to know hyperbolic geometry and group theory but to be new to GPU programming. We’ll therefore explain everything twice: once mathematically, and once as a computational recipe.


## 1. What We Are Drawing, Mathematically

Let $\Gamma \subset \mathrm{PSL}(2,\mathbb{C})$ be a finitely generated group of Möbius transformations. For any point $z_0 \in \widehat{\mathbb{C}}$, its **orbit** under $\Gamma$ is

$$
\Gamma z_0 = \{ g(z_0) : g \in \Gamma \}.
$$

The **limit set** of $\Gamma$ is the closure of this orbit:

$$
\Lambda(\Gamma) = \overline{ \Gamma z_0 }.
$$

For a *classical Schottky group*—generated by finitely many loxodromic Möbius transformations each identifying two disjoint circles—the limit set $\Lambda(\Gamma)$ is a Cantor-like subset of the sphere at infinity. The complement $\Omega = \widehat{\mathbb{C}} \setminus \Lambda(\Gamma)$ is the **domain of discontinuity**, on which $\Gamma$ acts properly discontinuously.

We can visualize $\Lambda(\Gamma)$ by **testing points** in the complex plane: points that escape the system of circles belong to $\Omega$, while points that never escape approximate the limit set.

::: {#fig-schottky-pairs}
_Figure: Two pairs of disjoint circles generate a rank-2 Schottky group. Arrows indicate how each pair is identified by a loxodromic Möbius transformation._
:::

---

## 2. Thinking Algorithmically

Imagine throwing a dart at the complex plane: you hit a point $z$. We now repeatedly apply the Schottky generators to fold the plane back into the fundamental domain.

If $z$ lands inside one of the paired circles $C_i$ (say the “interior” circle of generator $A_i$), we apply the Möbius transformation $A_i$ to move it to the paired exterior circle $C_i'$.
If it lands inside $C_i'$, we apply $A_i^{-1}$ instead.

If after a few steps the point leaves all circles, we say it **escaped** (it lies in $\Omega$). If it never escapes, it’s likely in or near the limit set.

### Pseudocode

```text
for each pixel z:
    scale = 1
    color = white
    for k = 1..N:
        if z inside A.interior:   z = A(z)
        elif z inside A.exterior: z = A^{-1}(z)
        elif z inside B.interior: z = B(z)
        elif z inside B.exterior: z = B^{-1}(z)
        else: break
```

The loop terminates when the point leaves all circles, or after a fixed number of steps.

The **color** records which generator acted last; the **scale** tracks the cumulative derivative $|f'(z)|$ and will later give us a distance estimate.

---

## 3. From Mathematics to Pixels

Each pixel on screen represents a complex number $z = x + iy$.

The shader’s main loop implements exactly the pseudocode above. It repeatedly applies the Möbius generators and their inverses to test how the orbit of $z$ behaves.

- If $z$ escapes, it belongs to the bright background (domain of discontinuity).
- If $z$ stays trapped, it’s near the dark filigree of the limit set.

::: {#fig-limitset-dynamics}
_Figure: Each pixel represents a complex point $z$. The shader iterates Möbius generators to decide whether it escapes (white) or remains trapped (black)._ 
:::

We color pixels by which generator last acted, creating the characteristic red-blue pattern of a two-generator Schottky group.

---

## 4. Distance Estimation and Smooth Boundaries

If we merely colored points as “in” or “out,” the boundary would look jagged. To smooth it, we use **distance estimation**.

For a Möbius map
$$
f(z) = c_2 + \frac{r_1 r_2}{z - c_1},
$$
the derivative is
$$
f'(z) = -\frac{r_1 r_2}{(z - c_1)^2}, \qquad |f'(z)| = \frac{r_1 r_2}{|z - c_1|^2}.
$$

After $n$ iterations the total contraction factor is

$$
S_n = \prod_{k=0}^{n-1} |f'_k(z_k)|.
$$

This $S_n$ tells us how much a small neighborhood around $z$ has been rescaled by the group action. The smaller $S_n$, the closer we are to the limit set.

In practice, we track a variable `scale` such that `scale *= 1/|z|^2` each time we invert a circle, then multiply by the ratio of circle radii. The **estimated distance** to the limit set is

$$
d \approx \frac{ \text{distance to nearest circle} }{ S_n }.
$$

This gives a smooth measure of proximity, allowing us to use `smoothstep` to render crisp boundaries.

---

## 5. Implementing the Algorithm Step-by-Step

We now translate this logic into GLSL, one piece at a time.

### 5.1. Circles and Generators

Each generator pairs two circles—an “interior” and an “exterior”—and carries a rotation angle for the twist in the identification.

```glsl
struct Circle {
    vec2 center;
    float radius;
};

struct Generator {
    Circle interior;
    Circle exterior;
    float rotation;
    vec3 color;
};
```

### 5.2. Core Geometry Operations

```glsl
bool isInsideCircle(vec2 z, Circle c) {
    return length(z - c.center) < c.radius;
}

float distanceToCircle(vec2 z, Circle c) {
    return length(z - c.center) - c.radius;
}

vec2 complexRotate(vec2 z, float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);
}

vec2 complexDiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;
}
```

### 5.3. The Schottky Map

We now implement the map that sends the exterior of one circle to the interior of another.

```glsl
vec2 schottkyMap(vec2 z, Generator gen, inout float scale) {
    Circle A = gen.interior;
    Circle B = gen.exterior;

    vec2 zA = (z - A.center) / A.radius;
    float inversionScale = 1.0 / dot(zA, zA);
    float radiusScale = B.radius / A.radius;
    scale *= inversionScale * radiusScale;

    vec2 inv = complexDiv(vec2(1.0,0.0), zA);
    vec2 inB = B.center + B.radius * inv;

    vec2 unitB = (inB - B.center) / B.radius;
    unitB = complexRotate(unitB, gen.rotation);

    return B.center + B.radius * unitB;
}

vec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {
    Circle A = gen.interior;
    Circle B = gen.exterior;

    vec2 unitB = (z - B.center) / B.radius;
    unitB = complexRotate(unitB, -gen.rotation);
    vec2 pre = B.center + B.radius * unitB;

    vec2 zB = (pre - B.center) / B.radius;
    float inversionScale = 1.0 / dot(zB, zB);
    float radiusScale = A.radius / B.radius;
    scale *= inversionScale * radiusScale;

    vec2 inv = complexDiv(vec2(1.0,0.0), zB);
    return A.center + A.radius * inv;
}
```

### 5.4. A Few Iterations

To start, we perform a few iterations and color by the last generator used.

```glsl
vec3 iterateColors(vec2 z, Generator A, Generator B) {
    vec3 color = vec3(1.0);
    float scale = 1.0;

    for (int i = 0; i < 12; i++) {
        bool moved = false;

        if (isInsideCircle(z, A.interior)) {
            z = schottkyMap(z, A, scale);
            color = A.color; moved = true;
        }
        else if (isInsideCircle(z, A.exterior)) {
            z = inverseSchottkyMap(z, A, scale);
            color = A.color; moved = true;
        }
        else if (isInsideCircle(z, B.interior)) {
            z = schottkyMap(z, B, scale);
            color = B.color; moved = true;
        }
        else if (isInsideCircle(z, B.exterior)) {
            z = inverseSchottkyMap(z, B, scale);
            color = B.color; moved = true;
        }

        if (!moved) break;
    }

    return color;
}
```

This already shows the rough outline of the limit set.

---

## 6. Adding Distance Estimation

We now compute the minimal distance to all circles and divide by the accumulated scale factor.

```glsl
float distanceToGenerator(vec2 z, Generator gen) {
    float d1 = abs(distanceToCircle(z, gen.interior));
    float d2 = abs(distanceToCircle(z, gen.exterior));
    return min(d1, d2);
}

float distanceToSchottkyCircles(vec2 z, Generator A, Generator B) {
    return min(distanceToGenerator(z, A), distanceToGenerator(z, B));
}

float correctedDistance(vec2 z, float scale, Generator A, Generator B) {
    float d = distanceToSchottkyCircles(z, A, B);
    float positionCorrection = 1.0 / (10.0 + length(z));
    return d / (scale * positionCorrection);
}
```

The corrected distance gives a scalar field that is small near the limit set. We convert it to a smooth boundary using `smoothstep`.

---

## 7. Full Shader: Two-Generator Schottky Group

This final program combines everything above into a complete, runnable shader that draws the limit set dynamically.

```glsl
// ============================================
// Schottky Group Renderer (Two Generators)
// ============================================

const float PI = 3.14159265359;
const int MAX_ITERATIONS = 20;

struct Circle { vec2 center; float radius; };
struct Generator { Circle interior; Circle exterior; float rotation; vec3 color; };

bool isInsideCircle(vec2 z, Circle c) { return length(z - c.center) < c.radius; }
float distanceToCircle(vec2 z, Circle c) { return length(z - c.center) - c.radius; }

vec2 complexRotate(vec2 z, float theta) {
    float c = cos(theta); float s = sin(theta);
    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);
}
vec2 complexDiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;
}

vec2 schottkyMap(vec2 z, Generator gen, inout float scale) {
    Circle A = gen.interior; Circle B = gen.exterior;
    vec2 zA = (z - A.center) / A.radius;
    float inversionScale = 1.0 / dot(zA, zA);
    float radiusScale = B.radius / A.radius;
    scale *= inversionScale * radiusScale;
    vec2 inv = complexDiv(vec2(1.0,0.0), zA);
    vec2 inB = B.center + B.radius * inv;
    vec2 unitB = (inB - B.center) / B.radius;
    unitB = complexRotate(unitB, gen.rotation);
    return B.center + B.radius * unitB;
}

vec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {
    Circle A = gen.interior; Circle B = gen.exterior;
    vec2 unitB = (z - B.center) / B.radius;
    unitB = complexRotate(unitB, -gen.rotation);
    vec2 pre = B.center + B.radius * unitB;
    vec2 zB = (pre - B.center) / B.radius;
    float inversionScale = 1.0 / dot(zB, zB);
    float radiusScale = A.radius / B.radius;
    scale *= inversionScale * radiusScale;
    vec2 inv = complexDiv(vec2(1.0,0.0), zB);
    return A.center + A.radius * inv;
}

vec3 renderSchottky(vec2 z, Generator A, Generator B) {
    vec3 color = vec3(1.0); float scale = 1.0;
    for (int i=0;i<MAX_ITERATIONS;i++) {
        bool moved=false;
        if (isInsideCircle(z,A.interior)) { z=schottkyMap(z,A,scale); color=A.color; moved=true; }
        else if (isInsideCircle(z,A.exterior)) { z=inverseSchottkyMap(z,A,scale); color=A.color; moved=true; }
        else if (isInsideCircle(z,B.interior)) { z=schottkyMap(z,B,scale); color=B.color; moved=true; }
        else if (isInsideCircle(z,B.exterior)) { z=inverseSchottkyMap(z,B,scale); color=B.color; moved=true; }
        if (!moved) break;
    }
    float d = distanceToCircle(z, A.interior);
    d = min(d, distanceToCircle(z, A.exterior));
    d = min(d, distanceToCircle(z, B.interior));
    d = min(d, distanceToCircle(z, B.exterior));
    float pixel = 1.0 / iResolution.y;
    float boundary = smoothstep(0.0, 5.5*pixel, abs(d) - 5.5*pixel);
    return mix(vec3(0.0), color, boundary);
}

void setupGenerators(out Generator A, out Generator B, float time) {
    float t = 3.0 * time; float s = 1.05 + 0.05 * cos(t);
    A.interior.center = vec2(0.55, 0.55) * s;
    A.interior.radius = 0.55;
    A.exterior.center = vec2(-0.55, -0.55) * s;
    A.exterior.radius = 0.55;
    A.rotation = -PI/2.0; A.color = vec3(0.95,0.2,0.2);
    B.interior.center = vec2(0.45,-0.45) * s;
    B.interior.radius = 0.45;
    B.exterior.center = vec2(-0.45, 0.45) * s;
    B.exterior.radius = 0.45;
    B.rotation = PI/2.0; B.color = vec3(0.2,0.3,1.0);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    Generator A,B; setupGenerators(A,B,iTime);
    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;
    uv *= 2.0;
    vec3 col = renderSchottky(uv,A,B);
    fragColor = vec4(col,1.0);
}
```

---

## 8. Mathematical Commentary

Every pixel corresponds to a point on the Riemann sphere, and each iteration applies one of the generators of $\Gamma$. Points that forever remain in the union of fundamental disks approximate the **limit set** $\Lambda(\Gamma)$.

In hyperbolic terms, each generator corresponds to a loxodromic isometry of $\mathbb{H}^3$, acting by a translation and rotation along its geodesic axis. The limit set we see on the screen is the **ideal boundary** of the handlebody $\mathbb{H}^3 / \Gamma$.

The parameter $\lambda$ of each loxodromic element encodes both the translation length $L = 2\log|\lambda|$ and the rotation angle $\arg(\lambda)$, which together determine how the paired circles are glued in 3D.

::: {#fig-handlebody}
_Figure: The Schottky group defines a handlebody in $\mathbb{H}^3$. Its limit set is the fractal boundary seen in the shader._
:::

---




Perfect — here’s the **final optional section** written in Quarto-ready Markdown style (no YAML front matter, standard LaTeX math, fenced GLSL code).
You can paste it directly at the end of your existing `.qmd` file.

---

## Optional: Making the Limit Set Look Good

Up to now, our emphasis has been on **getting the geometry right**: the correct Möbius transformations, iteration rules, and distance estimators that reveal the limit set of a Schottky group.
But if you’ve ever run the simple version of the shader, you may have noticed that the picture looks *fuzzy*: the black circle boundaries are uneven, and their thickness changes with screen resolution.

To produce publication-quality limit sets, we must teach the shader to think like a **cartographer** — to measure in screen space, not world space, and to correct for the distortions of the Möbius maps.
This section develops the *refined version* of the renderer that does just that.

---

### 1. The Problem: Thickness and Scale

In the mathematical world, our circles are perfect.
But on a screen, a “circle” is made of pixels. When you zoom or change resolution, the physical thickness of the black border changes unless we explicitly tell the shader what a *pixel* means in world coordinates.

The base shader also ignored how much each Möbius map **contracts or expands** space.
If a point has been contracted by a factor of 10⁶ after several iterations, its Euclidean distance to a circle means something very different than it did at the start.
We need to correct by the **product of derivative magnitudes** — that’s our `scale` variable.

---

### 2. The Mathematical Correction

For the Schottky map

$$
f(z) = c_2 + \frac{r_1 r_2}{z - c_1},
$$

we know

$$
f'(z) = -\frac{r_1 r_2}{(z - c_1)^2}, \qquad |f'(z)| = \frac{r_1 r_2}{|z - c_1|^2}.
$$

So each time we apply a generator, we update

```glsl
scale *= (r1 * r2) / dot(z - c1, z - c1);
```

At the end of the iteration, dividing by this `scale` converts the raw circle distance into a true *hyperbolic-style* distance that measures how close we are to the limit set.

---

### 3. Measuring Thickness in Screen Space

A pixel on the screen has a definite height in normalized coordinates:

```glsl
float pixelSize = 1.0 / iResolution.y;
```

To make the black borders a consistent width across displays, we choose a fixed multiple:

```glsl
float boundaryThickness = 5.5 * pixelSize;
```

That means “make the border about five pixels thick,” regardless of zoom or monitor size.
Using `smoothstep` with that value ensures an anti-aliased transition rather than a hard cutoff.

---

### 4. Stabilizing the Far Corners

Points far from the origin tend to have large coordinate values.
Without correction, their distances become exaggerated, and black borders vanish in those regions.
A simple damping factor

```glsl
float positionCorrection = 1.0 / (10.0 + length(result.finalPosition));
```

tames this effect by decreasing the apparent distance when the point is far away.

---

### 5. The Final “Production” Shader

Putting these refinements together gives the version below, which produces smooth, consistent outlines and a crisp fractal limit set.

```glsl
// ============================================
// SCHOTTKY GROUP RENDERER - With Distance Estimation
// ============================================

const float PI = 3.14159265359;
const int MAX_ITERATIONS = 20;

// ---------- Complex arithmetic ----------
vec2 complexDiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y,
                a.y * b.x - a.x * b.y) / denom;
}

vec2 complexRotate(vec2 z, float theta) {
    float c = cos(theta), s = sin(theta);
    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);
}

// ---------- Circles ----------
struct Circle { vec2 center; float radius; };
bool  isInsideCircle(vec2 z, Circle c){return length(z-c.center)<c.radius;}
float distanceToCircle(vec2 z, Circle c){return length(z-c.center)-c.radius;}

// ---------- Generator ----------
struct Generator {
    Circle interior;
    Circle exterior;
    float rotation;
    vec3  color;
};

// ---------- Möbius and inverse ----------
vec2 schottkyMap(vec2 z, Generator g, inout float scale){
    vec2 c1=g.interior.center, c2=g.exterior.center;
    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;
    float denom=max(dot(z-c1,z-c1),1e-6);
    scale*=(k/denom);
    vec2 base=c2+complexDiv(vec2(k,0.0),z-c1);
    vec2 unit=(base-c2)/r2;
    unit=complexRotate(unit,g.rotation);
    return c2+r2*unit;
}

vec2 inverseSchottkyMap(vec2 z, Generator g, inout float scale){
    vec2 c1=g.interior.center, c2=g.exterior.center;
    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;
    float denom=max(dot(z-c2,z-c2),1e-6);
    scale*=(k/denom);
    vec2 unit=(z-c2)/r2;
    unit=complexRotate(unit,-g.rotation);
    vec2 baseOut=c2+r2*unit;
    return c1+complexDiv(vec2(k,0.0),baseOut-c2);
}

// ---------- Iteration ----------
struct IterationResult{vec3 color; vec2 finalPosition; float scale;};

IterationResult iterateSchottky(vec2 z, Generator A, Generator B){
    vec3 color=vec3(1.0); float scale=1.0;
    for(int i=0;i<MAX_ITERATIONS;i++){
        bool moved=false;
        if(isInsideCircle(z,A.interior)){z=schottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}
        else if(isInsideCircle(z,A.exterior)){z=inverseSchottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}
        else if(isInsideCircle(z,B.interior)){z=schottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}
        else if(isInsideCircle(z,B.exterior)){z=inverseSchottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}
        if(!moved)break;
    }
    return IterationResult(color,z,scale);
}

// ---------- Distance estimation ----------
float distanceToGenerator(vec2 z, Generator g){
    float d1=abs(distanceToCircle(z,g.interior));
    float d2=abs(distanceToCircle(z,g.exterior));
    return min(d1,d2);
}

float distanceToSchottkyCircles(vec2 z, Generator A, Generator B){
    return min(distanceToGenerator(z,A),distanceToGenerator(z,B));
}

float correctedDistance(IterationResult r, Generator A, Generator B){
    float d=distanceToSchottkyCircles(r.finalPosition,A,B);
    float positionCorrection=1.0/(10.0+length(r.finalPosition));
    return d/(r.scale*positionCorrection);
}

// ---------- Rendering ----------
vec3 renderSchottky(IterationResult r, Generator A, Generator B){
    float d=correctedDistance(r,A,B);
    float pixelSize=1.0/iResolution.y;
    float boundaryThickness=5.5*pixelSize;
    float boundary=smoothstep(0.0,boundaryThickness,abs(d)-boundaryThickness);
    return mix(vec3(0.0),r.color,boundary);
}

// ---------- Scene setup ----------
void setupGenerators(out Generator A,out Generator B,float time){
    float t=3.0*time, s=1.05+0.05*cos(t);
    A.interior.center=vec2(0.55,0.55)*s; A.interior.radius=0.55;
    A.exterior.center=vec2(-0.55,-0.55)*s; A.exterior.radius=0.55;
    A.rotation=-PI/2.0; A.color=vec3(0.95,0.2,0.2);
    B.interior.center=vec2(0.45,-0.45)*s; B.interior.radius=0.45;
    B.exterior.center=vec2(-0.45,0.45)*s; B.exterior.radius=0.45;
    B.rotation=PI/2.0; B.color=vec3(0.2,0.3,1.0);
}

// ---------- Main ----------
void mainImage(out vec4 fragColor,in vec2 fragCoord){
    Generator A,B; setupGenerators(A,B,iTime);
    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;
    uv*=2.0;
    IterationResult r=iterateSchottky(uv,A,B);
    vec3 color=renderSchottky(r,A,B);
    fragColor=vec4(color,1.0);
}
```

This shader is functionally identical to the simpler pedagogical one but with:

1. **Möbius-formula correctness** rather than a three-step normalize/invert/denormalize approach.
2. **Derivative-based scaling** for accurate distance estimation.
3. **Screen-space boundary control** (`5.5 * pixelSize`) for consistent black borders.
4. **Stabilized far-field correction** so the picture remains uniform everywhere.

The result is a crisp, visually stable limit set—mathematically faithful and aesthetically satisfying.

---

### 6. What to Experiment With

* Change `boundaryThickness` from `5.5` to `3.0` or `8.0` to feel how border width changes.
* Try different radii or centers for the generators to see how the limit set morphs.
* Replace `smoothstep` with a hard threshold to understand aliasing artifacts.
* Animate the rotations `genA.rotation` and `genB.rotation` to see how the twists deform the pattern.

---

This “advanced” version closes the loop between mathematical fidelity and graphical clarity.
Students who have followed the whole derivation will now appreciate that the small extra factors—`scale`, `pixelSize`, and `positionCorrection`—are what make a shader image *mathematically precise and visually beautiful at the same time*.



## 9. Full shader 2: two-generator Schottky group

This is a complete, self-contained version of your group renderer, but rewritten in the geometric style we developed:

```glsl
// ============================================
// Shader 2: Schottky group with two generators
// ============================================

const float PI = 3.14159265359;
const int MAX_ITERATIONS = 20;

// ------------------------------
// complex helpers
// ------------------------------
vec2 cdiv(vec2 a, vec2 b) {
    float d = dot(b, b);
    return vec2(a.x*b.x + a.y*b.y,
                a.y*b.x - a.x*b.y) / d;
}

vec2 complexRotate(vec2 z, float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return vec2(c*z.x - s*z.y,
                s*z.x + c*z.y);
}

// ------------------------------
// circle + generator structs
// ------------------------------
struct Circle {
    vec2 center;
    float radius;
};

struct Generator {
    Circle interior;
    Circle exterior;
    float rotation;
    vec3 color;
};

bool isInsideCircle(vec2 z, Circle c) {
    return length(z - c.center) < c.radius;
}

float distanceToCircle(vec2 z, Circle c) {
    return length(z - c.center) - c.radius;
}

// ------------------------------
// geometric schottky map (factored)
// maps exterior(interiorCircle) -> interior(exteriorCircle)
// ------------------------------
vec2 schottkyMap(vec2 z, Generator gen, inout float scale) {
    Circle A = gen.interior;
    Circle B = gen.exterior;

    // normalize to A
    vec2 zA = (z - A.center) / A.radius;

    // inversion derivative
    float inversionScale = 1.0 / dot(zA, zA);
    float radiusScale    = B.radius / A.radius;
    scale *= inversionScale * radiusScale;

    // invert
    vec2 inv = cdiv(vec2(1.0,0.0), zA);

    // to B
    vec2 inB = B.center + B.radius * inv;

    // rotate in B
    vec2 unitB = (inB - B.center) / B.radius;
    unitB = complexRotate(unitB, gen.rotation);
    return B.center + B.radius * unitB;
}

// inverse map: undo rotation, normalize to B, invert, go to A
vec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {
    Circle A = gen.interior;
    Circle B = gen.exterior;

    // undo rotation in B
    vec2 unitB = (z - B.center) / B.radius;
    unitB = complexRotate(unitB, -gen.rotation);
    vec2 pre = B.center + B.radius * unitB;

    // normalize to B
    vec2 zB = (pre - B.center) / B.radius;

    float inversionScale = 1.0 / dot(zB, zB);
    float radiusScale    = A.radius / B.radius;
    scale *= inversionScale * radiusScale;

    // invert and go to A
    vec2 inv = cdiv(vec2(1.0,0.0), zB);
    return A.center + A.radius * inv;
}

// ------------------------------
// iteration
// ------------------------------
struct IterationResult {
    vec3 color;
    vec2 finalPosition;
    float scale;
};

IterationResult iterateSchottky(vec2 z, Generator genA, Generator genB) {
    vec3 color = vec3(1.0);
    float scale = 1.0;

    for (int i = 0; i < MAX_ITERATIONS; i++) {
        bool moved = false;

        if (isInsideCircle(z, genA.interior)) {
            z = schottkyMap(z, genA, scale);
            color = mix(color, genA.color, 0.5);
            moved = true;
        }
        else if (isInsideCircle(z, genA.exterior)) {
            z = inverseSchottkyMap(z, genA, scale);
            color = mix(color, genA.color, 0.5);
            moved = true;
        }
        else if (isInsideCircle(z, genB.interior)) {
            z = schottkyMap(z, genB, scale);
            color = mix(color, genB.color, 0.5);
            moved = true;
        }
        else if (isInsideCircle(z, genB.exterior)) {
            z = inverseSchottkyMap(z, genB, scale);
            color = mix(color, genB.color, 0.5);
            moved = true;
        }

        if (!moved) break;
    }

    IterationResult result;
    result.color = color;
    result.finalPosition = z;
    result.scale = scale;
    return result;
}

// ------------------------------
// distance estimation (same idea as your program)
// ------------------------------
float distanceToGenerator(vec2 z, Generator gen) {
    float d1 = abs(distanceToCircle(z, gen.interior));
    float d2 = abs(distanceToCircle(z, gen.exterior));
    return min(d1, d2);
}

float distanceToSchottkyCircles(vec2 z, Generator genA, Generator genB) {
    return min(distanceToGenerator(z, genA),
               distanceToGenerator(z, genB));
}

float correctedDistance(IterationResult result, Generator genA, Generator genB) {
    float d = distanceToSchottkyCircles(result.finalPosition, genA, genB);
    float positionCorrection = 1.0 / (10.0 + length(result.finalPosition));
    return d / (result.scale * positionCorrection);
}

// ------------------------------
// rendering
// ------------------------------
vec3 renderSchottky(IterationResult result, Generator genA, Generator genB) {
    float d = correctedDistance(result, genA, genB);
    float pixel = 1.0 / iResolution.y;
    float thickness = 5.5 * pixel;
    float boundary = smoothstep(0.0, thickness, abs(d) - thickness);
    return mix(vec3(0.0), result.color, boundary);
}

// ------------------------------
// generator setup
// ------------------------------
void setupGenerators(out Generator genA, out Generator genB, float time) {
    float t = 3.0 * time;
    float s = 1.05 + 0.05 * cos(t);

    genA.interior.center = vec2(0.55, 0.55) * s;
    genA.interior.radius = 0.55;
    genA.exterior.center = vec2(-0.55, -0.55) * s;
    genA.exterior.radius = 0.55;
    genA.rotation = -PI / 2.0;
    genA.color = vec3(0.95, 0.2, 0.2);

    genB.interior.center = vec2(0.45, -0.45) * s;
    genB.interior.radius = 0.45;
    genB.exterior.center = vec2(-0.45, 0.45) * s;
    genB.exterior.radius = 0.45;
    genB.rotation = PI / 2.0;
    genB.color = vec3(0.2, 0.3, 1.0);
}

// ------------------------------
// main
// ------------------------------
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    Generator genA, genB;
    setupGenerators(genA, genB, iTime);

    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    uv *= 2.0;

    IterationResult result = iterateSchottky(uv, genA, genB);
    vec3 color = renderSchottky(result, genA, genB);

    fragColor = vec4(color, 1.0);
}
```

That’s the full group shader, expressed the way we described the geometry.
