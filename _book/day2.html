<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Day 2: Complex Dynamics and Iterated Inversions – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./day3.html" rel="next">
<link href="./day1-rewrite.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-86daaaaad7353f9cc0c554efc1dd6d94.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-f8dc6eab18fde03278982b0b35885446.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ed04f5f1653af6df52378e13bfdac05e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-d37bfdfd9a2222927534875c15a9020f.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./day2.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/yourusername/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1-rewrite.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./debug-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Debugging</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./folding-fractals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Folding Fractals</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./schottky.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Schottky Groups, Möbius Maps, and GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">2.1</span> Overview</a></li>
  <li><a href="#complex-numbers-in-glsl" id="toc-complex-numbers-in-glsl" class="nav-link" data-scroll-target="#complex-numbers-in-glsl"><span class="header-section-number">2.2</span> Complex Numbers in GLSL</a>
  <ul class="collapse">
  <li><a href="#representation" id="toc-representation" class="nav-link" data-scroll-target="#representation">Representation</a></li>
  <li><a href="#complex-arithmetic" id="toc-complex-arithmetic" class="nav-link" data-scroll-target="#complex-arithmetic">Complex Arithmetic</a></li>
  </ul></li>
  <li><a href="#the-mandelbrot-set" id="toc-the-mandelbrot-set" class="nav-link" data-scroll-target="#the-mandelbrot-set"><span class="header-section-number">2.3</span> The Mandelbrot Set</a>
  <ul class="collapse">
  <li><a href="#definition" id="toc-definition" class="nav-link" data-scroll-target="#definition">Definition</a></li>
  <li><a href="#basic-implementation" id="toc-basic-implementation" class="nav-link" data-scroll-target="#basic-implementation">Basic Implementation</a></li>
  <li><a href="#coloring-schemes" id="toc-coloring-schemes" class="nav-link" data-scroll-target="#coloring-schemes">Coloring Schemes</a></li>
  </ul></li>
  <li><a href="#circle-inversion" id="toc-circle-inversion" class="nav-link" data-scroll-target="#circle-inversion"><span class="header-section-number">2.4</span> Circle Inversion</a>
  <ul class="collapse">
  <li><a href="#mathematical-definition" id="toc-mathematical-definition" class="nav-link" data-scroll-target="#mathematical-definition">Mathematical Definition</a></li>
  <li><a href="#key-properties" id="toc-key-properties" class="nav-link" data-scroll-target="#key-properties">Key Properties</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  <li><a href="#visualizing-circle-inversion" id="toc-visualizing-circle-inversion" class="nav-link" data-scroll-target="#visualizing-circle-inversion">Visualizing Circle Inversion</a></li>
  </ul></li>
  <li><a href="#structs-in-glsl" id="toc-structs-in-glsl" class="nav-link" data-scroll-target="#structs-in-glsl"><span class="header-section-number">2.5</span> Structs in GLSL</a>
  <ul class="collapse">
  <li><a href="#defining-a-struct" id="toc-defining-a-struct" class="nav-link" data-scroll-target="#defining-a-struct">Defining a Struct</a></li>
  <li><a href="#using-structs" id="toc-using-structs" class="nav-link" data-scroll-target="#using-structs">Using Structs</a></li>
  <li><a href="#why-structs" id="toc-why-structs" class="nav-link" data-scroll-target="#why-structs">Why Structs?</a></li>
  </ul></li>
  <li><a href="#the-apollonian-gasket" id="toc-the-apollonian-gasket" class="nav-link" data-scroll-target="#the-apollonian-gasket"><span class="header-section-number">2.6</span> The Apollonian Gasket</a>
  <ul class="collapse">
  <li><a href="#setup-three-mutually-tangent-circles" id="toc-setup-three-mutually-tangent-circles" class="nav-link" data-scroll-target="#setup-three-mutually-tangent-circles">Setup: Three Mutually Tangent Circles</a></li>
  <li><a href="#the-iteration-algorithm" id="toc-the-iteration-algorithm" class="nav-link" data-scroll-target="#the-iteration-algorithm">The Iteration Algorithm</a></li>
  <li><a href="#coloring-strategies" id="toc-coloring-strategies" class="nav-link" data-scroll-target="#coloring-strategies">Coloring Strategies</a></li>
  <li><a href="#putting-it-all-together" id="toc-putting-it-all-together" class="nav-link" data-scroll-target="#putting-it-all-together">Putting It All Together</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">2.7</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">2.8</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-julia-sets" id="toc-required-julia-sets" class="nav-link" data-scroll-target="#required-julia-sets">Required: Julia Sets</a></li>
  <li><a href="#optional-1-grid-of-julia-sets" id="toc-optional-1-grid-of-julia-sets" class="nav-link" data-scroll-target="#optional-1-grid-of-julia-sets">Optional #1: Grid of Julia Sets</a></li>
  <li><a href="#optional-2-other-iterated-inversions" id="toc-optional-2-other-iterated-inversions" class="nav-link" data-scroll-target="#optional-2-other-iterated-inversions">Optional #2: Other Iterated Inversions</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">2.9</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">2.1</span> Overview</h2>
<p>Today we explore the power of iteration to generate fractals. We’ll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set. Then we’ll shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We’ll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles, and learn to organize geometric data using structs.</p>
<p>By the end of today, you’ll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.</p>
<hr>
</section>
<section id="complex-numbers-in-glsl" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="complex-numbers-in-glsl"><span class="header-section-number">2.2</span> Complex Numbers in GLSL</h2>
<section id="representation" class="level3">
<h3 class="anchored" data-anchor-id="representation">Representation</h3>
<p>A complex number <span class="math inline">\(z = a + bi\)</span> can be represented as a 2D vector with real part <span class="math inline">\(a\)</span> and imaginary part <span class="math inline">\(b\)</span>. This is actually a completely natural representation—complex numbers <em>are</em> the 2D plane! In GLSL:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> z <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span>  <span class="co">// Represents a + bi</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll consistently use the convention: <code>z.x</code> is the real part, <code>z.y</code> is the imaginary part. This means you can think of complex arithmetic as geometric operations in the plane, which gives great intuition for what’s happening.</p>
</section>
<section id="complex-arithmetic" class="level3">
<h3 class="anchored" data-anchor-id="complex-arithmetic">Complex Arithmetic</h3>
<p>Let <span class="math inline">\(z = a + bi\)</span> and <span class="math inline">\(w = c + di\)</span>. We need to implement the basic operations. Some of these are trivial, others require a bit more work:</p>
<p><strong>Addition:</strong> <span class="math inline">\((a + bi) + (c + di) = (a + c) + (b + d)i\)</span></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cadd</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z <span class="op">+</span> w<span class="op">;</span>  <span class="co">// Vector addition is sufficient!</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Addition of complex numbers is just vector addition—componentwise! We’re literally adding the real and imaginary parts separately. You might not even need this function since you can just write <code>z + w</code> directly, but it’s here for completeness.</p>
<p><strong>Multiplication:</strong> <span class="math inline">\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\)</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">,</span>  <span class="co">// Real part: ac - bd</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span>   <span class="co">// Imaginary part: ad + bc</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This one requires actually remembering the FOIL pattern and grouping real/imaginary terms. The key is that <span class="math inline">\(i^2 = -1\)</span>, which is why we get that minus sign in the real part.</p>
<p><strong>Magnitude squared:</strong> <span class="math inline">\(|z|^2 = a^2 + b^2\)</span></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">cabs2</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">dot</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">);</span>  <span class="co">// z.x * z.x + z.y * z.y</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The squared magnitude is just the dot product of the complex number with itself. This is computationally cheaper than taking the square root, so when we just need to check if <span class="math inline">\(|z| &gt; 2\)</span>, we’ll check if <span class="math inline">\(|z|^2 &gt; 4\)</span> instead.</p>
<p><strong>Magnitude:</strong> <span class="math inline">\(|z| = \sqrt{a^2 + b^2}\)</span></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">cabs</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span>z<span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The magnitude is the Euclidean distance from the origin—exactly what <code>length()</code> computes!</p>
<p><strong>Conjugate:</strong> <span class="math inline">\(\overline{z} = a - bi\)</span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cconj</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>z<span class="op">.</span><span class="fu">x</span><span class="op">,</span> <span class="op">-</span>z<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The conjugate just flips the sign of the imaginary part. Geometrically, this is reflection across the real axis.</p>
<p><strong>Division:</strong> <span class="math inline">\(\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{c^2 + d^2}\)</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cdiv</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>w<span class="op">,</span> w<span class="op">);</span>  <span class="co">// c² + d²</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom<span class="op">,</span>  <span class="co">// Real part</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom   <span class="co">// Imaginary part</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Division is the trickiest operation—we multiply numerator and denominator by the conjugate of <span class="math inline">\(w\)</span> to rationalize. The denominator becomes real (<span class="math inline">\(c^2 + d^2\)</span>), and the numerator becomes a new complex number we can compute.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why write helper functions?
</div>
</div>
<div class="callout-body-container callout-body">
<p>You might wonder why we’re defining all these functions when we could just inline the formulas. There are a few good reasons:</p>
<ol type="1">
<li><strong>Readability</strong>: <code>cmul(z, z)</code> is much clearer than <code>vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)</code></li>
<li><strong>Correctness</strong>: It’s easy to make sign errors in complex arithmetic—writing the function once and testing it is safer</li>
<li><strong>Consistency</strong>: Using the same functions throughout makes the code easier to understand and debug</li>
</ol>
<p>As your shaders get more complex, these helper functions will make your life much easier!</p>
</div>
</div>
<p>These are the building blocks we need for complex dynamics. Let’s put them to work!</p>
<hr>
</section>
</section>
<section id="the-mandelbrot-set" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="the-mandelbrot-set"><span class="header-section-number">2.3</span> The Mandelbrot Set</h2>
<section id="definition" class="level3">
<h3 class="anchored" data-anchor-id="definition">Definition</h3>
<p>The Mandelbrot set <span class="math inline">\(\mathcal{M}\)</span> is one of the most famous objects in mathematics—and for good reason! It’s defined as the set of complex numbers <span class="math inline">\(c\)</span> for which the iteration <span class="math display">\[z_{n+1} = z_n^2 + c, \quad z_0 = 0\]</span> remains bounded as <span class="math inline">\(n \to \infty\)</span>.</p>
<p>That’s it! Just iterate this simple quadratic map starting from <span class="math inline">\(z_0 = 0\)</span>, and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.</p>
<p>In practice, we can’t iterate to infinity, so we:</p>
<ol type="1">
<li>Start with <span class="math inline">\(z_0 = 0\)</span></li>
<li>Iterate <span class="math inline">\(z_{n+1} = z_n^2 + c\)</span> for a fixed number of iterations (say, 100)</li>
<li>Check if <span class="math inline">\(|z_n|\)</span> has escaped some large radius (typically <span class="math inline">\(R = 2\)</span>)</li>
</ol>
<p>There’s a theorem that says if <span class="math inline">\(|z_n| &gt; 2\)</span> for any <span class="math inline">\(n\)</span>, then the orbit escapes to infinity. So points that escape quickly are definitely not in <span class="math inline">\(\mathcal{M}\)</span>, while points that remain bounded after many iterations are likely in <span class="math inline">\(\mathcal{M}\)</span> (or at least, very close to the boundary).</p>
</section>
<section id="basic-implementation" class="level3">
<h3 class="anchored" data-anchor-id="basic-implementation">Basic Implementation</h3>
<p>Let’s code it up:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup: center at origin, scale to show interesting region</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c <span class="op">=</span> uv <span class="op">*</span> <span class="fl">3.5</span><span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Center on the interesting part</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mandelbrot iteration</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// z_0 = 0</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_iter <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iter<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span>iter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iter <span class="op">&lt;</span> max_iter<span class="op">;</span> iter<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check if escaped</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="fu">cabs2</span><span class="op">(</span>z<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">4.0</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span>  <span class="co">// |z| &gt; 2, so |z|² &gt; 4</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// z_{n+1} = z_n² + c</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">cmul</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">)</span> <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on iteration count</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>iter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>max_iter<span class="op">);</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>t<span class="op">);</span>  <span class="co">// Grayscale for now</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That’s the entire Mandelbrot set renderer! Notice how we’re using <code>cabs2</code> instead of <code>cabs</code>—since we’re just checking if the magnitude exceeds 2, we can check if the squared magnitude exceeds 4, which saves us a square root computation per pixel per iteration.</p>
<p>The coordinate scaling is tuned to show the “interesting part” of the Mandelbrot set—the main cardioid and its surrounding bulbs. The set actually extends from about <span class="math inline">\(-2.5\)</span> to <span class="math inline">\(0.5\)</span> on the real axis, so we shift our coordinate system accordingly.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Understanding the iteration
</div>
</div>
<div class="callout-body-container callout-body">
<p>What’s actually happening in that loop? Each pixel represents a complex number <span class="math inline">\(c\)</span>, and we’re asking: “If I start at <span class="math inline">\(z = 0\)</span> and repeatedly apply <span class="math inline">\(z \mapsto z^2 + c\)</span>, does the orbit stay bounded?”</p>
<p>Try adding some debug visualization—color based on the final value of <code>z</code>, or visualize the trajectory somehow. Understanding the dynamics geometrically will help you build intuition for Julia sets (which we’ll do in homework) and other complex dynamical systems.</p>
</div>
</div>
</section>
<section id="coloring-schemes" class="level3">
<h3 class="anchored" data-anchor-id="coloring-schemes">Coloring Schemes</h3>
<p>The grayscale rendering shows the structure of the set, but it’s not particularly exciting visually. We can do much better! The classic approach is to color based on how quickly points escape:</p>
<p><strong>Smooth coloring using escape time:</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>iter <span class="op">&lt;</span> max_iter<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Smooth iteration count (accounts for continuous escape)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> log_zn <span class="op">=</span> <span class="bu">log</span><span class="op">(</span><span class="fu">cabs2</span><span class="op">(</span>z<span class="op">))</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> nu <span class="op">=</span> <span class="bu">log</span><span class="op">(</span>log_zn <span class="op">/</span> <span class="bu">log</span><span class="op">(</span><span class="fl">2.0</span><span class="op">))</span> <span class="op">/</span> <span class="bu">log</span><span class="op">(</span><span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> smooth_iter <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>iter<span class="op">)</span> <span class="op">+</span> <span class="fl">1.0</span> <span class="op">-</span> nu<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> smooth_iter <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>max_iter<span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inside the set: black</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This “smooth iteration count” formula eliminates the harsh banding you get from just using integer iteration counts. The math is a bit involved (it comes from the fact that near escape, the magnitude grows roughly exponentially), but the result is smooth, continuous color gradients that look much more professional.</p>
<p><strong>Creating color palettes:</strong></p>
<p>Now we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">palette</span><span class="op">(</span><span class="dt">float</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a cyclic color palette using cosines</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> a <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> b <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> c <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> d <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> a <span class="op">+</span> b <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span>c <span class="op">*</span> t <span class="op">+</span> d<span class="op">));</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> control different aspects of the palette:</p>
<ul>
<li><code>a</code> and <code>b</code> control the range and center of the colors</li>
<li><code>c</code> controls the frequency of color cycling</li>
<li><code>d</code> controls the phase offset (shifts the colors)</li>
</ul>
<p>Play with these parameters to get different color schemes! Try <code>d = vec3(0.0, 0.1, 0.2)</code> for a more blue-purple palette, or <code>d = vec3(0.3, 0.2, 0.2)</code> for warmer tones.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The art of palette design
</div>
</div>
<div class="callout-body-container callout-body">
<p>Creating good color palettes is part science, part art. The cosine palette is mathematically elegant and gives smooth gradients, but you might want to try other approaches:</p>
<ul>
<li>Hand-picked color stops with interpolation (more control, more work)</li>
<li>HSV color spaces (easy to create rainbow gradients)</li>
<li>Perceptually uniform color spaces like LAB (ensures equal perceived color differences)</li>
</ul>
<p>For mathematical visualization, the key is that the colors should help reveal structure, not obscure it. High contrast can emphasize boundaries, while smooth gradients show continuous variation in escape time.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="circle-inversion" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="circle-inversion"><span class="header-section-number">2.4</span> Circle Inversion</h2>
<p>Now we shift from algebraic dynamics (iterating polynomials) to geometric dynamics (iterating transformations). Circle inversion is a beautiful geometric operation that will be the foundation for everything we do for the rest of the week!</p>
<section id="mathematical-definition" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-definition">Mathematical Definition</h3>
<p>Circle inversion is a transformation of the plane with respect to a circle. For a circle of radius <span class="math inline">\(R\)</span> centered at a point <span class="math inline">\(\mathbf{c}\)</span>, inversion maps a point <span class="math inline">\(\mathbf{p} \neq \mathbf{c}\)</span> to: <span class="math display">\[\text{inv}(\mathbf{p}) = \mathbf{c} + R^2 \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|^2}\]</span></p>
<p>Let’s understand this formula geometrically. The vector <span class="math inline">\(\mathbf{p} - \mathbf{c}\)</span> points from the center to <span class="math inline">\(\mathbf{p}\)</span>. We normalize this direction by dividing by its squared length, then scale by <span class="math inline">\(R^2\)</span>, and finally translate back by the center. The result?</p>
<ul>
<li>Points inside the circle map to points outside (and vice versa)</li>
<li>Points on the circle are fixed (they map to themselves)</li>
<li>The closer you are to the center, the farther away you go (and vice versa)</li>
<li>The center itself maps to infinity, and infinity maps to the center</li>
</ul>
<p>Here’s another way to think about it: draw a ray from the center through <span class="math inline">\(\mathbf{p}\)</span>. The inversion of <span class="math inline">\(\mathbf{p}\)</span> is the unique point on this ray such that the product of distances from the center is <span class="math inline">\(R^2\)</span>. If <span class="math inline">\(\mathbf{p}\)</span> is at distance <span class="math inline">\(r\)</span> from the center, its image is at distance <span class="math inline">\(R^2/r\)</span>.</p>
</section>
<section id="key-properties" class="level3">
<h3 class="anchored" data-anchor-id="key-properties">Key Properties</h3>
<p>Circle inversion has some remarkable geometric properties that make it incredibly useful:</p>
<ol type="1">
<li><strong>Lines through the center</strong> remain lines through the center (they’re just “flipped inside out” along the ray)</li>
<li><strong>Lines not through the center</strong> become circles through the center</li>
<li><strong>Circles through the center</strong> become lines (not through the center)</li>
<li><strong>Circles not through the center</strong> remain circles (but with different center and radius)</li>
<li><strong>Angles are preserved</strong> (it’s a conformal map—it preserves angles between curves)</li>
</ol>
<p>These properties mean that circle inversion turns geometric complexity into more geometric complexity in very controlled ways. When we iterate inversions through multiple circles, we’ll see beautiful fractal patterns emerge!</p>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>The formula translates directly to GLSL:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">invertCircle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">vec2</span> center<span class="op">,</span> <span class="dt">float</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> diff <span class="op">=</span> p <span class="op">-</span> center<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>diff<span class="op">,</span> diff<span class="op">);</span>  <span class="co">// squared distance from center</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Handle center (would be division by zero)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>r2 <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1000.0</span><span class="op">);</span>  <span class="co">// Map to "infinity"</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> center <span class="op">+</span> <span class="op">(</span>radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> diff <span class="op">/</span> r2<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it’s effectively off-screen.</p>
</section>
<section id="visualizing-circle-inversion" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-circle-inversion">Visualizing Circle Inversion</h3>
<p>Let’s see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Standard coordinate setup, resulting in p]</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inversion circle</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> circleCenter <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> circleRadius <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Apply inversion</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p_inverted <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> circleCenter<span class="op">,</span> circleRadius<span class="op">);</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a grid in the inverted space</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> grid <span class="op">=</span> <span class="bu">fract</span><span class="op">(</span>p_inverted <span class="op">*</span> <span class="fl">2.0</span><span class="op">);</span>  <span class="co">// Create repeating cells</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> gridLine <span class="op">=</span> <span class="bu">step</span><span class="op">(</span><span class="fl">0.95</span><span class="op">,</span> <span class="bu">max</span><span class="op">(</span>grid<span class="op">.</span><span class="fu">x</span><span class="op">,</span> grid<span class="op">.</span><span class="fu">y</span><span class="op">));</span>  <span class="co">// Draw grid lines</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>gridLine<span class="op">);</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw the inversion circle itself (for reference)</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> circDist <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p<span class="op">)</span> <span class="op">-</span> circleRadius<span class="op">);</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>circDist <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You’ll see straight grid lines transform into beautiful circular arcs! The lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.</p>
<p>Try animating the circle position or radius to see how the grid deforms. This really helps build intuition for how inversion works!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exploring circle inversion
</div>
</div>
<div class="callout-body-container callout-body">
<p>Here are some experiments to try:</p>
<ol type="1">
<li><strong>Multiple circles</strong>: Invert through a grid of circles instead of just one—create <code>cell_p</code> using <code>mod()</code> like in Day 1, then invert each cell independently</li>
<li><strong>Animated radius</strong>: Make <code>circleRadius = 1.0 + 0.5 * sin(iTime)</code> to watch the grid breathe in and out</li>
<li><strong>Different patterns</strong>: Instead of a grid, try drawing circles or other shapes in the inverted space</li>
</ol>
<p>Each of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="structs-in-glsl" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="structs-in-glsl"><span class="header-section-number">2.5</span> Structs in GLSL</h2>
<p>Before we build the Apollonian gasket, we need to talk about organizing our data. We’re about to deal with multiple circles, and passing around <code>center1</code>, <code>radius1</code>, <code>center2</code>, <code>radius2</code>, etc. gets unwieldy fast. GLSL provides <strong>structs</strong> (just like in C) for grouping related data together.</p>
<section id="defining-a-struct" class="level3">
<h3 class="anchored" data-anchor-id="defining-a-struct">Defining a Struct</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Circle <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> center<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That’s it! Now <code>Circle</code> is a type we can use just like <code>vec2</code> or <code>float</code>. Each <code>Circle</code> contains a center position and a radius—exactly the data we need to define a circle.</p>
</section>
<section id="using-structs" class="level3">
<h3 class="anchored" data-anchor-id="using-structs">Using Structs</h3>
<p>Creating and using structs is straightforward:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare a circle</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>Circle c1<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>c1<span class="op">.</span><span class="fu">center</span> <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>c1<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Or initialize directly</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>Circle c2 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">),</span> <span class="fl">0.75</span><span class="op">);</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Pass to functions</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">invertThroughCircle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> Circle circ<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> circ<span class="op">.</span><span class="fu">center</span><span class="op">,</span> circ<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The syntax is exactly what you’d expect—use the dot operator to access fields, just like accessing components of a <code>vec2</code> or <code>vec3</code>.</p>
</section>
<section id="why-structs" class="level3">
<h3 class="anchored" data-anchor-id="why-structs">Why Structs?</h3>
<p>They make the code dramatically more readable and maintainable. Compare:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Without structs - messy!</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">iterateInversions</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c1_center<span class="op">,</span> <span class="dt">float</span> c1_radius<span class="op">,</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c2_center<span class="op">,</span> <span class="dt">float</span> c2_radius<span class="op">,</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c3_center<span class="op">,</span> <span class="dt">float</span> c3_radius<span class="op">)</span> </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... lots of parameters to keep track of</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">// With structs - clean!</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">iterateInversions</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> Circle c1<span class="op">,</span> Circle c2<span class="op">,</span> Circle c3<span class="op">)</span> </span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Much clearer what we're working with</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the Apollonian gasket, we’ll have three circles we need to keep track of and pass around. Structs make this much more manageable!</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Structs vs.&nbsp;arrays
</div>
</div>
<div class="callout-body-container callout-body">
<p>You might wonder: why not just use an array of circles? That works too! The choice depends on your needs:</p>
<ul>
<li><strong>Structs</strong>: Better when circles have different roles (like “outer circle” vs “inner circles”)</li>
<li><strong>Arrays</strong>: Better when you have many similar circles and want to loop over them</li>
</ul>
<p>For the Apollonian gasket, we’ll use individual structs because each circle plays a specific geometric role. In the homework you might try arrays if you’re working with many circles!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="the-apollonian-gasket" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="the-apollonian-gasket"><span class="header-section-number">2.6</span> The Apollonian Gasket</h2>
<p>Now for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It’s named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles.</p>
<section id="setup-three-mutually-tangent-circles" class="level3">
<h3 class="anchored" data-anchor-id="setup-three-mutually-tangent-circles">Setup: Three Mutually Tangent Circles</h3>
<p>We start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For simplicity, we’ll use a nice symmetric configuration:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">setupApollonianCircles</span><span class="op">(</span><span class="dt">out</span> Circle c1<span class="op">,</span> <span class="dt">out</span> Circle c2<span class="op">,</span> <span class="dt">out</span> Circle c3<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A nice symmetric configuration</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> R <span class="op">=</span> <span class="fl">2.0</span><span class="op">;</span>  <span class="co">// Outer radius</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Inner radius</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Three circles arranged in a triangle</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    c1 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> R <span class="op">-</span> r<span class="op">),</span> r<span class="op">);</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    c2 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(-(</span>R <span class="op">-</span> r<span class="op">)</span> <span class="op">*</span> <span class="fl">0.866</span><span class="op">,</span> <span class="op">-(</span>R <span class="op">-</span> r<span class="op">)</span> <span class="op">*</span> <span class="fl">0.5</span><span class="op">),</span> r<span class="op">);</span>  <span class="co">// 0.866 ≈ sqrt(3)/2</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    c3 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">((</span>R <span class="op">-</span> r<span class="op">)</span> <span class="op">*</span> <span class="fl">0.866</span><span class="op">,</span> <span class="op">-(</span>R <span class="op">-</span> r<span class="op">)</span> <span class="op">*</span> <span class="fl">0.5</span><span class="op">),</span> r<span class="op">);</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These three circles are positioned at the vertices of an equilateral triangle, all tangent to each other and to a large outer circle (which we could add if we wanted).</p>
</section>
<section id="the-iteration-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-iteration-algorithm">The Iteration Algorithm</h3>
<p>The algorithm is beautifully simple:</p>
<ol type="1">
<li>Start with a point <span class="math inline">\(p\)</span></li>
<li>For each iteration:
<ul>
<li>Check which circles contain <span class="math inline">\(p\)</span></li>
<li>If <span class="math inline">\(p\)</span> is inside a circle, invert through that circle</li>
<li>Repeat</li>
</ul></li>
<li>Color based on the iteration behavior</li>
</ol>
<p>Here’s the code:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">iterateApollonian</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> Circle c1<span class="op">,</span> Circle c2<span class="op">,</span> Circle c3<span class="op">,</span> </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">int</span> maxIter<span class="op">,</span> <span class="dt">out</span> <span class="dt">int</span> finalIter<span class="op">,</span> <span class="dt">out</span> <span class="dt">int</span> lastCircle<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> maxIter<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> moved <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check each circle</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">&lt;</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            lastCircle <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            moved <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> </span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">&lt;</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>            lastCircle <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>            moved <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">&lt;</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>            lastCircle <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>            moved <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If we didn't move, we're done</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(!</span>moved<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>            finalIter <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    finalIter <span class="op">=</span> maxIter<span class="op">;</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We also track which circle we last inverted through (stored in <code>lastCircle</code>) and how many iterations we performed (stored in <code>finalIter</code>). These will be useful for coloring!</p>
</section>
<section id="coloring-strategies" class="level3">
<h3 class="anchored" data-anchor-id="coloring-strategies">Coloring Strategies</h3>
<p>There are several interesting ways to color the Apollonian gasket:</p>
<p><strong>By iteration count</strong> (like the Mandelbrot set):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>finalIter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>maxIter<span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>By last circle hit</strong>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> colors<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="dt">vec3</span><span class="op">[</span><span class="dv">3</span><span class="op">](</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span>  <span class="co">// Circle 1: red</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span>  <span class="co">// Circle 2: green</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">)</span>   <span class="co">// Circle 3: blue</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> colors<span class="op">[</span>lastCircle<span class="op">];</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>By final distance from circles</strong>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d1 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d2 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d3 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>d2<span class="op">,</span> d3<span class="op">));</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> d<span class="op">));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Each gives a different view of the fractal structure. The iteration count shows the “depth” of the orbit, the last circle shows the basin of attraction, and the distance shows the geometric structure of the nested circles.</p>
</section>
<section id="putting-it-all-together" class="level3">
<h3 class="anchored" data-anchor-id="putting-it-all-together">Putting It All Together</h3>
<p>Here’s a complete Apollonian gasket renderer:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup, resulting in p]</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Setup the three circles</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    Circle c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">setupApollonianCircles</span><span class="op">(</span>c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Iterate</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxIter <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> finalIter<span class="op">,</span> lastCircle<span class="op">;</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> final_p <span class="op">=</span> <span class="fu">iterateApollonian</span><span class="op">(</span>p<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> maxIter<span class="op">,</span> finalIter<span class="op">,</span> lastCircle<span class="op">);</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by iteration count with palette</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>finalIter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>maxIter<span class="op">);</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw the three circles themselves for reference</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d1 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d2 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d3 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>d2<span class="op">,</span> d3<span class="op">));</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White circles</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should see a beautiful nested pattern of circles! Zoom in (by scaling <code>p</code> differently) to see the fractal self-similarity—no matter how far you zoom, you’ll keep finding more nested circles.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The mathematics of Apollonian gaskets
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Apollonian gasket has deep connections to number theory and hyperbolic geometry. If you choose the initial circles carefully (with integer curvatures), all the nested circles will also have integer curvatures—this is the content of the “Descartes Circle Theorem.”</p>
<p>The pattern is also related to hyperbolic tilings, which we’ll explore tomorrow. The inversions we’re doing here are actually isometries (distance-preserving maps) of hyperbolic space! So in some sense, we’re already working in non-Euclidean geometry without realizing it.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="summary" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="summary"><span class="header-section-number">2.7</span> Summary</h2>
<p>Today we’ve explored two powerful iterative processes:</p>
<ol type="1">
<li><strong>Complex dynamics</strong>: The Mandelbrot set emerges from iterating <span class="math inline">\(z \mapsto z^2 + c\)</span>
<ul>
<li>Implemented complex arithmetic in GLSL</li>
<li>Escape-time algorithms and smooth coloring</li>
<li>The power of simple quadratic iteration</li>
</ul></li>
<li><strong>Geometric dynamics</strong>: The Apollonian gasket emerges from iterating circle inversions
<ul>
<li>Circle inversion as a conformal transformation</li>
<li>Structs for organizing geometric data</li>
<li>Iterated inversions creating fractal patterns</li>
</ul></li>
</ol>
<p>Both show how incredibly simple rules—a quadratic map, a geometric transformation—can generate infinite complexity through iteration. This is one of the core insights of fractal geometry and dynamical systems!</p>
<hr>
</section>
<section id="homework" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="homework"><span class="header-section-number">2.8</span> Homework</h2>
<section id="required-julia-sets" class="level3">
<h3 class="anchored" data-anchor-id="required-julia-sets">Required: Julia Sets</h3>
<p>The Julia set is the natural companion to the Mandelbrot set. Instead of varying <span class="math inline">\(c\)</span> and fixing <span class="math inline">\(z_0 = 0\)</span>, we fix <span class="math inline">\(c\)</span> and vary <span class="math inline">\(z_0\)</span>!</p>
<p><strong>The setup:</strong> For a fixed complex number <span class="math inline">\(c\)</span>, the Julia set <span class="math inline">\(J_c\)</span> is the set of initial conditions <span class="math inline">\(z_0\)</span> for which the iteration <span class="math inline">\(z_{n+1} = z_n^2 + c\)</span> remains bounded.</p>
<p><strong>Implementation:</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup, resulting in p]</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The initial z is now the pixel position!</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fix c to an interesting value</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.27015</span><span class="op">);</span>  <span class="co">// Classic Julia set parameter</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Iterate z_{n+1} = z_n² + c</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_iter <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iter<span class="op">;</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span>iter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iter <span class="op">&lt;</span> max_iter<span class="op">;</span> iter<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="fu">cabs2</span><span class="op">(</span>z<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">4.0</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">cmul</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">)</span> <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on escape time</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>iter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>max_iter<span class="op">);</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Exploration—pick one:</strong></p>
<p><strong>Option A: Animated parameter space</strong></p>
<p>Animate <span class="math inline">\(c\)</span> to explore how the Julia set morphs:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> angle <span class="op">=</span> iTime <span class="op">*</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> radius <span class="op">=</span> <span class="fl">0.7885</span><span class="op">;</span>  <span class="co">// Radius in parameter space</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> c <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>radius <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span>angle<span class="op">),</span> radius <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>angle<span class="op">));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Watch how the Julia set changes as you trace a circle in the complex plane! You’ll see it morph from connected to disconnected, develop tendrils, and create beautiful organic shapes.</p>
<p><strong>Option B: Mouse-controlled exploration</strong></p>
<p>Tie <span class="math inline">\(c\)</span> to the mouse position:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> mouse_uv <span class="op">=</span> <span class="op">(</span>iMouse<span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>mouse_uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> c <span class="op">=</span> mouse_uv <span class="op">*</span> <span class="fl">3.0</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now you can explore parameter space interactively! Move the mouse around to see different Julia sets. This really helps build intuition for how the Julia set depends on <span class="math inline">\(c\)</span>.</p>
<p><strong>Interesting values to try:</strong> - <code>vec2(-0.4, 0.6)</code> - dendrite-like fractal trees - <code>vec2(0.285, 0.01)</code> - beautiful spiral patterns<br>
- <code>vec2(-0.8, 0.156)</code> - intricate filaments - <code>vec2(-0.7269, 0.1889)</code> - “Douady’s rabbit” (famous Julia set) - <code>vec2(-0.835, -0.2321)</code> - another classic - <code>vec2(-0.70176, -0.3842)</code> - “San Marco dragon”</p>
</section>
<section id="optional-1-grid-of-julia-sets" class="level3">
<h3 class="anchored" data-anchor-id="optional-1-grid-of-julia-sets">Optional #1: Grid of Julia Sets</h3>
<p>Here’s a beautiful connection: create a grid where each cell shows the Julia set for that value of <span class="math inline">\(c\)</span>, and watch the Mandelbrot set emerge!</p>
<p><strong>The idea:</strong> The Mandelbrot set is a map of Julia set topology—points in <span class="math inline">\(\mathcal{M}\)</span> have connected Julia sets, points outside have disconnected Julia sets. If we draw a grid of Julia sets, we should see this pattern!</p>
<p><strong>Implementation strategy:</strong></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup]</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Divide screen into grid cells</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grid_size <span class="op">=</span> <span class="fl">8.0</span><span class="op">;</span>  <span class="co">// 8x8 grid</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">*</span> grid_size <span class="op">/</span> <span class="fl">4.0</span><span class="op">);</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">fract</span><span class="op">(</span>p <span class="op">*</span> grid_size <span class="op">/</span> <span class="fl">4.0</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    cell_p <span class="op">*=</span> <span class="fl">4.0</span><span class="op">;</span>  <span class="co">// Local coordinates within cell</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map cell_id to parameter c</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c <span class="op">=</span> <span class="op">(</span>cell_id <span class="op">/</span> grid_size<span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span> <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">2.5</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Center on interesting region</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Run Julia set iteration with z = cell_p, fixed c</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> cell_p<span class="op">;</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_iter <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [iterate as in Julia set code]</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>iter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>max_iter<span class="op">);</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Optional: draw grid lines</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> grid_edge <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">fract</span><span class="op">(</span>p <span class="op">*</span> grid_size <span class="op">/</span> <span class="fl">4.0</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="bu">max</span><span class="op">(</span>grid_edge<span class="op">.</span><span class="fu">x</span><span class="op">,</span> grid_edge<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fl">0.48</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should see a grid of tiny Julia sets, and if you look carefully, you’ll notice that the overall pattern resembles the Mandelbrot set! The cells with connected Julia sets (where you see solid regions) correspond to points in the Mandelbrot set, while cells with disconnected Julia sets (dust-like patterns) are outside.</p>
<p>This is one of the most beautiful connections in complex dynamics—the Mandelbrot set is literally a map showing which parameters give connected Julia sets!</p>
</section>
<section id="optional-2-other-iterated-inversions" class="level3">
<h3 class="anchored" data-anchor-id="optional-2-other-iterated-inversions">Optional #2: Other Iterated Inversions</h3>
<p>Explore variations on the Apollonian gasket theme! The key is to set up circles in interesting configurations and iterate inversions.</p>
<p><strong>Simple variations:</strong></p>
<p><strong>Different circle arrangements:</strong> - Four circles in a square configuration - Five circles in a pentagonal arrangement<br>
- Nested circles (one large, several small inside) - Randomly placed circles (use a hash function to generate positions)</p>
<p><strong>Non-uniform radii:</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Make circles pulse</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>c1<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime<span class="op">);</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>c2<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime <span class="op">+</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="fl">3.14159</span> <span class="op">/</span> <span class="fl">3.0</span><span class="op">);</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>c3<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime <span class="op">+</span> <span class="fl">4.0</span> <span class="op">*</span> <span class="fl">3.14159</span> <span class="op">/</span> <span class="fl">3.0</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Alternating inversion patterns:</strong></p>
<p>Instead of inverting through whichever circle contains the point, try alternating in a fixed pattern:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Cycle through circles in order</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> circle_index <span class="op">=</span> i <span class="op">%</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>circle_index <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">else</span> <span class="kw">if</span><span class="op">(</span>circle_index <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="kw">else</span> p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This creates very different patterns—more regular and less “space-filling” than the gasket, but with interesting self-similarity.</p>
<p><strong>Challenge:</strong> Can you create a configuration that tiles the plane with circular patterns? What about one that creates spiraling structures?</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="2.9">
<h2 data-number="2.9" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">2.9</span> Looking Ahead</h2>
<p>Tomorrow we’ll continue with geometric tilings! We’ll start in Euclidean space with triangle tilings using reflections, then move to <strong>hyperbolic geometry</strong>. The circle inversions you’ve learned today are actually hyperbolic isometries—so we’re already doing non-Euclidean geometry without realizing it!</p>
<p>We’ll explore multiple models of the hyperbolic plane (upper half-plane, Poincaré disk) and create beautiful tilings with <span class="math inline">\((2,3,\infty)\)</span> triangles. The same algorithmic ideas (iterated geometric transformations) work in hyperbolic space, but the results are even more intricate because hyperbolic space has “more room” than Euclidean space.</p>
<p>Make sure you’re comfortable with: - Iteration and escape-time algorithms (we’ll use similar ideas for tiling) - Circle inversion (this becomes reflection in hyperbolic geodesics!) - Structs for organizing data - Coloring strategies based on orbit behavior</p>
<p>See you tomorrow!</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./day1-rewrite.html" class="pagination-link" aria-label="Day 1: Introduction to Shader Programming">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./day3.html" class="pagination-link" aria-label="Day 3: Geometric Tilings in Euclidean and Hyperbolic Space">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb28" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 2: Complex Dynamics and Iterated Inversions</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>Today we explore the power of iteration to generate fractals. We'll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set. Then we'll shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We'll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles, and learn to organize geometric data using structs.</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Complex Numbers in GLSL</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="fu">### Representation</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>A complex number $z = a + bi$ can be represented as a 2D vector with real part $a$ and imaginary part $b$. This is actually a completely natural representation—complex numbers *are* the 2D plane! In GLSL:</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 z = vec2(a, b);  // Represents a + bi</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>We'll consistently use the convention: <span class="in">`z.x`</span> is the real part, <span class="in">`z.y`</span> is the imaginary part. This means you can think of complex arithmetic as geometric operations in the plane, which gives great intuition for what's happening.</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a><span class="fu">### Complex Arithmetic</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>Let $z = a + bi$ and $w = c + di$. We need to implement the basic operations. Some of these are trivial, others require a bit more work:</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>**Addition:** $(a + bi) + (c + di) = (a + c) + (b + d)i$</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cadd(vec2 z, vec2 w) {</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a><span class="in">    return z + w;  // Vector addition is sufficient!</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>Addition of complex numbers is just vector addition—componentwise! We're literally adding the real and imaginary parts separately. You might not even need this function since you can just write <span class="in">`z + w`</span> directly, but it's here for completeness.</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>**Multiplication:** $(a + bi)(c + di) = (ac - bd) + (ad + bc)i$</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cmul(vec2 z, vec2 w) {</span></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(</span></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a><span class="in">        z.x * w.x - z.y * w.y,  // Real part: ac - bd</span></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a><span class="in">        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>This one requires actually remembering the FOIL pattern and grouping real/imaginary terms. The key is that $i^2 = -1$, which is why we get that minus sign in the real part.</span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>**Magnitude squared:** $|z|^2 = a^2 + b^2$</span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a><span class="in">float cabs2(vec2 z) {</span></span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a><span class="in">    return dot(z, z);  // z.x * z.x + z.y * z.y</span></span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>The squared magnitude is just the dot product of the complex number with itself. This is computationally cheaper than taking the square root, so when we just need to check if $|z| &gt; 2$, we'll check if $|z|^2 &gt; 4$ instead.</span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>**Magnitude:** $|z| = \sqrt{a^2 + b^2}$</span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a><span class="in">float cabs(vec2 z) {</span></span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a><span class="in">    return length(z);</span></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a>The magnitude is the Euclidean distance from the origin—exactly what <span class="in">`length()`</span> computes!</span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a>**Conjugate:** $\overline{z} = a - bi$</span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cconj(vec2 z) {</span></span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(z.x, -z.y);</span></span>
<span id="cb28-75"><a href="#cb28-75" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-76"><a href="#cb28-76" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-77"><a href="#cb28-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-78"><a href="#cb28-78" aria-hidden="true" tabindex="-1"></a>The conjugate just flips the sign of the imaginary part. Geometrically, this is reflection across the real axis.</span>
<span id="cb28-79"><a href="#cb28-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-80"><a href="#cb28-80" aria-hidden="true" tabindex="-1"></a>**Division:** $\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{c^2 + d^2}$</span>
<span id="cb28-81"><a href="#cb28-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-82"><a href="#cb28-82" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-83"><a href="#cb28-83" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cdiv(vec2 z, vec2 w) {</span></span>
<span id="cb28-84"><a href="#cb28-84" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = dot(w, w);  // c² + d²</span></span>
<span id="cb28-85"><a href="#cb28-85" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(</span></span>
<span id="cb28-86"><a href="#cb28-86" aria-hidden="true" tabindex="-1"></a><span class="in">        (z.x * w.x + z.y * w.y) / denom,  // Real part</span></span>
<span id="cb28-87"><a href="#cb28-87" aria-hidden="true" tabindex="-1"></a><span class="in">        (z.y * w.x - z.x * w.y) / denom   // Imaginary part</span></span>
<span id="cb28-88"><a href="#cb28-88" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb28-89"><a href="#cb28-89" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-90"><a href="#cb28-90" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-91"><a href="#cb28-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-92"><a href="#cb28-92" aria-hidden="true" tabindex="-1"></a>Division is the trickiest operation—we multiply numerator and denominator by the conjugate of $w$ to rationalize. The denominator becomes real ($c^2 + d^2$), and the numerator becomes a new complex number we can compute.</span>
<span id="cb28-93"><a href="#cb28-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-94"><a href="#cb28-94" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb28-95"><a href="#cb28-95" aria-hidden="true" tabindex="-1"></a><span class="fu">## Why write helper functions?</span></span>
<span id="cb28-96"><a href="#cb28-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-97"><a href="#cb28-97" aria-hidden="true" tabindex="-1"></a>You might wonder why we're defining all these functions when we could just inline the formulas. There are a few good reasons:</span>
<span id="cb28-98"><a href="#cb28-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-99"><a href="#cb28-99" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Readability**: <span class="in">`cmul(z, z)`</span> is much clearer than <span class="in">`vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)`</span></span>
<span id="cb28-100"><a href="#cb28-100" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Correctness**: It's easy to make sign errors in complex arithmetic—writing the function once and testing it is safer</span>
<span id="cb28-101"><a href="#cb28-101" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Consistency**: Using the same functions throughout makes the code easier to understand and debug</span>
<span id="cb28-102"><a href="#cb28-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-103"><a href="#cb28-103" aria-hidden="true" tabindex="-1"></a>As your shaders get more complex, these helper functions will make your life much easier!</span>
<span id="cb28-104"><a href="#cb28-104" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb28-105"><a href="#cb28-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-106"><a href="#cb28-106" aria-hidden="true" tabindex="-1"></a>These are the building blocks we need for complex dynamics. Let's put them to work!</span>
<span id="cb28-107"><a href="#cb28-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-108"><a href="#cb28-108" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-109"><a href="#cb28-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-110"><a href="#cb28-110" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Mandelbrot Set</span></span>
<span id="cb28-111"><a href="#cb28-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-112"><a href="#cb28-112" aria-hidden="true" tabindex="-1"></a><span class="fu">### Definition</span></span>
<span id="cb28-113"><a href="#cb28-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-114"><a href="#cb28-114" aria-hidden="true" tabindex="-1"></a>The Mandelbrot set $\mathcal{M}$ is one of the most famous objects in mathematics—and for good reason! It's defined as the set of complex numbers $c$ for which the iteration</span>
<span id="cb28-115"><a href="#cb28-115" aria-hidden="true" tabindex="-1"></a>$$z_{n+1} = z_n^2 + c, \quad z_0 = 0$$</span>
<span id="cb28-116"><a href="#cb28-116" aria-hidden="true" tabindex="-1"></a>remains bounded as $n \to \infty$.</span>
<span id="cb28-117"><a href="#cb28-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-118"><a href="#cb28-118" aria-hidden="true" tabindex="-1"></a>That's it! Just iterate this simple quadratic map starting from $z_0 = 0$, and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.</span>
<span id="cb28-119"><a href="#cb28-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-120"><a href="#cb28-120" aria-hidden="true" tabindex="-1"></a>In practice, we can't iterate to infinity, so we:</span>
<span id="cb28-121"><a href="#cb28-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-122"><a href="#cb28-122" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Start with $z_0 = 0$</span>
<span id="cb28-123"><a href="#cb28-123" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Iterate $z_{n+1} = z_n^2 + c$ for a fixed number of iterations (say, 100)</span>
<span id="cb28-124"><a href="#cb28-124" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Check if $|z_n|$ has escaped some large radius (typically $R = 2$)</span>
<span id="cb28-125"><a href="#cb28-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-126"><a href="#cb28-126" aria-hidden="true" tabindex="-1"></a>There's a theorem that says if $|z_n| &gt; 2$ for any $n$, then the orbit escapes to infinity. So points that escape quickly are definitely not in $\mathcal{M}$, while points that remain bounded after many iterations are likely in $\mathcal{M}$ (or at least, very close to the boundary).</span>
<span id="cb28-127"><a href="#cb28-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-128"><a href="#cb28-128" aria-hidden="true" tabindex="-1"></a><span class="fu">### Basic Implementation</span></span>
<span id="cb28-129"><a href="#cb28-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-130"><a href="#cb28-130" aria-hidden="true" tabindex="-1"></a>Let's code it up:</span>
<span id="cb28-131"><a href="#cb28-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-132"><a href="#cb28-132" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-133"><a href="#cb28-133" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-134"><a href="#cb28-134" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-135"><a href="#cb28-135" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup: center at origin, scale to show interesting region</span></span>
<span id="cb28-136"><a href="#cb28-136" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb28-137"><a href="#cb28-137" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb28-138"><a href="#cb28-138" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb28-139"><a href="#cb28-139" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-140"><a href="#cb28-140" aria-hidden="true" tabindex="-1"></a><span class="in">    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])</span></span>
<span id="cb28-141"><a href="#cb28-141" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c = uv * 3.5;</span></span>
<span id="cb28-142"><a href="#cb28-142" aria-hidden="true" tabindex="-1"></a><span class="in">    c.x -= 0.5;  // Center on the interesting part</span></span>
<span id="cb28-143"><a href="#cb28-143" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-144"><a href="#cb28-144" aria-hidden="true" tabindex="-1"></a><span class="in">    // Mandelbrot iteration</span></span>
<span id="cb28-145"><a href="#cb28-145" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = vec2(0.0, 0.0);  // z_0 = 0</span></span>
<span id="cb28-146"><a href="#cb28-146" aria-hidden="true" tabindex="-1"></a><span class="in">    int max_iter = 100;</span></span>
<span id="cb28-147"><a href="#cb28-147" aria-hidden="true" tabindex="-1"></a><span class="in">    int iter;</span></span>
<span id="cb28-148"><a href="#cb28-148" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-149"><a href="#cb28-149" aria-hidden="true" tabindex="-1"></a><span class="in">    for(iter = 0; iter &lt; max_iter; iter++) {</span></span>
<span id="cb28-150"><a href="#cb28-150" aria-hidden="true" tabindex="-1"></a><span class="in">        // Check if escaped</span></span>
<span id="cb28-151"><a href="#cb28-151" aria-hidden="true" tabindex="-1"></a><span class="in">        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4</span></span>
<span id="cb28-152"><a href="#cb28-152" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-153"><a href="#cb28-153" aria-hidden="true" tabindex="-1"></a><span class="in">        // z_{n+1} = z_n² + c</span></span>
<span id="cb28-154"><a href="#cb28-154" aria-hidden="true" tabindex="-1"></a><span class="in">        z = cmul(z, z) + c;</span></span>
<span id="cb28-155"><a href="#cb28-155" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-156"><a href="#cb28-156" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-157"><a href="#cb28-157" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on iteration count</span></span>
<span id="cb28-158"><a href="#cb28-158" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(iter) / float(max_iter);</span></span>
<span id="cb28-159"><a href="#cb28-159" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(t);  // Grayscale for now</span></span>
<span id="cb28-160"><a href="#cb28-160" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-161"><a href="#cb28-161" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-162"><a href="#cb28-162" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-163"><a href="#cb28-163" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-164"><a href="#cb28-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-165"><a href="#cb28-165" aria-hidden="true" tabindex="-1"></a>That's the entire Mandelbrot set renderer! Notice how we're using <span class="in">`cabs2`</span> instead of <span class="in">`cabs`</span>—since we're just checking if the magnitude exceeds 2, we can check if the squared magnitude exceeds 4, which saves us a square root computation per pixel per iteration.</span>
<span id="cb28-166"><a href="#cb28-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-167"><a href="#cb28-167" aria-hidden="true" tabindex="-1"></a>The coordinate scaling is tuned to show the "interesting part" of the Mandelbrot set—the main cardioid and its surrounding bulbs. The set actually extends from about $-2.5$ to $0.5$ on the real axis, so we shift our coordinate system accordingly.</span>
<span id="cb28-168"><a href="#cb28-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-169"><a href="#cb28-169" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb28-170"><a href="#cb28-170" aria-hidden="true" tabindex="-1"></a><span class="fu">## Understanding the iteration</span></span>
<span id="cb28-171"><a href="#cb28-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-172"><a href="#cb28-172" aria-hidden="true" tabindex="-1"></a>What's actually happening in that loop? Each pixel represents a complex number $c$, and we're asking: "If I start at $z = 0$ and repeatedly apply $z \mapsto z^2 + c$, does the orbit stay bounded?"</span>
<span id="cb28-173"><a href="#cb28-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-174"><a href="#cb28-174" aria-hidden="true" tabindex="-1"></a>Try adding some debug visualization—color based on the final value of <span class="in">`z`</span>, or visualize the trajectory somehow. Understanding the dynamics geometrically will help you build intuition for Julia sets (which we'll do in homework) and other complex dynamical systems.</span>
<span id="cb28-175"><a href="#cb28-175" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb28-176"><a href="#cb28-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-177"><a href="#cb28-177" aria-hidden="true" tabindex="-1"></a><span class="fu">### Coloring Schemes</span></span>
<span id="cb28-178"><a href="#cb28-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-179"><a href="#cb28-179" aria-hidden="true" tabindex="-1"></a>The grayscale rendering shows the structure of the set, but it's not particularly exciting visually. We can do much better! The classic approach is to color based on how quickly points escape:</span>
<span id="cb28-180"><a href="#cb28-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-181"><a href="#cb28-181" aria-hidden="true" tabindex="-1"></a>**Smooth coloring using escape time:**</span>
<span id="cb28-182"><a href="#cb28-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-183"><a href="#cb28-183" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-184"><a href="#cb28-184" aria-hidden="true" tabindex="-1"></a><span class="in">if(iter &lt; max_iter) {</span></span>
<span id="cb28-185"><a href="#cb28-185" aria-hidden="true" tabindex="-1"></a><span class="in">    // Smooth iteration count (accounts for continuous escape)</span></span>
<span id="cb28-186"><a href="#cb28-186" aria-hidden="true" tabindex="-1"></a><span class="in">    float log_zn = log(cabs2(z)) / 2.0;</span></span>
<span id="cb28-187"><a href="#cb28-187" aria-hidden="true" tabindex="-1"></a><span class="in">    float nu = log(log_zn / log(2.0)) / log(2.0);</span></span>
<span id="cb28-188"><a href="#cb28-188" aria-hidden="true" tabindex="-1"></a><span class="in">    float smooth_iter = float(iter) + 1.0 - nu;</span></span>
<span id="cb28-189"><a href="#cb28-189" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-190"><a href="#cb28-190" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = smooth_iter / float(max_iter);</span></span>
<span id="cb28-191"><a href="#cb28-191" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb28-192"><a href="#cb28-192" aria-hidden="true" tabindex="-1"></a><span class="in">} else {</span></span>
<span id="cb28-193"><a href="#cb28-193" aria-hidden="true" tabindex="-1"></a><span class="in">    // Inside the set: black</span></span>
<span id="cb28-194"><a href="#cb28-194" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.0);</span></span>
<span id="cb28-195"><a href="#cb28-195" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-196"><a href="#cb28-196" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-197"><a href="#cb28-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-198"><a href="#cb28-198" aria-hidden="true" tabindex="-1"></a>This "smooth iteration count" formula eliminates the harsh banding you get from just using integer iteration counts. The math is a bit involved (it comes from the fact that near escape, the magnitude grows roughly exponentially), but the result is smooth, continuous color gradients that look much more professional.</span>
<span id="cb28-199"><a href="#cb28-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-200"><a href="#cb28-200" aria-hidden="true" tabindex="-1"></a>**Creating color palettes:**</span>
<span id="cb28-201"><a href="#cb28-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-202"><a href="#cb28-202" aria-hidden="true" tabindex="-1"></a>Now we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:</span>
<span id="cb28-203"><a href="#cb28-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-204"><a href="#cb28-204" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-205"><a href="#cb28-205" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 palette(float t) {</span></span>
<span id="cb28-206"><a href="#cb28-206" aria-hidden="true" tabindex="-1"></a><span class="in">    // Create a cyclic color palette using cosines</span></span>
<span id="cb28-207"><a href="#cb28-207" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 a = vec3(0.5, 0.5, 0.5);</span></span>
<span id="cb28-208"><a href="#cb28-208" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 b = vec3(0.5, 0.5, 0.5);</span></span>
<span id="cb28-209"><a href="#cb28-209" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 c = vec3(1.0, 1.0, 1.0);</span></span>
<span id="cb28-210"><a href="#cb28-210" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 d = vec3(0.0, 0.33, 0.67);</span></span>
<span id="cb28-211"><a href="#cb28-211" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-212"><a href="#cb28-212" aria-hidden="true" tabindex="-1"></a><span class="in">    return a + b * cos(6.28318 * (c * t + d));</span></span>
<span id="cb28-213"><a href="#cb28-213" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-214"><a href="#cb28-214" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-215"><a href="#cb28-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-216"><a href="#cb28-216" aria-hidden="true" tabindex="-1"></a>This uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters <span class="in">`a`</span>, <span class="in">`b`</span>, <span class="in">`c`</span>, <span class="in">`d`</span> control different aspects of the palette:</span>
<span id="cb28-217"><a href="#cb28-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-218"><a href="#cb28-218" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`a`</span> and <span class="in">`b`</span> control the range and center of the colors</span>
<span id="cb28-219"><a href="#cb28-219" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`c`</span> controls the frequency of color cycling</span>
<span id="cb28-220"><a href="#cb28-220" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`d`</span> controls the phase offset (shifts the colors)</span>
<span id="cb28-221"><a href="#cb28-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-222"><a href="#cb28-222" aria-hidden="true" tabindex="-1"></a>Play with these parameters to get different color schemes! Try <span class="in">`d = vec3(0.0, 0.1, 0.2)`</span> for a more blue-purple palette, or <span class="in">`d = vec3(0.3, 0.2, 0.2)`</span> for warmer tones.</span>
<span id="cb28-223"><a href="#cb28-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-224"><a href="#cb28-224" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb28-225"><a href="#cb28-225" aria-hidden="true" tabindex="-1"></a><span class="fu">## The art of palette design</span></span>
<span id="cb28-226"><a href="#cb28-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-227"><a href="#cb28-227" aria-hidden="true" tabindex="-1"></a>Creating good color palettes is part science, part art. The cosine palette is mathematically elegant and gives smooth gradients, but you might want to try other approaches:</span>
<span id="cb28-228"><a href="#cb28-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-229"><a href="#cb28-229" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Hand-picked color stops with interpolation (more control, more work)</span>
<span id="cb28-230"><a href="#cb28-230" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>HSV color spaces (easy to create rainbow gradients)</span>
<span id="cb28-231"><a href="#cb28-231" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Perceptually uniform color spaces like LAB (ensures equal perceived color differences)</span>
<span id="cb28-232"><a href="#cb28-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-233"><a href="#cb28-233" aria-hidden="true" tabindex="-1"></a>For mathematical visualization, the key is that the colors should help reveal structure, not obscure it. High contrast can emphasize boundaries, while smooth gradients show continuous variation in escape time.</span>
<span id="cb28-234"><a href="#cb28-234" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb28-235"><a href="#cb28-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-236"><a href="#cb28-236" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-237"><a href="#cb28-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-238"><a href="#cb28-238" aria-hidden="true" tabindex="-1"></a><span class="fu">## Circle Inversion</span></span>
<span id="cb28-239"><a href="#cb28-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-240"><a href="#cb28-240" aria-hidden="true" tabindex="-1"></a>Now we shift from algebraic dynamics (iterating polynomials) to geometric dynamics (iterating transformations). Circle inversion is a beautiful geometric operation that will be the foundation for everything we do for the rest of the week!</span>
<span id="cb28-241"><a href="#cb28-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-242"><a href="#cb28-242" aria-hidden="true" tabindex="-1"></a><span class="fu">### Mathematical Definition</span></span>
<span id="cb28-243"><a href="#cb28-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-244"><a href="#cb28-244" aria-hidden="true" tabindex="-1"></a>Circle inversion is a transformation of the plane with respect to a circle. For a circle of radius $R$ centered at a point $\mathbf{c}$, inversion maps a point $\mathbf{p} \neq \mathbf{c}$ to:</span>
<span id="cb28-245"><a href="#cb28-245" aria-hidden="true" tabindex="-1"></a>$$\text{inv}(\mathbf{p}) = \mathbf{c} + R^2 \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|^2}$$</span>
<span id="cb28-246"><a href="#cb28-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-247"><a href="#cb28-247" aria-hidden="true" tabindex="-1"></a>Let's understand this formula geometrically. The vector $\mathbf{p} - \mathbf{c}$ points from the center to $\mathbf{p}$. We normalize this direction by dividing by its squared length, then scale by $R^2$, and finally translate back by the center. The result?</span>
<span id="cb28-248"><a href="#cb28-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-249"><a href="#cb28-249" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points inside the circle map to points outside (and vice versa)</span>
<span id="cb28-250"><a href="#cb28-250" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points on the circle are fixed (they map to themselves)</span>
<span id="cb28-251"><a href="#cb28-251" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The closer you are to the center, the farther away you go (and vice versa)</span>
<span id="cb28-252"><a href="#cb28-252" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The center itself maps to infinity, and infinity maps to the center</span>
<span id="cb28-253"><a href="#cb28-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-254"><a href="#cb28-254" aria-hidden="true" tabindex="-1"></a>Here's another way to think about it: draw a ray from the center through $\mathbf{p}$. The inversion of $\mathbf{p}$ is the unique point on this ray such that the product of distances from the center is $R^2$. If $\mathbf{p}$ is at distance $r$ from the center, its image is at distance $R^2/r$.</span>
<span id="cb28-255"><a href="#cb28-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-256"><a href="#cb28-256" aria-hidden="true" tabindex="-1"></a><span class="fu">### Key Properties</span></span>
<span id="cb28-257"><a href="#cb28-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-258"><a href="#cb28-258" aria-hidden="true" tabindex="-1"></a>Circle inversion has some remarkable geometric properties that make it incredibly useful:</span>
<span id="cb28-259"><a href="#cb28-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-260"><a href="#cb28-260" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Lines through the center** remain lines through the center (they're just "flipped inside out" along the ray)</span>
<span id="cb28-261"><a href="#cb28-261" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Lines not through the center** become circles through the center</span>
<span id="cb28-262"><a href="#cb28-262" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Circles through the center** become lines (not through the center)</span>
<span id="cb28-263"><a href="#cb28-263" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Circles not through the center** remain circles (but with different center and radius)</span>
<span id="cb28-264"><a href="#cb28-264" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Angles are preserved** (it's a conformal map—it preserves angles between curves)</span>
<span id="cb28-265"><a href="#cb28-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-266"><a href="#cb28-266" aria-hidden="true" tabindex="-1"></a>These properties mean that circle inversion turns geometric complexity into more geometric complexity in very controlled ways. When we iterate inversions through multiple circles, we'll see beautiful fractal patterns emerge!</span>
<span id="cb28-267"><a href="#cb28-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-268"><a href="#cb28-268" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb28-269"><a href="#cb28-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-270"><a href="#cb28-270" aria-hidden="true" tabindex="-1"></a>The formula translates directly to GLSL:</span>
<span id="cb28-271"><a href="#cb28-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-272"><a href="#cb28-272" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-273"><a href="#cb28-273" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 invertCircle(vec2 p, vec2 center, float radius) {</span></span>
<span id="cb28-274"><a href="#cb28-274" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 diff = p - center;</span></span>
<span id="cb28-275"><a href="#cb28-275" aria-hidden="true" tabindex="-1"></a><span class="in">    float r2 = dot(diff, diff);  // squared distance from center</span></span>
<span id="cb28-276"><a href="#cb28-276" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-277"><a href="#cb28-277" aria-hidden="true" tabindex="-1"></a><span class="in">    // Handle center (would be division by zero)</span></span>
<span id="cb28-278"><a href="#cb28-278" aria-hidden="true" tabindex="-1"></a><span class="in">    if(r2 &lt; 0.0001) return vec2(1000.0);  // Map to "infinity"</span></span>
<span id="cb28-279"><a href="#cb28-279" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-280"><a href="#cb28-280" aria-hidden="true" tabindex="-1"></a><span class="in">    return center + (radius * radius) * diff / r2;</span></span>
<span id="cb28-281"><a href="#cb28-281" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-282"><a href="#cb28-282" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-283"><a href="#cb28-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-284"><a href="#cb28-284" aria-hidden="true" tabindex="-1"></a>The only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it's effectively off-screen.</span>
<span id="cb28-285"><a href="#cb28-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-286"><a href="#cb28-286" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing Circle Inversion</span></span>
<span id="cb28-287"><a href="#cb28-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-288"><a href="#cb28-288" aria-hidden="true" tabindex="-1"></a>Let's see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:</span>
<span id="cb28-289"><a href="#cb28-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-290"><a href="#cb28-290" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-291"><a href="#cb28-291" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-292"><a href="#cb28-292" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-293"><a href="#cb28-293" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Standard coordinate setup, resulting in p]</span></span>
<span id="cb28-294"><a href="#cb28-294" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-295"><a href="#cb28-295" aria-hidden="true" tabindex="-1"></a><span class="in">    // Inversion circle</span></span>
<span id="cb28-296"><a href="#cb28-296" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 circleCenter = vec2(0.0, 0.0);</span></span>
<span id="cb28-297"><a href="#cb28-297" aria-hidden="true" tabindex="-1"></a><span class="in">    float circleRadius = 1.0;</span></span>
<span id="cb28-298"><a href="#cb28-298" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-299"><a href="#cb28-299" aria-hidden="true" tabindex="-1"></a><span class="in">    // Apply inversion</span></span>
<span id="cb28-300"><a href="#cb28-300" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);</span></span>
<span id="cb28-301"><a href="#cb28-301" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-302"><a href="#cb28-302" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw a grid in the inverted space</span></span>
<span id="cb28-303"><a href="#cb28-303" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 grid = fract(p_inverted * 2.0);  // Create repeating cells</span></span>
<span id="cb28-304"><a href="#cb28-304" aria-hidden="true" tabindex="-1"></a><span class="in">    float gridLine = step(0.95, max(grid.x, grid.y));  // Draw grid lines</span></span>
<span id="cb28-305"><a href="#cb28-305" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-306"><a href="#cb28-306" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(gridLine);</span></span>
<span id="cb28-307"><a href="#cb28-307" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-308"><a href="#cb28-308" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw the inversion circle itself (for reference)</span></span>
<span id="cb28-309"><a href="#cb28-309" aria-hidden="true" tabindex="-1"></a><span class="in">    float circDist = abs(length(p) - circleRadius);</span></span>
<span id="cb28-310"><a href="#cb28-310" aria-hidden="true" tabindex="-1"></a><span class="in">    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);</span></span>
<span id="cb28-311"><a href="#cb28-311" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-312"><a href="#cb28-312" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-313"><a href="#cb28-313" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-314"><a href="#cb28-314" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-315"><a href="#cb28-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-316"><a href="#cb28-316" aria-hidden="true" tabindex="-1"></a>You'll see straight grid lines transform into beautiful circular arcs! The lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.</span>
<span id="cb28-317"><a href="#cb28-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-318"><a href="#cb28-318" aria-hidden="true" tabindex="-1"></a>Try animating the circle position or radius to see how the grid deforms. This really helps build intuition for how inversion works!</span>
<span id="cb28-319"><a href="#cb28-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-320"><a href="#cb28-320" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb28-321"><a href="#cb28-321" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exploring circle inversion</span></span>
<span id="cb28-322"><a href="#cb28-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-323"><a href="#cb28-323" aria-hidden="true" tabindex="-1"></a>Here are some experiments to try:</span>
<span id="cb28-324"><a href="#cb28-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-325"><a href="#cb28-325" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Multiple circles**: Invert through a grid of circles instead of just one—create <span class="in">`cell_p`</span> using <span class="in">`mod()`</span> like in Day 1, then invert each cell independently</span>
<span id="cb28-326"><a href="#cb28-326" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Animated radius**: Make <span class="in">`circleRadius = 1.0 + 0.5 * sin(iTime)`</span> to watch the grid breathe in and out</span>
<span id="cb28-327"><a href="#cb28-327" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Different patterns**: Instead of a grid, try drawing circles or other shapes in the inverted space</span>
<span id="cb28-328"><a href="#cb28-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-329"><a href="#cb28-329" aria-hidden="true" tabindex="-1"></a>Each of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!</span>
<span id="cb28-330"><a href="#cb28-330" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb28-331"><a href="#cb28-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-332"><a href="#cb28-332" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-333"><a href="#cb28-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-334"><a href="#cb28-334" aria-hidden="true" tabindex="-1"></a><span class="fu">## Structs in GLSL</span></span>
<span id="cb28-335"><a href="#cb28-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-336"><a href="#cb28-336" aria-hidden="true" tabindex="-1"></a>Before we build the Apollonian gasket, we need to talk about organizing our data. We're about to deal with multiple circles, and passing around <span class="in">`center1`</span>, <span class="in">`radius1`</span>, <span class="in">`center2`</span>, <span class="in">`radius2`</span>, etc. gets unwieldy fast. GLSL provides **structs** (just like in C) for grouping related data together.</span>
<span id="cb28-337"><a href="#cb28-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-338"><a href="#cb28-338" aria-hidden="true" tabindex="-1"></a><span class="fu">### Defining a Struct</span></span>
<span id="cb28-339"><a href="#cb28-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-340"><a href="#cb28-340" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-341"><a href="#cb28-341" aria-hidden="true" tabindex="-1"></a><span class="in">struct Circle {</span></span>
<span id="cb28-342"><a href="#cb28-342" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 center;</span></span>
<span id="cb28-343"><a href="#cb28-343" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius;</span></span>
<span id="cb28-344"><a href="#cb28-344" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-345"><a href="#cb28-345" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-346"><a href="#cb28-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-347"><a href="#cb28-347" aria-hidden="true" tabindex="-1"></a>That's it! Now <span class="in">`Circle`</span> is a type we can use just like <span class="in">`vec2`</span> or <span class="in">`float`</span>. Each <span class="in">`Circle`</span> contains a center position and a radius—exactly the data we need to define a circle.</span>
<span id="cb28-348"><a href="#cb28-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-349"><a href="#cb28-349" aria-hidden="true" tabindex="-1"></a><span class="fu">### Using Structs</span></span>
<span id="cb28-350"><a href="#cb28-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-351"><a href="#cb28-351" aria-hidden="true" tabindex="-1"></a>Creating and using structs is straightforward:</span>
<span id="cb28-352"><a href="#cb28-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-353"><a href="#cb28-353" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-354"><a href="#cb28-354" aria-hidden="true" tabindex="-1"></a><span class="in">// Declare a circle</span></span>
<span id="cb28-355"><a href="#cb28-355" aria-hidden="true" tabindex="-1"></a><span class="in">Circle c1;</span></span>
<span id="cb28-356"><a href="#cb28-356" aria-hidden="true" tabindex="-1"></a><span class="in">c1.center = vec2(0.0, 0.0);</span></span>
<span id="cb28-357"><a href="#cb28-357" aria-hidden="true" tabindex="-1"></a><span class="in">c1.radius = 1.0;</span></span>
<span id="cb28-358"><a href="#cb28-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-359"><a href="#cb28-359" aria-hidden="true" tabindex="-1"></a><span class="in">// Or initialize directly</span></span>
<span id="cb28-360"><a href="#cb28-360" aria-hidden="true" tabindex="-1"></a><span class="in">Circle c2 = Circle(vec2(1.0, 0.5), 0.75);</span></span>
<span id="cb28-361"><a href="#cb28-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-362"><a href="#cb28-362" aria-hidden="true" tabindex="-1"></a><span class="in">// Pass to functions</span></span>
<span id="cb28-363"><a href="#cb28-363" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 invertThroughCircle(vec2 p, Circle circ) {</span></span>
<span id="cb28-364"><a href="#cb28-364" aria-hidden="true" tabindex="-1"></a><span class="in">    return invertCircle(p, circ.center, circ.radius);</span></span>
<span id="cb28-365"><a href="#cb28-365" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-366"><a href="#cb28-366" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-367"><a href="#cb28-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-368"><a href="#cb28-368" aria-hidden="true" tabindex="-1"></a>The syntax is exactly what you'd expect—use the dot operator to access fields, just like accessing components of a <span class="in">`vec2`</span> or <span class="in">`vec3`</span>.</span>
<span id="cb28-369"><a href="#cb28-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-370"><a href="#cb28-370" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why Structs?</span></span>
<span id="cb28-371"><a href="#cb28-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-372"><a href="#cb28-372" aria-hidden="true" tabindex="-1"></a>They make the code dramatically more readable and maintainable. Compare:</span>
<span id="cb28-373"><a href="#cb28-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-374"><a href="#cb28-374" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-375"><a href="#cb28-375" aria-hidden="true" tabindex="-1"></a><span class="in">// Without structs - messy!</span></span>
<span id="cb28-376"><a href="#cb28-376" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 iterateInversions(vec2 p, </span></span>
<span id="cb28-377"><a href="#cb28-377" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c1_center, float c1_radius,</span></span>
<span id="cb28-378"><a href="#cb28-378" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c2_center, float c2_radius,</span></span>
<span id="cb28-379"><a href="#cb28-379" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c3_center, float c3_radius) </span></span>
<span id="cb28-380"><a href="#cb28-380" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-381"><a href="#cb28-381" aria-hidden="true" tabindex="-1"></a><span class="in">    // ... lots of parameters to keep track of</span></span>
<span id="cb28-382"><a href="#cb28-382" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-383"><a href="#cb28-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-384"><a href="#cb28-384" aria-hidden="true" tabindex="-1"></a><span class="in">// With structs - clean!</span></span>
<span id="cb28-385"><a href="#cb28-385" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 iterateInversions(vec2 p, Circle c1, Circle c2, Circle c3) </span></span>
<span id="cb28-386"><a href="#cb28-386" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-387"><a href="#cb28-387" aria-hidden="true" tabindex="-1"></a><span class="in">    // Much clearer what we're working with</span></span>
<span id="cb28-388"><a href="#cb28-388" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-389"><a href="#cb28-389" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-390"><a href="#cb28-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-391"><a href="#cb28-391" aria-hidden="true" tabindex="-1"></a>For the Apollonian gasket, we'll have three circles we need to keep track of and pass around. Structs make this much more manageable!</span>
<span id="cb28-392"><a href="#cb28-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-393"><a href="#cb28-393" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb28-394"><a href="#cb28-394" aria-hidden="true" tabindex="-1"></a><span class="fu">## Structs vs. arrays</span></span>
<span id="cb28-395"><a href="#cb28-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-396"><a href="#cb28-396" aria-hidden="true" tabindex="-1"></a>You might wonder: why not just use an array of circles? That works too! The choice depends on your needs:</span>
<span id="cb28-397"><a href="#cb28-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-398"><a href="#cb28-398" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Structs**: Better when circles have different roles (like "outer circle" vs "inner circles")</span>
<span id="cb28-399"><a href="#cb28-399" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Arrays**: Better when you have many similar circles and want to loop over them</span>
<span id="cb28-400"><a href="#cb28-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-401"><a href="#cb28-401" aria-hidden="true" tabindex="-1"></a>For the Apollonian gasket, we'll use individual structs because each circle plays a specific geometric role. In the homework you might try arrays if you're working with many circles!</span>
<span id="cb28-402"><a href="#cb28-402" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb28-403"><a href="#cb28-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-404"><a href="#cb28-404" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-405"><a href="#cb28-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-406"><a href="#cb28-406" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Apollonian Gasket</span></span>
<span id="cb28-407"><a href="#cb28-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-408"><a href="#cb28-408" aria-hidden="true" tabindex="-1"></a>Now for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It's named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles.</span>
<span id="cb28-409"><a href="#cb28-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-410"><a href="#cb28-410" aria-hidden="true" tabindex="-1"></a><span class="fu">### Setup: Three Mutually Tangent Circles</span></span>
<span id="cb28-411"><a href="#cb28-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-412"><a href="#cb28-412" aria-hidden="true" tabindex="-1"></a>We start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For simplicity, we'll use a nice symmetric configuration:</span>
<span id="cb28-413"><a href="#cb28-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-414"><a href="#cb28-414" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-415"><a href="#cb28-415" aria-hidden="true" tabindex="-1"></a><span class="in">void setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3) {</span></span>
<span id="cb28-416"><a href="#cb28-416" aria-hidden="true" tabindex="-1"></a><span class="in">    // A nice symmetric configuration</span></span>
<span id="cb28-417"><a href="#cb28-417" aria-hidden="true" tabindex="-1"></a><span class="in">    float R = 2.0;  // Outer radius</span></span>
<span id="cb28-418"><a href="#cb28-418" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 0.5;  // Inner radius</span></span>
<span id="cb28-419"><a href="#cb28-419" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-420"><a href="#cb28-420" aria-hidden="true" tabindex="-1"></a><span class="in">    // Three circles arranged in a triangle</span></span>
<span id="cb28-421"><a href="#cb28-421" aria-hidden="true" tabindex="-1"></a><span class="in">    c1 = Circle(vec2(0.0, R - r), r);</span></span>
<span id="cb28-422"><a href="#cb28-422" aria-hidden="true" tabindex="-1"></a><span class="in">    c2 = Circle(vec2(-(R - r) * 0.866, -(R - r) * 0.5), r);  // 0.866 ≈ sqrt(3)/2</span></span>
<span id="cb28-423"><a href="#cb28-423" aria-hidden="true" tabindex="-1"></a><span class="in">    c3 = Circle(vec2((R - r) * 0.866, -(R - r) * 0.5), r);</span></span>
<span id="cb28-424"><a href="#cb28-424" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-425"><a href="#cb28-425" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-426"><a href="#cb28-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-427"><a href="#cb28-427" aria-hidden="true" tabindex="-1"></a>These three circles are positioned at the vertices of an equilateral triangle, all tangent to each other and to a large outer circle (which we could add if we wanted).</span>
<span id="cb28-428"><a href="#cb28-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-429"><a href="#cb28-429" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Iteration Algorithm</span></span>
<span id="cb28-430"><a href="#cb28-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-431"><a href="#cb28-431" aria-hidden="true" tabindex="-1"></a>The algorithm is beautifully simple:</span>
<span id="cb28-432"><a href="#cb28-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-433"><a href="#cb28-433" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Start with a point $p$</span>
<span id="cb28-434"><a href="#cb28-434" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>For each iteration:</span>
<span id="cb28-435"><a href="#cb28-435" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Check which circles contain $p$</span>
<span id="cb28-436"><a href="#cb28-436" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>If $p$ is inside a circle, invert through that circle</span>
<span id="cb28-437"><a href="#cb28-437" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Repeat</span>
<span id="cb28-438"><a href="#cb28-438" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Color based on the iteration behavior</span>
<span id="cb28-439"><a href="#cb28-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-440"><a href="#cb28-440" aria-hidden="true" tabindex="-1"></a>Here's the code:</span>
<span id="cb28-441"><a href="#cb28-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-442"><a href="#cb28-442" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-443"><a href="#cb28-443" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, </span></span>
<span id="cb28-444"><a href="#cb28-444" aria-hidden="true" tabindex="-1"></a><span class="in">                       int maxIter, out int finalIter, out int lastCircle) {</span></span>
<span id="cb28-445"><a href="#cb28-445" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; maxIter; i++) {</span></span>
<span id="cb28-446"><a href="#cb28-446" aria-hidden="true" tabindex="-1"></a><span class="in">        bool moved = false;</span></span>
<span id="cb28-447"><a href="#cb28-447" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-448"><a href="#cb28-448" aria-hidden="true" tabindex="-1"></a><span class="in">        // Check each circle</span></span>
<span id="cb28-449"><a href="#cb28-449" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - c1.center) &lt; c1.radius) {</span></span>
<span id="cb28-450"><a href="#cb28-450" aria-hidden="true" tabindex="-1"></a><span class="in">            p = invertCircle(p, c1.center, c1.radius);</span></span>
<span id="cb28-451"><a href="#cb28-451" aria-hidden="true" tabindex="-1"></a><span class="in">            lastCircle = 0;</span></span>
<span id="cb28-452"><a href="#cb28-452" aria-hidden="true" tabindex="-1"></a><span class="in">            moved = true;</span></span>
<span id="cb28-453"><a href="#cb28-453" aria-hidden="true" tabindex="-1"></a><span class="in">        } </span></span>
<span id="cb28-454"><a href="#cb28-454" aria-hidden="true" tabindex="-1"></a><span class="in">        else if(length(p - c2.center) &lt; c2.radius) {</span></span>
<span id="cb28-455"><a href="#cb28-455" aria-hidden="true" tabindex="-1"></a><span class="in">            p = invertCircle(p, c2.center, c2.radius);</span></span>
<span id="cb28-456"><a href="#cb28-456" aria-hidden="true" tabindex="-1"></a><span class="in">            lastCircle = 1;</span></span>
<span id="cb28-457"><a href="#cb28-457" aria-hidden="true" tabindex="-1"></a><span class="in">            moved = true;</span></span>
<span id="cb28-458"><a href="#cb28-458" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb28-459"><a href="#cb28-459" aria-hidden="true" tabindex="-1"></a><span class="in">        else if(length(p - c3.center) &lt; c3.radius) {</span></span>
<span id="cb28-460"><a href="#cb28-460" aria-hidden="true" tabindex="-1"></a><span class="in">            p = invertCircle(p, c3.center, c3.radius);</span></span>
<span id="cb28-461"><a href="#cb28-461" aria-hidden="true" tabindex="-1"></a><span class="in">            lastCircle = 2;</span></span>
<span id="cb28-462"><a href="#cb28-462" aria-hidden="true" tabindex="-1"></a><span class="in">            moved = true;</span></span>
<span id="cb28-463"><a href="#cb28-463" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb28-464"><a href="#cb28-464" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-465"><a href="#cb28-465" aria-hidden="true" tabindex="-1"></a><span class="in">        // If we didn't move, we're done</span></span>
<span id="cb28-466"><a href="#cb28-466" aria-hidden="true" tabindex="-1"></a><span class="in">        if(!moved) {</span></span>
<span id="cb28-467"><a href="#cb28-467" aria-hidden="true" tabindex="-1"></a><span class="in">            finalIter = i;</span></span>
<span id="cb28-468"><a href="#cb28-468" aria-hidden="true" tabindex="-1"></a><span class="in">            return p;</span></span>
<span id="cb28-469"><a href="#cb28-469" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb28-470"><a href="#cb28-470" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-471"><a href="#cb28-471" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-472"><a href="#cb28-472" aria-hidden="true" tabindex="-1"></a><span class="in">    finalIter = maxIter;</span></span>
<span id="cb28-473"><a href="#cb28-473" aria-hidden="true" tabindex="-1"></a><span class="in">    return p;</span></span>
<span id="cb28-474"><a href="#cb28-474" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-475"><a href="#cb28-475" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-476"><a href="#cb28-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-477"><a href="#cb28-477" aria-hidden="true" tabindex="-1"></a>We also track which circle we last inverted through (stored in <span class="in">`lastCircle`</span>) and how many iterations we performed (stored in <span class="in">`finalIter`</span>). These will be useful for coloring!</span>
<span id="cb28-478"><a href="#cb28-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-479"><a href="#cb28-479" aria-hidden="true" tabindex="-1"></a><span class="fu">### Coloring Strategies</span></span>
<span id="cb28-480"><a href="#cb28-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-481"><a href="#cb28-481" aria-hidden="true" tabindex="-1"></a>There are several interesting ways to color the Apollonian gasket:</span>
<span id="cb28-482"><a href="#cb28-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-483"><a href="#cb28-483" aria-hidden="true" tabindex="-1"></a>**By iteration count** (like the Mandelbrot set):</span>
<span id="cb28-484"><a href="#cb28-484" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-485"><a href="#cb28-485" aria-hidden="true" tabindex="-1"></a><span class="in">float t = float(finalIter) / float(maxIter);</span></span>
<span id="cb28-486"><a href="#cb28-486" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = palette(t);</span></span>
<span id="cb28-487"><a href="#cb28-487" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-488"><a href="#cb28-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-489"><a href="#cb28-489" aria-hidden="true" tabindex="-1"></a>**By last circle hit**:</span>
<span id="cb28-490"><a href="#cb28-490" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-491"><a href="#cb28-491" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 colors[3] = vec3[3](</span></span>
<span id="cb28-492"><a href="#cb28-492" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3(1.0, 0.0, 0.0),  // Circle 1: red</span></span>
<span id="cb28-493"><a href="#cb28-493" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3(0.0, 1.0, 0.0),  // Circle 2: green</span></span>
<span id="cb28-494"><a href="#cb28-494" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3(0.0, 0.0, 1.0)   // Circle 3: blue</span></span>
<span id="cb28-495"><a href="#cb28-495" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb28-496"><a href="#cb28-496" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = colors[lastCircle];</span></span>
<span id="cb28-497"><a href="#cb28-497" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-498"><a href="#cb28-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-499"><a href="#cb28-499" aria-hidden="true" tabindex="-1"></a>**By final distance from circles**:</span>
<span id="cb28-500"><a href="#cb28-500" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-501"><a href="#cb28-501" aria-hidden="true" tabindex="-1"></a><span class="in">float d1 = abs(length(p - c1.center) - c1.radius);</span></span>
<span id="cb28-502"><a href="#cb28-502" aria-hidden="true" tabindex="-1"></a><span class="in">float d2 = abs(length(p - c2.center) - c2.radius);</span></span>
<span id="cb28-503"><a href="#cb28-503" aria-hidden="true" tabindex="-1"></a><span class="in">float d3 = abs(length(p - c3.center) - c3.radius);</span></span>
<span id="cb28-504"><a href="#cb28-504" aria-hidden="true" tabindex="-1"></a><span class="in">float d = min(d1, min(d2, d3));</span></span>
<span id="cb28-505"><a href="#cb28-505" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = vec3(smoothstep(0.0, 0.05, d));</span></span>
<span id="cb28-506"><a href="#cb28-506" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-507"><a href="#cb28-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-508"><a href="#cb28-508" aria-hidden="true" tabindex="-1"></a>Each gives a different view of the fractal structure. The iteration count shows the "depth" of the orbit, the last circle shows the basin of attraction, and the distance shows the geometric structure of the nested circles.</span>
<span id="cb28-509"><a href="#cb28-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-510"><a href="#cb28-510" aria-hidden="true" tabindex="-1"></a><span class="fu">### Putting It All Together</span></span>
<span id="cb28-511"><a href="#cb28-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-512"><a href="#cb28-512" aria-hidden="true" tabindex="-1"></a>Here's a complete Apollonian gasket renderer:</span>
<span id="cb28-513"><a href="#cb28-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-514"><a href="#cb28-514" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-515"><a href="#cb28-515" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-516"><a href="#cb28-516" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-517"><a href="#cb28-517" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup, resulting in p]</span></span>
<span id="cb28-518"><a href="#cb28-518" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-519"><a href="#cb28-519" aria-hidden="true" tabindex="-1"></a><span class="in">    // Setup the three circles</span></span>
<span id="cb28-520"><a href="#cb28-520" aria-hidden="true" tabindex="-1"></a><span class="in">    Circle c1, c2, c3;</span></span>
<span id="cb28-521"><a href="#cb28-521" aria-hidden="true" tabindex="-1"></a><span class="in">    setupApollonianCircles(c1, c2, c3);</span></span>
<span id="cb28-522"><a href="#cb28-522" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-523"><a href="#cb28-523" aria-hidden="true" tabindex="-1"></a><span class="in">    // Iterate</span></span>
<span id="cb28-524"><a href="#cb28-524" aria-hidden="true" tabindex="-1"></a><span class="in">    int maxIter = 50;</span></span>
<span id="cb28-525"><a href="#cb28-525" aria-hidden="true" tabindex="-1"></a><span class="in">    int finalIter, lastCircle;</span></span>
<span id="cb28-526"><a href="#cb28-526" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 final_p = iterateApollonian(p, c1, c2, c3, maxIter, finalIter, lastCircle);</span></span>
<span id="cb28-527"><a href="#cb28-527" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-528"><a href="#cb28-528" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color by iteration count with palette</span></span>
<span id="cb28-529"><a href="#cb28-529" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(finalIter) / float(maxIter);</span></span>
<span id="cb28-530"><a href="#cb28-530" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb28-531"><a href="#cb28-531" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-532"><a href="#cb28-532" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw the three circles themselves for reference</span></span>
<span id="cb28-533"><a href="#cb28-533" aria-hidden="true" tabindex="-1"></a><span class="in">    float d1 = abs(length(p - c1.center) - c1.radius);</span></span>
<span id="cb28-534"><a href="#cb28-534" aria-hidden="true" tabindex="-1"></a><span class="in">    float d2 = abs(length(p - c2.center) - c2.radius);</span></span>
<span id="cb28-535"><a href="#cb28-535" aria-hidden="true" tabindex="-1"></a><span class="in">    float d3 = abs(length(p - c3.center) - c3.radius);</span></span>
<span id="cb28-536"><a href="#cb28-536" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = min(d1, min(d2, d3));</span></span>
<span id="cb28-537"><a href="#cb28-537" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-538"><a href="#cb28-538" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.02) color = vec3(1.0);  // White circles</span></span>
<span id="cb28-539"><a href="#cb28-539" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-540"><a href="#cb28-540" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-541"><a href="#cb28-541" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-542"><a href="#cb28-542" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-543"><a href="#cb28-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-544"><a href="#cb28-544" aria-hidden="true" tabindex="-1"></a>You should see a beautiful nested pattern of circles! Zoom in (by scaling <span class="in">`p`</span> differently) to see the fractal self-similarity—no matter how far you zoom, you'll keep finding more nested circles.</span>
<span id="cb28-545"><a href="#cb28-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-546"><a href="#cb28-546" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb28-547"><a href="#cb28-547" aria-hidden="true" tabindex="-1"></a><span class="fu">## The mathematics of Apollonian gaskets</span></span>
<span id="cb28-548"><a href="#cb28-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-549"><a href="#cb28-549" aria-hidden="true" tabindex="-1"></a>The Apollonian gasket has deep connections to number theory and hyperbolic geometry. If you choose the initial circles carefully (with integer curvatures), all the nested circles will also have integer curvatures—this is the content of the "Descartes Circle Theorem."</span>
<span id="cb28-550"><a href="#cb28-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-551"><a href="#cb28-551" aria-hidden="true" tabindex="-1"></a>The pattern is also related to hyperbolic tilings, which we'll explore tomorrow. The inversions we're doing here are actually isometries (distance-preserving maps) of hyperbolic space! So in some sense, we're already working in non-Euclidean geometry without realizing it.</span>
<span id="cb28-552"><a href="#cb28-552" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb28-553"><a href="#cb28-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-554"><a href="#cb28-554" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-555"><a href="#cb28-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-556"><a href="#cb28-556" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb28-557"><a href="#cb28-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-558"><a href="#cb28-558" aria-hidden="true" tabindex="-1"></a>Today we've explored two powerful iterative processes:</span>
<span id="cb28-559"><a href="#cb28-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-560"><a href="#cb28-560" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Complex dynamics**: The Mandelbrot set emerges from iterating $z \mapsto z^2 + c$</span>
<span id="cb28-561"><a href="#cb28-561" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Implemented complex arithmetic in GLSL</span>
<span id="cb28-562"><a href="#cb28-562" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Escape-time algorithms and smooth coloring</span>
<span id="cb28-563"><a href="#cb28-563" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>The power of simple quadratic iteration</span>
<span id="cb28-564"><a href="#cb28-564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-565"><a href="#cb28-565" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Geometric dynamics**: The Apollonian gasket emerges from iterating circle inversions</span>
<span id="cb28-566"><a href="#cb28-566" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Circle inversion as a conformal transformation</span>
<span id="cb28-567"><a href="#cb28-567" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Structs for organizing geometric data</span>
<span id="cb28-568"><a href="#cb28-568" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Iterated inversions creating fractal patterns</span>
<span id="cb28-569"><a href="#cb28-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-570"><a href="#cb28-570" aria-hidden="true" tabindex="-1"></a>Both show how incredibly simple rules—a quadratic map, a geometric transformation—can generate infinite complexity through iteration. This is one of the core insights of fractal geometry and dynamical systems!</span>
<span id="cb28-571"><a href="#cb28-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-572"><a href="#cb28-572" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-573"><a href="#cb28-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-574"><a href="#cb28-574" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb28-575"><a href="#cb28-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-576"><a href="#cb28-576" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Julia Sets</span></span>
<span id="cb28-577"><a href="#cb28-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-578"><a href="#cb28-578" aria-hidden="true" tabindex="-1"></a>The Julia set is the natural companion to the Mandelbrot set. Instead of varying $c$ and fixing $z_0 = 0$, we fix $c$ and vary $z_0$!</span>
<span id="cb28-579"><a href="#cb28-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-580"><a href="#cb28-580" aria-hidden="true" tabindex="-1"></a>**The setup:** For a fixed complex number $c$, the Julia set $J_c$ is the set of initial conditions $z_0$ for which the iteration $z_{n+1} = z_n^2 + c$ remains bounded.</span>
<span id="cb28-581"><a href="#cb28-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-582"><a href="#cb28-582" aria-hidden="true" tabindex="-1"></a>**Implementation:**</span>
<span id="cb28-583"><a href="#cb28-583" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-584"><a href="#cb28-584" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-585"><a href="#cb28-585" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-586"><a href="#cb28-586" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup, resulting in p]</span></span>
<span id="cb28-587"><a href="#cb28-587" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-588"><a href="#cb28-588" aria-hidden="true" tabindex="-1"></a><span class="in">    // The initial z is now the pixel position!</span></span>
<span id="cb28-589"><a href="#cb28-589" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = p;</span></span>
<span id="cb28-590"><a href="#cb28-590" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-591"><a href="#cb28-591" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fix c to an interesting value</span></span>
<span id="cb28-592"><a href="#cb28-592" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c = vec2(-0.7, 0.27015);  // Classic Julia set parameter</span></span>
<span id="cb28-593"><a href="#cb28-593" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-594"><a href="#cb28-594" aria-hidden="true" tabindex="-1"></a><span class="in">    // Iterate z_{n+1} = z_n² + c</span></span>
<span id="cb28-595"><a href="#cb28-595" aria-hidden="true" tabindex="-1"></a><span class="in">    int max_iter = 100;</span></span>
<span id="cb28-596"><a href="#cb28-596" aria-hidden="true" tabindex="-1"></a><span class="in">    int iter;</span></span>
<span id="cb28-597"><a href="#cb28-597" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-598"><a href="#cb28-598" aria-hidden="true" tabindex="-1"></a><span class="in">    for(iter = 0; iter &lt; max_iter; iter++) {</span></span>
<span id="cb28-599"><a href="#cb28-599" aria-hidden="true" tabindex="-1"></a><span class="in">        if(cabs2(z) &gt; 4.0) break;</span></span>
<span id="cb28-600"><a href="#cb28-600" aria-hidden="true" tabindex="-1"></a><span class="in">        z = cmul(z, z) + c;</span></span>
<span id="cb28-601"><a href="#cb28-601" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-602"><a href="#cb28-602" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-603"><a href="#cb28-603" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on escape time</span></span>
<span id="cb28-604"><a href="#cb28-604" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(iter) / float(max_iter);</span></span>
<span id="cb28-605"><a href="#cb28-605" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb28-606"><a href="#cb28-606" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-607"><a href="#cb28-607" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-608"><a href="#cb28-608" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-609"><a href="#cb28-609" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-610"><a href="#cb28-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-611"><a href="#cb28-611" aria-hidden="true" tabindex="-1"></a>**Exploration—pick one:**</span>
<span id="cb28-612"><a href="#cb28-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-613"><a href="#cb28-613" aria-hidden="true" tabindex="-1"></a>**Option A: Animated parameter space**</span>
<span id="cb28-614"><a href="#cb28-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-615"><a href="#cb28-615" aria-hidden="true" tabindex="-1"></a>Animate $c$ to explore how the Julia set morphs:</span>
<span id="cb28-616"><a href="#cb28-616" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-617"><a href="#cb28-617" aria-hidden="true" tabindex="-1"></a><span class="in">float angle = iTime * 0.3;</span></span>
<span id="cb28-618"><a href="#cb28-618" aria-hidden="true" tabindex="-1"></a><span class="in">float radius = 0.7885;  // Radius in parameter space</span></span>
<span id="cb28-619"><a href="#cb28-619" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 c = vec2(radius * cos(angle), radius * sin(angle));</span></span>
<span id="cb28-620"><a href="#cb28-620" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-621"><a href="#cb28-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-622"><a href="#cb28-622" aria-hidden="true" tabindex="-1"></a>Watch how the Julia set changes as you trace a circle in the complex plane! You'll see it morph from connected to disconnected, develop tendrils, and create beautiful organic shapes.</span>
<span id="cb28-623"><a href="#cb28-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-624"><a href="#cb28-624" aria-hidden="true" tabindex="-1"></a>**Option B: Mouse-controlled exploration**</span>
<span id="cb28-625"><a href="#cb28-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-626"><a href="#cb28-626" aria-hidden="true" tabindex="-1"></a>Tie $c$ to the mouse position:</span>
<span id="cb28-627"><a href="#cb28-627" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-628"><a href="#cb28-628" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;</span></span>
<span id="cb28-629"><a href="#cb28-629" aria-hidden="true" tabindex="-1"></a><span class="in">mouse_uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb28-630"><a href="#cb28-630" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 c = mouse_uv * 3.0;</span></span>
<span id="cb28-631"><a href="#cb28-631" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-632"><a href="#cb28-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-633"><a href="#cb28-633" aria-hidden="true" tabindex="-1"></a>Now you can explore parameter space interactively! Move the mouse around to see different Julia sets. This really helps build intuition for how the Julia set depends on $c$.</span>
<span id="cb28-634"><a href="#cb28-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-635"><a href="#cb28-635" aria-hidden="true" tabindex="-1"></a>**Interesting values to try:**</span>
<span id="cb28-636"><a href="#cb28-636" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.4, 0.6)`</span> - dendrite-like fractal trees</span>
<span id="cb28-637"><a href="#cb28-637" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(0.285, 0.01)`</span> - beautiful spiral patterns  </span>
<span id="cb28-638"><a href="#cb28-638" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.8, 0.156)`</span> - intricate filaments</span>
<span id="cb28-639"><a href="#cb28-639" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.7269, 0.1889)`</span> - "Douady's rabbit" (famous Julia set)</span>
<span id="cb28-640"><a href="#cb28-640" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.835, -0.2321)`</span> - another classic</span>
<span id="cb28-641"><a href="#cb28-641" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.70176, -0.3842)`</span> - "San Marco dragon"</span>
<span id="cb28-642"><a href="#cb28-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-643"><a href="#cb28-643" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #1: Grid of Julia Sets</span></span>
<span id="cb28-644"><a href="#cb28-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-645"><a href="#cb28-645" aria-hidden="true" tabindex="-1"></a>Here's a beautiful connection: create a grid where each cell shows the Julia set for that value of $c$, and watch the Mandelbrot set emerge!</span>
<span id="cb28-646"><a href="#cb28-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-647"><a href="#cb28-647" aria-hidden="true" tabindex="-1"></a>**The idea:** The Mandelbrot set is a map of Julia set topology—points in $\mathcal{M}$ have connected Julia sets, points outside have disconnected Julia sets. If we draw a grid of Julia sets, we should see this pattern!</span>
<span id="cb28-648"><a href="#cb28-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-649"><a href="#cb28-649" aria-hidden="true" tabindex="-1"></a>**Implementation strategy:**</span>
<span id="cb28-650"><a href="#cb28-650" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-651"><a href="#cb28-651" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-652"><a href="#cb28-652" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-653"><a href="#cb28-653" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup]</span></span>
<span id="cb28-654"><a href="#cb28-654" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-655"><a href="#cb28-655" aria-hidden="true" tabindex="-1"></a><span class="in">    // Divide screen into grid cells</span></span>
<span id="cb28-656"><a href="#cb28-656" aria-hidden="true" tabindex="-1"></a><span class="in">    float grid_size = 8.0;  // 8x8 grid</span></span>
<span id="cb28-657"><a href="#cb28-657" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_id = floor(p * grid_size / 4.0);</span></span>
<span id="cb28-658"><a href="#cb28-658" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;</span></span>
<span id="cb28-659"><a href="#cb28-659" aria-hidden="true" tabindex="-1"></a><span class="in">    cell_p *= 4.0;  // Local coordinates within cell</span></span>
<span id="cb28-660"><a href="#cb28-660" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-661"><a href="#cb28-661" aria-hidden="true" tabindex="-1"></a><span class="in">    // Map cell_id to parameter c</span></span>
<span id="cb28-662"><a href="#cb28-662" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c = (cell_id / grid_size) * 4.0 - vec2(2.5, 2.0);</span></span>
<span id="cb28-663"><a href="#cb28-663" aria-hidden="true" tabindex="-1"></a><span class="in">    c.x -= 0.5;  // Center on interesting region</span></span>
<span id="cb28-664"><a href="#cb28-664" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-665"><a href="#cb28-665" aria-hidden="true" tabindex="-1"></a><span class="in">    // Run Julia set iteration with z = cell_p, fixed c</span></span>
<span id="cb28-666"><a href="#cb28-666" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = cell_p;</span></span>
<span id="cb28-667"><a href="#cb28-667" aria-hidden="true" tabindex="-1"></a><span class="in">    int max_iter = 50;</span></span>
<span id="cb28-668"><a href="#cb28-668" aria-hidden="true" tabindex="-1"></a><span class="in">    // [iterate as in Julia set code]</span></span>
<span id="cb28-669"><a href="#cb28-669" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-670"><a href="#cb28-670" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color</span></span>
<span id="cb28-671"><a href="#cb28-671" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(iter) / float(max_iter);</span></span>
<span id="cb28-672"><a href="#cb28-672" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb28-673"><a href="#cb28-673" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-674"><a href="#cb28-674" aria-hidden="true" tabindex="-1"></a><span class="in">    // Optional: draw grid lines</span></span>
<span id="cb28-675"><a href="#cb28-675" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);</span></span>
<span id="cb28-676"><a href="#cb28-676" aria-hidden="true" tabindex="-1"></a><span class="in">    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);</span></span>
<span id="cb28-677"><a href="#cb28-677" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-678"><a href="#cb28-678" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-679"><a href="#cb28-679" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-680"><a href="#cb28-680" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-681"><a href="#cb28-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-682"><a href="#cb28-682" aria-hidden="true" tabindex="-1"></a>You should see a grid of tiny Julia sets, and if you look carefully, you'll notice that the overall pattern resembles the Mandelbrot set! The cells with connected Julia sets (where you see solid regions) correspond to points in the Mandelbrot set, while cells with disconnected Julia sets (dust-like patterns) are outside.</span>
<span id="cb28-683"><a href="#cb28-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-684"><a href="#cb28-684" aria-hidden="true" tabindex="-1"></a>This is one of the most beautiful connections in complex dynamics—the Mandelbrot set is literally a map showing which parameters give connected Julia sets!</span>
<span id="cb28-685"><a href="#cb28-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-686"><a href="#cb28-686" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #2: Other Iterated Inversions</span></span>
<span id="cb28-687"><a href="#cb28-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-688"><a href="#cb28-688" aria-hidden="true" tabindex="-1"></a>Explore variations on the Apollonian gasket theme! The key is to set up circles in interesting configurations and iterate inversions.</span>
<span id="cb28-689"><a href="#cb28-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-690"><a href="#cb28-690" aria-hidden="true" tabindex="-1"></a>**Simple variations:**</span>
<span id="cb28-691"><a href="#cb28-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-692"><a href="#cb28-692" aria-hidden="true" tabindex="-1"></a>**Different circle arrangements:**</span>
<span id="cb28-693"><a href="#cb28-693" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Four circles in a square configuration</span>
<span id="cb28-694"><a href="#cb28-694" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Five circles in a pentagonal arrangement  </span>
<span id="cb28-695"><a href="#cb28-695" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Nested circles (one large, several small inside)</span>
<span id="cb28-696"><a href="#cb28-696" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Randomly placed circles (use a hash function to generate positions)</span>
<span id="cb28-697"><a href="#cb28-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-698"><a href="#cb28-698" aria-hidden="true" tabindex="-1"></a>**Non-uniform radii:**</span>
<span id="cb28-699"><a href="#cb28-699" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-700"><a href="#cb28-700" aria-hidden="true" tabindex="-1"></a><span class="in">// Make circles pulse</span></span>
<span id="cb28-701"><a href="#cb28-701" aria-hidden="true" tabindex="-1"></a><span class="in">c1.radius = 0.5 + 0.2 * sin(iTime);</span></span>
<span id="cb28-702"><a href="#cb28-702" aria-hidden="true" tabindex="-1"></a><span class="in">c2.radius = 0.5 + 0.2 * sin(iTime + 2.0 * 3.14159 / 3.0);</span></span>
<span id="cb28-703"><a href="#cb28-703" aria-hidden="true" tabindex="-1"></a><span class="in">c3.radius = 0.5 + 0.2 * sin(iTime + 4.0 * 3.14159 / 3.0);</span></span>
<span id="cb28-704"><a href="#cb28-704" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-705"><a href="#cb28-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-706"><a href="#cb28-706" aria-hidden="true" tabindex="-1"></a>**Alternating inversion patterns:**</span>
<span id="cb28-707"><a href="#cb28-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-708"><a href="#cb28-708" aria-hidden="true" tabindex="-1"></a>Instead of inverting through whichever circle contains the point, try alternating in a fixed pattern:</span>
<span id="cb28-709"><a href="#cb28-709" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-710"><a href="#cb28-710" aria-hidden="true" tabindex="-1"></a><span class="in">// Cycle through circles in order</span></span>
<span id="cb28-711"><a href="#cb28-711" aria-hidden="true" tabindex="-1"></a><span class="in">int circle_index = i % 3;</span></span>
<span id="cb28-712"><a href="#cb28-712" aria-hidden="true" tabindex="-1"></a><span class="in">if(circle_index == 0) p = invertCircle(p, c1.center, c1.radius);</span></span>
<span id="cb28-713"><a href="#cb28-713" aria-hidden="true" tabindex="-1"></a><span class="in">else if(circle_index == 1) p = invertCircle(p, c2.center, c2.radius);</span></span>
<span id="cb28-714"><a href="#cb28-714" aria-hidden="true" tabindex="-1"></a><span class="in">else p = invertCircle(p, c3.center, c3.radius);</span></span>
<span id="cb28-715"><a href="#cb28-715" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-716"><a href="#cb28-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-717"><a href="#cb28-717" aria-hidden="true" tabindex="-1"></a>This creates very different patterns—more regular and less "space-filling" than the gasket, but with interesting self-similarity.</span>
<span id="cb28-718"><a href="#cb28-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-719"><a href="#cb28-719" aria-hidden="true" tabindex="-1"></a>**Challenge:** Can you create a configuration that tiles the plane with circular patterns? What about one that creates spiraling structures?</span>
<span id="cb28-720"><a href="#cb28-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-721"><a href="#cb28-721" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-722"><a href="#cb28-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-723"><a href="#cb28-723" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking Ahead</span></span>
<span id="cb28-724"><a href="#cb28-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-725"><a href="#cb28-725" aria-hidden="true" tabindex="-1"></a>Tomorrow we'll continue with geometric tilings! We'll start in Euclidean space with triangle tilings using reflections, then move to **hyperbolic geometry**. The circle inversions you've learned today are actually hyperbolic isometries—so we're already doing non-Euclidean geometry without realizing it!</span>
<span id="cb28-726"><a href="#cb28-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-727"><a href="#cb28-727" aria-hidden="true" tabindex="-1"></a>We'll explore multiple models of the hyperbolic plane (upper half-plane, Poincaré disk) and create beautiful tilings with $(2,3,\infty)$ triangles. The same algorithmic ideas (iterated geometric transformations) work in hyperbolic space, but the results are even more intricate because hyperbolic space has "more room" than Euclidean space.</span>
<span id="cb28-728"><a href="#cb28-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-729"><a href="#cb28-729" aria-hidden="true" tabindex="-1"></a>Make sure you're comfortable with:</span>
<span id="cb28-730"><a href="#cb28-730" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Iteration and escape-time algorithms (we'll use similar ideas for tiling)</span>
<span id="cb28-731"><a href="#cb28-731" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Circle inversion (this becomes reflection in hyperbolic geodesics!)</span>
<span id="cb28-732"><a href="#cb28-732" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Structs for organizing data</span>
<span id="cb28-733"><a href="#cb28-733" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Coloring strategies based on orbit behavior</span>
<span id="cb28-734"><a href="#cb28-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-735"><a href="#cb28-735" aria-hidden="true" tabindex="-1"></a>See you tomorrow!</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>