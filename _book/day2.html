<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Day 2: Complex Dynamics and Iterated Inversions – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./day3.html" rel="next">
<link href="./day1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-597958c53c93a607afca12fd375c57ed.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-7ac2f9da8c2617a4fdd15004b4601015.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-597958c53c93a607afca12fd375c57ed.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e192c2ce351653e2d082fb362f7b7010.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-716a622b51d344c68734a98b9754e0e5.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-e192c2ce351653e2d082fb362f7b7010.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./day2.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/yourusername/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 1</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 2</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">2.1</span> Overview</a></li>
  <li><a href="#complex-numbers-in-glsl" id="toc-complex-numbers-in-glsl" class="nav-link" data-scroll-target="#complex-numbers-in-glsl"><span class="header-section-number">2.2</span> Complex Numbers in GLSL</a>
  <ul class="collapse">
  <li><a href="#representation" id="toc-representation" class="nav-link" data-scroll-target="#representation">Representation</a></li>
  <li><a href="#complex-arithmetic" id="toc-complex-arithmetic" class="nav-link" data-scroll-target="#complex-arithmetic">Complex Arithmetic</a></li>
  </ul></li>
  <li><a href="#the-mandelbrot-set" id="toc-the-mandelbrot-set" class="nav-link" data-scroll-target="#the-mandelbrot-set"><span class="header-section-number">2.3</span> The Mandelbrot Set</a>
  <ul class="collapse">
  <li><a href="#definition" id="toc-definition" class="nav-link" data-scroll-target="#definition">Definition</a></li>
  <li><a href="#the-escape-radius-theorem" id="toc-the-escape-radius-theorem" class="nav-link" data-scroll-target="#the-escape-radius-theorem">The Escape Radius Theorem</a></li>
  <li><a href="#historical-context" id="toc-historical-context" class="nav-link" data-scroll-target="#historical-context">Historical Context</a></li>
  <li><a href="#basic-implementation" id="toc-basic-implementation" class="nav-link" data-scroll-target="#basic-implementation">Basic Implementation</a></li>
  <li><a href="#smooth-coloring" id="toc-smooth-coloring" class="nav-link" data-scroll-target="#smooth-coloring">Smooth Coloring</a></li>
  <li><a href="#color-palettes" id="toc-color-palettes" class="nav-link" data-scroll-target="#color-palettes">Color Palettes</a></li>
  </ul></li>
  <li><a href="#julia-sets" id="toc-julia-sets" class="nav-link" data-scroll-target="#julia-sets"><span class="header-section-number">2.4</span> Julia Sets</a>
  <ul class="collapse">
  <li><a href="#definition-1" id="toc-definition-1" class="nav-link" data-scroll-target="#definition-1">Definition</a></li>
  <li><a href="#implementation-as-homework" id="toc-implementation-as-homework" class="nav-link" data-scroll-target="#implementation-as-homework">Implementation as Homework</a></li>
  </ul></li>
  <li><a href="#interlude-from-complex-to-geometric-dynamics" id="toc-interlude-from-complex-to-geometric-dynamics" class="nav-link" data-scroll-target="#interlude-from-complex-to-geometric-dynamics"><span class="header-section-number">2.5</span> Interlude: From Complex to Geometric Dynamics</a></li>
  <li><a href="#circle-inversion" id="toc-circle-inversion" class="nav-link" data-scroll-target="#circle-inversion"><span class="header-section-number">2.6</span> Circle Inversion</a>
  <ul class="collapse">
  <li><a href="#mathematical-definition" id="toc-mathematical-definition" class="nav-link" data-scroll-target="#mathematical-definition">Mathematical Definition</a></li>
  <li><a href="#key-properties" id="toc-key-properties" class="nav-link" data-scroll-target="#key-properties">Key Properties</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  <li><a href="#visualizing-circle-inversion" id="toc-visualizing-circle-inversion" class="nav-link" data-scroll-target="#visualizing-circle-inversion">Visualizing Circle Inversion</a></li>
  </ul></li>
  <li><a href="#structs-in-glsl" id="toc-structs-in-glsl" class="nav-link" data-scroll-target="#structs-in-glsl"><span class="header-section-number">2.7</span> Structs in GLSL</a>
  <ul class="collapse">
  <li><a href="#defining-and-using-structs" id="toc-defining-and-using-structs" class="nav-link" data-scroll-target="#defining-and-using-structs">Defining and Using Structs</a></li>
  </ul></li>
  <li><a href="#the-apollonian-gasket" id="toc-the-apollonian-gasket" class="nav-link" data-scroll-target="#the-apollonian-gasket"><span class="header-section-number">2.8</span> The Apollonian Gasket</a>
  <ul class="collapse">
  <li><a href="#descartes-circle-theorem" id="toc-descartes-circle-theorem" class="nav-link" data-scroll-target="#descartes-circle-theorem">Descartes Circle Theorem</a></li>
  <li><a href="#setup-three-mutually-tangent-circles" id="toc-setup-three-mutually-tangent-circles" class="nav-link" data-scroll-target="#setup-three-mutually-tangent-circles">Setup: Three Mutually Tangent Circles</a></li>
  <li><a href="#the-iteration-algorithm" id="toc-the-iteration-algorithm" class="nav-link" data-scroll-target="#the-iteration-algorithm">The Iteration Algorithm</a></li>
  <li><a href="#coloring-strategies" id="toc-coloring-strategies" class="nav-link" data-scroll-target="#coloring-strategies">Coloring Strategies</a></li>
  <li><a href="#putting-it-all-together" id="toc-putting-it-all-together" class="nav-link" data-scroll-target="#putting-it-all-together">Putting It All Together</a></li>
  <li><a href="#historical-context-and-connections" id="toc-historical-context-and-connections" class="nav-link" data-scroll-target="#historical-context-and-connections">Historical Context and Connections</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">2.9</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">2.10</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-julia-set-explorer" id="toc-required-julia-set-explorer" class="nav-link" data-scroll-target="#required-julia-set-explorer">Required: Julia Set Explorer</a></li>
  <li><a href="#optional-1-grid-of-julia-sets" id="toc-optional-1-grid-of-julia-sets" class="nav-link" data-scroll-target="#optional-1-grid-of-julia-sets">Optional #1: Grid of Julia Sets</a></li>
  <li><a href="#optional-2-other-iterated-inversions" id="toc-optional-2-other-iterated-inversions" class="nav-link" data-scroll-target="#optional-2-other-iterated-inversions">Optional #2: Other Iterated Inversions</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">2.11</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">2.1</span> Overview</h2>
<p>Today we explore the power of iteration to generate fractals. We’ll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set, then understand its companion, the Julia set. After that, we shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We’ll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles.</p>
<p>By the end of today, you’ll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Roadmap for Today
</div>
</div>
<div class="callout-body-container callout-body">
<p>We’ll explore iteration in two different mathematical settings:</p>
<ol type="1">
<li><strong>Complex dynamics</strong>: Iterating holomorphic maps (Mandelbrot and Julia sets)</li>
<li><strong>Geometric dynamics</strong>: Iterating circle inversions (Apollonian gasket)</li>
</ol>
<p>Both produce fractals through the same fundamental mechanism: simple rules applied repeatedly reveal infinite complexity. The common thread is <strong>conformality</strong>—both complex multiplication and circle inversion preserve angles, and this angle preservation is key to the beautiful structures we’ll see.</p>
<p>Along the way, we’ll learn shader programming techniques for organizing data (structs), implementing mathematical operations efficiently, and creating sophisticated coloring schemes.</p>
</div>
</div>
<hr>
</section>
<section id="complex-numbers-in-glsl" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="complex-numbers-in-glsl"><span class="header-section-number">2.2</span> Complex Numbers in GLSL</h2>
<section id="representation" class="level3">
<h3 class="anchored" data-anchor-id="representation">Representation</h3>
<p>A complex number <span class="math inline">\(z = a + bi\)</span> can be represented as a 2D vector with real part <span class="math inline">\(a\)</span> and imaginary part <span class="math inline">\(b\)</span>. This is the natural representation—complex numbers are the 2D plane with a particular multiplication structure! In GLSL:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> z <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span>  <span class="co">// Represents a + bi</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>We’ll consistently use the convention: <code>z.x</code> is the real part, <code>z.y</code> is the imaginary part. You already know complex numbers geometrically as rotations and scalings in the plane—here we’re just implementing that algebra in shader code.</p>
</section>
<section id="complex-arithmetic" class="level3">
<h3 class="anchored" data-anchor-id="complex-arithmetic">Complex Arithmetic</h3>
<p>Let <span class="math inline">\(z = a + bi\)</span> and <span class="math inline">\(w = c + di\)</span>. We need to implement the basic operations. Some of these are trivial, others require a bit more work:</p>
<p><strong>Addition:</strong> <span class="math inline">\((a + bi) + (c + di) = (a + c) + (b + d)i\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cadd</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z <span class="op">+</span> w<span class="op">;</span>  <span class="co">// Vector addition is sufficient!</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Addition of complex numbers is just vector addition—componentwise! You might not even need this function since you can just write <code>z + w</code> directly, but it’s here for completeness.</p>
<p><strong>Multiplication:</strong> <span class="math inline">\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">,</span>  <span class="co">// Real part: ac - bd</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span>   <span class="co">// Imaginary part: ad + bc</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This implements the familiar FOIL pattern with <span class="math inline">\(i^2 = -1\)</span>, giving us that minus sign in the real part.</p>
<p><strong>Magnitude squared:</strong> <span class="math inline">\(|z|^2 = a^2 + b^2\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">cabs2</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">dot</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">);</span>  <span class="co">// z.x * z.x + z.y * z.y</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The squared magnitude is just the dot product with itself. This is computationally cheaper than taking the square root, so when we just need to check if <span class="math inline">\(|z| &gt; 2\)</span>, we’ll check if <span class="math inline">\(|z|^2 &gt; 4\)</span> instead—millions of avoided square roots per frame!</p>
<p><strong>Magnitude:</strong> <span class="math inline">\(|z| = \sqrt{a^2 + b^2}\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">cabs</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span>z<span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The magnitude is the Euclidean distance from the origin—exactly what <code>length()</code> computes!</p>
<p><strong>Conjugate:</strong> <span class="math inline">\(\overline{z} = a - bi\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cconj</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>z<span class="op">.</span><span class="fu">x</span><span class="op">,</span> <span class="op">-</span>z<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The conjugate flips the sign of the imaginary part—reflection across the real axis.</p>
<p><strong>Division:</strong> <span class="math inline">\(\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{c^2 + d^2}\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cdiv</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>w<span class="op">,</span> w<span class="op">);</span>  <span class="co">// c² + d²</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom<span class="op">,</span>  <span class="co">// Real part</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom   <span class="co">// Imaginary part</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Division multiplies numerator and denominator by the conjugate of <span class="math inline">\(w\)</span> to rationalize. The denominator becomes real (<span class="math inline">\(c^2 + d^2\)</span>), and the numerator becomes a new complex number we can compute directly.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Computational Efficiency in Complex Arithmetic
</div>
</div>
<div class="callout-body-container callout-body">
<p>Notice we use <code>dot(z, z)</code> for magnitude squared—this is a single GPU operation rather than component-wise multiplication and addition. Similarly, <code>dot(w, w)</code> in the division routine. For operations you’ll compute millions of times per frame, these micro-optimizations add up!</p>
<p>We’re also using helper functions rather than inlining the formulas everywhere. This makes the code much more readable (<code>cmul(z, z)</code> vs <code>vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)</code>) and easier to debug. If you make a sign error once in <code>cmul</code>, you fix it once. If you inline the formula fifty times, you’ll hunt for bugs forever!</p>
</div>
</div>
<p>These are the building blocks we need for complex dynamics. Let’s put them to work!</p>
<hr>
</section>
</section>
<section id="the-mandelbrot-set" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="the-mandelbrot-set"><span class="header-section-number">2.3</span> The Mandelbrot Set</h2>
<section id="definition" class="level3">
<h3 class="anchored" data-anchor-id="definition">Definition</h3>
<p>The Mandelbrot set <span class="math inline">\(\mathcal{M}\)</span> is one of the most famous objects in mathematics—and for good reason! It’s defined as the set of complex numbers <span class="math inline">\(c\)</span> for which the iteration <span class="math display">\[z_{n+1} = z_n^2 + c, \quad z_0 = 0\]</span> remains bounded as <span class="math inline">\(n \to \infty\)</span>.</p>
<p>That’s it! Just iterate this simple quadratic map starting from <span class="math inline">\(z_0 = 0\)</span>, and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.</p>
</section>
<section id="the-escape-radius-theorem" class="level3">
<h3 class="anchored" data-anchor-id="the-escape-radius-theorem">The Escape Radius Theorem</h3>
<p>In practice, we can’t iterate to infinity, so we need a criterion to detect escape. Fortunately, there’s a beautiful theorem that tells us exactly when to stop:</p>
<p><strong>Theorem (Escape Radius).</strong> If <span class="math inline">\(|z_n| &gt; 2\)</span> for any <span class="math inline">\(n\)</span>, then <span class="math inline">\(|z_n| \to \infty\)</span> as <span class="math inline">\(n \to \infty\)</span>.</p>
<p>This means: once the orbit leaves the disk of radius 2, it’s definitely escaping to infinity. Points that escape are not in the Mandelbrot set, while points that remain bounded after many iterations are (likely) in the set or very close to its boundary.</p>
<p><strong>Proof.</strong> Suppose <span class="math inline">\(|z_n| &gt; 2\)</span> and write <span class="math inline">\(|z_n| = 2 + \epsilon\)</span> for some <span class="math inline">\(\epsilon &gt; 0\)</span>. Then <span class="math display">\[\begin{align*}
|z_{n+1}| &amp;= |z_n^2 + c|\\
&amp;\geq |z_n^2| - |c|\\
&amp;= |z_n|^2 - |c|\\
&amp;&gt; |z_n|^2 - 2 \quad \text{(since $c$ is in or near $\mathcal{M}$, which fits in $|z| \leq 2$)}\\
&amp;= (2 + \epsilon)^2 - 2\\
&amp;= 4 + 4\epsilon + \epsilon^2 - 2\\
&amp;= 2 + 4\epsilon + \epsilon^2\\
&amp;&gt; 2 + 2\epsilon = |z_n| + \epsilon
\end{align*}\]</span></p>
<p>So once <span class="math inline">\(|z_n| &gt; 2\)</span>, we have <span class="math inline">\(|z_{n+1}| &gt; |z_n| + \epsilon\)</span>, meaning the magnitude grows by at least <span class="math inline">\(\epsilon\)</span> each iteration. This linear growth accelerates: if <span class="math inline">\(|z_{n+1}| &gt; 2 + \epsilon\)</span>, then <span class="math inline">\(|z_{n+2}| &gt; |z_{n+1}| + \epsilon' &gt; 2 + 2\epsilon\)</span>, and so on. More carefully, the orbit actually grows exponentially (roughly like <span class="math inline">\(|z_n| \sim 2^{2^n}\)</span> for large <span class="math inline">\(n\)</span>), but the key point is: it definitely escapes to infinity.</p>
<p><strong>Computational Implication:</strong> We only need to check if <span class="math inline">\(|z_n| &gt; 2\)</span>. The moment this happens, we can stop iterating—this point will never be in the Mandelbrot set. This single theorem makes efficient rendering possible!</p>
</section>
<section id="historical-context" class="level3">
<h3 class="anchored" data-anchor-id="historical-context">Historical Context</h3>
<p>The Mandelbrot set was discovered remarkably recently—1980! Benoit Mandelbrot, working at IBM, was among the first to have access to computers powerful enough to visualize iterative processes in the complex plane. Before computers, studying these sets was nearly impossible—you’d need to manually iterate complex arithmetic hundreds of times for millions of points.</p>
<p>Interestingly, the mathematical theory predates visualization by over 60 years. Gaston Julia and Pierre Fatou studied iterative complex dynamics extensively in 1918, but without computers, they could only reason about these sets abstractly. They knew Julia sets existed and had deep properties, but had never seen one! When Mandelbrot generated the first images in 1980, it revolutionized the field—suddenly the intricate structure of these sets was visible, creating an explosion of interest in fractal geometry and complex dynamics.</p>
<p>The Mandelbrot set became iconic partly because it’s so accessible: anyone can understand the definition (iterate <span class="math inline">\(z \mapsto z^2 + c\)</span>), yet it produces infinitely intricate beauty. It also sparked broader interest in fractals, chaos theory, and the idea that simple rules can generate complex behavior—themes that would influence everything from physics to economics to art.</p>
</section>
<section id="basic-implementation" class="level3">
<h3 class="anchored" data-anchor-id="basic-implementation">Basic Implementation</h3>
<p>Let’s code it up:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup: center at origin, scale to show interesting region</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c <span class="op">=</span> uv <span class="op">*</span> <span class="fl">3.5</span><span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Center on the interesting part</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mandelbrot iteration</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// z_0 = 0</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_iter <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iter<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span>iter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iter <span class="op">&lt;</span> max_iter<span class="op">;</span> iter<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check if escaped</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="fu">cabs2</span><span class="op">(</span>z<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">4.0</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span>  <span class="co">// |z| &gt; 2, so |z|² &gt; 4</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// z_{n+1} = z_n² + c</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">cmul</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">)</span> <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on iteration count</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>iter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>max_iter<span class="op">);</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>t<span class="op">);</span>  <span class="co">// Grayscale for now</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>That’s the entire Mandelbrot set renderer! The coordinate scaling is tuned to show the “interesting part”—the main cardioid body and its surrounding bulbs. The set extends roughly from <span class="math inline">\(-2.5\)</span> to <span class="math inline">\(0.5\)</span> on the real axis, so we shift our coordinate system accordingly.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Why This Is Perfect for GPUs
</div>
</div>
<div class="callout-body-container callout-body">
<p>Notice what’s happening computationally: every pixel performs its own independent calculation. There’s no communication between pixels, no shared data structures, no synchronization needed. Each pixel just iterates its own complex number and decides when to stop.</p>
<p>This is <strong>embarrassingly parallel</strong>—the ideal workload for GPU architecture. A modern GPU has thousands of small processors, and they can all work on different pixels simultaneously. No pixel needs to wait for another pixel’s result. The entire screen (potentially millions of pixels) is computed in parallel, which is why we can render the Mandelbrot set at 60fps even with 100+ iterations per pixel.</p>
<p>Memory-wise, this is also very efficient: each pixel only needs to store its current <span class="math inline">\(z\)</span> value (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures. The computation is stateless—we only care about the current iterate, not the full orbit.</p>
<p>This contrasts sharply with sequential CPU code, where you’d iterate over pixels one at a time. Even with clever optimizations and SIMD vectorization, you’d be orders of magnitude slower than a GPU shader doing the same work.</p>
</div>
</div>
</section>
<section id="smooth-coloring" class="level3">
<h3 class="anchored" data-anchor-id="smooth-coloring">Smooth Coloring</h3>
<p>The grayscale rendering shows the structure of the set, but it has harsh banding—sudden transitions between integer iteration counts create visible stripes. We can do much better by interpolating between iteration steps!</p>
<p>The key insight is that near escape, the orbit grows exponentially. Specifically, once <span class="math inline">\(|z_n|\)</span> is large, we have approximately <span class="math inline">\(|z_{n+1}| \approx |z_n|^2\)</span>, which means <span class="math inline">\(\log |z_{n+1}| \approx 2\log|z_n|\)</span>. Taking logs repeatedly, we get <span class="math display">\[\log\log|z_{n+1}| \approx \log(2\log|z_n|) = \log 2 + \log\log|z_n|\]</span></p>
<p>This suggests that <span class="math inline">\(\log\log|z_n|\)</span> grows approximately linearly near escape, increasing by <span class="math inline">\(\log 2\)</span> per iteration. We can use this to compute a fractional iteration count!</p>
<p>Here’s the formula:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>iter <span class="op">&lt;</span> max_iter<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Smooth iteration count (accounts for continuous escape)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> log_zn <span class="op">=</span> <span class="bu">log</span><span class="op">(</span><span class="fu">cabs2</span><span class="op">(</span>z<span class="op">))</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span>  <span class="co">// = log|z_n|</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> nu <span class="op">=</span> <span class="bu">log</span><span class="op">(</span>log_zn <span class="op">/</span> <span class="bu">log</span><span class="op">(</span><span class="fl">2.0</span><span class="op">))</span> <span class="op">/</span> <span class="bu">log</span><span class="op">(</span><span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> smooth_iter <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>iter<span class="op">)</span> <span class="op">+</span> <span class="fl">1.0</span> <span class="op">-</span> nu<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> smooth_iter <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>max_iter<span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inside the set: black</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The variable <code>nu</code> represents how far we’ve progressed toward the next integer iteration. When <span class="math inline">\(|z_n| = 2\)</span> exactly (just hitting the escape threshold), <span class="math inline">\(nu = 0\)</span> and we get the integer iteration count. When <span class="math inline">\(|z_n|\)</span> is large (deep into escape), <span class="math inline">\(nu\)</span> approaches 1. Subtracting <code>nu</code> from <code>iter + 1</code> gives us a continuous, smooth value that transitions gradually between iteration levels.</p>
<p>This eliminates banding entirely! The result is smooth, continuous color gradients that look much more professional and reveal the fractal structure more clearly.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Smooth Coloring as Anti-Aliasing
</div>
</div>
<div class="callout-body-container callout-body">
<p>Smooth coloring is fundamentally an anti-aliasing technique. Without it, nearby pixels with iteration counts of, say, 45 and 46 get completely different colors—creating harsh edges. With smooth coloring, these pixels get nearly identical colors (say, iteration 45.3 and 45.8), producing a smooth gradient.</p>
<p>This is especially important at high zoom levels, where tiny changes in position lead to different integer iteration counts. The smooth interpolation ensures that small changes in <span class="math inline">\(c\)</span> produce small changes in color, which is exactly what we want for a continuous mathematical function.</p>
</div>
</div>
</section>
<section id="color-palettes" class="level3">
<h3 class="anchored" data-anchor-id="color-palettes">Color Palettes</h3>
<p>Now we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">palette</span><span class="op">(</span><span class="dt">float</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a cyclic color palette using cosines</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> a <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> b <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> c <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> d <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> a <span class="op">+</span> b <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span>c <span class="op">*</span> t <span class="op">+</span> d<span class="op">));</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters control different aspects:</p>
<ul>
<li><code>a</code> and <code>b</code> control the range and center of the colors (here, mapping to <span class="math inline">\([0,1]\)</span>)</li>
<li><code>c</code> controls the frequency of color cycling</li>
<li><code>d</code> controls the phase offset, shifting the entire palette</li>
</ul>
<p>Play with these parameters to get different color schemes! Try <code>d = vec3(0.0, 0.1, 0.2)</code> for a blue-purple palette, or <code>d = vec3(0.3, 0.2, 0.2)</code> for warmer tones. You can also adjust <code>c</code> to make the colors cycle faster or slower through the iteration range.</p>
<p>The beauty of this cosine approach is that it’s smooth (continuous derivatives), cyclic (no seams), and efficient (just a few trig operations). Other approaches exist—hand-picked color stops with interpolation, HSV color spaces, perceptually uniform LAB spaces—but cosine palettes are a great default for fractal visualization.</p>
<hr>
</section>
</section>
<section id="julia-sets" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="julia-sets"><span class="header-section-number">2.4</span> Julia Sets</h2>
<p>The Julia set is the natural companion to the Mandelbrot set, and understanding their relationship is key to understanding complex dynamics. Where the Mandelbrot set varies <span class="math inline">\(c\)</span> and fixes <span class="math inline">\(z_0 = 0\)</span>, the Julia set does the opposite: it fixes <span class="math inline">\(c\)</span> and varies <span class="math inline">\(z_0\)</span>.</p>
<section id="definition-1" class="level3">
<h3 class="anchored" data-anchor-id="definition-1">Definition</h3>
<p>For a fixed complex number <span class="math inline">\(c\)</span>, the <strong>filled Julia set</strong> <span class="math inline">\(K_c\)</span> is the set of initial conditions <span class="math inline">\(z_0\)</span> for which the iteration <span class="math display">\[z_{n+1} = z_n^2 + c\]</span> remains bounded. The <strong>Julia set</strong> <span class="math inline">\(J_c\)</span> is the boundary of <span class="math inline">\(K_c\)</span>—the set where the dynamics are chaotic, neither definitely bounded nor definitely escaping.</p>
<p>Think about what this means: every point <span class="math inline">\(c\)</span> in the complex plane has an associated Julia set <span class="math inline">\(J_c\)</span>. The Mandelbrot set is telling us about the topology of these Julia sets! Specifically:</p>
<ul>
<li>If <span class="math inline">\(c \in \mathcal{M}\)</span> (inside the Mandelbrot set), then <span class="math inline">\(J_c\)</span> is <strong>connected</strong>—a single, intricate curve</li>
<li>If <span class="math inline">\(c \notin \mathcal{M}\)</span> (outside the Mandelbrot set), then <span class="math inline">\(J_c\)</span> is <strong>totally disconnected</strong>—a Cantor-like dust of points</li>
</ul>
<p>This is one of the most beautiful connections in mathematics: the Mandelbrot set is a map of parameter space, showing which values of <span class="math inline">\(c\)</span> produce connected Julia sets. Julia and Fatou proved this in 1918 without ever seeing a picture—they understood these sets purely abstractly!</p>
</section>
<section id="implementation-as-homework" class="level3">
<h3 class="anchored" data-anchor-id="implementation-as-homework">Implementation as Homework</h3>
<p>You’ll implement Julia set rendering in the homework. The algorithm is nearly identical to the Mandelbrot set—just swap what’s fixed and what varies! Instead of setting <code>z = vec2(0.0)</code> and varying <code>c</code> across pixels, you’ll set <code>c</code> to a fixed value and let <code>z</code> be the pixel coordinate.</p>
<p>The key changes: 1. Fix <code>c</code> to an interesting value (we’ll give suggestions) 2. Initialize <code>z</code> from the pixel position (that’s your <span class="math inline">\(z_0\)</span>) 3. Iterate <span class="math inline">\(z \mapsto z^2 + c\)</span> exactly as before 4. Use the same escape criterion and coloring</p>
<p>This will give you a Julia set! Try different values of <span class="math inline">\(c\)</span> to see how the topology changes. You can make <code>c</code> depend on time (<code>iTime</code>) for animation, or on mouse position (<code>iMouse</code>) for interactive exploration.</p>
<p><strong>Some interesting values to try:</strong> - <span class="math inline">\(c = -0.7 + 0.27015i\)</span> — classic Julia set, intricate tendrils - <span class="math inline">\(c = -0.4 + 0.6i\)</span> — dendrite-like fractal trees - <span class="math inline">\(c = 0.285 + 0.01i\)</span> — beautiful spiral patterns - <span class="math inline">\(c = -0.8 + 0.156i\)</span> — highly filamentary - <span class="math inline">\(c = -0.70176 - 0.3842i\)</span> — “San Marco dragon”</p>
<p>Values inside the Mandelbrot set give connected Julia sets (single curves), while values outside give disconnected Julia sets (dust). The most interesting Julia sets often come from values right near the boundary of <span class="math inline">\(\mathcal{M}\)</span>—this is where the transition between connected and disconnected happens!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exploring Parameter Space
</div>
</div>
<div class="callout-body-container callout-body">
<p>When you implement Julia sets, try this: tie <span class="math inline">\(c\)</span> to your mouse position. Move the mouse around and watch the Julia set morph in real time! This is an incredibly powerful way to build intuition for how the parameter <span class="math inline">\(c\)</span> affects the dynamics.</p>
<p>You’ll notice that small changes in <span class="math inline">\(c\)</span> can produce dramatic changes in the Julia set topology—this is the sensitive dependence on parameters that makes complex dynamics so rich. Near the boundary of the Mandelbrot set, tiny movements create entirely different structures.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="interlude-from-complex-to-geometric-dynamics" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="interlude-from-complex-to-geometric-dynamics"><span class="header-section-number">2.5</span> Interlude: From Complex to Geometric Dynamics</h2>
<p>We’ve been iterating algebraic functions in the complex plane: <span class="math inline">\(z \mapsto z^2 + c\)</span>. Now we shift to iterating geometric transformations of the plane itself: circle inversion. The mathematical frameworks are different—holomorphic dynamics versus conformal geometry—but they share fundamental similarities.</p>
<p>Both complex multiplication and circle inversion are <strong>conformal maps</strong>: they preserve angles between curves. In complex dynamics, this comes from the Cauchy-Riemann equations and the geometric interpretation of multiplication as rotation and scaling. In circle inversion, it’s a theorem we’ll state shortly. This angle preservation is crucial—it’s what makes the fractal structures we generate geometrically coherent and visually beautiful.</p>
<p>There’s also a deep connection we’ll explore tomorrow: circle inversion is actually an isometry of hyperbolic space! The inversions we’re about to do are the same transformations that generate Kleinian groups and tessellate the hyperbolic plane. So in some sense, we’re already working in non-Euclidean geometry without realizing it. Tomorrow we’ll make this explicit when we explore hyperbolic tilings.</p>
<p>For now, let’s learn circle inversion and use it to build the Apollonian gasket—a fractal structure every bit as intricate as the Mandelbrot set, but generated through pure Euclidean geometry.</p>
<hr>
</section>
<section id="circle-inversion" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="circle-inversion"><span class="header-section-number">2.6</span> Circle Inversion</h2>
<p>Circle inversion is a beautiful geometric operation that will be the foundation for everything we do with geometric dynamics. It’s a transformation of the plane that turns inside into outside, maps circles to circles (or lines), and preserves angles—making it a powerful tool for creating fractal patterns.</p>
<section id="mathematical-definition" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-definition">Mathematical Definition</h3>
<p>Circle inversion is a transformation with respect to a circle. For a circle of radius <span class="math inline">\(R\)</span> centered at a point <span class="math inline">\(\mathbf{c}\)</span>, inversion maps a point <span class="math inline">\(\mathbf{p} \neq \mathbf{c}\)</span> to: <span class="math display">\[\text{inv}(\mathbf{p}) = \mathbf{c} + R^2 \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|^2}\]</span></p>
<p>The vector <span class="math inline">\(\mathbf{p} - \mathbf{c}\)</span> points from the center to <span class="math inline">\(\mathbf{p}\)</span>. We normalize this direction by dividing by its squared length, then scale by <span class="math inline">\(R^2\)</span>, and finally translate back by the center. Geometrically:</p>
<ul>
<li>Points inside the circle map to points outside (and vice versa)</li>
<li>Points on the circle are fixed (they map to themselves)</li>
<li>The closer you are to the center, the farther away you go</li>
<li>The center itself maps to infinity, and infinity maps to the center</li>
</ul>
<p>Here’s another way to think about it: draw a ray from the center through <span class="math inline">\(\mathbf{p}\)</span>. The inversion of <span class="math inline">\(\mathbf{p}\)</span> is the unique point on this ray such that the product of distances from the center is <span class="math inline">\(R^2\)</span>. If <span class="math inline">\(\mathbf{p}\)</span> is at distance <span class="math inline">\(r\)</span> from the center, its image is at distance <span class="math inline">\(R^2/r\)</span>.</p>
</section>
<section id="key-properties" class="level3">
<h3 class="anchored" data-anchor-id="key-properties">Key Properties</h3>
<p>Circle inversion has remarkable geometric properties. These aren’t obvious from the formula, but they’re all classical theorems:</p>
<ol type="1">
<li><p><strong>Lines through the center</strong> remain lines through the center (they’re “flipped inside out” along the ray)</p></li>
<li><p><strong>Lines not through the center</strong> become circles through the center</p></li>
<li><p><strong>Circles through the center</strong> become lines (not through the center)</p></li>
<li><p><strong>Circles not through the center</strong> generally remain circles, but with different center and radius</p></li>
<li><p><strong>Angles are preserved</strong> (conformal property)</p></li>
</ol>
<p>The angle preservation is the deepest property. It’s not at all obvious from the formula, but it can be proved using the chain rule and careful calculation. The key insight is that inversion is locally similar to a complex conjugation-like operation, which preserves angles.</p>
<p><strong>Why These Properties Matter for Iteration:</strong> When we iterate inversions through multiple circles, these properties ensure that the geometry remains coherent. Circles stay circles (or become lines), and the angles between curves are preserved. This means repeated inversion creates intricate but geometrically regular patterns—the hallmark of fractals generated by conformal maps.</p>
<p>Another key fact: inversion is <strong>involutive</strong>—applying it twice returns to the original point (assuming the point isn’t the center). Mathematically, <span class="math inline">\(\text{inv}(\text{inv}(\mathbf{p})) = \mathbf{p}\)</span>. This makes inversion a geometric reflection of sorts, which will be important when we think about symmetry groups tomorrow.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Historical Context: Circle Inversion
</div>
</div>
<div class="callout-body-container callout-body">
<p>Circle inversion has ancient roots—Apollonius of Perga studied related problems involving tangent circles around 200 BCE. But the modern theory of inversion as a geometric transformation developed in the 19th century as part of projective and non-Euclidean geometry.</p>
<p>A key insight was recognizing that circle inversion is related to stereographic projection: if you place a sphere on the plane, inversion in a circle corresponds to reflection through the sphere! This connection links circle inversion to spherical geometry and ultimately to hyperbolic geometry.</p>
<p>In the late 19th and early 20th centuries, mathematicians realized that groups of circle inversions (Kleinian groups) could tessellate hyperbolic space and create fractal limit sets. This anticipates the fractal geometry revolution of the 1970s-80s, though the connection wasn’t fully appreciated until computers made visualization possible.</p>
</div>
</div>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>The formula translates directly to GLSL:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">invertCircle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">vec2</span> center<span class="op">,</span> <span class="dt">float</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> diff <span class="op">=</span> p <span class="op">-</span> center<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>diff<span class="op">,</span> diff<span class="op">);</span>  <span class="co">// squared distance from center</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Handle center (would be division by zero)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>r2 <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1000.0</span><span class="op">);</span>  <span class="co">// Map to "infinity"</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> center <span class="op">+</span> <span class="op">(</span>radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> diff <span class="op">/</span> r2<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it’s effectively off-screen. The threshold <code>0.0001</code> is small enough to catch points numerically close to the center but large enough to avoid precision issues.</p>
<p>Computationally, circle inversion is very cheap: just one dot product, a division, a multiplication, and some vector operations. This efficiency is important because we’ll be doing many inversions per pixel when generating fractals!</p>
</section>
<section id="visualizing-circle-inversion" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-circle-inversion">Visualizing Circle Inversion</h3>
<p>Let’s see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Standard coordinate setup</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inversion circle</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> circleCenter <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> circleRadius <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Apply inversion</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p_inverted <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> circleCenter<span class="op">,</span> circleRadius<span class="op">);</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a grid in the inverted space</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> grid <span class="op">=</span> <span class="bu">fract</span><span class="op">(</span>p_inverted <span class="op">*</span> <span class="fl">2.0</span><span class="op">);</span>  <span class="co">// Create repeating cells</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> gridLine <span class="op">=</span> <span class="bu">step</span><span class="op">(</span><span class="fl">0.95</span><span class="op">,</span> <span class="bu">max</span><span class="op">(</span>grid<span class="op">.</span><span class="fu">x</span><span class="op">,</span> grid<span class="op">.</span><span class="fu">y</span><span class="op">));</span>  <span class="co">// Draw grid lines</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>gridLine<span class="op">);</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw the inversion circle itself (for reference)</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> circDist <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p<span class="op">)</span> <span class="op">-</span> circleRadius<span class="op">);</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>circDist <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You’ll see straight grid lines transform into beautiful circular arcs! Lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.</p>
<p>This visualization really helps build intuition. You can see: - The circle itself (in red) is unchanged—points on it are fixed - The grid inside the circle maps to a grid outside (and vice versa) - Lines become curves, but the angles where they intersect are preserved - The pattern has a pole singularity at the center (infinite distortion)</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exploring Circle Inversion
</div>
</div>
<div class="callout-body-container callout-body">
<p>Here are some experiments to try:</p>
<ol type="1">
<li><p><strong>Multiple circles</strong>: Create a grid of circles using <code>mod()</code> (like we did on Day 1) and invert through each cell’s circle independently. You’ll see beautiful overlapping patterns!</p></li>
<li><p><strong>Animated radius</strong>: Make <code>circleRadius = 1.0 + 0.5 * sin(iTime)</code> to watch the grid breathe in and out. This helps you see how the inversion depends on the circle’s size.</p></li>
<li><p><strong>Different patterns</strong>: Instead of a grid, try drawing circles or other shapes in the inverted space. Circles become circles (or lines), creating intricate nested patterns.</p></li>
<li><p><strong>Off-center inversion</strong>: Move the inversion circle away from the origin. Watch how the asymmetry creates even more complex distortions.</p></li>
</ol>
<p>Each of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="structs-in-glsl" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="structs-in-glsl"><span class="header-section-number">2.7</span> Structs in GLSL</h2>
<p>Before we build the Apollonian gasket, we need to talk about organizing our data. We’re about to deal with multiple circles, and passing around <code>center1</code>, <code>radius1</code>, <code>center2</code>, <code>radius2</code>, etc. gets unwieldy fast. GLSL provides <strong>structs</strong> (just like in C) for grouping related data together.</p>
<section id="defining-and-using-structs" class="level3">
<h3 class="anchored" data-anchor-id="defining-and-using-structs">Defining and Using Structs</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Circle <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> center<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Now <code>Circle</code> is a type we can use just like <code>vec2</code> or <code>float</code>. Creating and using structs is straightforward:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Declare and initialize</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>Circle c1 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Or declare first, set later</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>Circle c2<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>c2<span class="op">.</span><span class="fu">center</span> <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>c2<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">0.75</span><span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Pass to functions</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">invertThroughCircle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> Circle circ<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> circ<span class="op">.</span><span class="fu">center</span><span class="op">,</span> circ<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This makes the code dramatically more readable. Compare:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Without structs - messy!</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">iterate</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">vec2</span> c1_cen<span class="op">,</span> <span class="dt">float</span> c1_rad<span class="op">,</span> <span class="dt">vec2</span> c2_cen<span class="op">,</span> <span class="dt">float</span> c2_rad<span class="op">,</span> <span class="dt">vec2</span> c3_cen<span class="op">,</span> <span class="dt">float</span> c3_rad<span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">// With structs - clean!</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">iterate</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> Circle c1<span class="op">,</span> Circle c2<span class="op">,</span> Circle c3<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For the Apollonian gasket, we’ll have three circles we need to track and pass around. Structs make this much more manageable and semantically clear—we’re working with circles as geometric objects, not just pairs of vectors and floats.</p>
<hr>
</section>
</section>
<section id="the-apollonian-gasket" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="the-apollonian-gasket"><span class="header-section-number">2.8</span> The Apollonian Gasket</h2>
<p>Now for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It’s named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles around 200 BCE, though the fractal interpretation is much more modern.</p>
<section id="descartes-circle-theorem" class="level3">
<h3 class="anchored" data-anchor-id="descartes-circle-theorem">Descartes Circle Theorem</h3>
<p>To understand the Apollonian gasket, we need to know about a beautiful theorem: <strong>Descartes Circle Theorem</strong> (1643).</p>
<p>Given four mutually tangent circles (each tangent to the other three), let their curvatures be <span class="math inline">\(k_1, k_2, k_3, k_4\)</span> where curvature <span class="math inline">\(k = 1/r\)</span> (positive for external tangency, negative for internal). Then: <span class="math display">\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\]</span></p>
<p>This can be rearranged to solve for the fourth curvature given three: <span class="math display">\[k_4 = k_1 + k_2 + k_3 \pm 2\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}\]</span></p>
<p>The <span class="math inline">\(\pm\)</span> gives two solutions—the two circles tangent to the original three (one inside the curvilinear triangle they form, one outside).</p>
<p>What makes this magical for fractals: if you start with three mutually tangent circles with integer curvatures, then <strong>all</strong> circles in the Apollonian gasket have integer curvatures! This is the Apollonian gasket’s connection to number theory—it’s a fractal made entirely of circles with rational radii.</p>
<p>We won’t use this formula directly in our shader (we’ll set up circles geometrically), but it explains why certain configurations are special and why the patterns are so regular despite infinite nesting.</p>
</section>
<section id="setup-three-mutually-tangent-circles" class="level3">
<h3 class="anchored" data-anchor-id="setup-three-mutually-tangent-circles">Setup: Three Mutually Tangent Circles</h3>
<p>We start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For this to work, the distance between any two circle centers must be exactly twice the radius (so they touch edge-to-edge). The three centers form an equilateral triangle, and we’ll position this triangle symmetrically at the origin:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">setupApollonianCircles</span><span class="op">(</span><span class="dt">out</span> Circle c1<span class="op">,</span> <span class="dt">out</span> Circle c2<span class="op">,</span> <span class="dt">out</span> Circle c3<span class="op">,</span> <span class="dt">out</span> Circle outer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Radius of each inner circle</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For three circles to be mutually tangent: distance between centers = 2r</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Centers form equilateral triangle with circumradius = 2r/sqrt(3)</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> r <span class="op">/</span> <span class="bu">sqrt</span><span class="op">(</span><span class="fl">3.0</span><span class="op">);</span>  <span class="co">// ≈ 0.577 for r = 0.5</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Three inner circles</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    c1 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> d<span class="op">),</span> r<span class="op">);</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    c2 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(-</span>d <span class="op">*</span> <span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span>d <span class="op">*</span> <span class="fl">0.5</span><span class="op">),</span> r<span class="op">);</span>  <span class="co">// 0.866 ≈ sqrt(3)/2</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    c3 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>d <span class="op">*</span> <span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span>d <span class="op">*</span> <span class="fl">0.5</span><span class="op">),</span> r<span class="op">);</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outer circle tangent to all three, centered at origin</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> R <span class="op">=</span> d <span class="op">+</span> r<span class="op">;</span>  <span class="co">// ≈ 1.077 for r = 0.5</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    outer <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> R<span class="op">);</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>With <span class="math inline">\(r = 0.5\)</span>, the circumradius <span class="math inline">\(d \approx 0.577\)</span>, and the outer circle has radius <span class="math inline">\(R = d + r \approx 1.077\)</span>. All four circles are mutually tangent—each inner circle touches the other two inner circles and the outer circle.</p>
<p>This is just one possible configuration! You could use different radii (related by Descartes’ theorem), different arrangements, or even animated circles. The key is that they start mutually tangent—this ensures the iteration creates a proper Apollonian packing.</p>
</section>
<section id="the-iteration-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-iteration-algorithm">The Iteration Algorithm</h3>
<p>The algorithm is beautifully simple:</p>
<ol type="1">
<li>Start with a point <span class="math inline">\(p\)</span></li>
<li>Check which circles contain <span class="math inline">\(p\)</span></li>
<li>If <span class="math inline">\(p\)</span> is inside a circle, invert through that circle</li>
<li>Repeat until <span class="math inline">\(p\)</span> is outside all circles or we hit max iterations</li>
<li>Color based on iteration behavior</li>
</ol>
<p>Here’s the implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">iterateApollonian</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> Circle c1<span class="op">,</span> Circle c2<span class="op">,</span> Circle c3<span class="op">,</span> Circle outer<span class="op">,</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                       <span class="dt">int</span> maxIter<span class="op">,</span> <span class="dt">out</span> <span class="dt">int</span> finalIter<span class="op">,</span> <span class="dt">out</span> <span class="dt">int</span> lastCircle<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> maxIter<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> moved <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check the three inner circles</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">&lt;</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            lastCircle <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            moved <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> </span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">&lt;</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>            lastCircle <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>            moved <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">&lt;</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>            lastCircle <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>            moved <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check if outside the outer circle</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> outer<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">&gt;</span> outer<span class="op">.</span><span class="fu">radius</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> outer<span class="op">.</span><span class="fu">center</span><span class="op">,</span> outer<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>            lastCircle <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>            moved <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If we didn't move, we're in the gaps - done!</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(!</span>moved<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>            finalIter <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    finalIter <span class="op">=</span> maxIter<span class="op">;</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>We also track which circle we last inverted through (<code>lastCircle</code>) and how many iterations we performed (<code>finalIter</code>). These will be useful for coloring!</p>
<p><strong>Why This Creates a Fractal:</strong> Each time we invert through a circle, we “push” the point away from that circle’s center. But because the four circles are mutually tangent, pushing away from one circle might push us into another circle, triggering another inversion. The interplay between these four inversions (three inner circles plus the outer circle) creates a complex orbit.</p>
<p>Points in the “gaps” between the inner circles (the curvilinear triangles) escape quickly—they’re inside the outer circle but not inside any inner circle, so no inversion happens. But points near the tangency points get bounced back and forth between circles many times before escaping. And at the actual tangency points (where circles touch), the orbit never escapes—these are fixed points or periodic orbits of the iterated inversions.</p>
<p>The fractal structure emerges because these dynamics are self-similar: zooming in near any tangency point reveals the same pattern of nested circles and gaps. This self-similarity is a direct consequence of the conformal nature of circle inversion—the transformation preserves angles, so local geometry looks the same at all scales.</p>
</section>
<section id="coloring-strategies" class="level3">
<h3 class="anchored" data-anchor-id="coloring-strategies">Coloring Strategies</h3>
<p>There are several interesting ways to color the Apollonian gasket:</p>
<p><strong>By iteration count</strong> (like the Mandelbrot set):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>finalIter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>maxIter<span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This shows the “depth” of the orbit—points that escape quickly are colored differently from points that bounce around many times.</p>
<p><strong>By last circle hit</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> colors<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="dt">vec3</span><span class="op">[</span><span class="dv">4</span><span class="op">](</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span>  <span class="co">// Circle 1: red</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span>  <span class="co">// Circle 2: green</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span>  <span class="co">// Circle 3: blue</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span>   <span class="co">// Outer circle: yellow</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">);</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> colors<span class="op">[</span>lastCircle<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This shows the basin of attraction—which circle’s “influence” each point ultimately fell into. Yellow regions show points that escaped through the outer circle.</p>
<p><strong>By final distance from circles</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d1 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d2 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d3 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>d2<span class="op">,</span> d3<span class="op">));</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> d<span class="op">));</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This highlights the circle boundaries themselves, making the geometric structure more apparent.</p>
<p>Each coloring reveals different aspects of the fractal. Try combining them—for example, color by iteration count but modulate brightness by distance to circles.</p>
</section>
<section id="putting-it-all-together" class="level3">
<h3 class="anchored" data-anchor-id="putting-it-all-together">Putting It All Together</h3>
<p>Here’s a complete Apollonian gasket renderer:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Setup the four circles</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    Circle c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> outer<span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">setupApollonianCircles</span><span class="op">(</span>c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> outer<span class="op">);</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Iterate</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxIter <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> finalIter<span class="op">,</span> lastCircle<span class="op">;</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> final_p <span class="op">=</span> <span class="fu">iterateApollonian</span><span class="op">(</span>p<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> outer<span class="op">,</span> maxIter<span class="op">,</span> finalIter<span class="op">,</span> lastCircle<span class="op">);</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by iteration count with palette</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>finalIter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>maxIter<span class="op">);</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw all four circles for reference</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d1 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d2 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d3 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d_outer <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> outer<span class="op">.</span><span class="fu">center</span><span class="op">)</span> <span class="op">-</span> outer<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">min</span><span class="op">(</span><span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>d2<span class="op">,</span> d3<span class="op">)),</span> d_outer<span class="op">);</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White circle outlines</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a beautiful nested pattern of circles! The fractal structure is immediately apparent—circles within circles within circles, filling every gap with smaller circles.</p>
<p>Zoom in (by scaling <code>p</code> differently in the coordinate setup) to see the self-similarity. No matter how far you zoom, you’ll keep finding the same pattern repeated at smaller scales. This is true fractality—infinite detail that never runs out.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Computational Efficiency
</div>
</div>
<div class="callout-body-container callout-body">
<p>Despite the complexity of the output, this algorithm is remarkably efficient. Each iteration just checks three distances (cheap) and potentially does one inversion (also cheap—just a few arithmetic operations). With 50 iterations, we’re doing maybe 150 distance checks and 50 inversions per pixel.</p>
<p>Compare this to raymarching (Day 4), where we might do hundreds of distance evaluations per pixel! The Apollonian gasket is very GPU-friendly.</p>
<p>The key is that we terminate early—most pixels escape in just a few iterations. Only points near the fractal boundary require many iterations. This is similar to the Mandelbrot set: most of the computational work focuses on the interesting regions (the boundary), while simple regions (deep inside or far outside) are handled quickly.</p>
</div>
</div>
</section>
<section id="historical-context-and-connections" class="level3">
<h3 class="anchored" data-anchor-id="historical-context-and-connections">Historical Context and Connections</h3>
<p>The Apollonian gasket connects several mathematical threads across millennia:</p>
<p><strong>Ancient roots:</strong> Apollonius of Perga (~200 BCE) studied the problem of constructing circles tangent to three given circles (the “Problem of Apollonius”). He found geometric constructions but couldn’t have imagined the infinite fractal structure we’re visualizing.</p>
<p><strong>Renaissance mathematics:</strong> René Descartes (1643) discovered the circle theorem bearing his name, giving an algebraic formula for tangent circles. This turned Apollonius’s geometric problem into arithmetic.</p>
<p><strong>19th century:</strong> The connection to projective geometry and circle inversions was developed. Mathematicians realized that packing problems could be studied through group theory—the inversions form a discrete subgroup of the group of Möbius transformations.</p>
<p><strong>20th century:</strong> With computers, the fractal nature became visible. The Apollonian gasket was recognized as a limit set of a Kleinian group—a group of isometries of hyperbolic space. This connects to tomorrow’s material: the inversions we’re doing are actually hyperbolic isometries! In the Poincaré disk model (which we’ll see tomorrow), these inversions are reflections through hyperbolic geodesics.</p>
<p>The gasket also has connections to number theory: if the initial circles have integer curvatures, all circles in the packing do too (by Descartes’ theorem). This has led to deep questions about the distribution of integers in these packings, which remain active research areas today.</p>
<hr>
</section>
</section>
<section id="summary" class="level2" data-number="2.9">
<h2 data-number="2.9" class="anchored" data-anchor-id="summary"><span class="header-section-number">2.9</span> Summary</h2>
<p>Today we’ve explored two powerful iterative processes that generate fractals:</p>
<ol type="1">
<li><strong>Complex dynamics</strong>: The Mandelbrot and Julia sets emerge from iterating <span class="math inline">\(z \mapsto z^2 + c\)</span>
<ul>
<li>Implemented complex arithmetic in GLSL efficiently</li>
<li>Learned escape-time algorithms and the crucial escape radius theorem</li>
<li>Developed smooth coloring techniques for anti-aliased rendering</li>
<li>Understood the parameter space (Mandelbrot) vs dynamical space (Julia) distinction</li>
<li>Saw how 1980s computational power revolutionized a 1918 theory</li>
</ul></li>
<li><strong>Geometric dynamics</strong>: The Apollonian gasket emerges from iterating circle inversions
<ul>
<li>Circle inversion as a conformal transformation preserving angles</li>
<li>Used structs to organize geometric data cleanly</li>
<li>Applied Descartes Circle Theorem to understand tangent circle configurations</li>
<li>Iterated inversions through three circles to create fractal patterns</li>
<li>Connected ancient Greek geometry to modern fractal theory</li>
</ul></li>
</ol>
<p>Both processes show how incredibly simple rules—a quadratic map, a geometric transformation—generate infinite complexity through iteration. The key in both cases is <strong>conformality</strong>: angle-preserving maps create geometrically coherent fractals. This is one of the core insights of fractal geometry and dynamical systems.</p>
<p>The computational perspective is also crucial: both algorithms are embarrassingly parallel, making them perfect for GPU rendering. Each pixel’s calculation is independent, and we can terminate early when orbits escape. The result is real-time rendering of infinitely detailed mathematical objects.</p>
<p>Tomorrow we’ll push geometric iteration further, moving from Euclidean to hyperbolic geometry. The circle inversions we’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space. We’ll explore the upper half-plane and Poincaré disk models, create <span class="math inline">\((2,3,7)\)</span> and <span class="math inline">\((2,3,\infty)\)</span> triangle tilings, and see how the same algorithmic ideas (iterated geometric transformations) work in non-Euclidean geometry. The results will be even more intricate because hyperbolic space has “more room” than Euclidean space—triangles can have angle sums less than <span class="math inline">\(\pi\)</span>, allowing denser tilings and more complex fractal structures.</p>
<hr>
</section>
<section id="homework" class="level2" data-number="2.10">
<h2 data-number="2.10" class="anchored" data-anchor-id="homework"><span class="header-section-number">2.10</span> Homework</h2>
<section id="required-julia-set-explorer" class="level3">
<h3 class="anchored" data-anchor-id="required-julia-set-explorer">Required: Julia Set Explorer</h3>
<p>Implement a Julia set renderer starting from the Mandelbrot code. The algorithm is nearly identical—you just need to swap what’s fixed and what varies!</p>
<p><strong>Requirements:</strong></p>
<ol type="1">
<li>Start from the Mandelbrot implementation</li>
<li>Fix <code>c</code> to a constant value (see suggestions below)</li>
<li>Initialize <code>z</code> from the pixel position instead of zero</li>
<li>Iterate <span class="math inline">\(z_{n+1} = z_n^2 + c\)</span> exactly as before</li>
<li>Use the same escape criterion and coloring</li>
</ol>
<p><strong>Suggested structure:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">3.0</span><span class="op">;</span>  <span class="co">// Scale for Julia set viewing</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fix c to an interesting value</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.27015</span><span class="op">);</span>  <span class="co">// Classic Julia set</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize z from pixel position (this is the key change!)</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> p<span class="op">;</span>  <span class="co">// z_0 = pixel position</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Rest of iteration exactly like Mandelbrot]</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Interesting parameters to try:</strong> - <code>vec2(-0.7, 0.27015)</code> — classic Julia set, intricate tendrils - <code>vec2(-0.4, 0.6)</code> — dendrite-like fractal trees<br>
- <code>vec2(0.285, 0.01)</code> — beautiful spiral patterns - <code>vec2(-0.8, 0.156)</code> — highly filamentary structure - <code>vec2(-0.70176, -0.3842)</code> — “San Marco dragon” - <code>vec2(-0.835, -0.2321)</code> — another classic - <code>vec2(-0.7269, 0.1889)</code> — “Douady’s rabbit” (famous example)</p>
<p><strong>Extension Options (pick one or both):</strong></p>
<p><strong>Option A: Animated Parameter Space</strong></p>
<p>Make <span class="math inline">\(c\)</span> depend on time to watch the Julia set morph:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> angle <span class="op">=</span> iTime <span class="op">*</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> radius <span class="op">=</span> <span class="fl">0.7885</span><span class="op">;</span>  <span class="co">// Distance from origin in parameter space</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> c <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>radius <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span>angle<span class="op">),</span> radius <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>angle<span class="op">));</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Watch how the Julia set changes topology as you trace a circle in the complex plane! You’ll see it transition from connected to disconnected, develop tendrils, and create organic shapes.</p>
<p><strong>Option B: Mouse-Controlled Exploration</strong></p>
<p>Tie <span class="math inline">\(c\)</span> to mouse position for interactive exploration:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> mouse_uv <span class="op">=</span> <span class="op">(</span>iMouse<span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>mouse_uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> c <span class="op">=</span> mouse_uv <span class="op">*</span> <span class="fl">3.0</span><span class="op">;</span>  <span class="co">// Scale to cover interesting parameter range</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Now you can explore parameter space by moving the mouse! This really helps build intuition for how <span class="math inline">\(c\)</span> affects the Julia set. Try finding the boundary of the Mandelbrot set—parameters right at the edge produce the most intricate Julia sets.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Understanding Connected vs Disconnected
</div>
</div>
<div class="callout-body-container callout-body">
<p>As you explore parameter space, pay attention to whether the Julia set appears as a single connected structure or as disconnected dust. Values of <span class="math inline">\(c\)</span> inside the Mandelbrot set give connected Julia sets, while values outside give disconnected ones. The most beautiful Julia sets often come from values right near the boundary of <span class="math inline">\(\mathcal{M}\)</span>!</p>
</div>
</div>
<hr>
</section>
<section id="optional-1-grid-of-julia-sets" class="level3">
<h3 class="anchored" data-anchor-id="optional-1-grid-of-julia-sets">Optional #1: Grid of Julia Sets</h3>
<p>Create a grid where each cell shows the Julia set for that value of <span class="math inline">\(c\)</span>, revealing the Mandelbrot set as an emergent pattern!</p>
<p><strong>The idea:</strong> The Mandelbrot set is a map of Julia set topology. If we draw a grid of Julia sets for different values of <span class="math inline">\(c\)</span>, we should see the Mandelbrot set emerge in the overall pattern—cells with connected Julia sets (solid regions) correspond to points in <span class="math inline">\(\mathcal{M}\)</span>, while cells with disconnected Julia sets (dust) are outside.</p>
<p><strong>Implementation strategy:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Divide screen into grid cells</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> grid_size <span class="op">=</span> <span class="fl">8.0</span><span class="op">;</span>  <span class="co">// 8×8 grid of Julia sets</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">*</span> grid_size <span class="op">/</span> <span class="fl">4.0</span><span class="op">);</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">fract</span><span class="op">(</span>p <span class="op">*</span> grid_size <span class="op">/</span> <span class="fl">4.0</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    cell_p <span class="op">*=</span> <span class="fl">4.0</span><span class="op">;</span>  <span class="co">// Local coordinates within cell</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map cell_id to parameter c</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> c <span class="op">=</span> <span class="op">(</span>cell_id <span class="op">/</span> grid_size<span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span> <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">2.5</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Center on interesting region of Mandelbrot set</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Run Julia set iteration with z = cell_p, fixed c</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> cell_p<span class="op">;</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_iter <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> iter<span class="op">;</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span>iter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> iter <span class="op">&lt;</span> max_iter<span class="op">;</span> iter<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="fu">cabs2</span><span class="op">(</span>z<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">4.0</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">cmul</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">)</span> <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>iter<span class="op">)</span> <span class="op">/</span> <span class="dt">float</span><span class="op">(</span>max_iter<span class="op">);</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Optional: draw grid lines to separate cells</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> grid_edge <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">fract</span><span class="op">(</span>p <span class="op">*</span> grid_size <span class="op">/</span> <span class="fl">4.0</span><span class="op">)</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="bu">max</span><span class="op">(</span>grid_edge<span class="op">.</span><span class="fu">x</span><span class="op">,</span> grid_edge<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">&gt;</span> <span class="fl">0.48</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a grid of tiny Julia sets! If you look carefully at the overall pattern, you’ll notice it resembles the Mandelbrot set—cells with connected Julia sets (solid colored regions) correspond to points inside <span class="math inline">\(\mathcal{M}\)</span>, while cells with disconnected Julia sets (fine dust patterns) are outside.</p>
<p>This is one of the most beautiful visualizations in complex dynamics—the Mandelbrot set literally encodes the topology of all Julia sets!</p>
<p><strong>Variations to try:</strong> - Adjust <code>grid_size</code> (larger for more detail, smaller for clearer overview) - Change the parameter space region being sampled - Color cells based on whether the Julia set appears connected (black) or disconnected (white)—you’ll get a pixelated approximation of the Mandelbrot set!</p>
<hr>
</section>
<section id="optional-2-other-iterated-inversions" class="level3">
<h3 class="anchored" data-anchor-id="optional-2-other-iterated-inversions">Optional #2: Other Iterated Inversions</h3>
<p>Explore variations on the Apollonian gasket theme! The key is setting up circles in interesting configurations and iterating inversions.</p>
<p><strong>Different circle arrangements:</strong></p>
<p><strong>Four circles in a square:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">setupSquareCircles</span><span class="op">(</span><span class="dt">out</span> Circle c1<span class="op">,</span> <span class="dt">out</span> Circle c2<span class="op">,</span> <span class="dt">out</span> Circle c3<span class="op">,</span> <span class="dt">out</span> Circle c4<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="fl">1.5</span><span class="op">;</span>  <span class="co">// Distance from center</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    c1 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>d<span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> r<span class="op">);</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    c2 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> d<span class="op">),</span> r<span class="op">);</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    c3 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(-</span>d<span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> r<span class="op">);</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    c4 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span>d<span class="op">),</span> r<span class="op">);</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Modify the iteration loop to check four circles instead of three!</p>
<p><strong>Nested circles:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// One large circle containing several smaller ones</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>c1 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="fl">2.0</span><span class="op">);</span>  <span class="co">// Large outer circle</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>c2 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(-</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="fl">0.4</span><span class="op">);</span>  <span class="co">// Small inner circles</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>c3 <span class="op">=</span> <span class="fu">Circle</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="fl">0.4</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Animated radii:</strong></p>
<p>Make the circles pulse:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>c1<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime<span class="op">);</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>c2<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime <span class="op">+</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="fl">3.14159</span> <span class="op">/</span> <span class="fl">3.0</span><span class="op">);</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>c3<span class="op">.</span><span class="fu">radius</span> <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.2</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime <span class="op">+</span> <span class="fl">4.0</span> <span class="op">*</span> <span class="fl">3.14159</span> <span class="op">/</span> <span class="fl">3.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Watch the fractal breathe!</p>
<p><strong>Alternating inversion patterns:</strong></p>
<p>Instead of inverting through whichever circle contains the point, try a fixed cycling pattern:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Cycle through circles in order</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> circle_index <span class="op">=</span> i <span class="op">%</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>circle_index <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c1<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c1<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span>circle_index <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c2<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c2<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">invertCircle</span><span class="op">(</span>p<span class="op">,</span> c3<span class="op">.</span><span class="fu">center</span><span class="op">,</span> c3<span class="op">.</span><span class="fu">radius</span><span class="op">);</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This creates very different patterns—more regular and less space-filling than the gasket, but with interesting self-similarity.</p>
<p><strong>Challenge problems:</strong> - Can you create a configuration that tiles the plane with circular patterns? - What about spiraling structures? - Can you make a fractal that’s asymmetric (not rotationally symmetric)? - Try combining inversion with other transformations (rotation, scaling)</p>
<p>The key is experimentation—try different setups and see what emerges!</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="2.11">
<h2 data-number="2.11" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">2.11</span> Looking Ahead</h2>
<p>Tomorrow we continue with geometric transformations, but move from Euclidean to <strong>hyperbolic geometry</strong>. The circle inversions you’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space!</p>
<p>We’ll explore: - <strong>Multiple models</strong> of the hyperbolic plane (upper half-plane, Poincaré disk) - <strong>Geodesics</strong> (straight lines in hyperbolic geometry—they look like circles in our Euclidean view!) - <strong>Triangle tilings</strong> with <span class="math inline">\((2,3,7)\)</span> and <span class="math inline">\((2,3,\infty)\)</span> symmetry groups - <strong>Why hyperbolic space is different</strong>: triangles with angle sum less than <span class="math inline">\(\pi\)</span>, exponential growth of area</p>
<p>The same algorithmic ideas we’ve used today (iterated geometric transformations, escape-time coloring, distance-based rendering) will work in hyperbolic space. But the results will be even more intricate because hyperbolic space has “more room” than Euclidean space—allowing denser tilings and more complex fractal structures.</p>
<p>Make sure you’re comfortable with: - <strong>Iteration and escape-time algorithms</strong> (we’ll use similar ideas for tiling) - <strong>Circle inversion</strong> (this becomes reflection through hyperbolic geodesics!) - <strong>Structs</strong> for organizing geometric data - <strong>Coloring strategies</strong> based on orbit behavior</p>
<p>See you tomorrow!</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./day1.html" class="pagination-link" aria-label="Day 1: Introduction to Shader Programming">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./day3.html" class="pagination-link" aria-label="Day 3: Geometric Tilings in Euclidean and Hyperbolic Space">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 2: Complex Dynamics and Iterated Inversions</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>Today we explore the power of iteration to generate fractals. We'll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set, then understand its companion, the Julia set. After that, we shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We'll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles.</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="fu">## Roadmap for Today</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>We'll explore iteration in two different mathematical settings:</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Complex dynamics**: Iterating holomorphic maps (Mandelbrot and Julia sets)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Geometric dynamics**: Iterating circle inversions (Apollonian gasket)</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>Both produce fractals through the same fundamental mechanism: simple rules applied repeatedly reveal infinite complexity. The common thread is **conformality**—both complex multiplication and circle inversion preserve angles, and this angle preservation is key to the beautiful structures we'll see.</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>Along the way, we'll learn shader programming techniques for organizing data (structs), implementing mathematical operations efficiently, and creating sophisticated coloring schemes.</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a><span class="fu">## Complex Numbers in GLSL</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="fu">### Representation</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>A complex number $z = a + bi$ can be represented as a 2D vector with real part $a$ and imaginary part $b$. This is the natural representation—complex numbers are the 2D plane with a particular multiplication structure! In GLSL:</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 z = vec2(a, b);  // Represents a + bi</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>We'll consistently use the convention: <span class="in">`z.x`</span> is the real part, <span class="in">`z.y`</span> is the imaginary part. You already know complex numbers geometrically as rotations and scalings in the plane—here we're just implementing that algebra in shader code.</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a><span class="fu">### Complex Arithmetic</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>Let $z = a + bi$ and $w = c + di$. We need to implement the basic operations. Some of these are trivial, others require a bit more work:</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a>**Addition:** $(a + bi) + (c + di) = (a + c) + (b + d)i$</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cadd(vec2 z, vec2 w) {</span></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a><span class="in">    return z + w;  // Vector addition is sufficient!</span></span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>Addition of complex numbers is just vector addition—componentwise! You might not even need this function since you can just write <span class="in">`z + w`</span> directly, but it's here for completeness.</span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-50"><a href="#cb30-50" aria-hidden="true" tabindex="-1"></a>**Multiplication:** $(a + bi)(c + di) = (ac - bd) + (ad + bc)i$</span>
<span id="cb30-51"><a href="#cb30-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-52"><a href="#cb30-52" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-53"><a href="#cb30-53" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cmul(vec2 z, vec2 w) {</span></span>
<span id="cb30-54"><a href="#cb30-54" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(</span></span>
<span id="cb30-55"><a href="#cb30-55" aria-hidden="true" tabindex="-1"></a><span class="in">        z.x * w.x - z.y * w.y,  // Real part: ac - bd</span></span>
<span id="cb30-56"><a href="#cb30-56" aria-hidden="true" tabindex="-1"></a><span class="in">        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc</span></span>
<span id="cb30-57"><a href="#cb30-57" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb30-58"><a href="#cb30-58" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-59"><a href="#cb30-59" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-60"><a href="#cb30-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-61"><a href="#cb30-61" aria-hidden="true" tabindex="-1"></a>This implements the familiar FOIL pattern with $i^2 = -1$, giving us that minus sign in the real part.</span>
<span id="cb30-62"><a href="#cb30-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-63"><a href="#cb30-63" aria-hidden="true" tabindex="-1"></a>**Magnitude squared:** $|z|^2 = a^2 + b^2$</span>
<span id="cb30-64"><a href="#cb30-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-65"><a href="#cb30-65" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-66"><a href="#cb30-66" aria-hidden="true" tabindex="-1"></a><span class="in">float cabs2(vec2 z) {</span></span>
<span id="cb30-67"><a href="#cb30-67" aria-hidden="true" tabindex="-1"></a><span class="in">    return dot(z, z);  // z.x * z.x + z.y * z.y</span></span>
<span id="cb30-68"><a href="#cb30-68" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-69"><a href="#cb30-69" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-70"><a href="#cb30-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-71"><a href="#cb30-71" aria-hidden="true" tabindex="-1"></a>The squared magnitude is just the dot product with itself. This is computationally cheaper than taking the square root, so when we just need to check if $|z| &gt; 2$, we'll check if $|z|^2 &gt; 4$ instead—millions of avoided square roots per frame!</span>
<span id="cb30-72"><a href="#cb30-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-73"><a href="#cb30-73" aria-hidden="true" tabindex="-1"></a>**Magnitude:** $|z| = \sqrt{a^2 + b^2}$</span>
<span id="cb30-74"><a href="#cb30-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-75"><a href="#cb30-75" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-76"><a href="#cb30-76" aria-hidden="true" tabindex="-1"></a><span class="in">float cabs(vec2 z) {</span></span>
<span id="cb30-77"><a href="#cb30-77" aria-hidden="true" tabindex="-1"></a><span class="in">    return length(z);</span></span>
<span id="cb30-78"><a href="#cb30-78" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-79"><a href="#cb30-79" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-80"><a href="#cb30-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-81"><a href="#cb30-81" aria-hidden="true" tabindex="-1"></a>The magnitude is the Euclidean distance from the origin—exactly what <span class="in">`length()`</span> computes!</span>
<span id="cb30-82"><a href="#cb30-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-83"><a href="#cb30-83" aria-hidden="true" tabindex="-1"></a>**Conjugate:** $\overline{z} = a - bi$</span>
<span id="cb30-84"><a href="#cb30-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-85"><a href="#cb30-85" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-86"><a href="#cb30-86" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cconj(vec2 z) {</span></span>
<span id="cb30-87"><a href="#cb30-87" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(z.x, -z.y);</span></span>
<span id="cb30-88"><a href="#cb30-88" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-89"><a href="#cb30-89" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-90"><a href="#cb30-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-91"><a href="#cb30-91" aria-hidden="true" tabindex="-1"></a>The conjugate flips the sign of the imaginary part—reflection across the real axis.</span>
<span id="cb30-92"><a href="#cb30-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-93"><a href="#cb30-93" aria-hidden="true" tabindex="-1"></a>**Division:** $\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{c^2 + d^2}$</span>
<span id="cb30-94"><a href="#cb30-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-95"><a href="#cb30-95" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-96"><a href="#cb30-96" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cdiv(vec2 z, vec2 w) {</span></span>
<span id="cb30-97"><a href="#cb30-97" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = dot(w, w);  // c² + d²</span></span>
<span id="cb30-98"><a href="#cb30-98" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(</span></span>
<span id="cb30-99"><a href="#cb30-99" aria-hidden="true" tabindex="-1"></a><span class="in">        (z.x * w.x + z.y * w.y) / denom,  // Real part</span></span>
<span id="cb30-100"><a href="#cb30-100" aria-hidden="true" tabindex="-1"></a><span class="in">        (z.y * w.x - z.x * w.y) / denom   // Imaginary part</span></span>
<span id="cb30-101"><a href="#cb30-101" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb30-102"><a href="#cb30-102" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-103"><a href="#cb30-103" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-104"><a href="#cb30-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-105"><a href="#cb30-105" aria-hidden="true" tabindex="-1"></a>Division multiplies numerator and denominator by the conjugate of $w$ to rationalize. The denominator becomes real ($c^2 + d^2$), and the numerator becomes a new complex number we can compute directly.</span>
<span id="cb30-106"><a href="#cb30-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-107"><a href="#cb30-107" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb30-108"><a href="#cb30-108" aria-hidden="true" tabindex="-1"></a><span class="fu">## Computational Efficiency in Complex Arithmetic</span></span>
<span id="cb30-109"><a href="#cb30-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-110"><a href="#cb30-110" aria-hidden="true" tabindex="-1"></a>Notice we use <span class="in">`dot(z, z)`</span> for magnitude squared—this is a single GPU operation rather than component-wise multiplication and addition. Similarly, <span class="in">`dot(w, w)`</span> in the division routine. For operations you'll compute millions of times per frame, these micro-optimizations add up!</span>
<span id="cb30-111"><a href="#cb30-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-112"><a href="#cb30-112" aria-hidden="true" tabindex="-1"></a>We're also using helper functions rather than inlining the formulas everywhere. This makes the code much more readable (<span class="in">`cmul(z, z)`</span> vs <span class="in">`vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)`</span>) and easier to debug. If you make a sign error once in <span class="in">`cmul`</span>, you fix it once. If you inline the formula fifty times, you'll hunt for bugs forever!</span>
<span id="cb30-113"><a href="#cb30-113" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-114"><a href="#cb30-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-115"><a href="#cb30-115" aria-hidden="true" tabindex="-1"></a>These are the building blocks we need for complex dynamics. Let's put them to work!</span>
<span id="cb30-116"><a href="#cb30-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-117"><a href="#cb30-117" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-118"><a href="#cb30-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-119"><a href="#cb30-119" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Mandelbrot Set</span></span>
<span id="cb30-120"><a href="#cb30-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-121"><a href="#cb30-121" aria-hidden="true" tabindex="-1"></a><span class="fu">### Definition</span></span>
<span id="cb30-122"><a href="#cb30-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-123"><a href="#cb30-123" aria-hidden="true" tabindex="-1"></a>The Mandelbrot set $\mathcal{M}$ is one of the most famous objects in mathematics—and for good reason! It's defined as the set of complex numbers $c$ for which the iteration</span>
<span id="cb30-124"><a href="#cb30-124" aria-hidden="true" tabindex="-1"></a>$$z_{n+1} = z_n^2 + c, \quad z_0 = 0$$</span>
<span id="cb30-125"><a href="#cb30-125" aria-hidden="true" tabindex="-1"></a>remains bounded as $n \to \infty$.</span>
<span id="cb30-126"><a href="#cb30-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-127"><a href="#cb30-127" aria-hidden="true" tabindex="-1"></a>That's it! Just iterate this simple quadratic map starting from $z_0 = 0$, and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.</span>
<span id="cb30-128"><a href="#cb30-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-129"><a href="#cb30-129" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Escape Radius Theorem</span></span>
<span id="cb30-130"><a href="#cb30-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-131"><a href="#cb30-131" aria-hidden="true" tabindex="-1"></a>In practice, we can't iterate to infinity, so we need a criterion to detect escape. Fortunately, there's a beautiful theorem that tells us exactly when to stop:</span>
<span id="cb30-132"><a href="#cb30-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-133"><a href="#cb30-133" aria-hidden="true" tabindex="-1"></a>**Theorem (Escape Radius).** If $|z_n| &gt; 2$ for any $n$, then $|z_n| \to \infty$ as $n \to \infty$.</span>
<span id="cb30-134"><a href="#cb30-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-135"><a href="#cb30-135" aria-hidden="true" tabindex="-1"></a>This means: once the orbit leaves the disk of radius 2, it's definitely escaping to infinity. Points that escape are not in the Mandelbrot set, while points that remain bounded after many iterations are (likely) in the set or very close to its boundary.</span>
<span id="cb30-136"><a href="#cb30-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-137"><a href="#cb30-137" aria-hidden="true" tabindex="-1"></a>**Proof.** Suppose $|z_n| &gt; 2$ and write $|z_n| = 2 + \epsilon$ for some $\epsilon &gt; 0$. Then</span>
<span id="cb30-138"><a href="#cb30-138" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb30-139"><a href="#cb30-139" aria-hidden="true" tabindex="-1"></a><span class="pp">|</span>z_{n+1}<span class="pp">|</span> &amp;= <span class="pp">|</span>z_n^2 + c<span class="pp">|</span><span class="sc">\\</span></span>
<span id="cb30-140"><a href="#cb30-140" aria-hidden="true" tabindex="-1"></a>&amp;\geq |z_n^2| - |c|<span class="sc">\\</span></span>
<span id="cb30-141"><a href="#cb30-141" aria-hidden="true" tabindex="-1"></a>&amp;= |z_n|^2 - |c|<span class="sc">\\</span></span>
<span id="cb30-142"><a href="#cb30-142" aria-hidden="true" tabindex="-1"></a>&amp;&gt; |z_n|^2 - 2 \quad \text{(since $c$ is in or near $\mathcal{M}$, which fits in $|z| \leq 2$)}<span class="sc">\\</span></span>
<span id="cb30-143"><a href="#cb30-143" aria-hidden="true" tabindex="-1"></a>&amp;= (2 + \epsilon)^2 - 2<span class="sc">\\</span></span>
<span id="cb30-144"><a href="#cb30-144" aria-hidden="true" tabindex="-1"></a>&amp;= 4 + 4\epsilon + \epsilon^2 - 2<span class="sc">\\</span></span>
<span id="cb30-145"><a href="#cb30-145" aria-hidden="true" tabindex="-1"></a>&amp;= 2 + 4\epsilon + \epsilon^2<span class="sc">\\</span></span>
<span id="cb30-146"><a href="#cb30-146" aria-hidden="true" tabindex="-1"></a>&amp;&gt; 2 + 2\epsilon = |z_n| + \epsilon</span>
<span id="cb30-147"><a href="#cb30-147" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb30-148"><a href="#cb30-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-149"><a href="#cb30-149" aria-hidden="true" tabindex="-1"></a>So once $|z_n| &gt; 2$, we have $|z_{n+1}| &gt; |z_n| + \epsilon$, meaning the magnitude grows by at least $\epsilon$ each iteration. This linear growth accelerates: if $|z_{n+1}| &gt; 2 + \epsilon$, then $|z_{n+2}| &gt; |z_{n+1}| + \epsilon' &gt; 2 + 2\epsilon$, and so on. More carefully, the orbit actually grows exponentially (roughly like $|z_n| \sim 2^{2^n}$ for large $n$), but the key point is: it definitely escapes to infinity.</span>
<span id="cb30-150"><a href="#cb30-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-151"><a href="#cb30-151" aria-hidden="true" tabindex="-1"></a>**Computational Implication:** We only need to check if $|z_n| &gt; 2$. The moment this happens, we can stop iterating—this point will never be in the Mandelbrot set. This single theorem makes efficient rendering possible!</span>
<span id="cb30-152"><a href="#cb30-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-153"><a href="#cb30-153" aria-hidden="true" tabindex="-1"></a><span class="fu">### Historical Context</span></span>
<span id="cb30-154"><a href="#cb30-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-155"><a href="#cb30-155" aria-hidden="true" tabindex="-1"></a>The Mandelbrot set was discovered remarkably recently—1980! Benoit Mandelbrot, working at IBM, was among the first to have access to computers powerful enough to visualize iterative processes in the complex plane. Before computers, studying these sets was nearly impossible—you'd need to manually iterate complex arithmetic hundreds of times for millions of points.</span>
<span id="cb30-156"><a href="#cb30-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-157"><a href="#cb30-157" aria-hidden="true" tabindex="-1"></a>Interestingly, the mathematical theory predates visualization by over 60 years. Gaston Julia and Pierre Fatou studied iterative complex dynamics extensively in 1918, but without computers, they could only reason about these sets abstractly. They knew Julia sets existed and had deep properties, but had never seen one! When Mandelbrot generated the first images in 1980, it revolutionized the field—suddenly the intricate structure of these sets was visible, creating an explosion of interest in fractal geometry and complex dynamics.</span>
<span id="cb30-158"><a href="#cb30-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-159"><a href="#cb30-159" aria-hidden="true" tabindex="-1"></a>The Mandelbrot set became iconic partly because it's so accessible: anyone can understand the definition (iterate $z \mapsto z^2 + c$), yet it produces infinitely intricate beauty. It also sparked broader interest in fractals, chaos theory, and the idea that simple rules can generate complex behavior—themes that would influence everything from physics to economics to art.</span>
<span id="cb30-160"><a href="#cb30-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-161"><a href="#cb30-161" aria-hidden="true" tabindex="-1"></a><span class="fu">### Basic Implementation</span></span>
<span id="cb30-162"><a href="#cb30-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-163"><a href="#cb30-163" aria-hidden="true" tabindex="-1"></a>Let's code it up:</span>
<span id="cb30-164"><a href="#cb30-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-165"><a href="#cb30-165" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-166"><a href="#cb30-166" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb30-167"><a href="#cb30-167" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb30-168"><a href="#cb30-168" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup: center at origin, scale to show interesting region</span></span>
<span id="cb30-169"><a href="#cb30-169" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb30-170"><a href="#cb30-170" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb30-171"><a href="#cb30-171" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb30-172"><a href="#cb30-172" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-173"><a href="#cb30-173" aria-hidden="true" tabindex="-1"></a><span class="in">    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])</span></span>
<span id="cb30-174"><a href="#cb30-174" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c = uv * 3.5;</span></span>
<span id="cb30-175"><a href="#cb30-175" aria-hidden="true" tabindex="-1"></a><span class="in">    c.x -= 0.5;  // Center on the interesting part</span></span>
<span id="cb30-176"><a href="#cb30-176" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-177"><a href="#cb30-177" aria-hidden="true" tabindex="-1"></a><span class="in">    // Mandelbrot iteration</span></span>
<span id="cb30-178"><a href="#cb30-178" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = vec2(0.0, 0.0);  // z_0 = 0</span></span>
<span id="cb30-179"><a href="#cb30-179" aria-hidden="true" tabindex="-1"></a><span class="in">    int max_iter = 100;</span></span>
<span id="cb30-180"><a href="#cb30-180" aria-hidden="true" tabindex="-1"></a><span class="in">    int iter;</span></span>
<span id="cb30-181"><a href="#cb30-181" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-182"><a href="#cb30-182" aria-hidden="true" tabindex="-1"></a><span class="in">    for(iter = 0; iter &lt; max_iter; iter++) {</span></span>
<span id="cb30-183"><a href="#cb30-183" aria-hidden="true" tabindex="-1"></a><span class="in">        // Check if escaped</span></span>
<span id="cb30-184"><a href="#cb30-184" aria-hidden="true" tabindex="-1"></a><span class="in">        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4</span></span>
<span id="cb30-185"><a href="#cb30-185" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb30-186"><a href="#cb30-186" aria-hidden="true" tabindex="-1"></a><span class="in">        // z_{n+1} = z_n² + c</span></span>
<span id="cb30-187"><a href="#cb30-187" aria-hidden="true" tabindex="-1"></a><span class="in">        z = cmul(z, z) + c;</span></span>
<span id="cb30-188"><a href="#cb30-188" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb30-189"><a href="#cb30-189" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-190"><a href="#cb30-190" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on iteration count</span></span>
<span id="cb30-191"><a href="#cb30-191" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(iter) / float(max_iter);</span></span>
<span id="cb30-192"><a href="#cb30-192" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(t);  // Grayscale for now</span></span>
<span id="cb30-193"><a href="#cb30-193" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-194"><a href="#cb30-194" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb30-195"><a href="#cb30-195" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-196"><a href="#cb30-196" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-197"><a href="#cb30-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-198"><a href="#cb30-198" aria-hidden="true" tabindex="-1"></a>That's the entire Mandelbrot set renderer! The coordinate scaling is tuned to show the "interesting part"—the main cardioid body and its surrounding bulbs. The set extends roughly from $-2.5$ to $0.5$ on the real axis, so we shift our coordinate system accordingly.</span>
<span id="cb30-199"><a href="#cb30-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-200"><a href="#cb30-200" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb30-201"><a href="#cb30-201" aria-hidden="true" tabindex="-1"></a><span class="fu">## Why This Is Perfect for GPUs</span></span>
<span id="cb30-202"><a href="#cb30-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-203"><a href="#cb30-203" aria-hidden="true" tabindex="-1"></a>Notice what's happening computationally: every pixel performs its own independent calculation. There's no communication between pixels, no shared data structures, no synchronization needed. Each pixel just iterates its own complex number and decides when to stop.</span>
<span id="cb30-204"><a href="#cb30-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-205"><a href="#cb30-205" aria-hidden="true" tabindex="-1"></a>This is **embarrassingly parallel**—the ideal workload for GPU architecture. A modern GPU has thousands of small processors, and they can all work on different pixels simultaneously. No pixel needs to wait for another pixel's result. The entire screen (potentially millions of pixels) is computed in parallel, which is why we can render the Mandelbrot set at 60fps even with 100+ iterations per pixel.</span>
<span id="cb30-206"><a href="#cb30-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-207"><a href="#cb30-207" aria-hidden="true" tabindex="-1"></a>Memory-wise, this is also very efficient: each pixel only needs to store its current $z$ value (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures. The computation is stateless—we only care about the current iterate, not the full orbit.</span>
<span id="cb30-208"><a href="#cb30-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-209"><a href="#cb30-209" aria-hidden="true" tabindex="-1"></a>This contrasts sharply with sequential CPU code, where you'd iterate over pixels one at a time. Even with clever optimizations and SIMD vectorization, you'd be orders of magnitude slower than a GPU shader doing the same work.</span>
<span id="cb30-210"><a href="#cb30-210" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-211"><a href="#cb30-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-212"><a href="#cb30-212" aria-hidden="true" tabindex="-1"></a><span class="fu">### Smooth Coloring</span></span>
<span id="cb30-213"><a href="#cb30-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-214"><a href="#cb30-214" aria-hidden="true" tabindex="-1"></a>The grayscale rendering shows the structure of the set, but it has harsh banding—sudden transitions between integer iteration counts create visible stripes. We can do much better by interpolating between iteration steps!</span>
<span id="cb30-215"><a href="#cb30-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-216"><a href="#cb30-216" aria-hidden="true" tabindex="-1"></a>The key insight is that near escape, the orbit grows exponentially. Specifically, once $|z_n|$ is large, we have approximately $|z_{n+1}| \approx |z_n|^2$, which means $\log |z_{n+1}| \approx 2\log|z_n|$. Taking logs repeatedly, we get</span>
<span id="cb30-217"><a href="#cb30-217" aria-hidden="true" tabindex="-1"></a>$$\log\log|z_{n+1}| \approx \log(2\log|z_n|) = \log 2 + \log\log|z_n|$$</span>
<span id="cb30-218"><a href="#cb30-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-219"><a href="#cb30-219" aria-hidden="true" tabindex="-1"></a>This suggests that $\log\log|z_n|$ grows approximately linearly near escape, increasing by $\log 2$ per iteration. We can use this to compute a fractional iteration count!</span>
<span id="cb30-220"><a href="#cb30-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-221"><a href="#cb30-221" aria-hidden="true" tabindex="-1"></a>Here's the formula:</span>
<span id="cb30-222"><a href="#cb30-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-223"><a href="#cb30-223" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-224"><a href="#cb30-224" aria-hidden="true" tabindex="-1"></a><span class="in">if(iter &lt; max_iter) {</span></span>
<span id="cb30-225"><a href="#cb30-225" aria-hidden="true" tabindex="-1"></a><span class="in">    // Smooth iteration count (accounts for continuous escape)</span></span>
<span id="cb30-226"><a href="#cb30-226" aria-hidden="true" tabindex="-1"></a><span class="in">    float log_zn = log(cabs2(z)) / 2.0;  // = log|z_n|</span></span>
<span id="cb30-227"><a href="#cb30-227" aria-hidden="true" tabindex="-1"></a><span class="in">    float nu = log(log_zn / log(2.0)) / log(2.0);</span></span>
<span id="cb30-228"><a href="#cb30-228" aria-hidden="true" tabindex="-1"></a><span class="in">    float smooth_iter = float(iter) + 1.0 - nu;</span></span>
<span id="cb30-229"><a href="#cb30-229" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-230"><a href="#cb30-230" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = smooth_iter / float(max_iter);</span></span>
<span id="cb30-231"><a href="#cb30-231" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb30-232"><a href="#cb30-232" aria-hidden="true" tabindex="-1"></a><span class="in">} else {</span></span>
<span id="cb30-233"><a href="#cb30-233" aria-hidden="true" tabindex="-1"></a><span class="in">    // Inside the set: black</span></span>
<span id="cb30-234"><a href="#cb30-234" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.0);</span></span>
<span id="cb30-235"><a href="#cb30-235" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-236"><a href="#cb30-236" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-237"><a href="#cb30-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-238"><a href="#cb30-238" aria-hidden="true" tabindex="-1"></a>The variable <span class="in">`nu`</span> represents how far we've progressed toward the next integer iteration. When $|z_n| = 2$ exactly (just hitting the escape threshold), $nu = 0$ and we get the integer iteration count. When $|z_n|$ is large (deep into escape), $nu$ approaches 1. Subtracting <span class="in">`nu`</span> from <span class="in">`iter + 1`</span> gives us a continuous, smooth value that transitions gradually between iteration levels.</span>
<span id="cb30-239"><a href="#cb30-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-240"><a href="#cb30-240" aria-hidden="true" tabindex="-1"></a>This eliminates banding entirely! The result is smooth, continuous color gradients that look much more professional and reveal the fractal structure more clearly.</span>
<span id="cb30-241"><a href="#cb30-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-242"><a href="#cb30-242" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb30-243"><a href="#cb30-243" aria-hidden="true" tabindex="-1"></a><span class="fu">## Smooth Coloring as Anti-Aliasing</span></span>
<span id="cb30-244"><a href="#cb30-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-245"><a href="#cb30-245" aria-hidden="true" tabindex="-1"></a>Smooth coloring is fundamentally an anti-aliasing technique. Without it, nearby pixels with iteration counts of, say, 45 and 46 get completely different colors—creating harsh edges. With smooth coloring, these pixels get nearly identical colors (say, iteration 45.3 and 45.8), producing a smooth gradient.</span>
<span id="cb30-246"><a href="#cb30-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-247"><a href="#cb30-247" aria-hidden="true" tabindex="-1"></a>This is especially important at high zoom levels, where tiny changes in position lead to different integer iteration counts. The smooth interpolation ensures that small changes in $c$ produce small changes in color, which is exactly what we want for a continuous mathematical function.</span>
<span id="cb30-248"><a href="#cb30-248" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-249"><a href="#cb30-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-250"><a href="#cb30-250" aria-hidden="true" tabindex="-1"></a><span class="fu">### Color Palettes</span></span>
<span id="cb30-251"><a href="#cb30-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-252"><a href="#cb30-252" aria-hidden="true" tabindex="-1"></a>Now we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:</span>
<span id="cb30-253"><a href="#cb30-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-254"><a href="#cb30-254" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-255"><a href="#cb30-255" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 palette(float t) {</span></span>
<span id="cb30-256"><a href="#cb30-256" aria-hidden="true" tabindex="-1"></a><span class="in">    // Create a cyclic color palette using cosines</span></span>
<span id="cb30-257"><a href="#cb30-257" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 a = vec3(0.5, 0.5, 0.5);</span></span>
<span id="cb30-258"><a href="#cb30-258" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 b = vec3(0.5, 0.5, 0.5);</span></span>
<span id="cb30-259"><a href="#cb30-259" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 c = vec3(1.0, 1.0, 1.0);</span></span>
<span id="cb30-260"><a href="#cb30-260" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 d = vec3(0.0, 0.33, 0.67);</span></span>
<span id="cb30-261"><a href="#cb30-261" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-262"><a href="#cb30-262" aria-hidden="true" tabindex="-1"></a><span class="in">    return a + b * cos(6.28318 * (c * t + d));</span></span>
<span id="cb30-263"><a href="#cb30-263" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-264"><a href="#cb30-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-265"><a href="#cb30-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-266"><a href="#cb30-266" aria-hidden="true" tabindex="-1"></a>This uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters control different aspects:</span>
<span id="cb30-267"><a href="#cb30-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-268"><a href="#cb30-268" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`a`</span> and <span class="in">`b`</span> control the range and center of the colors (here, mapping to $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$)</span>
<span id="cb30-269"><a href="#cb30-269" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`c`</span> controls the frequency of color cycling</span>
<span id="cb30-270"><a href="#cb30-270" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`d`</span> controls the phase offset, shifting the entire palette</span>
<span id="cb30-271"><a href="#cb30-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-272"><a href="#cb30-272" aria-hidden="true" tabindex="-1"></a>Play with these parameters to get different color schemes! Try <span class="in">`d = vec3(0.0, 0.1, 0.2)`</span> for a blue-purple palette, or <span class="in">`d = vec3(0.3, 0.2, 0.2)`</span> for warmer tones. You can also adjust <span class="in">`c`</span> to make the colors cycle faster or slower through the iteration range.</span>
<span id="cb30-273"><a href="#cb30-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-274"><a href="#cb30-274" aria-hidden="true" tabindex="-1"></a>The beauty of this cosine approach is that it's smooth (continuous derivatives), cyclic (no seams), and efficient (just a few trig operations). Other approaches exist—hand-picked color stops with interpolation, HSV color spaces, perceptually uniform LAB spaces—but cosine palettes are a great default for fractal visualization.</span>
<span id="cb30-275"><a href="#cb30-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-276"><a href="#cb30-276" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-277"><a href="#cb30-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-278"><a href="#cb30-278" aria-hidden="true" tabindex="-1"></a><span class="fu">## Julia Sets</span></span>
<span id="cb30-279"><a href="#cb30-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-280"><a href="#cb30-280" aria-hidden="true" tabindex="-1"></a>The Julia set is the natural companion to the Mandelbrot set, and understanding their relationship is key to understanding complex dynamics. Where the Mandelbrot set varies $c$ and fixes $z_0 = 0$, the Julia set does the opposite: it fixes $c$ and varies $z_0$.</span>
<span id="cb30-281"><a href="#cb30-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-282"><a href="#cb30-282" aria-hidden="true" tabindex="-1"></a><span class="fu">### Definition</span></span>
<span id="cb30-283"><a href="#cb30-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-284"><a href="#cb30-284" aria-hidden="true" tabindex="-1"></a>For a fixed complex number $c$, the **filled Julia set** $K_c$ is the set of initial conditions $z_0$ for which the iteration</span>
<span id="cb30-285"><a href="#cb30-285" aria-hidden="true" tabindex="-1"></a>$$z_{n+1} = z_n^2 + c$$</span>
<span id="cb30-286"><a href="#cb30-286" aria-hidden="true" tabindex="-1"></a>remains bounded. The **Julia set** $J_c$ is the boundary of $K_c$—the set where the dynamics are chaotic, neither definitely bounded nor definitely escaping.</span>
<span id="cb30-287"><a href="#cb30-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-288"><a href="#cb30-288" aria-hidden="true" tabindex="-1"></a>Think about what this means: every point $c$ in the complex plane has an associated Julia set $J_c$. The Mandelbrot set is telling us about the topology of these Julia sets! Specifically:</span>
<span id="cb30-289"><a href="#cb30-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-290"><a href="#cb30-290" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $c \in \mathcal{M}$ (inside the Mandelbrot set), then $J_c$ is **connected**—a single, intricate curve</span>
<span id="cb30-291"><a href="#cb30-291" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $c \notin \mathcal{M}$ (outside the Mandelbrot set), then $J_c$ is **totally disconnected**—a Cantor-like dust of points</span>
<span id="cb30-292"><a href="#cb30-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-293"><a href="#cb30-293" aria-hidden="true" tabindex="-1"></a>This is one of the most beautiful connections in mathematics: the Mandelbrot set is a map of parameter space, showing which values of $c$ produce connected Julia sets. Julia and Fatou proved this in 1918 without ever seeing a picture—they understood these sets purely abstractly!</span>
<span id="cb30-294"><a href="#cb30-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-295"><a href="#cb30-295" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation as Homework</span></span>
<span id="cb30-296"><a href="#cb30-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-297"><a href="#cb30-297" aria-hidden="true" tabindex="-1"></a>You'll implement Julia set rendering in the homework. The algorithm is nearly identical to the Mandelbrot set—just swap what's fixed and what varies! Instead of setting <span class="in">`z = vec2(0.0)`</span> and varying <span class="in">`c`</span> across pixels, you'll set <span class="in">`c`</span> to a fixed value and let <span class="in">`z`</span> be the pixel coordinate.</span>
<span id="cb30-298"><a href="#cb30-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-299"><a href="#cb30-299" aria-hidden="true" tabindex="-1"></a>The key changes:</span>
<span id="cb30-300"><a href="#cb30-300" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Fix <span class="in">`c`</span> to an interesting value (we'll give suggestions)</span>
<span id="cb30-301"><a href="#cb30-301" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Initialize <span class="in">`z`</span> from the pixel position (that's your $z_0$)</span>
<span id="cb30-302"><a href="#cb30-302" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Iterate $z \mapsto z^2 + c$ exactly as before</span>
<span id="cb30-303"><a href="#cb30-303" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Use the same escape criterion and coloring</span>
<span id="cb30-304"><a href="#cb30-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-305"><a href="#cb30-305" aria-hidden="true" tabindex="-1"></a>This will give you a Julia set! Try different values of $c$ to see how the topology changes. You can make <span class="in">`c`</span> depend on time (<span class="in">`iTime`</span>) for animation, or on mouse position (<span class="in">`iMouse`</span>) for interactive exploration.</span>
<span id="cb30-306"><a href="#cb30-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-307"><a href="#cb30-307" aria-hidden="true" tabindex="-1"></a>**Some interesting values to try:**</span>
<span id="cb30-308"><a href="#cb30-308" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$c = -0.7 + 0.27015i$ — classic Julia set, intricate tendrils</span>
<span id="cb30-309"><a href="#cb30-309" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$c = -0.4 + 0.6i$ — dendrite-like fractal trees</span>
<span id="cb30-310"><a href="#cb30-310" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$c = 0.285 + 0.01i$ — beautiful spiral patterns</span>
<span id="cb30-311"><a href="#cb30-311" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$c = -0.8 + 0.156i$ — highly filamentary</span>
<span id="cb30-312"><a href="#cb30-312" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$c = -0.70176 - 0.3842i$ — "San Marco dragon"</span>
<span id="cb30-313"><a href="#cb30-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-314"><a href="#cb30-314" aria-hidden="true" tabindex="-1"></a>Values inside the Mandelbrot set give connected Julia sets (single curves), while values outside give disconnected Julia sets (dust). The most interesting Julia sets often come from values right near the boundary of $\mathcal{M}$—this is where the transition between connected and disconnected happens!</span>
<span id="cb30-315"><a href="#cb30-315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-316"><a href="#cb30-316" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb30-317"><a href="#cb30-317" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exploring Parameter Space</span></span>
<span id="cb30-318"><a href="#cb30-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-319"><a href="#cb30-319" aria-hidden="true" tabindex="-1"></a>When you implement Julia sets, try this: tie $c$ to your mouse position. Move the mouse around and watch the Julia set morph in real time! This is an incredibly powerful way to build intuition for how the parameter $c$ affects the dynamics.</span>
<span id="cb30-320"><a href="#cb30-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-321"><a href="#cb30-321" aria-hidden="true" tabindex="-1"></a>You'll notice that small changes in $c$ can produce dramatic changes in the Julia set topology—this is the sensitive dependence on parameters that makes complex dynamics so rich. Near the boundary of the Mandelbrot set, tiny movements create entirely different structures.</span>
<span id="cb30-322"><a href="#cb30-322" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-323"><a href="#cb30-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-324"><a href="#cb30-324" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-325"><a href="#cb30-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-326"><a href="#cb30-326" aria-hidden="true" tabindex="-1"></a><span class="fu">## Interlude: From Complex to Geometric Dynamics</span></span>
<span id="cb30-327"><a href="#cb30-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-328"><a href="#cb30-328" aria-hidden="true" tabindex="-1"></a>We've been iterating algebraic functions in the complex plane: $z \mapsto z^2 + c$. Now we shift to iterating geometric transformations of the plane itself: circle inversion. The mathematical frameworks are different—holomorphic dynamics versus conformal geometry—but they share fundamental similarities.</span>
<span id="cb30-329"><a href="#cb30-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-330"><a href="#cb30-330" aria-hidden="true" tabindex="-1"></a>Both complex multiplication and circle inversion are **conformal maps**: they preserve angles between curves. In complex dynamics, this comes from the Cauchy-Riemann equations and the geometric interpretation of multiplication as rotation and scaling. In circle inversion, it's a theorem we'll state shortly. This angle preservation is crucial—it's what makes the fractal structures we generate geometrically coherent and visually beautiful.</span>
<span id="cb30-331"><a href="#cb30-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-332"><a href="#cb30-332" aria-hidden="true" tabindex="-1"></a>There's also a deep connection we'll explore tomorrow: circle inversion is actually an isometry of hyperbolic space! The inversions we're about to do are the same transformations that generate Kleinian groups and tessellate the hyperbolic plane. So in some sense, we're already working in non-Euclidean geometry without realizing it. Tomorrow we'll make this explicit when we explore hyperbolic tilings.</span>
<span id="cb30-333"><a href="#cb30-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-334"><a href="#cb30-334" aria-hidden="true" tabindex="-1"></a>For now, let's learn circle inversion and use it to build the Apollonian gasket—a fractal structure every bit as intricate as the Mandelbrot set, but generated through pure Euclidean geometry.</span>
<span id="cb30-335"><a href="#cb30-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-336"><a href="#cb30-336" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-337"><a href="#cb30-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-338"><a href="#cb30-338" aria-hidden="true" tabindex="-1"></a><span class="fu">## Circle Inversion</span></span>
<span id="cb30-339"><a href="#cb30-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-340"><a href="#cb30-340" aria-hidden="true" tabindex="-1"></a>Circle inversion is a beautiful geometric operation that will be the foundation for everything we do with geometric dynamics. It's a transformation of the plane that turns inside into outside, maps circles to circles (or lines), and preserves angles—making it a powerful tool for creating fractal patterns.</span>
<span id="cb30-341"><a href="#cb30-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-342"><a href="#cb30-342" aria-hidden="true" tabindex="-1"></a><span class="fu">### Mathematical Definition</span></span>
<span id="cb30-343"><a href="#cb30-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-344"><a href="#cb30-344" aria-hidden="true" tabindex="-1"></a>Circle inversion is a transformation with respect to a circle. For a circle of radius $R$ centered at a point $\mathbf{c}$, inversion maps a point $\mathbf{p} \neq \mathbf{c}$ to:</span>
<span id="cb30-345"><a href="#cb30-345" aria-hidden="true" tabindex="-1"></a>$$\text{inv}(\mathbf{p}) = \mathbf{c} + R^2 \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|^2}$$</span>
<span id="cb30-346"><a href="#cb30-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-347"><a href="#cb30-347" aria-hidden="true" tabindex="-1"></a>The vector $\mathbf{p} - \mathbf{c}$ points from the center to $\mathbf{p}$. We normalize this direction by dividing by its squared length, then scale by $R^2$, and finally translate back by the center. Geometrically:</span>
<span id="cb30-348"><a href="#cb30-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-349"><a href="#cb30-349" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points inside the circle map to points outside (and vice versa)</span>
<span id="cb30-350"><a href="#cb30-350" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points on the circle are fixed (they map to themselves)</span>
<span id="cb30-351"><a href="#cb30-351" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The closer you are to the center, the farther away you go</span>
<span id="cb30-352"><a href="#cb30-352" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The center itself maps to infinity, and infinity maps to the center</span>
<span id="cb30-353"><a href="#cb30-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-354"><a href="#cb30-354" aria-hidden="true" tabindex="-1"></a>Here's another way to think about it: draw a ray from the center through $\mathbf{p}$. The inversion of $\mathbf{p}$ is the unique point on this ray such that the product of distances from the center is $R^2$. If $\mathbf{p}$ is at distance $r$ from the center, its image is at distance $R^2/r$.</span>
<span id="cb30-355"><a href="#cb30-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-356"><a href="#cb30-356" aria-hidden="true" tabindex="-1"></a><span class="fu">### Key Properties</span></span>
<span id="cb30-357"><a href="#cb30-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-358"><a href="#cb30-358" aria-hidden="true" tabindex="-1"></a>Circle inversion has remarkable geometric properties. These aren't obvious from the formula, but they're all classical theorems:</span>
<span id="cb30-359"><a href="#cb30-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-360"><a href="#cb30-360" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Lines through the center** remain lines through the center (they're "flipped inside out" along the ray)</span>
<span id="cb30-361"><a href="#cb30-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-362"><a href="#cb30-362" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Lines not through the center** become circles through the center</span>
<span id="cb30-363"><a href="#cb30-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-364"><a href="#cb30-364" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Circles through the center** become lines (not through the center)</span>
<span id="cb30-365"><a href="#cb30-365" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-366"><a href="#cb30-366" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Circles not through the center** generally remain circles, but with different center and radius</span>
<span id="cb30-367"><a href="#cb30-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-368"><a href="#cb30-368" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Angles are preserved** (conformal property)</span>
<span id="cb30-369"><a href="#cb30-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-370"><a href="#cb30-370" aria-hidden="true" tabindex="-1"></a>The angle preservation is the deepest property. It's not at all obvious from the formula, but it can be proved using the chain rule and careful calculation. The key insight is that inversion is locally similar to a complex conjugation-like operation, which preserves angles.</span>
<span id="cb30-371"><a href="#cb30-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-372"><a href="#cb30-372" aria-hidden="true" tabindex="-1"></a>**Why These Properties Matter for Iteration:** When we iterate inversions through multiple circles, these properties ensure that the geometry remains coherent. Circles stay circles (or become lines), and the angles between curves are preserved. This means repeated inversion creates intricate but geometrically regular patterns—the hallmark of fractals generated by conformal maps.</span>
<span id="cb30-373"><a href="#cb30-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-374"><a href="#cb30-374" aria-hidden="true" tabindex="-1"></a>Another key fact: inversion is **involutive**—applying it twice returns to the original point (assuming the point isn't the center). Mathematically, $\text{inv}(\text{inv}(\mathbf{p})) = \mathbf{p}$. This makes inversion a geometric reflection of sorts, which will be important when we think about symmetry groups tomorrow.</span>
<span id="cb30-375"><a href="#cb30-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-376"><a href="#cb30-376" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb30-377"><a href="#cb30-377" aria-hidden="true" tabindex="-1"></a><span class="fu">## Historical Context: Circle Inversion</span></span>
<span id="cb30-378"><a href="#cb30-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-379"><a href="#cb30-379" aria-hidden="true" tabindex="-1"></a>Circle inversion has ancient roots—Apollonius of Perga studied related problems involving tangent circles around 200 BCE. But the modern theory of inversion as a geometric transformation developed in the 19th century as part of projective and non-Euclidean geometry.</span>
<span id="cb30-380"><a href="#cb30-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-381"><a href="#cb30-381" aria-hidden="true" tabindex="-1"></a>A key insight was recognizing that circle inversion is related to stereographic projection: if you place a sphere on the plane, inversion in a circle corresponds to reflection through the sphere! This connection links circle inversion to spherical geometry and ultimately to hyperbolic geometry.</span>
<span id="cb30-382"><a href="#cb30-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-383"><a href="#cb30-383" aria-hidden="true" tabindex="-1"></a>In the late 19th and early 20th centuries, mathematicians realized that groups of circle inversions (Kleinian groups) could tessellate hyperbolic space and create fractal limit sets. This anticipates the fractal geometry revolution of the 1970s-80s, though the connection wasn't fully appreciated until computers made visualization possible.</span>
<span id="cb30-384"><a href="#cb30-384" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-385"><a href="#cb30-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-386"><a href="#cb30-386" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb30-387"><a href="#cb30-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-388"><a href="#cb30-388" aria-hidden="true" tabindex="-1"></a>The formula translates directly to GLSL:</span>
<span id="cb30-389"><a href="#cb30-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-390"><a href="#cb30-390" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-391"><a href="#cb30-391" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 invertCircle(vec2 p, vec2 center, float radius) {</span></span>
<span id="cb30-392"><a href="#cb30-392" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 diff = p - center;</span></span>
<span id="cb30-393"><a href="#cb30-393" aria-hidden="true" tabindex="-1"></a><span class="in">    float r2 = dot(diff, diff);  // squared distance from center</span></span>
<span id="cb30-394"><a href="#cb30-394" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-395"><a href="#cb30-395" aria-hidden="true" tabindex="-1"></a><span class="in">    // Handle center (would be division by zero)</span></span>
<span id="cb30-396"><a href="#cb30-396" aria-hidden="true" tabindex="-1"></a><span class="in">    if(r2 &lt; 0.0001) return vec2(1000.0);  // Map to "infinity"</span></span>
<span id="cb30-397"><a href="#cb30-397" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-398"><a href="#cb30-398" aria-hidden="true" tabindex="-1"></a><span class="in">    return center + (radius * radius) * diff / r2;</span></span>
<span id="cb30-399"><a href="#cb30-399" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-400"><a href="#cb30-400" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-401"><a href="#cb30-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-402"><a href="#cb30-402" aria-hidden="true" tabindex="-1"></a>The only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it's effectively off-screen. The threshold <span class="in">`0.0001`</span> is small enough to catch points numerically close to the center but large enough to avoid precision issues.</span>
<span id="cb30-403"><a href="#cb30-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-404"><a href="#cb30-404" aria-hidden="true" tabindex="-1"></a>Computationally, circle inversion is very cheap: just one dot product, a division, a multiplication, and some vector operations. This efficiency is important because we'll be doing many inversions per pixel when generating fractals!</span>
<span id="cb30-405"><a href="#cb30-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-406"><a href="#cb30-406" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing Circle Inversion</span></span>
<span id="cb30-407"><a href="#cb30-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-408"><a href="#cb30-408" aria-hidden="true" tabindex="-1"></a>Let's see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:</span>
<span id="cb30-409"><a href="#cb30-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-410"><a href="#cb30-410" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-411"><a href="#cb30-411" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb30-412"><a href="#cb30-412" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb30-413"><a href="#cb30-413" aria-hidden="true" tabindex="-1"></a><span class="in">    // Standard coordinate setup</span></span>
<span id="cb30-414"><a href="#cb30-414" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb30-415"><a href="#cb30-415" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb30-416"><a href="#cb30-416" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb30-417"><a href="#cb30-417" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb30-418"><a href="#cb30-418" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-419"><a href="#cb30-419" aria-hidden="true" tabindex="-1"></a><span class="in">    // Inversion circle</span></span>
<span id="cb30-420"><a href="#cb30-420" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 circleCenter = vec2(0.0, 0.0);</span></span>
<span id="cb30-421"><a href="#cb30-421" aria-hidden="true" tabindex="-1"></a><span class="in">    float circleRadius = 1.0;</span></span>
<span id="cb30-422"><a href="#cb30-422" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-423"><a href="#cb30-423" aria-hidden="true" tabindex="-1"></a><span class="in">    // Apply inversion</span></span>
<span id="cb30-424"><a href="#cb30-424" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);</span></span>
<span id="cb30-425"><a href="#cb30-425" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-426"><a href="#cb30-426" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw a grid in the inverted space</span></span>
<span id="cb30-427"><a href="#cb30-427" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 grid = fract(p_inverted * 2.0);  // Create repeating cells</span></span>
<span id="cb30-428"><a href="#cb30-428" aria-hidden="true" tabindex="-1"></a><span class="in">    float gridLine = step(0.95, max(grid.x, grid.y));  // Draw grid lines</span></span>
<span id="cb30-429"><a href="#cb30-429" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-430"><a href="#cb30-430" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(gridLine);</span></span>
<span id="cb30-431"><a href="#cb30-431" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-432"><a href="#cb30-432" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw the inversion circle itself (for reference)</span></span>
<span id="cb30-433"><a href="#cb30-433" aria-hidden="true" tabindex="-1"></a><span class="in">    float circDist = abs(length(p) - circleRadius);</span></span>
<span id="cb30-434"><a href="#cb30-434" aria-hidden="true" tabindex="-1"></a><span class="in">    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);</span></span>
<span id="cb30-435"><a href="#cb30-435" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-436"><a href="#cb30-436" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb30-437"><a href="#cb30-437" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-438"><a href="#cb30-438" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-439"><a href="#cb30-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-440"><a href="#cb30-440" aria-hidden="true" tabindex="-1"></a>You'll see straight grid lines transform into beautiful circular arcs! Lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.</span>
<span id="cb30-441"><a href="#cb30-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-442"><a href="#cb30-442" aria-hidden="true" tabindex="-1"></a>This visualization really helps build intuition. You can see:</span>
<span id="cb30-443"><a href="#cb30-443" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The circle itself (in red) is unchanged—points on it are fixed</span>
<span id="cb30-444"><a href="#cb30-444" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The grid inside the circle maps to a grid outside (and vice versa)</span>
<span id="cb30-445"><a href="#cb30-445" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Lines become curves, but the angles where they intersect are preserved</span>
<span id="cb30-446"><a href="#cb30-446" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The pattern has a pole singularity at the center (infinite distortion)</span>
<span id="cb30-447"><a href="#cb30-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-448"><a href="#cb30-448" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb30-449"><a href="#cb30-449" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exploring Circle Inversion</span></span>
<span id="cb30-450"><a href="#cb30-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-451"><a href="#cb30-451" aria-hidden="true" tabindex="-1"></a>Here are some experiments to try:</span>
<span id="cb30-452"><a href="#cb30-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-453"><a href="#cb30-453" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Multiple circles**: Create a grid of circles using <span class="in">`mod()`</span> (like we did on Day 1) and invert through each cell's circle independently. You'll see beautiful overlapping patterns!</span>
<span id="cb30-454"><a href="#cb30-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-455"><a href="#cb30-455" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Animated radius**: Make <span class="in">`circleRadius = 1.0 + 0.5 * sin(iTime)`</span> to watch the grid breathe in and out. This helps you see how the inversion depends on the circle's size.</span>
<span id="cb30-456"><a href="#cb30-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-457"><a href="#cb30-457" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Different patterns**: Instead of a grid, try drawing circles or other shapes in the inverted space. Circles become circles (or lines), creating intricate nested patterns.</span>
<span id="cb30-458"><a href="#cb30-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-459"><a href="#cb30-459" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Off-center inversion**: Move the inversion circle away from the origin. Watch how the asymmetry creates even more complex distortions.</span>
<span id="cb30-460"><a href="#cb30-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-461"><a href="#cb30-461" aria-hidden="true" tabindex="-1"></a>Each of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!</span>
<span id="cb30-462"><a href="#cb30-462" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-463"><a href="#cb30-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-464"><a href="#cb30-464" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-465"><a href="#cb30-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-466"><a href="#cb30-466" aria-hidden="true" tabindex="-1"></a><span class="fu">## Structs in GLSL</span></span>
<span id="cb30-467"><a href="#cb30-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-468"><a href="#cb30-468" aria-hidden="true" tabindex="-1"></a>Before we build the Apollonian gasket, we need to talk about organizing our data. We're about to deal with multiple circles, and passing around <span class="in">`center1`</span>, <span class="in">`radius1`</span>, <span class="in">`center2`</span>, <span class="in">`radius2`</span>, etc. gets unwieldy fast. GLSL provides **structs** (just like in C) for grouping related data together.</span>
<span id="cb30-469"><a href="#cb30-469" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-470"><a href="#cb30-470" aria-hidden="true" tabindex="-1"></a><span class="fu">### Defining and Using Structs</span></span>
<span id="cb30-471"><a href="#cb30-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-472"><a href="#cb30-472" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-473"><a href="#cb30-473" aria-hidden="true" tabindex="-1"></a><span class="in">struct Circle {</span></span>
<span id="cb30-474"><a href="#cb30-474" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 center;</span></span>
<span id="cb30-475"><a href="#cb30-475" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius;</span></span>
<span id="cb30-476"><a href="#cb30-476" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb30-477"><a href="#cb30-477" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-478"><a href="#cb30-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-479"><a href="#cb30-479" aria-hidden="true" tabindex="-1"></a>Now <span class="in">`Circle`</span> is a type we can use just like <span class="in">`vec2`</span> or <span class="in">`float`</span>. Creating and using structs is straightforward:</span>
<span id="cb30-480"><a href="#cb30-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-481"><a href="#cb30-481" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-482"><a href="#cb30-482" aria-hidden="true" tabindex="-1"></a><span class="in">// Declare and initialize</span></span>
<span id="cb30-483"><a href="#cb30-483" aria-hidden="true" tabindex="-1"></a><span class="in">Circle c1 = Circle(vec2(0.0, 0.0), 1.0);</span></span>
<span id="cb30-484"><a href="#cb30-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-485"><a href="#cb30-485" aria-hidden="true" tabindex="-1"></a><span class="in">// Or declare first, set later</span></span>
<span id="cb30-486"><a href="#cb30-486" aria-hidden="true" tabindex="-1"></a><span class="in">Circle c2;</span></span>
<span id="cb30-487"><a href="#cb30-487" aria-hidden="true" tabindex="-1"></a><span class="in">c2.center = vec2(1.0, 0.5);</span></span>
<span id="cb30-488"><a href="#cb30-488" aria-hidden="true" tabindex="-1"></a><span class="in">c2.radius = 0.75;</span></span>
<span id="cb30-489"><a href="#cb30-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-490"><a href="#cb30-490" aria-hidden="true" tabindex="-1"></a><span class="in">// Pass to functions</span></span>
<span id="cb30-491"><a href="#cb30-491" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 invertThroughCircle(vec2 p, Circle circ) {</span></span>
<span id="cb30-492"><a href="#cb30-492" aria-hidden="true" tabindex="-1"></a><span class="in">    return invertCircle(p, circ.center, circ.radius);</span></span>
<span id="cb30-493"><a href="#cb30-493" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-494"><a href="#cb30-494" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-495"><a href="#cb30-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-496"><a href="#cb30-496" aria-hidden="true" tabindex="-1"></a>This makes the code dramatically more readable. Compare:</span>
<span id="cb30-497"><a href="#cb30-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-498"><a href="#cb30-498" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-499"><a href="#cb30-499" aria-hidden="true" tabindex="-1"></a><span class="in">// Without structs - messy!</span></span>
<span id="cb30-500"><a href="#cb30-500" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 iterate(vec2 p, vec2 c1_cen, float c1_rad, vec2 c2_cen, float c2_rad, vec2 c3_cen, float c3_rad);</span></span>
<span id="cb30-501"><a href="#cb30-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-502"><a href="#cb30-502" aria-hidden="true" tabindex="-1"></a><span class="in">// With structs - clean!</span></span>
<span id="cb30-503"><a href="#cb30-503" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 iterate(vec2 p, Circle c1, Circle c2, Circle c3);</span></span>
<span id="cb30-504"><a href="#cb30-504" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-505"><a href="#cb30-505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-506"><a href="#cb30-506" aria-hidden="true" tabindex="-1"></a>For the Apollonian gasket, we'll have three circles we need to track and pass around. Structs make this much more manageable and semantically clear—we're working with circles as geometric objects, not just pairs of vectors and floats.</span>
<span id="cb30-507"><a href="#cb30-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-508"><a href="#cb30-508" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-509"><a href="#cb30-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-510"><a href="#cb30-510" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Apollonian Gasket</span></span>
<span id="cb30-511"><a href="#cb30-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-512"><a href="#cb30-512" aria-hidden="true" tabindex="-1"></a>Now for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It's named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles around 200 BCE, though the fractal interpretation is much more modern.</span>
<span id="cb30-513"><a href="#cb30-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-514"><a href="#cb30-514" aria-hidden="true" tabindex="-1"></a><span class="fu">### Descartes Circle Theorem</span></span>
<span id="cb30-515"><a href="#cb30-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-516"><a href="#cb30-516" aria-hidden="true" tabindex="-1"></a>To understand the Apollonian gasket, we need to know about a beautiful theorem: **Descartes Circle Theorem** (1643).</span>
<span id="cb30-517"><a href="#cb30-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-518"><a href="#cb30-518" aria-hidden="true" tabindex="-1"></a>Given four mutually tangent circles (each tangent to the other three), let their curvatures be $k_1, k_2, k_3, k_4$ where curvature $k = 1/r$ (positive for external tangency, negative for internal). Then:</span>
<span id="cb30-519"><a href="#cb30-519" aria-hidden="true" tabindex="-1"></a>$$(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)$$</span>
<span id="cb30-520"><a href="#cb30-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-521"><a href="#cb30-521" aria-hidden="true" tabindex="-1"></a>This can be rearranged to solve for the fourth curvature given three:</span>
<span id="cb30-522"><a href="#cb30-522" aria-hidden="true" tabindex="-1"></a>$$k_4 = k_1 + k_2 + k_3 \pm 2\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}$$</span>
<span id="cb30-523"><a href="#cb30-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-524"><a href="#cb30-524" aria-hidden="true" tabindex="-1"></a>The $\pm$ gives two solutions—the two circles tangent to the original three (one inside the curvilinear triangle they form, one outside).</span>
<span id="cb30-525"><a href="#cb30-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-526"><a href="#cb30-526" aria-hidden="true" tabindex="-1"></a>What makes this magical for fractals: if you start with three mutually tangent circles with integer curvatures, then **all** circles in the Apollonian gasket have integer curvatures! This is the Apollonian gasket's connection to number theory—it's a fractal made entirely of circles with rational radii.</span>
<span id="cb30-527"><a href="#cb30-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-528"><a href="#cb30-528" aria-hidden="true" tabindex="-1"></a>We won't use this formula directly in our shader (we'll set up circles geometrically), but it explains why certain configurations are special and why the patterns are so regular despite infinite nesting.</span>
<span id="cb30-529"><a href="#cb30-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-530"><a href="#cb30-530" aria-hidden="true" tabindex="-1"></a><span class="fu">### Setup: Three Mutually Tangent Circles</span></span>
<span id="cb30-531"><a href="#cb30-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-532"><a href="#cb30-532" aria-hidden="true" tabindex="-1"></a>We start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For this to work, the distance between any two circle centers must be exactly twice the radius (so they touch edge-to-edge). The three centers form an equilateral triangle, and we'll position this triangle symmetrically at the origin:</span>
<span id="cb30-533"><a href="#cb30-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-534"><a href="#cb30-534" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-535"><a href="#cb30-535" aria-hidden="true" tabindex="-1"></a><span class="in">void setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {</span></span>
<span id="cb30-536"><a href="#cb30-536" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 0.5;  // Radius of each inner circle</span></span>
<span id="cb30-537"><a href="#cb30-537" aria-hidden="true" tabindex="-1"></a><span class="in">    // For three circles to be mutually tangent: distance between centers = 2r</span></span>
<span id="cb30-538"><a href="#cb30-538" aria-hidden="true" tabindex="-1"></a><span class="in">    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)</span></span>
<span id="cb30-539"><a href="#cb30-539" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5</span></span>
<span id="cb30-540"><a href="#cb30-540" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-541"><a href="#cb30-541" aria-hidden="true" tabindex="-1"></a><span class="in">    // Three inner circles</span></span>
<span id="cb30-542"><a href="#cb30-542" aria-hidden="true" tabindex="-1"></a><span class="in">    c1 = Circle(vec2(0.0, d), r);</span></span>
<span id="cb30-543"><a href="#cb30-543" aria-hidden="true" tabindex="-1"></a><span class="in">    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2</span></span>
<span id="cb30-544"><a href="#cb30-544" aria-hidden="true" tabindex="-1"></a><span class="in">    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);</span></span>
<span id="cb30-545"><a href="#cb30-545" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-546"><a href="#cb30-546" aria-hidden="true" tabindex="-1"></a><span class="in">    // Outer circle tangent to all three, centered at origin</span></span>
<span id="cb30-547"><a href="#cb30-547" aria-hidden="true" tabindex="-1"></a><span class="in">    float R = d + r;  // ≈ 1.077 for r = 0.5</span></span>
<span id="cb30-548"><a href="#cb30-548" aria-hidden="true" tabindex="-1"></a><span class="in">    outer = Circle(vec2(0.0, 0.0), R);</span></span>
<span id="cb30-549"><a href="#cb30-549" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-550"><a href="#cb30-550" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-551"><a href="#cb30-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-552"><a href="#cb30-552" aria-hidden="true" tabindex="-1"></a>With $r = 0.5$, the circumradius $d \approx 0.577$, and the outer circle has radius $R = d + r \approx 1.077$. All four circles are mutually tangent—each inner circle touches the other two inner circles and the outer circle.</span>
<span id="cb30-553"><a href="#cb30-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-554"><a href="#cb30-554" aria-hidden="true" tabindex="-1"></a>This is just one possible configuration! You could use different radii (related by Descartes' theorem), different arrangements, or even animated circles. The key is that they start mutually tangent—this ensures the iteration creates a proper Apollonian packing.</span>
<span id="cb30-555"><a href="#cb30-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-556"><a href="#cb30-556" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Iteration Algorithm</span></span>
<span id="cb30-557"><a href="#cb30-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-558"><a href="#cb30-558" aria-hidden="true" tabindex="-1"></a>The algorithm is beautifully simple:</span>
<span id="cb30-559"><a href="#cb30-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-560"><a href="#cb30-560" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Start with a point $p$</span>
<span id="cb30-561"><a href="#cb30-561" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Check which circles contain $p$</span>
<span id="cb30-562"><a href="#cb30-562" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>If $p$ is inside a circle, invert through that circle</span>
<span id="cb30-563"><a href="#cb30-563" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Repeat until $p$ is outside all circles or we hit max iterations</span>
<span id="cb30-564"><a href="#cb30-564" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Color based on iteration behavior</span>
<span id="cb30-565"><a href="#cb30-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-566"><a href="#cb30-566" aria-hidden="true" tabindex="-1"></a>Here's the implementation:</span>
<span id="cb30-567"><a href="#cb30-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-568"><a href="#cb30-568" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-569"><a href="#cb30-569" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,</span></span>
<span id="cb30-570"><a href="#cb30-570" aria-hidden="true" tabindex="-1"></a><span class="in">                       int maxIter, out int finalIter, out int lastCircle) {</span></span>
<span id="cb30-571"><a href="#cb30-571" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; maxIter; i++) {</span></span>
<span id="cb30-572"><a href="#cb30-572" aria-hidden="true" tabindex="-1"></a><span class="in">        bool moved = false;</span></span>
<span id="cb30-573"><a href="#cb30-573" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb30-574"><a href="#cb30-574" aria-hidden="true" tabindex="-1"></a><span class="in">        // Check the three inner circles</span></span>
<span id="cb30-575"><a href="#cb30-575" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - c1.center) &lt; c1.radius) {</span></span>
<span id="cb30-576"><a href="#cb30-576" aria-hidden="true" tabindex="-1"></a><span class="in">            p = invertCircle(p, c1.center, c1.radius);</span></span>
<span id="cb30-577"><a href="#cb30-577" aria-hidden="true" tabindex="-1"></a><span class="in">            lastCircle = 0;</span></span>
<span id="cb30-578"><a href="#cb30-578" aria-hidden="true" tabindex="-1"></a><span class="in">            moved = true;</span></span>
<span id="cb30-579"><a href="#cb30-579" aria-hidden="true" tabindex="-1"></a><span class="in">        } </span></span>
<span id="cb30-580"><a href="#cb30-580" aria-hidden="true" tabindex="-1"></a><span class="in">        else if(length(p - c2.center) &lt; c2.radius) {</span></span>
<span id="cb30-581"><a href="#cb30-581" aria-hidden="true" tabindex="-1"></a><span class="in">            p = invertCircle(p, c2.center, c2.radius);</span></span>
<span id="cb30-582"><a href="#cb30-582" aria-hidden="true" tabindex="-1"></a><span class="in">            lastCircle = 1;</span></span>
<span id="cb30-583"><a href="#cb30-583" aria-hidden="true" tabindex="-1"></a><span class="in">            moved = true;</span></span>
<span id="cb30-584"><a href="#cb30-584" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb30-585"><a href="#cb30-585" aria-hidden="true" tabindex="-1"></a><span class="in">        else if(length(p - c3.center) &lt; c3.radius) {</span></span>
<span id="cb30-586"><a href="#cb30-586" aria-hidden="true" tabindex="-1"></a><span class="in">            p = invertCircle(p, c3.center, c3.radius);</span></span>
<span id="cb30-587"><a href="#cb30-587" aria-hidden="true" tabindex="-1"></a><span class="in">            lastCircle = 2;</span></span>
<span id="cb30-588"><a href="#cb30-588" aria-hidden="true" tabindex="-1"></a><span class="in">            moved = true;</span></span>
<span id="cb30-589"><a href="#cb30-589" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb30-590"><a href="#cb30-590" aria-hidden="true" tabindex="-1"></a><span class="in">        // Check if outside the outer circle</span></span>
<span id="cb30-591"><a href="#cb30-591" aria-hidden="true" tabindex="-1"></a><span class="in">        else if(length(p - outer.center) &gt; outer.radius) {</span></span>
<span id="cb30-592"><a href="#cb30-592" aria-hidden="true" tabindex="-1"></a><span class="in">            p = invertCircle(p, outer.center, outer.radius);</span></span>
<span id="cb30-593"><a href="#cb30-593" aria-hidden="true" tabindex="-1"></a><span class="in">            lastCircle = 3;</span></span>
<span id="cb30-594"><a href="#cb30-594" aria-hidden="true" tabindex="-1"></a><span class="in">            moved = true;</span></span>
<span id="cb30-595"><a href="#cb30-595" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb30-596"><a href="#cb30-596" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb30-597"><a href="#cb30-597" aria-hidden="true" tabindex="-1"></a><span class="in">        // If we didn't move, we're in the gaps - done!</span></span>
<span id="cb30-598"><a href="#cb30-598" aria-hidden="true" tabindex="-1"></a><span class="in">        if(!moved) {</span></span>
<span id="cb30-599"><a href="#cb30-599" aria-hidden="true" tabindex="-1"></a><span class="in">            finalIter = i;</span></span>
<span id="cb30-600"><a href="#cb30-600" aria-hidden="true" tabindex="-1"></a><span class="in">            return p;</span></span>
<span id="cb30-601"><a href="#cb30-601" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb30-602"><a href="#cb30-602" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb30-603"><a href="#cb30-603" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-604"><a href="#cb30-604" aria-hidden="true" tabindex="-1"></a><span class="in">    finalIter = maxIter;</span></span>
<span id="cb30-605"><a href="#cb30-605" aria-hidden="true" tabindex="-1"></a><span class="in">    return p;</span></span>
<span id="cb30-606"><a href="#cb30-606" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-607"><a href="#cb30-607" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-608"><a href="#cb30-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-609"><a href="#cb30-609" aria-hidden="true" tabindex="-1"></a>We also track which circle we last inverted through (<span class="in">`lastCircle`</span>) and how many iterations we performed (<span class="in">`finalIter`</span>). These will be useful for coloring!</span>
<span id="cb30-610"><a href="#cb30-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-611"><a href="#cb30-611" aria-hidden="true" tabindex="-1"></a>**Why This Creates a Fractal:** Each time we invert through a circle, we "push" the point away from that circle's center. But because the four circles are mutually tangent, pushing away from one circle might push us into another circle, triggering another inversion. The interplay between these four inversions (three inner circles plus the outer circle) creates a complex orbit.</span>
<span id="cb30-612"><a href="#cb30-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-613"><a href="#cb30-613" aria-hidden="true" tabindex="-1"></a>Points in the "gaps" between the inner circles (the curvilinear triangles) escape quickly—they're inside the outer circle but not inside any inner circle, so no inversion happens. But points near the tangency points get bounced back and forth between circles many times before escaping. And at the actual tangency points (where circles touch), the orbit never escapes—these are fixed points or periodic orbits of the iterated inversions.</span>
<span id="cb30-614"><a href="#cb30-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-615"><a href="#cb30-615" aria-hidden="true" tabindex="-1"></a>The fractal structure emerges because these dynamics are self-similar: zooming in near any tangency point reveals the same pattern of nested circles and gaps. This self-similarity is a direct consequence of the conformal nature of circle inversion—the transformation preserves angles, so local geometry looks the same at all scales.</span>
<span id="cb30-616"><a href="#cb30-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-617"><a href="#cb30-617" aria-hidden="true" tabindex="-1"></a><span class="fu">### Coloring Strategies</span></span>
<span id="cb30-618"><a href="#cb30-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-619"><a href="#cb30-619" aria-hidden="true" tabindex="-1"></a>There are several interesting ways to color the Apollonian gasket:</span>
<span id="cb30-620"><a href="#cb30-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-621"><a href="#cb30-621" aria-hidden="true" tabindex="-1"></a>**By iteration count** (like the Mandelbrot set):</span>
<span id="cb30-622"><a href="#cb30-622" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-623"><a href="#cb30-623" aria-hidden="true" tabindex="-1"></a><span class="in">float t = float(finalIter) / float(maxIter);</span></span>
<span id="cb30-624"><a href="#cb30-624" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = palette(t);</span></span>
<span id="cb30-625"><a href="#cb30-625" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-626"><a href="#cb30-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-627"><a href="#cb30-627" aria-hidden="true" tabindex="-1"></a>This shows the "depth" of the orbit—points that escape quickly are colored differently from points that bounce around many times.</span>
<span id="cb30-628"><a href="#cb30-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-629"><a href="#cb30-629" aria-hidden="true" tabindex="-1"></a>**By last circle hit**:</span>
<span id="cb30-630"><a href="#cb30-630" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-631"><a href="#cb30-631" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 colors[4] = vec3[4](</span></span>
<span id="cb30-632"><a href="#cb30-632" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3(1.0, 0.0, 0.0),  // Circle 1: red</span></span>
<span id="cb30-633"><a href="#cb30-633" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3(0.0, 1.0, 0.0),  // Circle 2: green</span></span>
<span id="cb30-634"><a href="#cb30-634" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3(0.0, 0.0, 1.0),  // Circle 3: blue</span></span>
<span id="cb30-635"><a href="#cb30-635" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3(1.0, 1.0, 0.0)   // Outer circle: yellow</span></span>
<span id="cb30-636"><a href="#cb30-636" aria-hidden="true" tabindex="-1"></a><span class="in">);</span></span>
<span id="cb30-637"><a href="#cb30-637" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = colors[lastCircle];</span></span>
<span id="cb30-638"><a href="#cb30-638" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-639"><a href="#cb30-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-640"><a href="#cb30-640" aria-hidden="true" tabindex="-1"></a>This shows the basin of attraction—which circle's "influence" each point ultimately fell into. Yellow regions show points that escaped through the outer circle.</span>
<span id="cb30-641"><a href="#cb30-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-642"><a href="#cb30-642" aria-hidden="true" tabindex="-1"></a>**By final distance from circles**:</span>
<span id="cb30-643"><a href="#cb30-643" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-644"><a href="#cb30-644" aria-hidden="true" tabindex="-1"></a><span class="in">float d1 = abs(length(p - c1.center) - c1.radius);</span></span>
<span id="cb30-645"><a href="#cb30-645" aria-hidden="true" tabindex="-1"></a><span class="in">float d2 = abs(length(p - c2.center) - c2.radius);</span></span>
<span id="cb30-646"><a href="#cb30-646" aria-hidden="true" tabindex="-1"></a><span class="in">float d3 = abs(length(p - c3.center) - c3.radius);</span></span>
<span id="cb30-647"><a href="#cb30-647" aria-hidden="true" tabindex="-1"></a><span class="in">float d = min(d1, min(d2, d3));</span></span>
<span id="cb30-648"><a href="#cb30-648" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = vec3(smoothstep(0.0, 0.05, d));</span></span>
<span id="cb30-649"><a href="#cb30-649" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-650"><a href="#cb30-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-651"><a href="#cb30-651" aria-hidden="true" tabindex="-1"></a>This highlights the circle boundaries themselves, making the geometric structure more apparent.</span>
<span id="cb30-652"><a href="#cb30-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-653"><a href="#cb30-653" aria-hidden="true" tabindex="-1"></a>Each coloring reveals different aspects of the fractal. Try combining them—for example, color by iteration count but modulate brightness by distance to circles.</span>
<span id="cb30-654"><a href="#cb30-654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-655"><a href="#cb30-655" aria-hidden="true" tabindex="-1"></a><span class="fu">### Putting It All Together</span></span>
<span id="cb30-656"><a href="#cb30-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-657"><a href="#cb30-657" aria-hidden="true" tabindex="-1"></a>Here's a complete Apollonian gasket renderer:</span>
<span id="cb30-658"><a href="#cb30-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-659"><a href="#cb30-659" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-660"><a href="#cb30-660" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb30-661"><a href="#cb30-661" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb30-662"><a href="#cb30-662" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb30-663"><a href="#cb30-663" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb30-664"><a href="#cb30-664" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb30-665"><a href="#cb30-665" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb30-666"><a href="#cb30-666" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb30-667"><a href="#cb30-667" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-668"><a href="#cb30-668" aria-hidden="true" tabindex="-1"></a><span class="in">    // Setup the four circles</span></span>
<span id="cb30-669"><a href="#cb30-669" aria-hidden="true" tabindex="-1"></a><span class="in">    Circle c1, c2, c3, outer;</span></span>
<span id="cb30-670"><a href="#cb30-670" aria-hidden="true" tabindex="-1"></a><span class="in">    setupApollonianCircles(c1, c2, c3, outer);</span></span>
<span id="cb30-671"><a href="#cb30-671" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-672"><a href="#cb30-672" aria-hidden="true" tabindex="-1"></a><span class="in">    // Iterate</span></span>
<span id="cb30-673"><a href="#cb30-673" aria-hidden="true" tabindex="-1"></a><span class="in">    int maxIter = 50;</span></span>
<span id="cb30-674"><a href="#cb30-674" aria-hidden="true" tabindex="-1"></a><span class="in">    int finalIter, lastCircle;</span></span>
<span id="cb30-675"><a href="#cb30-675" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);</span></span>
<span id="cb30-676"><a href="#cb30-676" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-677"><a href="#cb30-677" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color by iteration count with palette</span></span>
<span id="cb30-678"><a href="#cb30-678" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(finalIter) / float(maxIter);</span></span>
<span id="cb30-679"><a href="#cb30-679" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb30-680"><a href="#cb30-680" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-681"><a href="#cb30-681" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw all four circles for reference</span></span>
<span id="cb30-682"><a href="#cb30-682" aria-hidden="true" tabindex="-1"></a><span class="in">    float d1 = abs(length(p - c1.center) - c1.radius);</span></span>
<span id="cb30-683"><a href="#cb30-683" aria-hidden="true" tabindex="-1"></a><span class="in">    float d2 = abs(length(p - c2.center) - c2.radius);</span></span>
<span id="cb30-684"><a href="#cb30-684" aria-hidden="true" tabindex="-1"></a><span class="in">    float d3 = abs(length(p - c3.center) - c3.radius);</span></span>
<span id="cb30-685"><a href="#cb30-685" aria-hidden="true" tabindex="-1"></a><span class="in">    float d_outer = abs(length(p - outer.center) - outer.radius);</span></span>
<span id="cb30-686"><a href="#cb30-686" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = min(min(d1, min(d2, d3)), d_outer);</span></span>
<span id="cb30-687"><a href="#cb30-687" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-688"><a href="#cb30-688" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.02) color = vec3(1.0);  // White circle outlines</span></span>
<span id="cb30-689"><a href="#cb30-689" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-690"><a href="#cb30-690" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb30-691"><a href="#cb30-691" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-692"><a href="#cb30-692" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-693"><a href="#cb30-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-694"><a href="#cb30-694" aria-hidden="true" tabindex="-1"></a>You should see a beautiful nested pattern of circles! The fractal structure is immediately apparent—circles within circles within circles, filling every gap with smaller circles.</span>
<span id="cb30-695"><a href="#cb30-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-696"><a href="#cb30-696" aria-hidden="true" tabindex="-1"></a>Zoom in (by scaling <span class="in">`p`</span> differently in the coordinate setup) to see the self-similarity. No matter how far you zoom, you'll keep finding the same pattern repeated at smaller scales. This is true fractality—infinite detail that never runs out.</span>
<span id="cb30-697"><a href="#cb30-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-698"><a href="#cb30-698" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb30-699"><a href="#cb30-699" aria-hidden="true" tabindex="-1"></a><span class="fu">## Computational Efficiency</span></span>
<span id="cb30-700"><a href="#cb30-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-701"><a href="#cb30-701" aria-hidden="true" tabindex="-1"></a>Despite the complexity of the output, this algorithm is remarkably efficient. Each iteration just checks three distances (cheap) and potentially does one inversion (also cheap—just a few arithmetic operations). With 50 iterations, we're doing maybe 150 distance checks and 50 inversions per pixel.</span>
<span id="cb30-702"><a href="#cb30-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-703"><a href="#cb30-703" aria-hidden="true" tabindex="-1"></a>Compare this to raymarching (Day 4), where we might do hundreds of distance evaluations per pixel! The Apollonian gasket is very GPU-friendly.</span>
<span id="cb30-704"><a href="#cb30-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-705"><a href="#cb30-705" aria-hidden="true" tabindex="-1"></a>The key is that we terminate early—most pixels escape in just a few iterations. Only points near the fractal boundary require many iterations. This is similar to the Mandelbrot set: most of the computational work focuses on the interesting regions (the boundary), while simple regions (deep inside or far outside) are handled quickly.</span>
<span id="cb30-706"><a href="#cb30-706" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-707"><a href="#cb30-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-708"><a href="#cb30-708" aria-hidden="true" tabindex="-1"></a><span class="fu">### Historical Context and Connections</span></span>
<span id="cb30-709"><a href="#cb30-709" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-710"><a href="#cb30-710" aria-hidden="true" tabindex="-1"></a>The Apollonian gasket connects several mathematical threads across millennia:</span>
<span id="cb30-711"><a href="#cb30-711" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-712"><a href="#cb30-712" aria-hidden="true" tabindex="-1"></a>**Ancient roots:** Apollonius of Perga (~200 BCE) studied the problem of constructing circles tangent to three given circles (the "Problem of Apollonius"). He found geometric constructions but couldn't have imagined the infinite fractal structure we're visualizing.</span>
<span id="cb30-713"><a href="#cb30-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-714"><a href="#cb30-714" aria-hidden="true" tabindex="-1"></a>**Renaissance mathematics:** René Descartes (1643) discovered the circle theorem bearing his name, giving an algebraic formula for tangent circles. This turned Apollonius's geometric problem into arithmetic.</span>
<span id="cb30-715"><a href="#cb30-715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-716"><a href="#cb30-716" aria-hidden="true" tabindex="-1"></a>**19th century:** The connection to projective geometry and circle inversions was developed. Mathematicians realized that packing problems could be studied through group theory—the inversions form a discrete subgroup of the group of Möbius transformations.</span>
<span id="cb30-717"><a href="#cb30-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-718"><a href="#cb30-718" aria-hidden="true" tabindex="-1"></a>**20th century:** With computers, the fractal nature became visible. The Apollonian gasket was recognized as a limit set of a Kleinian group—a group of isometries of hyperbolic space. This connects to tomorrow's material: the inversions we're doing are actually hyperbolic isometries! In the Poincaré disk model (which we'll see tomorrow), these inversions are reflections through hyperbolic geodesics.</span>
<span id="cb30-719"><a href="#cb30-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-720"><a href="#cb30-720" aria-hidden="true" tabindex="-1"></a>The gasket also has connections to number theory: if the initial circles have integer curvatures, all circles in the packing do too (by Descartes' theorem). This has led to deep questions about the distribution of integers in these packings, which remain active research areas today.</span>
<span id="cb30-721"><a href="#cb30-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-722"><a href="#cb30-722" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-723"><a href="#cb30-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-724"><a href="#cb30-724" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb30-725"><a href="#cb30-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-726"><a href="#cb30-726" aria-hidden="true" tabindex="-1"></a>Today we've explored two powerful iterative processes that generate fractals:</span>
<span id="cb30-727"><a href="#cb30-727" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-728"><a href="#cb30-728" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Complex dynamics**: The Mandelbrot and Julia sets emerge from iterating $z \mapsto z^2 + c$</span>
<span id="cb30-729"><a href="#cb30-729" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Implemented complex arithmetic in GLSL efficiently</span>
<span id="cb30-730"><a href="#cb30-730" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Learned escape-time algorithms and the crucial escape radius theorem</span>
<span id="cb30-731"><a href="#cb30-731" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Developed smooth coloring techniques for anti-aliased rendering</span>
<span id="cb30-732"><a href="#cb30-732" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Understood the parameter space (Mandelbrot) vs dynamical space (Julia) distinction</span>
<span id="cb30-733"><a href="#cb30-733" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Saw how 1980s computational power revolutionized a 1918 theory</span>
<span id="cb30-734"><a href="#cb30-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-735"><a href="#cb30-735" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Geometric dynamics**: The Apollonian gasket emerges from iterating circle inversions</span>
<span id="cb30-736"><a href="#cb30-736" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Circle inversion as a conformal transformation preserving angles</span>
<span id="cb30-737"><a href="#cb30-737" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Used structs to organize geometric data cleanly</span>
<span id="cb30-738"><a href="#cb30-738" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Applied Descartes Circle Theorem to understand tangent circle configurations</span>
<span id="cb30-739"><a href="#cb30-739" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Iterated inversions through three circles to create fractal patterns</span>
<span id="cb30-740"><a href="#cb30-740" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Connected ancient Greek geometry to modern fractal theory</span>
<span id="cb30-741"><a href="#cb30-741" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-742"><a href="#cb30-742" aria-hidden="true" tabindex="-1"></a>Both processes show how incredibly simple rules—a quadratic map, a geometric transformation—generate infinite complexity through iteration. The key in both cases is **conformality**: angle-preserving maps create geometrically coherent fractals. This is one of the core insights of fractal geometry and dynamical systems.</span>
<span id="cb30-743"><a href="#cb30-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-744"><a href="#cb30-744" aria-hidden="true" tabindex="-1"></a>The computational perspective is also crucial: both algorithms are embarrassingly parallel, making them perfect for GPU rendering. Each pixel's calculation is independent, and we can terminate early when orbits escape. The result is real-time rendering of infinitely detailed mathematical objects.</span>
<span id="cb30-745"><a href="#cb30-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-746"><a href="#cb30-746" aria-hidden="true" tabindex="-1"></a>Tomorrow we'll push geometric iteration further, moving from Euclidean to hyperbolic geometry. The circle inversions we've learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space. We'll explore the upper half-plane and Poincaré disk models, create $(2,3,7)$ and $(2,3,\infty)$ triangle tilings, and see how the same algorithmic ideas (iterated geometric transformations) work in non-Euclidean geometry. The results will be even more intricate because hyperbolic space has "more room" than Euclidean space—triangles can have angle sums less than $\pi$, allowing denser tilings and more complex fractal structures.</span>
<span id="cb30-747"><a href="#cb30-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-748"><a href="#cb30-748" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-749"><a href="#cb30-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-750"><a href="#cb30-750" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb30-751"><a href="#cb30-751" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-752"><a href="#cb30-752" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Julia Set Explorer</span></span>
<span id="cb30-753"><a href="#cb30-753" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-754"><a href="#cb30-754" aria-hidden="true" tabindex="-1"></a>Implement a Julia set renderer starting from the Mandelbrot code. The algorithm is nearly identical—you just need to swap what's fixed and what varies!</span>
<span id="cb30-755"><a href="#cb30-755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-756"><a href="#cb30-756" aria-hidden="true" tabindex="-1"></a>**Requirements:**</span>
<span id="cb30-757"><a href="#cb30-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-758"><a href="#cb30-758" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Start from the Mandelbrot implementation</span>
<span id="cb30-759"><a href="#cb30-759" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Fix <span class="in">`c`</span> to a constant value (see suggestions below)</span>
<span id="cb30-760"><a href="#cb30-760" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Initialize <span class="in">`z`</span> from the pixel position instead of zero</span>
<span id="cb30-761"><a href="#cb30-761" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Iterate $z_{n+1} = z_n^2 + c$ exactly as before</span>
<span id="cb30-762"><a href="#cb30-762" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Use the same escape criterion and coloring</span>
<span id="cb30-763"><a href="#cb30-763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-764"><a href="#cb30-764" aria-hidden="true" tabindex="-1"></a>**Suggested structure:**</span>
<span id="cb30-765"><a href="#cb30-765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-766"><a href="#cb30-766" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-767"><a href="#cb30-767" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb30-768"><a href="#cb30-768" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb30-769"><a href="#cb30-769" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb30-770"><a href="#cb30-770" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb30-771"><a href="#cb30-771" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb30-772"><a href="#cb30-772" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb30-773"><a href="#cb30-773" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 3.0;  // Scale for Julia set viewing</span></span>
<span id="cb30-774"><a href="#cb30-774" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-775"><a href="#cb30-775" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fix c to an interesting value</span></span>
<span id="cb30-776"><a href="#cb30-776" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c = vec2(-0.7, 0.27015);  // Classic Julia set</span></span>
<span id="cb30-777"><a href="#cb30-777" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-778"><a href="#cb30-778" aria-hidden="true" tabindex="-1"></a><span class="in">    // Initialize z from pixel position (this is the key change!)</span></span>
<span id="cb30-779"><a href="#cb30-779" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = p;  // z_0 = pixel position</span></span>
<span id="cb30-780"><a href="#cb30-780" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-781"><a href="#cb30-781" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Rest of iteration exactly like Mandelbrot]</span></span>
<span id="cb30-782"><a href="#cb30-782" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-783"><a href="#cb30-783" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-784"><a href="#cb30-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-785"><a href="#cb30-785" aria-hidden="true" tabindex="-1"></a>**Interesting parameters to try:**</span>
<span id="cb30-786"><a href="#cb30-786" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.7, 0.27015)`</span> — classic Julia set, intricate tendrils</span>
<span id="cb30-787"><a href="#cb30-787" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.4, 0.6)`</span> — dendrite-like fractal trees  </span>
<span id="cb30-788"><a href="#cb30-788" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(0.285, 0.01)`</span> — beautiful spiral patterns</span>
<span id="cb30-789"><a href="#cb30-789" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.8, 0.156)`</span> — highly filamentary structure</span>
<span id="cb30-790"><a href="#cb30-790" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.70176, -0.3842)`</span> — "San Marco dragon"</span>
<span id="cb30-791"><a href="#cb30-791" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.835, -0.2321)`</span> — another classic</span>
<span id="cb30-792"><a href="#cb30-792" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`vec2(-0.7269, 0.1889)`</span> — "Douady's rabbit" (famous example)</span>
<span id="cb30-793"><a href="#cb30-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-794"><a href="#cb30-794" aria-hidden="true" tabindex="-1"></a>**Extension Options (pick one or both):**</span>
<span id="cb30-795"><a href="#cb30-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-796"><a href="#cb30-796" aria-hidden="true" tabindex="-1"></a>**Option A: Animated Parameter Space**</span>
<span id="cb30-797"><a href="#cb30-797" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-798"><a href="#cb30-798" aria-hidden="true" tabindex="-1"></a>Make $c$ depend on time to watch the Julia set morph:</span>
<span id="cb30-799"><a href="#cb30-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-800"><a href="#cb30-800" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-801"><a href="#cb30-801" aria-hidden="true" tabindex="-1"></a><span class="in">float angle = iTime * 0.3;</span></span>
<span id="cb30-802"><a href="#cb30-802" aria-hidden="true" tabindex="-1"></a><span class="in">float radius = 0.7885;  // Distance from origin in parameter space</span></span>
<span id="cb30-803"><a href="#cb30-803" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 c = vec2(radius * cos(angle), radius * sin(angle));</span></span>
<span id="cb30-804"><a href="#cb30-804" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-805"><a href="#cb30-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-806"><a href="#cb30-806" aria-hidden="true" tabindex="-1"></a>Watch how the Julia set changes topology as you trace a circle in the complex plane! You'll see it transition from connected to disconnected, develop tendrils, and create organic shapes.</span>
<span id="cb30-807"><a href="#cb30-807" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-808"><a href="#cb30-808" aria-hidden="true" tabindex="-1"></a>**Option B: Mouse-Controlled Exploration**</span>
<span id="cb30-809"><a href="#cb30-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-810"><a href="#cb30-810" aria-hidden="true" tabindex="-1"></a>Tie $c$ to mouse position for interactive exploration:</span>
<span id="cb30-811"><a href="#cb30-811" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-812"><a href="#cb30-812" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-813"><a href="#cb30-813" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;</span></span>
<span id="cb30-814"><a href="#cb30-814" aria-hidden="true" tabindex="-1"></a><span class="in">mouse_uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb30-815"><a href="#cb30-815" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 c = mouse_uv * 3.0;  // Scale to cover interesting parameter range</span></span>
<span id="cb30-816"><a href="#cb30-816" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-817"><a href="#cb30-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-818"><a href="#cb30-818" aria-hidden="true" tabindex="-1"></a>Now you can explore parameter space by moving the mouse! This really helps build intuition for how $c$ affects the Julia set. Try finding the boundary of the Mandelbrot set—parameters right at the edge produce the most intricate Julia sets.</span>
<span id="cb30-819"><a href="#cb30-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-820"><a href="#cb30-820" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb30-821"><a href="#cb30-821" aria-hidden="true" tabindex="-1"></a><span class="fu">## Understanding Connected vs Disconnected</span></span>
<span id="cb30-822"><a href="#cb30-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-823"><a href="#cb30-823" aria-hidden="true" tabindex="-1"></a>As you explore parameter space, pay attention to whether the Julia set appears as a single connected structure or as disconnected dust. Values of $c$ inside the Mandelbrot set give connected Julia sets, while values outside give disconnected ones. The most beautiful Julia sets often come from values right near the boundary of $\mathcal{M}$!</span>
<span id="cb30-824"><a href="#cb30-824" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb30-825"><a href="#cb30-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-826"><a href="#cb30-826" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-827"><a href="#cb30-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-828"><a href="#cb30-828" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #1: Grid of Julia Sets</span></span>
<span id="cb30-829"><a href="#cb30-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-830"><a href="#cb30-830" aria-hidden="true" tabindex="-1"></a>Create a grid where each cell shows the Julia set for that value of $c$, revealing the Mandelbrot set as an emergent pattern!</span>
<span id="cb30-831"><a href="#cb30-831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-832"><a href="#cb30-832" aria-hidden="true" tabindex="-1"></a>**The idea:** The Mandelbrot set is a map of Julia set topology. If we draw a grid of Julia sets for different values of $c$, we should see the Mandelbrot set emerge in the overall pattern—cells with connected Julia sets (solid regions) correspond to points in $\mathcal{M}$, while cells with disconnected Julia sets (dust) are outside.</span>
<span id="cb30-833"><a href="#cb30-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-834"><a href="#cb30-834" aria-hidden="true" tabindex="-1"></a>**Implementation strategy:**</span>
<span id="cb30-835"><a href="#cb30-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-836"><a href="#cb30-836" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-837"><a href="#cb30-837" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb30-838"><a href="#cb30-838" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb30-839"><a href="#cb30-839" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb30-840"><a href="#cb30-840" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb30-841"><a href="#cb30-841" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb30-842"><a href="#cb30-842" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb30-843"><a href="#cb30-843" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb30-844"><a href="#cb30-844" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-845"><a href="#cb30-845" aria-hidden="true" tabindex="-1"></a><span class="in">    // Divide screen into grid cells</span></span>
<span id="cb30-846"><a href="#cb30-846" aria-hidden="true" tabindex="-1"></a><span class="in">    float grid_size = 8.0;  // 8×8 grid of Julia sets</span></span>
<span id="cb30-847"><a href="#cb30-847" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_id = floor(p * grid_size / 4.0);</span></span>
<span id="cb30-848"><a href="#cb30-848" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;</span></span>
<span id="cb30-849"><a href="#cb30-849" aria-hidden="true" tabindex="-1"></a><span class="in">    cell_p *= 4.0;  // Local coordinates within cell</span></span>
<span id="cb30-850"><a href="#cb30-850" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-851"><a href="#cb30-851" aria-hidden="true" tabindex="-1"></a><span class="in">    // Map cell_id to parameter c</span></span>
<span id="cb30-852"><a href="#cb30-852" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 c = (cell_id / grid_size) * 4.0 - vec2(2.5, 2.0);</span></span>
<span id="cb30-853"><a href="#cb30-853" aria-hidden="true" tabindex="-1"></a><span class="in">    c.x -= 0.5;  // Center on interesting region of Mandelbrot set</span></span>
<span id="cb30-854"><a href="#cb30-854" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-855"><a href="#cb30-855" aria-hidden="true" tabindex="-1"></a><span class="in">    // Run Julia set iteration with z = cell_p, fixed c</span></span>
<span id="cb30-856"><a href="#cb30-856" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = cell_p;</span></span>
<span id="cb30-857"><a href="#cb30-857" aria-hidden="true" tabindex="-1"></a><span class="in">    int max_iter = 50;</span></span>
<span id="cb30-858"><a href="#cb30-858" aria-hidden="true" tabindex="-1"></a><span class="in">    int iter;</span></span>
<span id="cb30-859"><a href="#cb30-859" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-860"><a href="#cb30-860" aria-hidden="true" tabindex="-1"></a><span class="in">    for(iter = 0; iter &lt; max_iter; iter++) {</span></span>
<span id="cb30-861"><a href="#cb30-861" aria-hidden="true" tabindex="-1"></a><span class="in">        if(cabs2(z) &gt; 4.0) break;</span></span>
<span id="cb30-862"><a href="#cb30-862" aria-hidden="true" tabindex="-1"></a><span class="in">        z = cmul(z, z) + c;</span></span>
<span id="cb30-863"><a href="#cb30-863" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb30-864"><a href="#cb30-864" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-865"><a href="#cb30-865" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color</span></span>
<span id="cb30-866"><a href="#cb30-866" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(iter) / float(max_iter);</span></span>
<span id="cb30-867"><a href="#cb30-867" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb30-868"><a href="#cb30-868" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-869"><a href="#cb30-869" aria-hidden="true" tabindex="-1"></a><span class="in">    // Optional: draw grid lines to separate cells</span></span>
<span id="cb30-870"><a href="#cb30-870" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);</span></span>
<span id="cb30-871"><a href="#cb30-871" aria-hidden="true" tabindex="-1"></a><span class="in">    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);</span></span>
<span id="cb30-872"><a href="#cb30-872" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb30-873"><a href="#cb30-873" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb30-874"><a href="#cb30-874" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-875"><a href="#cb30-875" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-876"><a href="#cb30-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-877"><a href="#cb30-877" aria-hidden="true" tabindex="-1"></a>You should see a grid of tiny Julia sets! If you look carefully at the overall pattern, you'll notice it resembles the Mandelbrot set—cells with connected Julia sets (solid colored regions) correspond to points inside $\mathcal{M}$, while cells with disconnected Julia sets (fine dust patterns) are outside.</span>
<span id="cb30-878"><a href="#cb30-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-879"><a href="#cb30-879" aria-hidden="true" tabindex="-1"></a>This is one of the most beautiful visualizations in complex dynamics—the Mandelbrot set literally encodes the topology of all Julia sets!</span>
<span id="cb30-880"><a href="#cb30-880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-881"><a href="#cb30-881" aria-hidden="true" tabindex="-1"></a>**Variations to try:**</span>
<span id="cb30-882"><a href="#cb30-882" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Adjust <span class="in">`grid_size`</span> (larger for more detail, smaller for clearer overview)</span>
<span id="cb30-883"><a href="#cb30-883" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Change the parameter space region being sampled</span>
<span id="cb30-884"><a href="#cb30-884" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Color cells based on whether the Julia set appears connected (black) or disconnected (white)—you'll get a pixelated approximation of the Mandelbrot set!</span>
<span id="cb30-885"><a href="#cb30-885" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-886"><a href="#cb30-886" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-887"><a href="#cb30-887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-888"><a href="#cb30-888" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #2: Other Iterated Inversions</span></span>
<span id="cb30-889"><a href="#cb30-889" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-890"><a href="#cb30-890" aria-hidden="true" tabindex="-1"></a>Explore variations on the Apollonian gasket theme! The key is setting up circles in interesting configurations and iterating inversions.</span>
<span id="cb30-891"><a href="#cb30-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-892"><a href="#cb30-892" aria-hidden="true" tabindex="-1"></a>**Different circle arrangements:**</span>
<span id="cb30-893"><a href="#cb30-893" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-894"><a href="#cb30-894" aria-hidden="true" tabindex="-1"></a>**Four circles in a square:**</span>
<span id="cb30-895"><a href="#cb30-895" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-896"><a href="#cb30-896" aria-hidden="true" tabindex="-1"></a><span class="in">void setupSquareCircles(out Circle c1, out Circle c2, out Circle c3, out Circle c4) {</span></span>
<span id="cb30-897"><a href="#cb30-897" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 0.5;</span></span>
<span id="cb30-898"><a href="#cb30-898" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = 1.5;  // Distance from center</span></span>
<span id="cb30-899"><a href="#cb30-899" aria-hidden="true" tabindex="-1"></a><span class="in">    c1 = Circle(vec2(d, 0.0), r);</span></span>
<span id="cb30-900"><a href="#cb30-900" aria-hidden="true" tabindex="-1"></a><span class="in">    c2 = Circle(vec2(0.0, d), r);</span></span>
<span id="cb30-901"><a href="#cb30-901" aria-hidden="true" tabindex="-1"></a><span class="in">    c3 = Circle(vec2(-d, 0.0), r);</span></span>
<span id="cb30-902"><a href="#cb30-902" aria-hidden="true" tabindex="-1"></a><span class="in">    c4 = Circle(vec2(0.0, -d), r);</span></span>
<span id="cb30-903"><a href="#cb30-903" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-904"><a href="#cb30-904" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-905"><a href="#cb30-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-906"><a href="#cb30-906" aria-hidden="true" tabindex="-1"></a>Modify the iteration loop to check four circles instead of three!</span>
<span id="cb30-907"><a href="#cb30-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-908"><a href="#cb30-908" aria-hidden="true" tabindex="-1"></a>**Nested circles:**</span>
<span id="cb30-909"><a href="#cb30-909" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-910"><a href="#cb30-910" aria-hidden="true" tabindex="-1"></a><span class="in">// One large circle containing several smaller ones</span></span>
<span id="cb30-911"><a href="#cb30-911" aria-hidden="true" tabindex="-1"></a><span class="in">c1 = Circle(vec2(0.0, 0.0), 2.0);  // Large outer circle</span></span>
<span id="cb30-912"><a href="#cb30-912" aria-hidden="true" tabindex="-1"></a><span class="in">c2 = Circle(vec2(-0.5, 0.0), 0.4);  // Small inner circles</span></span>
<span id="cb30-913"><a href="#cb30-913" aria-hidden="true" tabindex="-1"></a><span class="in">c3 = Circle(vec2(0.5, 0.0), 0.4);</span></span>
<span id="cb30-914"><a href="#cb30-914" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-915"><a href="#cb30-915" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-916"><a href="#cb30-916" aria-hidden="true" tabindex="-1"></a>**Animated radii:**</span>
<span id="cb30-917"><a href="#cb30-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-918"><a href="#cb30-918" aria-hidden="true" tabindex="-1"></a>Make the circles pulse:</span>
<span id="cb30-919"><a href="#cb30-919" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-920"><a href="#cb30-920" aria-hidden="true" tabindex="-1"></a><span class="in">c1.radius = 0.5 + 0.2 * sin(iTime);</span></span>
<span id="cb30-921"><a href="#cb30-921" aria-hidden="true" tabindex="-1"></a><span class="in">c2.radius = 0.5 + 0.2 * sin(iTime + 2.0 * 3.14159 / 3.0);</span></span>
<span id="cb30-922"><a href="#cb30-922" aria-hidden="true" tabindex="-1"></a><span class="in">c3.radius = 0.5 + 0.2 * sin(iTime + 4.0 * 3.14159 / 3.0);</span></span>
<span id="cb30-923"><a href="#cb30-923" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-924"><a href="#cb30-924" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-925"><a href="#cb30-925" aria-hidden="true" tabindex="-1"></a>Watch the fractal breathe!</span>
<span id="cb30-926"><a href="#cb30-926" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-927"><a href="#cb30-927" aria-hidden="true" tabindex="-1"></a>**Alternating inversion patterns:**</span>
<span id="cb30-928"><a href="#cb30-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-929"><a href="#cb30-929" aria-hidden="true" tabindex="-1"></a>Instead of inverting through whichever circle contains the point, try a fixed cycling pattern:</span>
<span id="cb30-930"><a href="#cb30-930" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-931"><a href="#cb30-931" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb30-932"><a href="#cb30-932" aria-hidden="true" tabindex="-1"></a><span class="in">// Cycle through circles in order</span></span>
<span id="cb30-933"><a href="#cb30-933" aria-hidden="true" tabindex="-1"></a><span class="in">int circle_index = i % 3;</span></span>
<span id="cb30-934"><a href="#cb30-934" aria-hidden="true" tabindex="-1"></a><span class="in">if(circle_index == 0) {</span></span>
<span id="cb30-935"><a href="#cb30-935" aria-hidden="true" tabindex="-1"></a><span class="in">    p = invertCircle(p, c1.center, c1.radius);</span></span>
<span id="cb30-936"><a href="#cb30-936" aria-hidden="true" tabindex="-1"></a><span class="in">} else if(circle_index == 1) {</span></span>
<span id="cb30-937"><a href="#cb30-937" aria-hidden="true" tabindex="-1"></a><span class="in">    p = invertCircle(p, c2.center, c2.radius);</span></span>
<span id="cb30-938"><a href="#cb30-938" aria-hidden="true" tabindex="-1"></a><span class="in">} else {</span></span>
<span id="cb30-939"><a href="#cb30-939" aria-hidden="true" tabindex="-1"></a><span class="in">    p = invertCircle(p, c3.center, c3.radius);</span></span>
<span id="cb30-940"><a href="#cb30-940" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb30-941"><a href="#cb30-941" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb30-942"><a href="#cb30-942" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-943"><a href="#cb30-943" aria-hidden="true" tabindex="-1"></a>This creates very different patterns—more regular and less space-filling than the gasket, but with interesting self-similarity.</span>
<span id="cb30-944"><a href="#cb30-944" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-945"><a href="#cb30-945" aria-hidden="true" tabindex="-1"></a>**Challenge problems:**</span>
<span id="cb30-946"><a href="#cb30-946" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Can you create a configuration that tiles the plane with circular patterns?</span>
<span id="cb30-947"><a href="#cb30-947" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>What about spiraling structures?</span>
<span id="cb30-948"><a href="#cb30-948" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Can you make a fractal that's asymmetric (not rotationally symmetric)?</span>
<span id="cb30-949"><a href="#cb30-949" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Try combining inversion with other transformations (rotation, scaling)</span>
<span id="cb30-950"><a href="#cb30-950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-951"><a href="#cb30-951" aria-hidden="true" tabindex="-1"></a>The key is experimentation—try different setups and see what emerges!</span>
<span id="cb30-952"><a href="#cb30-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-953"><a href="#cb30-953" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb30-954"><a href="#cb30-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-955"><a href="#cb30-955" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking Ahead</span></span>
<span id="cb30-956"><a href="#cb30-956" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-957"><a href="#cb30-957" aria-hidden="true" tabindex="-1"></a>Tomorrow we continue with geometric transformations, but move from Euclidean to **hyperbolic geometry**. The circle inversions you've learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space!</span>
<span id="cb30-958"><a href="#cb30-958" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-959"><a href="#cb30-959" aria-hidden="true" tabindex="-1"></a>We'll explore:</span>
<span id="cb30-960"><a href="#cb30-960" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Multiple models** of the hyperbolic plane (upper half-plane, Poincaré disk)</span>
<span id="cb30-961"><a href="#cb30-961" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Geodesics** (straight lines in hyperbolic geometry—they look like circles in our Euclidean view!)</span>
<span id="cb30-962"><a href="#cb30-962" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Triangle tilings** with $(2,3,7)$ and $(2,3,\infty)$ symmetry groups</span>
<span id="cb30-963"><a href="#cb30-963" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Why hyperbolic space is different**: triangles with angle sum less than $\pi$, exponential growth of area</span>
<span id="cb30-964"><a href="#cb30-964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-965"><a href="#cb30-965" aria-hidden="true" tabindex="-1"></a>The same algorithmic ideas we've used today (iterated geometric transformations, escape-time coloring, distance-based rendering) will work in hyperbolic space. But the results will be even more intricate because hyperbolic space has "more room" than Euclidean space—allowing denser tilings and more complex fractal structures.</span>
<span id="cb30-966"><a href="#cb30-966" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-967"><a href="#cb30-967" aria-hidden="true" tabindex="-1"></a>Make sure you're comfortable with:</span>
<span id="cb30-968"><a href="#cb30-968" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Iteration and escape-time algorithms** (we'll use similar ideas for tiling)</span>
<span id="cb30-969"><a href="#cb30-969" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Circle inversion** (this becomes reflection through hyperbolic geodesics!)</span>
<span id="cb30-970"><a href="#cb30-970" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Structs** for organizing geometric data</span>
<span id="cb30-971"><a href="#cb30-971" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Coloring strategies** based on orbit behavior</span>
<span id="cb30-972"><a href="#cb30-972" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-973"><a href="#cb30-973" aria-hidden="true" tabindex="-1"></a>See you tomorrow!</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>