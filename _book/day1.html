<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Day 1: Introduction to Shader Programming – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./day2.html" rel="next">
<link href="./outline.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-597958c53c93a607afca12fd375c57ed.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-7ac2f9da8c2617a4fdd15004b4601015.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-597958c53c93a607afca12fd375c57ed.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e192c2ce351653e2d082fb362f7b7010.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-716a622b51d344c68734a98b9754e0e5.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-e192c2ce351653e2d082fb362f7b7010.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./day1.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/yourusername/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 1</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 2</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">1.1</span> Overview</a></li>
  <li><a href="#what-is-a-shader" id="toc-what-is-a-shader" class="nav-link" data-scroll-target="#what-is-a-shader"><span class="header-section-number">1.2</span> What is a Shader?</a>
  <ul class="collapse">
  <li><a href="#mathematical-perspective" id="toc-mathematical-perspective" class="nav-link" data-scroll-target="#mathematical-perspective">Mathematical Perspective</a></li>
  <li><a href="#why-shadertoy" id="toc-why-shadertoy" class="nav-link" data-scroll-target="#why-shadertoy">Why Shadertoy?</a></li>
  </ul></li>
  <li><a href="#first-shader-solid-colors" id="toc-first-shader-solid-colors" class="nav-link" data-scroll-target="#first-shader-solid-colors"><span class="header-section-number">1.3</span> First Shader: Solid Colors</a>
  <ul class="collapse">
  <li><a href="#basic-structure" id="toc-basic-structure" class="nav-link" data-scroll-target="#basic-structure">Basic Structure</a></li>
  <li><a href="#example-red-screen" id="toc-example-red-screen" class="nav-link" data-scroll-target="#example-red-screen">Example: Red Screen</a></li>
  <li><a href="#glsl-syntax-basics" id="toc-glsl-syntax-basics" class="nav-link" data-scroll-target="#glsl-syntax-basics">GLSL Syntax Basics</a></li>
  <li><a href="#animating-with-time" id="toc-animating-with-time" class="nav-link" data-scroll-target="#animating-with-time">Animating with Time</a></li>
  </ul></li>
  <li><a href="#coordinate-systems" id="toc-coordinate-systems" class="nav-link" data-scroll-target="#coordinate-systems"><span class="header-section-number">1.4</span> Coordinate Systems</a>
  <ul class="collapse">
  <li><a href="#raw-coordinates" id="toc-raw-coordinates" class="nav-link" data-scroll-target="#raw-coordinates">Raw Coordinates</a></li>
  <li><a href="#centered-normalized-coordinates" id="toc-centered-normalized-coordinates" class="nav-link" data-scroll-target="#centered-normalized-coordinates">Centered, Normalized Coordinates</a></li>
  <li><a href="#visualizing-coordinates" id="toc-visualizing-coordinates" class="nav-link" data-scroll-target="#visualizing-coordinates">Visualizing Coordinates</a></li>
  </ul></li>
  <li><a href="#conditional-coloring-half-planes" id="toc-conditional-coloring-half-planes" class="nav-link" data-scroll-target="#conditional-coloring-half-planes"><span class="header-section-number">1.5</span> Conditional Coloring: Half-Planes</a>
  <ul class="collapse">
  <li><a href="#the-concept" id="toc-the-concept" class="nav-link" data-scroll-target="#the-concept">The Concept</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  <li><a href="#the-step-function" id="toc-the-step-function" class="nav-link" data-scroll-target="#the-step-function">The Step Function</a></li>
  <li><a href="#arbitrary-half-planes" id="toc-arbitrary-half-planes" class="nav-link" data-scroll-target="#arbitrary-half-planes">Arbitrary Half-Planes</a></li>
  </ul></li>
  <li><a href="#distance-fields-and-circles" id="toc-distance-fields-and-circles" class="nav-link" data-scroll-target="#distance-fields-and-circles"><span class="header-section-number">1.6</span> Distance Fields and Circles</a>
  <ul class="collapse">
  <li><a href="#distance-to-center" id="toc-distance-to-center" class="nav-link" data-scroll-target="#distance-to-center">Distance to Center</a></li>
  <li><a href="#filled-circle" id="toc-filled-circle" class="nav-link" data-scroll-target="#filled-circle">Filled Circle</a></li>
  <li><a href="#distance-based-coloring" id="toc-distance-based-coloring" class="nav-link" data-scroll-target="#distance-based-coloring">Distance-Based Coloring</a></li>
  <li><a href="#circle-outline" id="toc-circle-outline" class="nav-link" data-scroll-target="#circle-outline">Circle Outline</a></li>
  </ul></li>
  <li><a href="#grids-and-repetition" id="toc-grids-and-repetition" class="nav-link" data-scroll-target="#grids-and-repetition"><span class="header-section-number">1.7</span> Grids and Repetition</a>
  <ul class="collapse">
  <li><a href="#modular-arithmetic" id="toc-modular-arithmetic" class="nav-link" data-scroll-target="#modular-arithmetic">Modular Arithmetic</a></li>
  <li><a href="#creating-a-grid" id="toc-creating-a-grid" class="nav-link" data-scroll-target="#creating-a-grid">Creating a Grid</a></li>
  <li><a href="#alternating-pattern" id="toc-alternating-pattern" class="nav-link" data-scroll-target="#alternating-pattern">Alternating Pattern</a></li>
  <li><a href="#combining-with-circles" id="toc-combining-with-circles" class="nav-link" data-scroll-target="#combining-with-circles">Combining with Circles</a></li>
  </ul></li>
  <li><a href="#implicit-curves" id="toc-implicit-curves" class="nav-link" data-scroll-target="#implicit-curves"><span class="header-section-number">1.8</span> Implicit Curves</a>
  <ul class="collapse">
  <li><a href="#general-principle" id="toc-general-principle" class="nav-link" data-scroll-target="#general-principle">General Principle</a></li>
  <li><a href="#example-parabola" id="toc-example-parabola" class="nav-link" data-scroll-target="#example-parabola">Example: Parabola</a></li>
  <li><a href="#example-circle-implicit-form" id="toc-example-circle-implicit-form" class="nav-link" data-scroll-target="#example-circle-implicit-form">Example: Circle (Implicit Form)</a></li>
  <li><a href="#more-examples" id="toc-more-examples" class="nav-link" data-scroll-target="#more-examples">More Examples</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">1.9</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">1.10</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-parabola-graphing-calculator" id="toc-required-parabola-graphing-calculator" class="nav-link" data-scroll-target="#required-parabola-graphing-calculator">Required: Parabola Graphing Calculator</a></li>
  <li><a href="#optional-1-animated-curve-family" id="toc-optional-1-animated-curve-family" class="nav-link" data-scroll-target="#optional-1-animated-curve-family">Optional #1: Animated Curve Family</a></li>
  <li><a href="#optional-2-beautiful-tiling-pattern" id="toc-optional-2-beautiful-tiling-pattern" class="nav-link" data-scroll-target="#optional-2-beautiful-tiling-pattern">Optional #2: Beautiful Tiling Pattern</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">1.11</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">1.1</span> Overview</h2>
<p>Today we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.</p>
<p>By the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Roadmap for Today
</div>
</div>
<div class="callout-body-container callout-body">
<p>We’ll build up shader programming in layers:</p>
<ol type="1">
<li><strong>Core concept</strong>: Shaders as parallel functions (What is a Shader?)</li>
<li><strong>Setup</strong>: Coordinate systems and GLSL syntax (First Shader, Coordinate Systems)</li>
<li><strong>Basic techniques</strong>: Conditional coloring and distance fields (Half-Planes, Distance Fields)<br>
</li>
<li><strong>Repetition</strong>: Grids via modular arithmetic (Grids and Repetition)</li>
<li><strong>Application</strong>: Implicit curves (Implicit Curves)</li>
</ol>
<p>Each section builds on the previous, so if something feels unclear, it’s worth revisiting earlier material before moving forward.</p>
</div>
</div>
<hr>
</section>
<section id="what-is-a-shader" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="what-is-a-shader"><span class="header-section-number">1.2</span> What is a Shader?</h2>
<section id="mathematical-perspective" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-perspective">Mathematical Perspective</h3>
<p>A shader is fundamentally a function <span class="math display">\[f: \mathbb{R}^2 \times \mathbb{R} \times \cdots \to [0,1]^4\]</span> that maps pixel coordinates <span class="math inline">\((x,y)\)</span>, time <span class="math inline">\(t\)</span>, and potentially other parameters to RGBA color values. For today, we’ll focus on the spatial dependence—thinking of the shader as a function <span class="math inline">\(f: \mathbb{R}^2 \to [0,1]^4\)</span> that assigns a color to each point in the plane. The domain <span class="math inline">\([0,1]^4\)</span> represents the red, green, blue, and alpha (transparency) channels, each normalized to the unit interval.</p>
<p>Here’s the magic: modern GPUs can evaluate this function for <strong>all pixels simultaneously</strong>. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!</p>
<p>This is completely different from how you might write mathematical visualization code in, say, Python or MATLAB. There you’d have nested loops:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(width):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(height):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        color[x,y] <span class="op">=</span> f(x, y)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>With shaders, there are no loops. You write the function <span class="math inline">\(f\)</span>, and the GPU just <em>does it</em> everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.</p>
<p>The computational model is fundamentally different: in traditional CPU programming you have sequential control flow with explicit loops, while in shader programming you express computation as a pure mathematical function that gets evaluated independently at every pixel. The GPU architecture is specifically designed for this kind of massively parallel workload—it has thousands of small processors that can each evaluate your function simultaneously. This is why a relatively modest GPU can outperform even a powerful CPU on graphics tasks by orders of magnitude.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Why is this called a “shader”?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Historically, these programs were used for <em>shading</em> 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!</p>
</div>
</div>
</section>
<section id="why-shadertoy" class="level3">
<h3 class="anchored" data-anchor-id="why-shadertoy">Why Shadertoy?</h3>
<p>Shadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.</p>
<p>Shadertoy launched in 2013, created by Pol Jeremias-Vila and Íñigo Quílez (we’ll see more of Íñigo’s work throughout this week—he’s pioneered many shader techniques). Before platforms like Shadertoy, shader programming required managing the entire OpenGL or DirectX pipeline yourself—compiling shaders, linking programs, setting up vertex buffers, managing textures. It was the domain of graphics programmers, not mathematicians.</p>
<p>The genius of Shadertoy was recognizing that for many visualizations, you don’t need that complexity. Just give people a function to fill in, handle the boilerplate invisibly, and suddenly shaders become accessible to anyone. It’s democratized GPU programming in much the same way that Python notebooks democratized scientific computing—lower the barrier to entry, and a whole new community emerges.</p>
<p>The platform provides several built-in <strong>uniforms</strong> (read-only global variables that are the same for all pixels):</p>
<ul>
<li><code>iResolution</code>: screen resolution as a <code>vec3</code> (width, height, pixel aspect ratio)</li>
<li><code>iTime</code>: elapsed time in seconds since the shader started</li>
<li><code>iMouse</code>: mouse position and click state as a <code>vec4</code></li>
</ul>
<p>We’ll use these throughout the week to create animated, interactive mathematical visualizations.</p>
<hr>
</section>
</section>
<section id="first-shader-solid-colors" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="first-shader-solid-colors"><span class="header-section-number">1.3</span> First Shader: Solid Colors</h2>
<section id="basic-structure" class="level3">
<h3 class="anchored" data-anchor-id="basic-structure">Basic Structure</h3>
<p>Every Shadertoy shader has the same entry point:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Your code here</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fragCoord</code>: the pixel coordinate we’re currently computing, as a <code>vec2</code> giving the <span class="math inline">\((x, y)\)</span> position</li>
<li><code>fragColor</code>: the output color we need to set, as a <code>vec4</code> giving the <span class="math inline">\((r, g, b, a)\)</span> color</li>
</ul>
<p>Colors are represented in RGBA format with values in <span class="math inline">\([0, 1]\)</span>. So <code>vec4(1.0, 0.0, 0.0, 1.0)</code> represents opaque red, while <code>vec4(0.5, 0.5, 0.5, 1.0)</code> is middle gray.</p>
</section>
<section id="example-red-screen" class="level3">
<h3 class="anchored" data-anchor-id="example-red-screen">Example: Red Screen</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on <code>fragCoord</code>, every pixel gets the same value. Not very exciting—but it’s a start!</p>
</section>
<section id="glsl-syntax-basics" class="level3">
<h3 class="anchored" data-anchor-id="glsl-syntax-basics">GLSL Syntax Basics</h3>
<p>Before we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>GLSL Syntax Rules
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Semicolons are required.</strong> Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.</p>
<p><strong>Floating point literals:</strong> Write <code>1.0</code> not <code>1</code> for floating point values. GLSL is very picky about types—if you write <code>1</code>, it’s an integer, and mixing types causes errors. Get in the habit of always writing the <code>.0</code>.</p>
<p><strong>Vector types:</strong> GLSL has built-in types <code>vec2</code>, <code>vec3</code>, <code>vec4</code> for 2D, 3D, and 4D vectors. You can construct them with:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> w <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec4</span> color <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>v<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Can combine vectors and scalars</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Swizzling:</strong> You can access components by name: <code>v.x</code>, <code>v.y</code> or equivalently <code>v.r</code>, <code>v.g</code> (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: <code>v.yx</code> swaps the coordinates, <code>v.xxx</code> repeats the x-component three times. This is incredibly useful!</p>
</div>
</div>
</section>
<section id="animating-with-time" class="level3">
<h3 class="anchored" data-anchor-id="animating-with-time">Animating with Time</h3>
<p>Let’s make something that changes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> red <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>red<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>iTime</code> grows continuously, <code>sin(iTime)</code> oscillates between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>, and we remap this to <span class="math inline">\([0, 1]\)</span> with the affine transformation <span class="math inline">\(t \mapsto \frac{1}{2}(1 + t)\)</span>. The screen now pulses between black and red!</p>
<p>This pattern—<code>0.5 + 0.5 * sin(...)</code>—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range <span class="math inline">\([0,1]\)</span>. You’ll use this so often it becomes second nature.</p>
<hr>
</section>
</section>
<section id="coordinate-systems" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="coordinate-systems"><span class="header-section-number">1.4</span> Coordinate Systems</h2>
<section id="raw-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="raw-coordinates">Raw Coordinates</h3>
<p>By default, <code>fragCoord</code> gives pixel coordinates with:</p>
<ul>
<li>Origin <span class="math inline">\((0, 0)\)</span> at the bottom-left</li>
<li><span class="math inline">\(x\)</span> increases rightward to <code>iResolution.x</code></li>
<li><span class="math inline">\(y\)</span> increases upward to <code>iResolution.y</code></li>
</ul>
<p>This is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!</p>
</section>
<section id="centered-normalized-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="centered-normalized-coordinates">Centered, Normalized Coordinates</h3>
<p>Here’s the standard transformation we’ll use in every shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Normalize to [0,1]</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Center at origin: [-0.5, 0.5]</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to account for aspect ratio</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now uv is centered and aspect-corrected</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to desired viewing window (e.g., [-2, 2] on x-axis)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span>  </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Let’s understand this transformation rigorously. We’re composing four maps. Let’s write <span class="math inline">\(w =\)</span> <code>iResolution.x</code> and <span class="math inline">\(h =\)</span> <code>iResolution.y</code> for the width and height in pixels.</p>
<p><strong>Step 1: Normalization</strong> <span class="math display">\[T_1: [0, w] \times [0, h] \to [0,1]^2, \quad T_1(x,y) = \left(\frac{x}{w}, \frac{y}{h}\right)\]</span></p>
<p>This makes our coordinates resolution-independent—the same shader code works whether your screen is 1920×1080 or 800×600. A point that’s halfway across the screen is <span class="math inline">\((0.5, v)\)</span> regardless of how many pixels wide the screen actually is.</p>
<p><strong>Step 2: Centering</strong> <span class="math display">\[T_2: [0,1]^2 \to [-\tfrac{1}{2}, \tfrac{1}{2}]^2, \quad T_2(u,v) = (u - \tfrac{1}{2}, v - \tfrac{1}{2})\]</span></p>
<p>Now the origin is at the center of the screen, which is much more natural for mathematical work. We can think about positive and negative coordinates, circles centered at the origin, and so on.</p>
<p><strong>Step 3: Aspect correction</strong> <span class="math display">\[T_3(u,v) = \left(\frac{w}{h} \cdot u, v\right)\]</span></p>
<p>This is crucial! Without it, circles would appear as ellipses on non-square screens. The aspect ratio <span class="math inline">\(w/h\)</span> stretches the <span class="math inline">\(x\)</span>-coordinate so that one unit in <span class="math inline">\(x\)</span> corresponds to the same screen distance as one unit in <span class="math inline">\(y\)</span>. On a typical 16:9 display (<span class="math inline">\(w/h \approx 1.78\)</span>), this means the <span class="math inline">\(x\)</span>-axis spans a wider range than the <span class="math inline">\(y\)</span>-axis—as it should to maintain equal scaling. A circle of radius <span class="math inline">\(r\)</span> will actually appear circular on screen, not squashed.</p>
<p><strong>Step 4: Scaling to viewing window</strong> <span class="math display">\[T_4(u,v) = s \cdot (u,v)\]</span></p>
<p>Finally, we scale by whatever factor gives us the mathematical viewing window we want. If we choose <span class="math inline">\(s = 4\)</span>, then on a 16:9 screen our coordinates range roughly from <span class="math inline">\([-3.56, 3.56]\)</span> in <span class="math inline">\(x\)</span> and <span class="math inline">\([-2, 2]\)</span> in <span class="math inline">\(y\)</span>—notice the <span class="math inline">\(x\)</span>-range is wider to match the screen aspect ratio.</p>
<p>The composition <span class="math inline">\(T_4 \circ T_3 \circ T_2 \circ T_1\)</span> is our complete coordinate transformation, taking us from raw pixel coordinates to a centered, aspect-corrected mathematical coordinate system.</p>
<p>From now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable <code>p</code> for “position.”</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>The coordinate transformation boilerplate
</div>
</div>
<div class="callout-body-container callout-body">
<p>You’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit and you can modify it when needed.</p>
</div>
</div>
</section>
<section id="visualizing-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-coordinates">Visualizing Coordinates</h3>
<p>Let’s verify our coordinate system is working by coloring pixels according to their position:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map x coordinate to red, y to green</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> color_rg <span class="op">=</span> p <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Remap to [0, 1]</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color_rg<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup! This is a good debugging technique—whenever you’re unsure about your coordinates, visualize them directly as colors.</p>
<hr>
</section>
</section>
<section id="conditional-coloring-half-planes" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="conditional-coloring-half-planes"><span class="header-section-number">1.5</span> Conditional Coloring: Half-Planes</h2>
<section id="the-concept" class="level3">
<h3 class="anchored" data-anchor-id="the-concept">The Concept</h3>
<p>Given a linear function <span class="math inline">\(L(x, y) = ax + by + c\)</span>, we want to color pixels differently depending on whether <span class="math inline">\(L(p) &lt; 0\)</span> or <span class="math inline">\(L(p) \geq 0\)</span>. This divides the plane into two half-planes—the regions where the function is negative versus positive.</p>
<p>The line itself is the zero set: <span class="math inline">\(\{(x,y) : L(x,y) = 0\}\)</span>. This is the boundary between the two regions.</p>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>GLSL provides a conditional operator (ternary operator) just like C:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> L <span class="op">=</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span>  <span class="co">// The function L(x,y) = x</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>L <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Left half-plane is red, right half-plane is blue. The syntax <code>(condition) ? value_if_true : value_if_false</code> should be familiar if you’ve programmed in C, Java, or JavaScript.</p>
</section>
<section id="the-step-function" class="level3">
<h3 class="anchored" data-anchor-id="the-step-function">The Step Function</h3>
<p>GLSL also provides <code>step(edge, x)</code> which returns <span class="math inline">\(0\)</span> if <span class="math inline">\(x &lt; \text{edge}\)</span> and <span class="math inline">\(1\)</span> otherwise. The name comes from its graph—a step function in the calculus sense, jumping discontinuously from 0 to 1 at the edge value. This is useful for writing cleaner code without explicit conditionals:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> s <span class="op">=</span> <span class="bu">step</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> p<span class="op">.</span><span class="fu">x</span><span class="op">);</span>  <span class="co">// 0 on left, 1 on right</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span> s<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>mix(a, b, t)</code> performs linear interpolation: <span class="math inline">\((1-t)a + tb\)</span>. So when <code>s = 0</code> we get pure red, when <code>s = 1</code> we get pure blue. The <code>mix</code> function is one of GLSL’s most useful tools—you’ll use it constantly for blending colors, smoothly transitioning between values, and implementing linear interpolation in all sorts of contexts.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Why use <code>step</code> instead of the ternary operator?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Both work fine! The ternary operator <code>?:</code> is more explicit and familiar if you know C-like languages. But <code>step</code> and <code>mix</code> are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation. For now, use whichever makes sense to you.</p>
</div>
</div>
</section>
<section id="arbitrary-half-planes" class="level3">
<h3 class="anchored" data-anchor-id="arbitrary-half-planes">Arbitrary Half-Planes</h3>
<p>For a general line <span class="math inline">\(ax + by + c = 0\)</span>, we just evaluate the corresponding linear function:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> b <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> c <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> L <span class="op">=</span> a <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> b <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>L <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Try different values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> to see different line orientations and positions. The line itself is where <span class="math inline">\(L = 0\)</span>, and we’re coloring the two sides differently. Notice that scaling <span class="math inline">\((a,b,c)\)</span> by a positive constant doesn’t change the geometry—it’s the zero set that matters, not the specific values of the function away from zero.</p>
<hr>
</section>
</section>
<section id="distance-fields-and-circles" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="distance-fields-and-circles"><span class="header-section-number">1.6</span> Distance Fields and Circles</h2>
<section id="distance-to-center" class="level3">
<h3 class="anchored" data-anchor-id="distance-to-center">Distance to Center</h3>
<p>The distance from a point <span class="math inline">\(p = (x, y)\)</span> to the origin is just the usual Euclidean distance: <span class="math display">\[d = \|p\| = \sqrt{x^2 + y^2}\]</span></p>
<p>In GLSL this is built-in:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>length()</code> function computes the Euclidean norm of a vector. It works for <code>vec2</code>, <code>vec3</code>, <code>vec4</code>—whatever you need. Under the hood it’s computing the square root of the dot product of the vector with itself, but there’s no need to write that out explicitly.</p>
</section>
<section id="filled-circle" class="level3">
<h3 class="anchored" data-anchor-id="filled-circle">Filled Circle</h3>
<p>A circle of radius <span class="math inline">\(r\)</span> centered at the origin is the set <span class="math inline">\(\{p : \|p\| &lt; r\}\)</span>—just points whose distance from the origin is less than <span class="math inline">\(r\)</span>. So to color the inside versus outside of a circle, we just compare distances:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>That’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle. Simple, elegant, and fast—millions of distance calculations per frame, all happening in parallel.</p>
</section>
<section id="distance-based-coloring" class="level3">
<h3 class="anchored" data-anchor-id="distance-based-coloring">Distance-Based Coloring</h3>
<p>But we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> intensity <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> d <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span>  <span class="co">// Fades from 1 at center to 0 at distance 2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>intensity <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span>intensity<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Keep it in [0, 1]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>intensity<span class="op">);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This creates a radial gradient—bright at the center, dark at the edges. The <code>clamp</code> function ensures we stay within <span class="math inline">\([0,1]\)</span> even if our formula would produce values outside that range. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!</p>
<p>Distance fields will become increasingly important as the week progresses. On Day 4, we’ll use them as the foundation for <strong>raymarching</strong>—a technique for rendering 3D geometry without any triangles or polygons, purely by iteratively evaluating distance functions. The <code>length(p)</code> function we used for circles today generalizes to arbitrary implicit surfaces: $d(p) = $ “distance to the surface defined by <span class="math inline">\(F(p) = 0\)</span>.” It’s a beautiful connection between analysis and computer graphics.</p>
</section>
<section id="circle-outline" class="level3">
<h3 class="anchored" data-anchor-id="circle-outline">Circle Outline</h3>
<p>What if we want to draw just the <em>boundary</em> of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is <em>approximately equal</em> to the radius. Mathematically, we’re coloring the set <span class="math inline">\(\{p : |d(p) - r| &lt; \epsilon\}\)</span> where <span class="math inline">\(\epsilon\)</span> is a small thickness parameter:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> circle_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>d <span class="op">-</span> r<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>circle_mask<span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This draws a thin white annulus around the circle. Play with the <code>thickness</code> parameter to see how it affects the line width!</p>
<p>For a smoother, anti-aliased edge, GLSL provides <code>smoothstep</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> circle_mask <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> <span class="bu">smoothstep</span><span class="op">(</span>r <span class="op">-</span> thickness<span class="op">,</span> r <span class="op">+</span> thickness<span class="op">,</span> d<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>smoothstep(a, b, x)</code> function performs smooth Hermite interpolation. For <span class="math inline">\(x \in [a,b]\)</span>, it returns <span class="math display">\[s(t) = 3t^2 - 2t^3 \quad \text{where } t = \frac{x-a}{b-a}\]</span></p>
<p>This is a cubic polynomial with <span class="math inline">\(s(0) = 0\)</span>, <span class="math inline">\(s(1) = 1\)</span>, and crucially <span class="math inline">\(s'(0) = s'(1) = 0\)</span>—the zero derivatives at the endpoints mean it transitions smoothly without visible “kinks.” For <span class="math inline">\(x &lt; a\)</span> it returns <span class="math inline">\(0\)</span>, for <span class="math inline">\(x &gt; b\)</span> it returns <span class="math inline">\(1\)</span>.</p>
<p>The result is anti-aliasing: instead of a hard transition at a single pixel, the edge is blurred over the interval <span class="math inline">\([a,b]\)</span>. For circle outlines, using <code>smoothstep(r - thickness, r + thickness, d)</code> creates a smooth transition zone of width <span class="math inline">\(2 \cdot \text{thickness}\)</span> around the target radius. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Anti-aliasing in shaders
</div>
</div>
<div class="callout-body-container callout-body">
<p>The harsh cutoffs from using <code>&lt;</code> or the ternary operator create jagged, pixelated edges—what computer graphics people call “aliasing” (the signal is being undersampled relative to its frequency content, creating artifacts). Functions like <code>smoothstep</code> give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with <code>smoothstep</code> for smoother results.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="grids-and-repetition" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="grids-and-repetition"><span class="header-section-number">1.7</span> Grids and Repetition</h2>
<section id="modular-arithmetic" class="level3">
<h3 class="anchored" data-anchor-id="modular-arithmetic">Modular Arithmetic</h3>
<p>The modulo operation creates periodic repetition. For a period <span class="math inline">\(T\)</span>, the function <span class="math inline">\(p \mapsto (p \bmod T) - T/2\)</span> maps <span class="math inline">\(\mathbb{R}\)</span> to <span class="math inline">\([-T/2, T/2]\)</span> repeatedly—it “folds” the entire real line into a finite interval over and over again.</p>
<p>More precisely, recall that <span class="math inline">\(x \bmod T\)</span> is the unique value in <span class="math inline">\([0, T)\)</span> satisfying <span class="math inline">\(x \equiv r \pmod{T}\)</span>—that is, <span class="math inline">\(x = nT + r\)</span> for some integer <span class="math inline">\(n\)</span>. Geometrically, this takes the real line and wraps it into the interval <span class="math inline">\([0,T)\)</span>. Subtracting <span class="math inline">\(T/2\)</span> recenters this to <span class="math inline">\([-T/2, T/2]\)</span>.</p>
<p>In GLSL, <code>mod(x, T)</code> computes <span class="math inline">\(x \bmod T\)</span>. This is one of the most powerful tools in shader programming!</p>
</section>
<section id="creating-a-grid" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-grid">Creating a Grid</h3>
<p>To create a grid of repeated cells, we apply <code>mod</code> to our coordinates:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> spacing <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>p <span class="op">+</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">,</span> spacing<span class="op">)</span> <span class="op">-</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now cell_p repeats every spacing units</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a circle in each cell</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>cell_p<span class="op">);</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This creates an infinite grid of yellow circles! The coordinate transformation <code>cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0</code> ensures that <code>cell_p</code> is always in the range <span class="math inline">\([-\text{spacing}/2, \text{spacing}/2]\)</span>, and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.</p>
<p>Think about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation.</p>
<p>Compare this to how you might approach this in Python or MATLAB: you’d probably set up a nested loop over grid cells, compute the center of each cell, then draw a circle there. That’s <span class="math inline">\(O(n^2)\)</span> work for an <span class="math inline">\(n \times n\)</span> grid. With shaders, it’s <span class="math inline">\(O(1)\)</span> in the grid size—the cost is entirely in the number of <em>pixels</em>, not the number of <em>circles</em>. This is why shaders can render infinitely complex patterns at the same framerate as simple ones.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>The power of <code>mod</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>This computational efficiency through coordinate transformations is a recurring theme in shader programming. You’ll see it again when we talk about domain repetition for fractals (Day 2), symmetry groups for hyperbolic tilings (Day 3), and space folding for raymarched scenes (Day 4). The key insight is always the same: instead of explicitly iterating over instances, transform the coordinate system so that all instances share the same local coordinates.</p>
</div>
</div>
</section>
<section id="alternating-pattern" class="level3">
<h3 class="anchored" data-anchor-id="alternating-pattern">Alternating Pattern</h3>
<p>We can create checkerboard-like patterns by using the <em>cell index</em> to vary colors. To get the cell index, we divide by the spacing and floor:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">/</span> spacing<span class="op">);</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> checker <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>cell_id<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> cell_id<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color_a <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color_b <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> bg_color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color_a<span class="op">,</span> color_b<span class="op">,</span> checker<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>floor(p / spacing)</code> gives us integer grid indices <span class="math inline">\((i, j)\)</span>, and we alternate colors based on the parity of <span class="math inline">\(i + j\)</span>. When <span class="math inline">\(i + j\)</span> is even, <code>checker = 0</code> (giving us <code>color_a</code>), when odd, <code>checker = 1</code> (giving us <code>color_b</code>).</p>
<p>Notice the elegant separation: <code>cell_id</code> tells us <em>which</em> cell we’re in, while <code>cell_p</code> tells us <em>where within</em> that cell. This separation of global position and local coordinates is fundamental to working with repeating patterns.</p>
</section>
<section id="combining-with-circles" class="level3">
<h3 class="anchored" data-anchor-id="combining-with-circles">Combining with Circles</h3>
<p>Let’s put it all together—a grid of circles on an alternating background:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> spacing <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">/</span> spacing<span class="op">);</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>p <span class="op">+</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">,</span> spacing<span class="op">)</span> <span class="op">-</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Checkerboard background</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> checker <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>cell_id<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> cell_id<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> bg_color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">),</span> checker<span class="op">);</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle in each cell</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>cell_p<span class="op">);</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> circle_color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> circle_color <span class="op">:</span> bg_color<span class="op">;</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Try varying the <code>spacing</code> and <code>r</code> parameters. What happens if you make the circles larger than the cells? (They overlap across cell boundaries!) What if you use different spacing values for <code>x</code> and <code>y</code>? (You get a rectangular rather than square lattice.) This simple framework is incredibly flexible.</p>
<hr>
</section>
</section>
<section id="implicit-curves" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="implicit-curves"><span class="header-section-number">1.8</span> Implicit Curves</h2>
<section id="general-principle" class="level3">
<h3 class="anchored" data-anchor-id="general-principle">General Principle</h3>
<p>An implicit curve is defined by an equation <span class="math inline">\(F(x, y) = 0\)</span>. Points on the curve satisfy the equation exactly, while points off the curve have <span class="math inline">\(F(x,y) \neq 0\)</span>. To render the curve, we compute <span class="math inline">\(F(p)\)</span> for each pixel and color based on proximity to zero:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="op">[</span>some function of p<span class="op">.</span><span class="fu">x</span> and p<span class="op">.</span><span class="fu">y</span><span class="op">];</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>background<span class="op">,</span> curve_color<span class="op">,</span> curve_mask<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, transcendental curves, whatever you want. If you can write down a formula <span class="math inline">\(F(x,y)\)</span>, you can visualize its zero set.</p>
</section>
<section id="example-parabola" class="level3">
<h3 class="anchored" data-anchor-id="example-parabola">Example: Parabola</h3>
<p>The parabola <span class="math inline">\(y = x^2\)</span> can be written implicitly as <span class="math inline">\(F(x, y) = y - x^2 = 0\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> curve_mask<span class="op">);</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a yellow parabola on a dark blue background. The curve appears wherever <span class="math inline">\(|F(x,y)| &lt; 0.1\)</span>—a thin band around the zero set of <span class="math inline">\(F\)</span>.</p>
<p>One thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker, while in the steep regions it appears thinner. Why does this happen?</p>
<p>We’re thresholding on the <em>value</em> of <span class="math inline">\(F\)</span>, not the <em>geometric distance</em> to the curve. Near the vertex at <span class="math inline">\((0,0)\)</span>, the parabola is nearly horizontal—small changes in <span class="math inline">\(y\)</span> correspond to small changes in <span class="math inline">\(x\)</span>, so the set <span class="math inline">\(\{p : |y - x^2| &lt; \epsilon\}\)</span> is a thick vertical band. But on the steep parts where <span class="math inline">\(|x|\)</span> is large, the parabola is nearly vertical—now the same change in <span class="math inline">\(y\)</span> corresponds to a large change in <span class="math inline">\(x\)</span>, so the band is thin.</p>
<p>To see this more precisely, consider the gradient: <span class="math inline">\(\nabla F = (-2x, 1)\)</span>. Near the vertex this has magnitude close to <span class="math inline">\(1\)</span>, but for large <span class="math inline">\(|x|\)</span> it has magnitude approximately <span class="math inline">\(2|x|\)</span>. The visual thickness is roughly inversely proportional to <span class="math inline">\(|\nabla F|\)</span>—where the gradient is small, the level sets are far apart, and where it’s large, they’re close together.</p>
<p>To get uniform thickness, we’d need the <em>signed distance function</em> to the curve: <span class="math display">\[d(p) = \inf\{\|p - q\| : F(q) = 0\}\]</span></p>
<p>Then thresholding on <span class="math inline">\(|d(p)| &lt; \epsilon\)</span> gives exactly thickness <span class="math inline">\(\epsilon\)</span> everywhere. Computing exact signed distance functions is nontrivial (we’ll see techniques for this on Day 4 when we discuss raymarching), but for many applications the naive thresholding on <span class="math inline">\(|F|\)</span> works fine—especially if you tune the thickness parameter appropriately or use different thickness values in different regions.</p>
</section>
<section id="example-circle-implicit-form" class="level3">
<h3 class="anchored" data-anchor-id="example-circle-implicit-form">Example: Circle (Implicit Form)</h3>
<p>We’ve been using <span class="math inline">\(\|p\| &lt; r\)</span> for filled circles, but we can also write the circle implicitly as <span class="math inline">\(x^2 + y^2 - r^2 = 0\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">)</span> <span class="op">-</span> r <span class="op">*</span> r<span class="op">;</span>  <span class="co">// dot(p,p) = x² + y²</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The <code>dot(p, p)</code> computes <span class="math inline">\(x^2 + y^2\)</span> as a single GPU operation—more efficient than <code>p.x * p.x + p.y * p.y</code> and certainly cleaner than writing it out! For circles, the signed distance function and the implicit function are particularly closely related: <span class="math inline">\(d(p) = |\|p\| - r|\)</span>, so the naive implicit approach actually works quite well.</p>
</section>
<section id="more-examples" class="level3">
<h3 class="anchored" data-anchor-id="more-examples">More Examples</h3>
<p>Let’s look at a few more interesting curves:</p>
<p><strong>Hyperbola</strong>: <span class="math inline">\(xy = 1\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Ellipse</strong>: <span class="math inline">\(\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">2.0</span><span class="op">,</span> b <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span>a <span class="op">*</span> a<span class="op">)</span> <span class="op">+</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span>b <span class="op">*</span> b<span class="op">)</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Lemniscate of Bernoulli</strong>: <span class="math inline">\((x^2 + y^2)^2 = a^2(x^2 - y^2)\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> r2 <span class="op">*</span> r2 <span class="op">-</span> a <span class="op">*</span> a <span class="op">*</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each of these creates beautiful curves! Try implementing them and experimenting with different parameters.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Implicit curves in your homework
</div>
</div>
<div class="callout-body-container callout-body">
<p>When you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation <span class="math inline">\(F(x,y) = y - (ax^2 + bx + c)\)</span> and thresholding on <span class="math inline">\(|F| &lt; \epsilon\)</span>. Make sure to test with various values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> to ensure your grapher is robust!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="summary" class="level2" data-number="1.9">
<h2 data-number="1.9" class="anchored" data-anchor-id="summary"><span class="header-section-number">1.9</span> Summary</h2>
<p>Today we’ve learned the fundamental tools of shader programming:</p>
<ol type="1">
<li><p><strong>Shaders as parallel functions</strong>: Every pixel evaluates <span class="math inline">\(f(x, y, t, \ldots) \to \text{color}\)</span> simultaneously—no loops required! The computational model is fundamentally different from sequential CPU programming.</p></li>
<li><p><strong>GLSL basics</strong>: Syntax rules (semicolons, <code>.0</code> for floats), vector types (<code>vec2</code>, <code>vec3</code>, <code>vec4</code>), and essential built-in functions like <code>length()</code>, <code>dot()</code>, <code>step()</code>, and <code>smoothstep()</code></p></li>
<li><p><strong>Coordinate systems</strong>: The four-step transformation (normalize, center, aspect-correct, scale) that takes us from pixel coordinates to a mathematical coordinate system suitable for visualization</p></li>
<li><p><strong>Conditional coloring</strong>: Using boolean expressions, the ternary operator, and <code>step()</code> combined with <code>mix()</code> to create discrete color regions based on mathematical predicates</p></li>
<li><p><strong>Distance fields</strong>: Using <code>length()</code> to create circles and radial patterns—the foundation for much more complex techniques we’ll explore on Day 4 with raymarching</p></li>
<li><p><strong>Modular arithmetic</strong>: Creating grids and repeating patterns with <code>mod()</code>—achieving infinite complexity with finite computation through coordinate transformations rather than explicit iteration</p></li>
<li><p><strong>Implicit curves</strong>: Rendering curves defined by <span class="math inline">\(F(x, y) = 0\)</span> by thresholding on <span class="math inline">\(|F|\)</span>—a general technique that works for any curve we can express as an equation, though we must be aware of the non-uniform thickness issue</p></li>
</ol>
<p>With these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today.</p>
<hr>
</section>
<section id="homework" class="level2" data-number="1.10">
<h2 data-number="1.10" class="anchored" data-anchor-id="homework"><span class="header-section-number">1.10</span> Homework</h2>
<section id="required-parabola-graphing-calculator" class="level3">
<h3 class="anchored" data-anchor-id="required-parabola-graphing-calculator">Required: Parabola Graphing Calculator</h3>
<p>Create a shader that draws a customizable parabola <span class="math inline">\(y = ax^2 + bx + c\)</span> along with coordinate axes.</p>
<p><strong>Requirements:</strong></p>
<ul>
<li>Define variables <code>a</code>, <code>b</code>, <code>c</code> at the top of your shader (hardcoded values are fine—we’re not building a GUI yet)</li>
<li>Draw the <span class="math inline">\(x\)</span>-axis and <span class="math inline">\(y\)</span>-axis as thin lines using the implicit line technique: <span class="math inline">\(|y| &lt; \epsilon\)</span> for the <span class="math inline">\(x\)</span>-axis, <span class="math inline">\(|x| &lt; \epsilon\)</span> for the <span class="math inline">\(y\)</span>-axis</li>
<li>Plot the parabola <span class="math inline">\(y = ax^2 + bx + c\)</span> as a thicker curve</li>
<li>Use distinct colors for axes (suggest a neutral gray) and parabola (suggest something bright)</li>
<li>The visualization should work for any reasonable values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>—make sure to test edge cases!</li>
</ul>
<p><strong>What it should look like:</strong> A coordinate plane with thin gray axes, and a colored curve tracing out your parabola. The entire parabola should be visible in your viewing window (you may need to adjust your scaling factor depending on your parameters).</p>
<p><strong>Test cases to verify:</strong> - <span class="math inline">\(a=1, b=0, c=0\)</span> (standard parabola opening upward) - <span class="math inline">\(a=-1, b=0, c=1\)</span> (downward-opening parabola shifted up) - <span class="math inline">\(a=0.5, b=1, c=-0.5\)</span> (general case with all parameters nonzero) - <span class="math inline">\(a=0, b=1, c=0\)</span> (degenerate case—just a line! Your code should handle this gracefully)</p>
<p><strong>Suggested approach:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define parameters</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> b <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> c <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Background</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">);</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Axes</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> axis_thickness <span class="op">=</span> <span class="fl">0.02</span><span class="op">;</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x_axis_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">&lt;</span> axis_thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> y_axis_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">)</span> <span class="op">&lt;</span> axis_thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> axis_color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Parabola: F(x,y) = y - (ax² + bx + c) = 0</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> <span class="op">(</span>a <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> b <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> c<span class="op">);</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> curve_thickness <span class="op">=</span> <span class="fl">0.08</span><span class="op">;</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parabola_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> curve_thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> parabola_color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Combine (axes behind parabola)</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> axis_color<span class="op">,</span> <span class="bu">max</span><span class="op">(</span>x_axis_mask<span class="op">,</span> y_axis_mask<span class="op">));</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> parabola_color<span class="op">,</span> parabola_mask<span class="op">);</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Try different values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> and verify your grapher works correctly! What happens with negative <span class="math inline">\(a\)</span>? What about <span class="math inline">\(b \neq 0\)</span>? Make sure the axes and parabola remain visible for all parameter values you try. If the parabola goes off-screen, you may need to adjust your coordinate scaling in the setup.</p>
</section>
<section id="optional-1-animated-curve-family" class="level3">
<h3 class="anchored" data-anchor-id="optional-1-animated-curve-family">Optional #1: Animated Curve Family</h3>
<p>Create a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build geometric intuition!</p>
<p><strong>Easier options:</strong></p>
<ul>
<li><p><strong>Circle family</strong>: Draw circles of varying radii: <span class="math inline">\(x^2 + y^2 = r^2\)</span> where <span class="math inline">\(r = 1 + 0.5\sin(\text{iTime})\)</span>. Simple but mesmerizing!</p></li>
<li><p><strong>Rotating ellipse</strong>: <span class="math inline">\((x\cos\theta + y\sin\theta)^2/a^2 + (-x\sin\theta + y\cos\theta)^2/b^2 = 1\)</span> with <span class="math inline">\(\theta = \text{iTime}\)</span>. Watch an ellipse rotate continuously.</p></li>
</ul>
<p><strong>More challenging options:</strong></p>
<ul>
<li><p><strong>Lissajous curves</strong>: Use parametric equations <span class="math inline">\(x = A\sin(at + \delta)\)</span>, <span class="math inline">\(y = B\sin(bt)\)</span> and animate <span class="math inline">\(\delta\)</span> with <code>iTime</code>. To render a parametric curve implicitly, you’ll need to be clever—one approach is to sample many points along the curve and draw circles at each point (we’ll learn better techniques for this later).</p></li>
<li><p><strong>Cassini ovals</strong>: <span class="math inline">\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\)</span>. Fix <span class="math inline">\(c = 1\)</span> and vary <span class="math inline">\(a\)</span> with <code>iTime</code>. Watch the curve transition from two separate loops to a single figure-eight-like shape as <span class="math inline">\(a\)</span> passes through the critical value <span class="math inline">\(a = c\)</span>!</p></li>
<li><p><strong>Cubic curves</strong>: Take <span class="math inline">\(y^2 = x^3 + ax + b\)</span> and vary one parameter with <code>iTime</code>. The topology of the curve changes dramatically as you pass through singular values—this is the beginning of the theory of elliptic curves!</p></li>
</ul>
<p>Use <code>iTime</code> creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes (these are the singularities of the family)!</p>
</section>
<section id="optional-2-beautiful-tiling-pattern" class="level3">
<h3 class="anchored" data-anchor-id="optional-2-beautiful-tiling-pattern">Optional #2: Beautiful Tiling Pattern</h3>
<p>Design an aesthetically pleasing tiling pattern using the <code>mod()</code> technique. This is your chance to be creative and make something visually striking!</p>
<p><strong>Requirements:</strong></p>
<ul>
<li>Create a non-trivial pattern within a fundamental domain (a single tile)</li>
<li>Use <code>mod()</code> to repeat it across the plane</li>
<li>The pattern should tile seamlessly—edges must match up so there are no visible discontinuities at tile boundaries</li>
</ul>
<p><strong>Ideas to get you started:</strong></p>
<ul>
<li><strong>Geometric patterns</strong>: Nested circles, polygons approximated by implicit curves, star shapes using angular coordinates</li>
<li><strong>Color gradients</strong>: Use <code>cell_id</code> to vary colors smoothly across tiles, creating large-scale gradient effects superimposed on the local pattern</li>
<li><strong>Multiple implicit curves</strong>: Combine several curves within each tile using boolean operations (intersection, union, etc.)</li>
<li><strong>Symmetry</strong>: Use <code>abs()</code> to create reflections within tiles—this is a simple way to get complex patterns with built-in symmetry</li>
<li><strong>Distance-based effects</strong>: Make features pulse or fade based on <code>iTime</code> and their position in the grid—create waves propagating across the tiling</li>
</ul>
<p><strong>Advanced challenge</strong>: Can you create a pattern that has different symmetries in different tiles? For example, alternate between rotational and reflectional symmetry using the checkerboard <code>cell_id</code> technique. Or create a pattern where the colors vary smoothly across the entire infinite tiling, creating a large-scale gradient effect that’s independent of the tile boundaries?</p>
<p>Think about Islamic geometric patterns, Escher tilings, or quasiperiodic tilings (though true quasiperiodicity requires techniques beyond simple <code>mod</code>—we’ll see that on Day 3!). The goal is to create something mathematically interesting and visually beautiful.</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="1.11">
<h2 data-number="1.11" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">1.11</span> Looking Ahead</h2>
<p>Tomorrow we’ll use these techniques to explore <strong>complex dynamics</strong> and <strong>geometric transformations</strong>:</p>
<ul>
<li><strong>Mandelbrot and Julia sets</strong>: Using the implicit curve technique to visualize the boundary of escape sets for complex iteration</li>
<li><strong>Circle inversions</strong>: A geometric transformation that takes lines and circles to lines and circles, creating beautiful fractal-like patterns</li>
<li><strong>Apollonian gasket</strong>: An infinite packing of circles constructed via repeated inversions—a stunning example of how simple geometric rules create intricate structures</li>
</ul>
<p>The coordinate systems, distance fields, and implicit curve techniques you’ve learned today will be the foundation for everything to come. Make sure you’re comfortable with:</p>
<ul>
<li>Setting up coordinates (the standard four-step transformation from <code>fragCoord</code> to centered, aspect-corrected <code>p</code>)</li>
<li>Computing distances with <code>length()</code> and dot products</li>
<li>Using <code>mod()</code> for repetition and understanding the separation of global <code>cell_id</code> and local <code>cell_p</code></li>
<li>Conditionally coloring based on mathematical expressions, using both explicit conditionals and smooth interpolation with <code>smoothstep</code></li>
</ul>
<p>If any of these feel shaky, now is the time to practice! Work through the homework problems, experiment with variations, and make sure you understand not just <em>how</em> the code works but <em>why</em> the mathematics gives the visual results you see. Everything this week builds on this foundation.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./outline.html" class="pagination-link" aria-label="Outline">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Outline</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./day2.html" class="pagination-link" aria-label="Day 2: Complex Dynamics and Iterated Inversions">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 1: Introduction to Shader Programming</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>Today we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We'll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="fu">## Roadmap for Today</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>We'll build up shader programming in layers:</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Core concept**: Shaders as parallel functions (What is a Shader?)</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Setup**: Coordinate systems and GLSL syntax (First Shader, Coordinate Systems)</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Basic techniques**: Conditional coloring and distance fields (Half-Planes, Distance Fields)  </span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Repetition**: Grids via modular arithmetic (Grids and Repetition)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Application**: Implicit curves (Implicit Curves)</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>Each section builds on the previous, so if something feels unclear, it's worth revisiting earlier material before moving forward.</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a><span class="fu">## What is a Shader?</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a><span class="fu">### Mathematical Perspective</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>A shader is fundamentally a function</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>$$f: \mathbb{R}^2 \times \mathbb{R} \times \cdots \to <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>^4$$</span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>that maps pixel coordinates $(x,y)$, time $t$, and potentially other parameters to RGBA color values. For today, we'll focus on the spatial dependence—thinking of the shader as a function $f: \mathbb{R}^2 \to <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>^4$ that assigns a color to each point in the plane. The domain $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>^4$ represents the red, green, blue, and alpha (transparency) channels, each normalized to the unit interval.</span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>Here's the magic: modern GPUs can evaluate this function for **all pixels simultaneously**. If your screen has 1920×1080 pixels, that's over 2 million function evaluations happening in parallel, typically 60 times per second. We're not looping over pixels one at a time—we're computing them all at once!</span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>This is completely different from how you might write mathematical visualization code in, say, Python or MATLAB. There you'd have nested loops:</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(width):</span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(height):</span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a>        color[x,y] <span class="op">=</span> f(x, y)</span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a>With shaders, there are no loops. You write the function $f$, and the GPU just *does it* everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.</span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-45"><a href="#cb26-45" aria-hidden="true" tabindex="-1"></a>The computational model is fundamentally different: in traditional CPU programming you have sequential control flow with explicit loops, while in shader programming you express computation as a pure mathematical function that gets evaluated independently at every pixel. The GPU architecture is specifically designed for this kind of massively parallel workload—it has thousands of small processors that can each evaluate your function simultaneously. This is why a relatively modest GPU can outperform even a powerful CPU on graphics tasks by orders of magnitude.</span>
<span id="cb26-46"><a href="#cb26-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-47"><a href="#cb26-47" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb26-48"><a href="#cb26-48" aria-hidden="true" tabindex="-1"></a><span class="fu">## Why is this called a "shader"?</span></span>
<span id="cb26-49"><a href="#cb26-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-50"><a href="#cb26-50" aria-hidden="true" tabindex="-1"></a>Historically, these programs were used for *shading* 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We're going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with "shading" in the traditional sense!</span>
<span id="cb26-51"><a href="#cb26-51" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-52"><a href="#cb26-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-53"><a href="#cb26-53" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why Shadertoy?</span></span>
<span id="cb26-54"><a href="#cb26-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-55"><a href="#cb26-55" aria-hidden="true" tabindex="-1"></a>Shadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it's a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.</span>
<span id="cb26-56"><a href="#cb26-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-57"><a href="#cb26-57" aria-hidden="true" tabindex="-1"></a>Shadertoy launched in 2013, created by Pol Jeremias-Vila and Íñigo Quílez (we'll see more of Íñigo's work throughout this week—he's pioneered many shader techniques). Before platforms like Shadertoy, shader programming required managing the entire OpenGL or DirectX pipeline yourself—compiling shaders, linking programs, setting up vertex buffers, managing textures. It was the domain of graphics programmers, not mathematicians.</span>
<span id="cb26-58"><a href="#cb26-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-59"><a href="#cb26-59" aria-hidden="true" tabindex="-1"></a>The genius of Shadertoy was recognizing that for many visualizations, you don't need that complexity. Just give people a function to fill in, handle the boilerplate invisibly, and suddenly shaders become accessible to anyone. It's democratized GPU programming in much the same way that Python notebooks democratized scientific computing—lower the barrier to entry, and a whole new community emerges.</span>
<span id="cb26-60"><a href="#cb26-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-61"><a href="#cb26-61" aria-hidden="true" tabindex="-1"></a>The platform provides several built-in **uniforms** (read-only global variables that are the same for all pixels):</span>
<span id="cb26-62"><a href="#cb26-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-63"><a href="#cb26-63" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`iResolution`</span>: screen resolution as a <span class="in">`vec3`</span> (width, height, pixel aspect ratio)</span>
<span id="cb26-64"><a href="#cb26-64" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`iTime`</span>: elapsed time in seconds since the shader started</span>
<span id="cb26-65"><a href="#cb26-65" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`iMouse`</span>: mouse position and click state as a <span class="in">`vec4`</span></span>
<span id="cb26-66"><a href="#cb26-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-67"><a href="#cb26-67" aria-hidden="true" tabindex="-1"></a>We'll use these throughout the week to create animated, interactive mathematical visualizations.</span>
<span id="cb26-68"><a href="#cb26-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-69"><a href="#cb26-69" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-70"><a href="#cb26-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-71"><a href="#cb26-71" aria-hidden="true" tabindex="-1"></a><span class="fu">## First Shader: Solid Colors</span></span>
<span id="cb26-72"><a href="#cb26-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-73"><a href="#cb26-73" aria-hidden="true" tabindex="-1"></a><span class="fu">### Basic Structure</span></span>
<span id="cb26-74"><a href="#cb26-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-75"><a href="#cb26-75" aria-hidden="true" tabindex="-1"></a>Every Shadertoy shader has the same entry point:</span>
<span id="cb26-76"><a href="#cb26-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-77"><a href="#cb26-77" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-78"><a href="#cb26-78" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-79"><a href="#cb26-79" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-80"><a href="#cb26-80" aria-hidden="true" tabindex="-1"></a><span class="in">    // Your code here</span></span>
<span id="cb26-81"><a href="#cb26-81" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-82"><a href="#cb26-82" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-83"><a href="#cb26-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-84"><a href="#cb26-84" aria-hidden="true" tabindex="-1"></a>**Parameters:**</span>
<span id="cb26-85"><a href="#cb26-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-86"><a href="#cb26-86" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`fragCoord`</span>: the pixel coordinate we're currently computing, as a <span class="in">`vec2`</span> giving the $(x, y)$ position</span>
<span id="cb26-87"><a href="#cb26-87" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`fragColor`</span>: the output color we need to set, as a <span class="in">`vec4`</span> giving the $(r, g, b, a)$ color</span>
<span id="cb26-88"><a href="#cb26-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-89"><a href="#cb26-89" aria-hidden="true" tabindex="-1"></a>Colors are represented in RGBA format with values in $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$. So <span class="in">`vec4(1.0, 0.0, 0.0, 1.0)`</span> represents opaque red, while <span class="in">`vec4(0.5, 0.5, 0.5, 1.0)`</span> is middle gray.</span>
<span id="cb26-90"><a href="#cb26-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-91"><a href="#cb26-91" aria-hidden="true" tabindex="-1"></a><span class="fu">### Example: Red Screen</span></span>
<span id="cb26-92"><a href="#cb26-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-93"><a href="#cb26-93" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-94"><a href="#cb26-94" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-95"><a href="#cb26-95" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-96"><a href="#cb26-96" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span>
<span id="cb26-97"><a href="#cb26-97" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-98"><a href="#cb26-98" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-99"><a href="#cb26-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-100"><a href="#cb26-100" aria-hidden="true" tabindex="-1"></a>This sets every pixel to red. The function is evaluated once per pixel, but since the output doesn't depend on <span class="in">`fragCoord`</span>, every pixel gets the same value. Not very exciting—but it's a start!</span>
<span id="cb26-101"><a href="#cb26-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-102"><a href="#cb26-102" aria-hidden="true" tabindex="-1"></a><span class="fu">### GLSL Syntax Basics</span></span>
<span id="cb26-103"><a href="#cb26-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-104"><a href="#cb26-104" aria-hidden="true" tabindex="-1"></a>Before we go further, let's talk about some essential GLSL conventions. If you're coming from Python or MATLAB, a few things will feel different:</span>
<span id="cb26-105"><a href="#cb26-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-106"><a href="#cb26-106" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb26-107"><a href="#cb26-107" aria-hidden="true" tabindex="-1"></a><span class="fu">## GLSL Syntax Rules</span></span>
<span id="cb26-108"><a href="#cb26-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-109"><a href="#cb26-109" aria-hidden="true" tabindex="-1"></a>**Semicolons are required.** Every statement must end with a semicolon. This is not Python! Forget one and your shader won't compile.</span>
<span id="cb26-110"><a href="#cb26-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-111"><a href="#cb26-111" aria-hidden="true" tabindex="-1"></a>**Floating point literals:** Write <span class="in">`1.0`</span> not <span class="in">`1`</span> for floating point values. GLSL is very picky about types—if you write <span class="in">`1`</span>, it's an integer, and mixing types causes errors. Get in the habit of always writing the <span class="in">`.0`</span>.</span>
<span id="cb26-112"><a href="#cb26-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-113"><a href="#cb26-113" aria-hidden="true" tabindex="-1"></a>**Vector types:** GLSL has built-in types <span class="in">`vec2`</span>, <span class="in">`vec3`</span>, <span class="in">`vec4`</span> for 2D, 3D, and 4D vectors. You can construct them with:</span>
<span id="cb26-114"><a href="#cb26-114" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-115"><a href="#cb26-115" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v = vec2(1.0, 2.0);</span></span>
<span id="cb26-116"><a href="#cb26-116" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 w = vec3(1.0, 2.0, 3.0);</span></span>
<span id="cb26-117"><a href="#cb26-117" aria-hidden="true" tabindex="-1"></a><span class="in">vec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars</span></span>
<span id="cb26-118"><a href="#cb26-118" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-119"><a href="#cb26-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-120"><a href="#cb26-120" aria-hidden="true" tabindex="-1"></a>**Swizzling:** You can access components by name: <span class="in">`v.x`</span>, <span class="in">`v.y`</span> or equivalently <span class="in">`v.r`</span>, <span class="in">`v.g`</span> (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: <span class="in">`v.yx`</span> swaps the coordinates, <span class="in">`v.xxx`</span> repeats the x-component three times. This is incredibly useful!</span>
<span id="cb26-121"><a href="#cb26-121" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-122"><a href="#cb26-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-123"><a href="#cb26-123" aria-hidden="true" tabindex="-1"></a><span class="fu">### Animating with Time</span></span>
<span id="cb26-124"><a href="#cb26-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-125"><a href="#cb26-125" aria-hidden="true" tabindex="-1"></a>Let's make something that changes:</span>
<span id="cb26-126"><a href="#cb26-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-127"><a href="#cb26-127" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-128"><a href="#cb26-128" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-129"><a href="#cb26-129" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-130"><a href="#cb26-130" aria-hidden="true" tabindex="-1"></a><span class="in">    float red = 0.5 + 0.5 * sin(iTime);</span></span>
<span id="cb26-131"><a href="#cb26-131" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(red, 0.0, 0.0, 1.0);</span></span>
<span id="cb26-132"><a href="#cb26-132" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-133"><a href="#cb26-133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-134"><a href="#cb26-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-135"><a href="#cb26-135" aria-hidden="true" tabindex="-1"></a>Here <span class="in">`iTime`</span> grows continuously, <span class="in">`sin(iTime)`</span> oscillates between $-1$ and $1$, and we remap this to $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$ with the affine transformation $t \mapsto \frac{1}{2}(1 + t)$. The screen now pulses between black and red!</span>
<span id="cb26-136"><a href="#cb26-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-137"><a href="#cb26-137" aria-hidden="true" tabindex="-1"></a>This pattern—<span class="in">`0.5 + 0.5 * sin(...)`</span>—comes up constantly when animating. It's the standard way to turn a sinusoid into something that stays in the range $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. You'll use this so often it becomes second nature.</span>
<span id="cb26-138"><a href="#cb26-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-139"><a href="#cb26-139" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-140"><a href="#cb26-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-141"><a href="#cb26-141" aria-hidden="true" tabindex="-1"></a><span class="fu">## Coordinate Systems</span></span>
<span id="cb26-142"><a href="#cb26-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-143"><a href="#cb26-143" aria-hidden="true" tabindex="-1"></a><span class="fu">### Raw Coordinates</span></span>
<span id="cb26-144"><a href="#cb26-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-145"><a href="#cb26-145" aria-hidden="true" tabindex="-1"></a>By default, <span class="in">`fragCoord`</span> gives pixel coordinates with:</span>
<span id="cb26-146"><a href="#cb26-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-147"><a href="#cb26-147" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Origin $(0, 0)$ at the bottom-left</span>
<span id="cb26-148"><a href="#cb26-148" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$x$ increases rightward to <span class="in">`iResolution.x`</span></span>
<span id="cb26-149"><a href="#cb26-149" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$y$ increases upward to <span class="in">`iResolution.y`</span></span>
<span id="cb26-150"><a href="#cb26-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-151"><a href="#cb26-151" aria-hidden="true" tabindex="-1"></a>This is fine if you're thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!</span>
<span id="cb26-152"><a href="#cb26-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-153"><a href="#cb26-153" aria-hidden="true" tabindex="-1"></a><span class="fu">### Centered, Normalized Coordinates</span></span>
<span id="cb26-154"><a href="#cb26-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-155"><a href="#cb26-155" aria-hidden="true" tabindex="-1"></a>Here's the standard transformation we'll use in every shader:</span>
<span id="cb26-156"><a href="#cb26-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-157"><a href="#cb26-157" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-158"><a href="#cb26-158" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-159"><a href="#cb26-159" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-160"><a href="#cb26-160" aria-hidden="true" tabindex="-1"></a><span class="in">    // Normalize to [0,1]</span></span>
<span id="cb26-161"><a href="#cb26-161" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb26-162"><a href="#cb26-162" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-163"><a href="#cb26-163" aria-hidden="true" tabindex="-1"></a><span class="in">    // Center at origin: [-0.5, 0.5]</span></span>
<span id="cb26-164"><a href="#cb26-164" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb26-165"><a href="#cb26-165" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-166"><a href="#cb26-166" aria-hidden="true" tabindex="-1"></a><span class="in">    // Scale to account for aspect ratio</span></span>
<span id="cb26-167"><a href="#cb26-167" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb26-168"><a href="#cb26-168" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-169"><a href="#cb26-169" aria-hidden="true" tabindex="-1"></a><span class="in">    // Now uv is centered and aspect-corrected</span></span>
<span id="cb26-170"><a href="#cb26-170" aria-hidden="true" tabindex="-1"></a><span class="in">    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)</span></span>
<span id="cb26-171"><a href="#cb26-171" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;  </span></span>
<span id="cb26-172"><a href="#cb26-172" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-173"><a href="#cb26-173" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span>
<span id="cb26-174"><a href="#cb26-174" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-175"><a href="#cb26-175" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-176"><a href="#cb26-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-177"><a href="#cb26-177" aria-hidden="true" tabindex="-1"></a>Let's understand this transformation rigorously. We're composing four maps. Let's write $w =$ <span class="in">`iResolution.x`</span> and $h =$ <span class="in">`iResolution.y`</span> for the width and height in pixels.</span>
<span id="cb26-178"><a href="#cb26-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-179"><a href="#cb26-179" aria-hidden="true" tabindex="-1"></a>**Step 1: Normalization** </span>
<span id="cb26-180"><a href="#cb26-180" aria-hidden="true" tabindex="-1"></a>$$T_1: <span class="co">[</span><span class="ot">0, w</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">0, h</span><span class="co">]</span> \to <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>^2, \quad T_1(x,y) = \left(\frac{x}{w}, \frac{y}{h}\right)$$</span>
<span id="cb26-181"><a href="#cb26-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-182"><a href="#cb26-182" aria-hidden="true" tabindex="-1"></a>This makes our coordinates resolution-independent—the same shader code works whether your screen is 1920×1080 or 800×600. A point that's halfway across the screen is $(0.5, v)$ regardless of how many pixels wide the screen actually is.</span>
<span id="cb26-183"><a href="#cb26-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-184"><a href="#cb26-184" aria-hidden="true" tabindex="-1"></a>**Step 2: Centering**</span>
<span id="cb26-185"><a href="#cb26-185" aria-hidden="true" tabindex="-1"></a>$$T_2: <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>^2 \to <span class="co">[</span><span class="ot">-\tfrac{1}{2}, \tfrac{1}{2}</span><span class="co">]</span>^2, \quad T_2(u,v) = (u - \tfrac{1}{2}, v - \tfrac{1}{2})$$</span>
<span id="cb26-186"><a href="#cb26-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-187"><a href="#cb26-187" aria-hidden="true" tabindex="-1"></a>Now the origin is at the center of the screen, which is much more natural for mathematical work. We can think about positive and negative coordinates, circles centered at the origin, and so on.</span>
<span id="cb26-188"><a href="#cb26-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-189"><a href="#cb26-189" aria-hidden="true" tabindex="-1"></a>**Step 3: Aspect correction**</span>
<span id="cb26-190"><a href="#cb26-190" aria-hidden="true" tabindex="-1"></a>$$T_3(u,v) = \left(\frac{w}{h} \cdot u, v\right)$$</span>
<span id="cb26-191"><a href="#cb26-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-192"><a href="#cb26-192" aria-hidden="true" tabindex="-1"></a>This is crucial! Without it, circles would appear as ellipses on non-square screens. The aspect ratio $w/h$ stretches the $x$-coordinate so that one unit in $x$ corresponds to the same screen distance as one unit in $y$. On a typical 16:9 display ($w/h \approx 1.78$), this means the $x$-axis spans a wider range than the $y$-axis—as it should to maintain equal scaling. A circle of radius $r$ will actually appear circular on screen, not squashed.</span>
<span id="cb26-193"><a href="#cb26-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-194"><a href="#cb26-194" aria-hidden="true" tabindex="-1"></a>**Step 4: Scaling to viewing window**</span>
<span id="cb26-195"><a href="#cb26-195" aria-hidden="true" tabindex="-1"></a>$$T_4(u,v) = s \cdot (u,v)$$</span>
<span id="cb26-196"><a href="#cb26-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-197"><a href="#cb26-197" aria-hidden="true" tabindex="-1"></a>Finally, we scale by whatever factor gives us the mathematical viewing window we want. If we choose $s = 4$, then on a 16:9 screen our coordinates range roughly from $<span class="co">[</span><span class="ot">-3.56, 3.56</span><span class="co">]</span>$ in $x$ and $<span class="co">[</span><span class="ot">-2, 2</span><span class="co">]</span>$ in $y$—notice the $x$-range is wider to match the screen aspect ratio.</span>
<span id="cb26-198"><a href="#cb26-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-199"><a href="#cb26-199" aria-hidden="true" tabindex="-1"></a>The composition $T_4 \circ T_3 \circ T_2 \circ T_1$ is our complete coordinate transformation, taking us from raw pixel coordinates to a centered, aspect-corrected mathematical coordinate system.</span>
<span id="cb26-200"><a href="#cb26-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-201"><a href="#cb26-201" aria-hidden="true" tabindex="-1"></a>From now on, we'll assume this coordinate setup is done at the start of every shader, storing the result in a variable <span class="in">`p`</span> for "position."</span>
<span id="cb26-202"><a href="#cb26-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-203"><a href="#cb26-203" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb26-204"><a href="#cb26-204" aria-hidden="true" tabindex="-1"></a><span class="fu">## The coordinate transformation boilerplate</span></span>
<span id="cb26-205"><a href="#cb26-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-206"><a href="#cb26-206" aria-hidden="true" tabindex="-1"></a>You'll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we'll just write it out each time so the transformation is explicit and you can modify it when needed.</span>
<span id="cb26-207"><a href="#cb26-207" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-208"><a href="#cb26-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-209"><a href="#cb26-209" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing Coordinates</span></span>
<span id="cb26-210"><a href="#cb26-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-211"><a href="#cb26-211" aria-hidden="true" tabindex="-1"></a>Let's verify our coordinate system is working by coloring pixels according to their position:</span>
<span id="cb26-212"><a href="#cb26-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-213"><a href="#cb26-213" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-214"><a href="#cb26-214" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-215"><a href="#cb26-215" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-216"><a href="#cb26-216" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb26-217"><a href="#cb26-217" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb26-218"><a href="#cb26-218" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb26-219"><a href="#cb26-219" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb26-220"><a href="#cb26-220" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-221"><a href="#cb26-221" aria-hidden="true" tabindex="-1"></a><span class="in">    // Map x coordinate to red, y to green</span></span>
<span id="cb26-222"><a href="#cb26-222" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]</span></span>
<span id="cb26-223"><a href="#cb26-223" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color_rg, 0.0, 1.0);</span></span>
<span id="cb26-224"><a href="#cb26-224" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-225"><a href="#cb26-225" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-226"><a href="#cb26-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-227"><a href="#cb26-227" aria-hidden="true" tabindex="-1"></a>You should see a smooth gradient: red increases rightward, green increases upward. If you don't see this, something went wrong in your coordinate setup! This is a good debugging technique—whenever you're unsure about your coordinates, visualize them directly as colors.</span>
<span id="cb26-228"><a href="#cb26-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-229"><a href="#cb26-229" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-230"><a href="#cb26-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-231"><a href="#cb26-231" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conditional Coloring: Half-Planes</span></span>
<span id="cb26-232"><a href="#cb26-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-233"><a href="#cb26-233" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Concept</span></span>
<span id="cb26-234"><a href="#cb26-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-235"><a href="#cb26-235" aria-hidden="true" tabindex="-1"></a>Given a linear function $L(x, y) = ax + by + c$, we want to color pixels differently depending on whether $L(p) &lt; 0$ or $L(p) \geq 0$. This divides the plane into two half-planes—the regions where the function is negative versus positive.</span>
<span id="cb26-236"><a href="#cb26-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-237"><a href="#cb26-237" aria-hidden="true" tabindex="-1"></a>The line itself is the zero set: $<span class="sc">\{</span>(x,y) : L(x,y) = 0<span class="sc">\}</span>$. This is the boundary between the two regions.</span>
<span id="cb26-238"><a href="#cb26-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-239"><a href="#cb26-239" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb26-240"><a href="#cb26-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-241"><a href="#cb26-241" aria-hidden="true" tabindex="-1"></a>GLSL provides a conditional operator (ternary operator) just like C:</span>
<span id="cb26-242"><a href="#cb26-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-243"><a href="#cb26-243" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-244"><a href="#cb26-244" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-245"><a href="#cb26-245" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-246"><a href="#cb26-246" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb26-247"><a href="#cb26-247" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb26-248"><a href="#cb26-248" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb26-249"><a href="#cb26-249" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb26-250"><a href="#cb26-250" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-251"><a href="#cb26-251" aria-hidden="true" tabindex="-1"></a><span class="in">    float L = p.x;  // The function L(x,y) = x</span></span>
<span id="cb26-252"><a href="#cb26-252" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-253"><a href="#cb26-253" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);</span></span>
<span id="cb26-254"><a href="#cb26-254" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-255"><a href="#cb26-255" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-256"><a href="#cb26-256" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-257"><a href="#cb26-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-258"><a href="#cb26-258" aria-hidden="true" tabindex="-1"></a>Left half-plane is red, right half-plane is blue. The syntax <span class="in">`(condition) ? value_if_true : value_if_false`</span> should be familiar if you've programmed in C, Java, or JavaScript.</span>
<span id="cb26-259"><a href="#cb26-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-260"><a href="#cb26-260" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Step Function</span></span>
<span id="cb26-261"><a href="#cb26-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-262"><a href="#cb26-262" aria-hidden="true" tabindex="-1"></a>GLSL also provides <span class="in">`step(edge, x)`</span> which returns $0$ if $x &lt; \text{edge}$ and $1$ otherwise. The name comes from its graph—a step function in the calculus sense, jumping discontinuously from 0 to 1 at the edge value. This is useful for writing cleaner code without explicit conditionals:</span>
<span id="cb26-263"><a href="#cb26-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-264"><a href="#cb26-264" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-265"><a href="#cb26-265" aria-hidden="true" tabindex="-1"></a><span class="in">float s = step(0.0, p.x);  // 0 on left, 1 on right</span></span>
<span id="cb26-266"><a href="#cb26-266" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);</span></span>
<span id="cb26-267"><a href="#cb26-267" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-268"><a href="#cb26-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-269"><a href="#cb26-269" aria-hidden="true" tabindex="-1"></a>Here <span class="in">`mix(a, b, t)`</span> performs linear interpolation: $(1-t)a + tb$. So when <span class="in">`s = 0`</span> we get pure red, when <span class="in">`s = 1`</span> we get pure blue. The <span class="in">`mix`</span> function is one of GLSL's most useful tools—you'll use it constantly for blending colors, smoothly transitioning between values, and implementing linear interpolation in all sorts of contexts.</span>
<span id="cb26-270"><a href="#cb26-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-271"><a href="#cb26-271" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb26-272"><a href="#cb26-272" aria-hidden="true" tabindex="-1"></a><span class="fu">## Why use `step` instead of the ternary operator?</span></span>
<span id="cb26-273"><a href="#cb26-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-274"><a href="#cb26-274" aria-hidden="true" tabindex="-1"></a>Both work fine! The ternary operator <span class="in">`?:`</span> is more explicit and familiar if you know C-like languages. But <span class="in">`step`</span> and <span class="in">`mix`</span> are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you'll develop a feel for which style is clearer in each situation. For now, use whichever makes sense to you.</span>
<span id="cb26-275"><a href="#cb26-275" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-276"><a href="#cb26-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-277"><a href="#cb26-277" aria-hidden="true" tabindex="-1"></a><span class="fu">### Arbitrary Half-Planes</span></span>
<span id="cb26-278"><a href="#cb26-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-279"><a href="#cb26-279" aria-hidden="true" tabindex="-1"></a>For a general line $ax + by + c = 0$, we just evaluate the corresponding linear function:</span>
<span id="cb26-280"><a href="#cb26-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-281"><a href="#cb26-281" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-282"><a href="#cb26-282" aria-hidden="true" tabindex="-1"></a><span class="in">float a = 1.0, b = 1.0, c = 0.0;</span></span>
<span id="cb26-283"><a href="#cb26-283" aria-hidden="true" tabindex="-1"></a><span class="in">float L = a * p.x + b * p.y + c;</span></span>
<span id="cb26-284"><a href="#cb26-284" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);</span></span>
<span id="cb26-285"><a href="#cb26-285" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-286"><a href="#cb26-286" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-287"><a href="#cb26-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-288"><a href="#cb26-288" aria-hidden="true" tabindex="-1"></a>Try different values of $a$, $b$, and $c$ to see different line orientations and positions. The line itself is where $L = 0$, and we're coloring the two sides differently. Notice that scaling $(a,b,c)$ by a positive constant doesn't change the geometry—it's the zero set that matters, not the specific values of the function away from zero.</span>
<span id="cb26-289"><a href="#cb26-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-290"><a href="#cb26-290" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-291"><a href="#cb26-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-292"><a href="#cb26-292" aria-hidden="true" tabindex="-1"></a><span class="fu">## Distance Fields and Circles</span></span>
<span id="cb26-293"><a href="#cb26-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-294"><a href="#cb26-294" aria-hidden="true" tabindex="-1"></a><span class="fu">### Distance to Center</span></span>
<span id="cb26-295"><a href="#cb26-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-296"><a href="#cb26-296" aria-hidden="true" tabindex="-1"></a>The distance from a point $p = (x, y)$ to the origin is just the usual Euclidean distance:</span>
<span id="cb26-297"><a href="#cb26-297" aria-hidden="true" tabindex="-1"></a>$$d = <span class="sc">\|</span>p<span class="sc">\|</span> = \sqrt{x^2 + y^2}$$</span>
<span id="cb26-298"><a href="#cb26-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-299"><a href="#cb26-299" aria-hidden="true" tabindex="-1"></a>In GLSL this is built-in:</span>
<span id="cb26-300"><a href="#cb26-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-301"><a href="#cb26-301" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-302"><a href="#cb26-302" aria-hidden="true" tabindex="-1"></a><span class="in">float d = length(p);</span></span>
<span id="cb26-303"><a href="#cb26-303" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-304"><a href="#cb26-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-305"><a href="#cb26-305" aria-hidden="true" tabindex="-1"></a>The <span class="in">`length()`</span> function computes the Euclidean norm of a vector. It works for <span class="in">`vec2`</span>, <span class="in">`vec3`</span>, <span class="in">`vec4`</span>—whatever you need. Under the hood it's computing the square root of the dot product of the vector with itself, but there's no need to write that out explicitly.</span>
<span id="cb26-306"><a href="#cb26-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-307"><a href="#cb26-307" aria-hidden="true" tabindex="-1"></a><span class="fu">### Filled Circle</span></span>
<span id="cb26-308"><a href="#cb26-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-309"><a href="#cb26-309" aria-hidden="true" tabindex="-1"></a>A circle of radius $r$ centered at the origin is the set $<span class="sc">\{</span>p : <span class="sc">\|</span>p<span class="sc">\|</span> &lt; r<span class="sc">\}</span>$—just points whose distance from the origin is less than $r$. So to color the inside versus outside of a circle, we just compare distances:</span>
<span id="cb26-310"><a href="#cb26-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-311"><a href="#cb26-311" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-312"><a href="#cb26-312" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-313"><a href="#cb26-313" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-314"><a href="#cb26-314" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb26-315"><a href="#cb26-315" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb26-316"><a href="#cb26-316" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb26-317"><a href="#cb26-317" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb26-318"><a href="#cb26-318" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-319"><a href="#cb26-319" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p);</span></span>
<span id="cb26-320"><a href="#cb26-320" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 1.0;</span></span>
<span id="cb26-321"><a href="#cb26-321" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-322"><a href="#cb26-322" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);</span></span>
<span id="cb26-323"><a href="#cb26-323" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-324"><a href="#cb26-324" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-325"><a href="#cb26-325" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-326"><a href="#cb26-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-327"><a href="#cb26-327" aria-hidden="true" tabindex="-1"></a>That's it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it's inside or outside the circle. Simple, elegant, and fast—millions of distance calculations per frame, all happening in parallel.</span>
<span id="cb26-328"><a href="#cb26-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-329"><a href="#cb26-329" aria-hidden="true" tabindex="-1"></a><span class="fu">### Distance-Based Coloring</span></span>
<span id="cb26-330"><a href="#cb26-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-331"><a href="#cb26-331" aria-hidden="true" tabindex="-1"></a>But we don't have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:</span>
<span id="cb26-332"><a href="#cb26-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-333"><a href="#cb26-333" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-334"><a href="#cb26-334" aria-hidden="true" tabindex="-1"></a><span class="in">float d = length(p);</span></span>
<span id="cb26-335"><a href="#cb26-335" aria-hidden="true" tabindex="-1"></a><span class="in">float intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2</span></span>
<span id="cb26-336"><a href="#cb26-336" aria-hidden="true" tabindex="-1"></a><span class="in">intensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]</span></span>
<span id="cb26-337"><a href="#cb26-337" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = vec3(intensity);</span></span>
<span id="cb26-338"><a href="#cb26-338" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-339"><a href="#cb26-339" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-340"><a href="#cb26-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-341"><a href="#cb26-341" aria-hidden="true" tabindex="-1"></a>This creates a radial gradient—bright at the center, dark at the edges. The <span class="in">`clamp`</span> function ensures we stay within $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$ even if our formula would produce values outside that range. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we'll see on Day 4) as the foundation for 3D rendering!</span>
<span id="cb26-342"><a href="#cb26-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-343"><a href="#cb26-343" aria-hidden="true" tabindex="-1"></a>Distance fields will become increasingly important as the week progresses. On Day 4, we'll use them as the foundation for **raymarching**—a technique for rendering 3D geometry without any triangles or polygons, purely by iteratively evaluating distance functions. The <span class="in">`length(p)`</span> function we used for circles today generalizes to arbitrary implicit surfaces: $d(p) = $ "distance to the surface defined by $F(p) = 0$." It's a beautiful connection between analysis and computer graphics.</span>
<span id="cb26-344"><a href="#cb26-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-345"><a href="#cb26-345" aria-hidden="true" tabindex="-1"></a><span class="fu">### Circle Outline</span></span>
<span id="cb26-346"><a href="#cb26-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-347"><a href="#cb26-347" aria-hidden="true" tabindex="-1"></a>What if we want to draw just the *boundary* of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is *approximately equal* to the radius. Mathematically, we're coloring the set $<span class="sc">\{</span>p : |d(p) - r| &lt; \epsilon<span class="sc">\}</span>$ where $\epsilon$ is a small thickness parameter:</span>
<span id="cb26-348"><a href="#cb26-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-349"><a href="#cb26-349" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-350"><a href="#cb26-350" aria-hidden="true" tabindex="-1"></a><span class="in">float d = length(p);</span></span>
<span id="cb26-351"><a href="#cb26-351" aria-hidden="true" tabindex="-1"></a><span class="in">float r = 1.0;</span></span>
<span id="cb26-352"><a href="#cb26-352" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.05;</span></span>
<span id="cb26-353"><a href="#cb26-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-354"><a href="#cb26-354" aria-hidden="true" tabindex="-1"></a><span class="in">float circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb26-355"><a href="#cb26-355" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = vec3(circle_mask);</span></span>
<span id="cb26-356"><a href="#cb26-356" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-357"><a href="#cb26-357" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-358"><a href="#cb26-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-359"><a href="#cb26-359" aria-hidden="true" tabindex="-1"></a>This draws a thin white annulus around the circle. Play with the <span class="in">`thickness`</span> parameter to see how it affects the line width!</span>
<span id="cb26-360"><a href="#cb26-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-361"><a href="#cb26-361" aria-hidden="true" tabindex="-1"></a>For a smoother, anti-aliased edge, GLSL provides <span class="in">`smoothstep`</span>:</span>
<span id="cb26-362"><a href="#cb26-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-363"><a href="#cb26-363" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-364"><a href="#cb26-364" aria-hidden="true" tabindex="-1"></a><span class="in">float circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);</span></span>
<span id="cb26-365"><a href="#cb26-365" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-366"><a href="#cb26-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-367"><a href="#cb26-367" aria-hidden="true" tabindex="-1"></a>The <span class="in">`smoothstep(a, b, x)`</span> function performs smooth Hermite interpolation. For $x \in <span class="co">[</span><span class="ot">a,b</span><span class="co">]</span>$, it returns</span>
<span id="cb26-368"><a href="#cb26-368" aria-hidden="true" tabindex="-1"></a>$$s(t) = 3t^2 - 2t^3 \quad \text{where } t = \frac{x-a}{b-a}$$</span>
<span id="cb26-369"><a href="#cb26-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-370"><a href="#cb26-370" aria-hidden="true" tabindex="-1"></a>This is a cubic polynomial with $s(0) = 0$, $s(1) = 1$, and crucially $s'(0) = s'(1) = 0$—the zero derivatives at the endpoints mean it transitions smoothly without visible "kinks." For $x &lt; a$ it returns $0$, for $x &gt; b$ it returns $1$.</span>
<span id="cb26-371"><a href="#cb26-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-372"><a href="#cb26-372" aria-hidden="true" tabindex="-1"></a>The result is anti-aliasing: instead of a hard transition at a single pixel, the edge is blurred over the interval $<span class="co">[</span><span class="ot">a,b</span><span class="co">]</span>$. For circle outlines, using <span class="in">`smoothstep(r - thickness, r + thickness, d)`</span> creates a smooth transition zone of width $2 \cdot \text{thickness}$ around the target radius. This eliminates jagged edges and makes the circle look much nicer—especially important when you're creating publication-quality mathematical illustrations!</span>
<span id="cb26-373"><a href="#cb26-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-374"><a href="#cb26-374" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb26-375"><a href="#cb26-375" aria-hidden="true" tabindex="-1"></a><span class="fu">## Anti-aliasing in shaders</span></span>
<span id="cb26-376"><a href="#cb26-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-377"><a href="#cb26-377" aria-hidden="true" tabindex="-1"></a>The harsh cutoffs from using <span class="in">`&lt;`</span> or the ternary operator create jagged, pixelated edges—what computer graphics people call "aliasing" (the signal is being undersampled relative to its frequency content, creating artifacts). Functions like <span class="in">`smoothstep`</span> give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We'll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with <span class="in">`smoothstep`</span> for smoother results.</span>
<span id="cb26-378"><a href="#cb26-378" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-379"><a href="#cb26-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-380"><a href="#cb26-380" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-381"><a href="#cb26-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-382"><a href="#cb26-382" aria-hidden="true" tabindex="-1"></a><span class="fu">## Grids and Repetition</span></span>
<span id="cb26-383"><a href="#cb26-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-384"><a href="#cb26-384" aria-hidden="true" tabindex="-1"></a><span class="fu">### Modular Arithmetic</span></span>
<span id="cb26-385"><a href="#cb26-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-386"><a href="#cb26-386" aria-hidden="true" tabindex="-1"></a>The modulo operation creates periodic repetition. For a period $T$, the function $p \mapsto (p \bmod T) - T/2$ maps $\mathbb{R}$ to $<span class="co">[</span><span class="ot">-T/2, T/2</span><span class="co">]</span>$ repeatedly—it "folds" the entire real line into a finite interval over and over again.</span>
<span id="cb26-387"><a href="#cb26-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-388"><a href="#cb26-388" aria-hidden="true" tabindex="-1"></a>More precisely, recall that $x \bmod T$ is the unique value in $<span class="co">[</span><span class="ot">0, T)$ satisfying $x \equiv r \pmod{T}$—that is, $x = nT + r$ for some integer $n$. Geometrically, this takes the real line and wraps it into the interval $[0,T)$. Subtracting $T/2$ recenters this to $[-T/2, T/2</span><span class="co">]</span>$.</span>
<span id="cb26-389"><a href="#cb26-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-390"><a href="#cb26-390" aria-hidden="true" tabindex="-1"></a>In GLSL, <span class="in">`mod(x, T)`</span> computes $x \bmod T$. This is one of the most powerful tools in shader programming!</span>
<span id="cb26-391"><a href="#cb26-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-392"><a href="#cb26-392" aria-hidden="true" tabindex="-1"></a><span class="fu">### Creating a Grid</span></span>
<span id="cb26-393"><a href="#cb26-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-394"><a href="#cb26-394" aria-hidden="true" tabindex="-1"></a>To create a grid of repeated cells, we apply <span class="in">`mod`</span> to our coordinates:</span>
<span id="cb26-395"><a href="#cb26-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-396"><a href="#cb26-396" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-397"><a href="#cb26-397" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-398"><a href="#cb26-398" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-399"><a href="#cb26-399" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb26-400"><a href="#cb26-400" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb26-401"><a href="#cb26-401" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb26-402"><a href="#cb26-402" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb26-403"><a href="#cb26-403" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-404"><a href="#cb26-404" aria-hidden="true" tabindex="-1"></a><span class="in">    float spacing = 1.0;</span></span>
<span id="cb26-405"><a href="#cb26-405" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;</span></span>
<span id="cb26-406"><a href="#cb26-406" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-407"><a href="#cb26-407" aria-hidden="true" tabindex="-1"></a><span class="in">    // Now cell_p repeats every spacing units</span></span>
<span id="cb26-408"><a href="#cb26-408" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw a circle in each cell</span></span>
<span id="cb26-409"><a href="#cb26-409" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(cell_p);</span></span>
<span id="cb26-410"><a href="#cb26-410" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 0.3;</span></span>
<span id="cb26-411"><a href="#cb26-411" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-412"><a href="#cb26-412" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);</span></span>
<span id="cb26-413"><a href="#cb26-413" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-414"><a href="#cb26-414" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-415"><a href="#cb26-415" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-416"><a href="#cb26-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-417"><a href="#cb26-417" aria-hidden="true" tabindex="-1"></a>This creates an infinite grid of yellow circles! The coordinate transformation <span class="in">`cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0`</span> ensures that <span class="in">`cell_p`</span> is always in the range $<span class="co">[</span><span class="ot">-\text{spacing}/2, \text{spacing}/2</span><span class="co">]</span>$, and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.</span>
<span id="cb26-418"><a href="#cb26-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-419"><a href="#cb26-419" aria-hidden="true" tabindex="-1"></a>Think about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There's no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation. </span>
<span id="cb26-420"><a href="#cb26-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-421"><a href="#cb26-421" aria-hidden="true" tabindex="-1"></a>Compare this to how you might approach this in Python or MATLAB: you'd probably set up a nested loop over grid cells, compute the center of each cell, then draw a circle there. That's $O(n^2)$ work for an $n \times n$ grid. With shaders, it's $O(1)$ in the grid size—the cost is entirely in the number of *pixels*, not the number of *circles*. This is why shaders can render infinitely complex patterns at the same framerate as simple ones.</span>
<span id="cb26-422"><a href="#cb26-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-423"><a href="#cb26-423" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb26-424"><a href="#cb26-424" aria-hidden="true" tabindex="-1"></a><span class="fu">## The power of `mod`</span></span>
<span id="cb26-425"><a href="#cb26-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-426"><a href="#cb26-426" aria-hidden="true" tabindex="-1"></a>This computational efficiency through coordinate transformations is a recurring theme in shader programming. You'll see it again when we talk about domain repetition for fractals (Day 2), symmetry groups for hyperbolic tilings (Day 3), and space folding for raymarched scenes (Day 4). The key insight is always the same: instead of explicitly iterating over instances, transform the coordinate system so that all instances share the same local coordinates.</span>
<span id="cb26-427"><a href="#cb26-427" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-428"><a href="#cb26-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-429"><a href="#cb26-429" aria-hidden="true" tabindex="-1"></a><span class="fu">### Alternating Pattern</span></span>
<span id="cb26-430"><a href="#cb26-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-431"><a href="#cb26-431" aria-hidden="true" tabindex="-1"></a>We can create checkerboard-like patterns by using the *cell index* to vary colors. To get the cell index, we divide by the spacing and floor:</span>
<span id="cb26-432"><a href="#cb26-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-433"><a href="#cb26-433" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-434"><a href="#cb26-434" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cell_id = floor(p / spacing);</span></span>
<span id="cb26-435"><a href="#cb26-435" aria-hidden="true" tabindex="-1"></a><span class="in">float checker = mod(cell_id.x + cell_id.y, 2.0);</span></span>
<span id="cb26-436"><a href="#cb26-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-437"><a href="#cb26-437" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color_a = vec3(1.0, 0.0, 0.0);</span></span>
<span id="cb26-438"><a href="#cb26-438" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color_b = vec3(0.0, 0.0, 1.0);</span></span>
<span id="cb26-439"><a href="#cb26-439" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 bg_color = mix(color_a, color_b, checker);</span></span>
<span id="cb26-440"><a href="#cb26-440" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-441"><a href="#cb26-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-442"><a href="#cb26-442" aria-hidden="true" tabindex="-1"></a>Here <span class="in">`floor(p / spacing)`</span> gives us integer grid indices $(i, j)$, and we alternate colors based on the parity of $i + j$. When $i + j$ is even, <span class="in">`checker = 0`</span> (giving us <span class="in">`color_a`</span>), when odd, <span class="in">`checker = 1`</span> (giving us <span class="in">`color_b`</span>).</span>
<span id="cb26-443"><a href="#cb26-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-444"><a href="#cb26-444" aria-hidden="true" tabindex="-1"></a>Notice the elegant separation: <span class="in">`cell_id`</span> tells us *which* cell we're in, while `cell_p` tells us *where within* that cell. This separation of global position and local coordinates is fundamental to working with repeating patterns.</span>
<span id="cb26-445"><a href="#cb26-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-446"><a href="#cb26-446" aria-hidden="true" tabindex="-1"></a><span class="fu">### Combining with Circles</span></span>
<span id="cb26-447"><a href="#cb26-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-448"><a href="#cb26-448" aria-hidden="true" tabindex="-1"></a>Let's put it all together—a grid of circles on an alternating background:</span>
<span id="cb26-449"><a href="#cb26-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-450"><a href="#cb26-450" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-451"><a href="#cb26-451" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-452"><a href="#cb26-452" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-453"><a href="#cb26-453" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb26-454"><a href="#cb26-454" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb26-455"><a href="#cb26-455" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb26-456"><a href="#cb26-456" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb26-457"><a href="#cb26-457" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-458"><a href="#cb26-458" aria-hidden="true" tabindex="-1"></a><span class="in">    float spacing = 1.0;</span></span>
<span id="cb26-459"><a href="#cb26-459" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_id = floor(p / spacing);</span></span>
<span id="cb26-460"><a href="#cb26-460" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;</span></span>
<span id="cb26-461"><a href="#cb26-461" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-462"><a href="#cb26-462" aria-hidden="true" tabindex="-1"></a><span class="in">    // Checkerboard background</span></span>
<span id="cb26-463"><a href="#cb26-463" aria-hidden="true" tabindex="-1"></a><span class="in">    float checker = mod(cell_id.x + cell_id.y, 2.0);</span></span>
<span id="cb26-464"><a href="#cb26-464" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);</span></span>
<span id="cb26-465"><a href="#cb26-465" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-466"><a href="#cb26-466" aria-hidden="true" tabindex="-1"></a><span class="in">    // Circle in each cell</span></span>
<span id="cb26-467"><a href="#cb26-467" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(cell_p);</span></span>
<span id="cb26-468"><a href="#cb26-468" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 0.3;</span></span>
<span id="cb26-469"><a href="#cb26-469" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 circle_color = vec3(1.0, 1.0, 0.0);</span></span>
<span id="cb26-470"><a href="#cb26-470" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-471"><a href="#cb26-471" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (d &lt; r) ? circle_color : bg_color;</span></span>
<span id="cb26-472"><a href="#cb26-472" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-473"><a href="#cb26-473" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-474"><a href="#cb26-474" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-475"><a href="#cb26-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-476"><a href="#cb26-476" aria-hidden="true" tabindex="-1"></a>Try varying the <span class="in">`spacing`</span> and <span class="in">`r`</span> parameters. What happens if you make the circles larger than the cells? (They overlap across cell boundaries!) What if you use different spacing values for <span class="in">`x`</span> and <span class="in">`y`</span>? (You get a rectangular rather than square lattice.) This simple framework is incredibly flexible.</span>
<span id="cb26-477"><a href="#cb26-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-478"><a href="#cb26-478" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-479"><a href="#cb26-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-480"><a href="#cb26-480" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implicit Curves</span></span>
<span id="cb26-481"><a href="#cb26-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-482"><a href="#cb26-482" aria-hidden="true" tabindex="-1"></a><span class="fu">### General Principle</span></span>
<span id="cb26-483"><a href="#cb26-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-484"><a href="#cb26-484" aria-hidden="true" tabindex="-1"></a>An implicit curve is defined by an equation $F(x, y) = 0$. Points on the curve satisfy the equation exactly, while points off the curve have $F(x,y) \neq 0$. To render the curve, we compute $F(p)$ for each pixel and color based on proximity to zero:</span>
<span id="cb26-485"><a href="#cb26-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-486"><a href="#cb26-486" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-487"><a href="#cb26-487" aria-hidden="true" tabindex="-1"></a><span class="in">float F = [some function of p.x and p.y];</span></span>
<span id="cb26-488"><a href="#cb26-488" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.05;</span></span>
<span id="cb26-489"><a href="#cb26-489" aria-hidden="true" tabindex="-1"></a><span class="in">float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb26-490"><a href="#cb26-490" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = mix(background, curve_color, curve_mask);</span></span>
<span id="cb26-491"><a href="#cb26-491" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-492"><a href="#cb26-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-493"><a href="#cb26-493" aria-hidden="true" tabindex="-1"></a>This is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, transcendental curves, whatever you want. If you can write down a formula $F(x,y)$, you can visualize its zero set.</span>
<span id="cb26-494"><a href="#cb26-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-495"><a href="#cb26-495" aria-hidden="true" tabindex="-1"></a><span class="fu">### Example: Parabola</span></span>
<span id="cb26-496"><a href="#cb26-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-497"><a href="#cb26-497" aria-hidden="true" tabindex="-1"></a>The parabola $y = x^2$ can be written implicitly as $F(x, y) = y - x^2 = 0$:</span>
<span id="cb26-498"><a href="#cb26-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-499"><a href="#cb26-499" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-500"><a href="#cb26-500" aria-hidden="true" tabindex="-1"></a><span class="in">float F = p.y - p.x * p.x;</span></span>
<span id="cb26-501"><a href="#cb26-501" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.1;</span></span>
<span id="cb26-502"><a href="#cb26-502" aria-hidden="true" tabindex="-1"></a><span class="in">float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb26-503"><a href="#cb26-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-504"><a href="#cb26-504" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);</span></span>
<span id="cb26-505"><a href="#cb26-505" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-506"><a href="#cb26-506" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-507"><a href="#cb26-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-508"><a href="#cb26-508" aria-hidden="true" tabindex="-1"></a>You should see a yellow parabola on a dark blue background. The curve appears wherever $|F(x,y)| &lt; 0.1$—a thin band around the zero set of $F$.</span>
<span id="cb26-509"><a href="#cb26-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-510"><a href="#cb26-510" aria-hidden="true" tabindex="-1"></a>One thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker, while in the steep regions it appears thinner. Why does this happen?</span>
<span id="cb26-511"><a href="#cb26-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-512"><a href="#cb26-512" aria-hidden="true" tabindex="-1"></a>We're thresholding on the *value* of $F$, not the *geometric distance* to the curve. Near the vertex at $(0,0)$, the parabola is nearly horizontal—small changes in $y$ correspond to small changes in $x$, so the set $<span class="sc">\{</span>p : |y - x^2| &lt; \epsilon<span class="sc">\}</span>$ is a thick vertical band. But on the steep parts where $|x|$ is large, the parabola is nearly vertical—now the same change in $y$ corresponds to a large change in $x$, so the band is thin.</span>
<span id="cb26-513"><a href="#cb26-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-514"><a href="#cb26-514" aria-hidden="true" tabindex="-1"></a>To see this more precisely, consider the gradient: $\nabla F = (-2x, 1)$. Near the vertex this has magnitude close to $1$, but for large $|x|$ it has magnitude approximately $2|x|$. The visual thickness is roughly inversely proportional to $|\nabla F|$—where the gradient is small, the level sets are far apart, and where it's large, they're close together.</span>
<span id="cb26-515"><a href="#cb26-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-516"><a href="#cb26-516" aria-hidden="true" tabindex="-1"></a>To get uniform thickness, we'd need the *signed distance function* to the curve: </span>
<span id="cb26-517"><a href="#cb26-517" aria-hidden="true" tabindex="-1"></a>$$d(p) = \inf<span class="sc">\{\|</span>p - q<span class="sc">\|</span> : F(q) = 0<span class="sc">\}</span>$$</span>
<span id="cb26-518"><a href="#cb26-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-519"><a href="#cb26-519" aria-hidden="true" tabindex="-1"></a>Then thresholding on $|d(p)| &lt; \epsilon$ gives exactly thickness $\epsilon$ everywhere. Computing exact signed distance functions is nontrivial (we'll see techniques for this on Day 4 when we discuss raymarching), but for many applications the naive thresholding on $|F|$ works fine—especially if you tune the thickness parameter appropriately or use different thickness values in different regions.</span>
<span id="cb26-520"><a href="#cb26-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-521"><a href="#cb26-521" aria-hidden="true" tabindex="-1"></a><span class="fu">### Example: Circle (Implicit Form)</span></span>
<span id="cb26-522"><a href="#cb26-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-523"><a href="#cb26-523" aria-hidden="true" tabindex="-1"></a>We've been using $<span class="sc">\|</span>p<span class="sc">\|</span> &lt; r$ for filled circles, but we can also write the circle implicitly as $x^2 + y^2 - r^2 = 0$:</span>
<span id="cb26-524"><a href="#cb26-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-525"><a href="#cb26-525" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-526"><a href="#cb26-526" aria-hidden="true" tabindex="-1"></a><span class="in">float r = 1.0;</span></span>
<span id="cb26-527"><a href="#cb26-527" aria-hidden="true" tabindex="-1"></a><span class="in">float F = dot(p, p) - r * r;  // dot(p,p) = x² + y²</span></span>
<span id="cb26-528"><a href="#cb26-528" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.1;</span></span>
<span id="cb26-529"><a href="#cb26-529" aria-hidden="true" tabindex="-1"></a><span class="in">float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb26-530"><a href="#cb26-530" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-531"><a href="#cb26-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-532"><a href="#cb26-532" aria-hidden="true" tabindex="-1"></a>This is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The <span class="in">`dot(p, p)`</span> computes $x^2 + y^2$ as a single GPU operation—more efficient than <span class="in">`p.x * p.x + p.y * p.y`</span> and certainly cleaner than writing it out! For circles, the signed distance function and the implicit function are particularly closely related: $d(p) = |<span class="sc">\|</span>p<span class="sc">\|</span> - r|$, so the naive implicit approach actually works quite well.</span>
<span id="cb26-533"><a href="#cb26-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-534"><a href="#cb26-534" aria-hidden="true" tabindex="-1"></a><span class="fu">### More Examples</span></span>
<span id="cb26-535"><a href="#cb26-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-536"><a href="#cb26-536" aria-hidden="true" tabindex="-1"></a>Let's look at a few more interesting curves:</span>
<span id="cb26-537"><a href="#cb26-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-538"><a href="#cb26-538" aria-hidden="true" tabindex="-1"></a>**Hyperbola**: $xy = 1$</span>
<span id="cb26-539"><a href="#cb26-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-540"><a href="#cb26-540" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-541"><a href="#cb26-541" aria-hidden="true" tabindex="-1"></a><span class="in">float F = p.x * p.y - 1.0;</span></span>
<span id="cb26-542"><a href="#cb26-542" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-543"><a href="#cb26-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-544"><a href="#cb26-544" aria-hidden="true" tabindex="-1"></a>**Ellipse**: $\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1$</span>
<span id="cb26-545"><a href="#cb26-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-546"><a href="#cb26-546" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-547"><a href="#cb26-547" aria-hidden="true" tabindex="-1"></a><span class="in">float a = 2.0, b = 1.0;</span></span>
<span id="cb26-548"><a href="#cb26-548" aria-hidden="true" tabindex="-1"></a><span class="in">float F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;</span></span>
<span id="cb26-549"><a href="#cb26-549" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-550"><a href="#cb26-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-551"><a href="#cb26-551" aria-hidden="true" tabindex="-1"></a>**Lemniscate of Bernoulli**: $(x^2 + y^2)^2 = a^2(x^2 - y^2)$</span>
<span id="cb26-552"><a href="#cb26-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-553"><a href="#cb26-553" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-554"><a href="#cb26-554" aria-hidden="true" tabindex="-1"></a><span class="in">float a = 1.0;</span></span>
<span id="cb26-555"><a href="#cb26-555" aria-hidden="true" tabindex="-1"></a><span class="in">float r2 = dot(p, p);</span></span>
<span id="cb26-556"><a href="#cb26-556" aria-hidden="true" tabindex="-1"></a><span class="in">float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);</span></span>
<span id="cb26-557"><a href="#cb26-557" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-558"><a href="#cb26-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-559"><a href="#cb26-559" aria-hidden="true" tabindex="-1"></a>Each of these creates beautiful curves! Try implementing them and experimenting with different parameters.</span>
<span id="cb26-560"><a href="#cb26-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-561"><a href="#cb26-561" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb26-562"><a href="#cb26-562" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implicit curves in your homework</span></span>
<span id="cb26-563"><a href="#cb26-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-564"><a href="#cb26-564" aria-hidden="true" tabindex="-1"></a>When you're implementing the parabola graphing calculator for homework, you'll use this exact implicit curve technique. The key is setting up the equation $F(x,y) = y - (ax^2 + bx + c)$ and thresholding on $|F| &lt; \epsilon$. Make sure to test with various values of $a$, $b$, $c$ to ensure your grapher is robust!</span>
<span id="cb26-565"><a href="#cb26-565" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-566"><a href="#cb26-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-567"><a href="#cb26-567" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-568"><a href="#cb26-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-569"><a href="#cb26-569" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb26-570"><a href="#cb26-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-571"><a href="#cb26-571" aria-hidden="true" tabindex="-1"></a>Today we've learned the fundamental tools of shader programming:</span>
<span id="cb26-572"><a href="#cb26-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-573"><a href="#cb26-573" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Shaders as parallel functions**: Every pixel evaluates $f(x, y, t, \ldots) \to \text{color}$ simultaneously—no loops required! The computational model is fundamentally different from sequential CPU programming.</span>
<span id="cb26-574"><a href="#cb26-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-575"><a href="#cb26-575" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**GLSL basics**: Syntax rules (semicolons, <span class="in">`.0`</span> for floats), vector types (<span class="in">`vec2`</span>, <span class="in">`vec3`</span>, <span class="in">`vec4`</span>), and essential built-in functions like <span class="in">`length()`</span>, <span class="in">`dot()`</span>, <span class="in">`step()`</span>, and <span class="in">`smoothstep()`</span></span>
<span id="cb26-576"><a href="#cb26-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-577"><a href="#cb26-577" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Coordinate systems**: The four-step transformation (normalize, center, aspect-correct, scale) that takes us from pixel coordinates to a mathematical coordinate system suitable for visualization</span>
<span id="cb26-578"><a href="#cb26-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-579"><a href="#cb26-579" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Conditional coloring**: Using boolean expressions, the ternary operator, and <span class="in">`step()`</span> combined with <span class="in">`mix()`</span> to create discrete color regions based on mathematical predicates</span>
<span id="cb26-580"><a href="#cb26-580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-581"><a href="#cb26-581" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Distance fields**: Using <span class="in">`length()`</span> to create circles and radial patterns—the foundation for much more complex techniques we'll explore on Day 4 with raymarching</span>
<span id="cb26-582"><a href="#cb26-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-583"><a href="#cb26-583" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**Modular arithmetic**: Creating grids and repeating patterns with <span class="in">`mod()`</span>—achieving infinite complexity with finite computation through coordinate transformations rather than explicit iteration</span>
<span id="cb26-584"><a href="#cb26-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-585"><a href="#cb26-585" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**Implicit curves**: Rendering curves defined by $F(x, y) = 0$ by thresholding on $|F|$—a general technique that works for any curve we can express as an equation, though we must be aware of the non-uniform thickness issue</span>
<span id="cb26-586"><a href="#cb26-586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-587"><a href="#cb26-587" aria-hidden="true" tabindex="-1"></a>With these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we'll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we've established today.</span>
<span id="cb26-588"><a href="#cb26-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-589"><a href="#cb26-589" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-590"><a href="#cb26-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-591"><a href="#cb26-591" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb26-592"><a href="#cb26-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-593"><a href="#cb26-593" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Parabola Graphing Calculator</span></span>
<span id="cb26-594"><a href="#cb26-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-595"><a href="#cb26-595" aria-hidden="true" tabindex="-1"></a>Create a shader that draws a customizable parabola $y = ax^2 + bx + c$ along with coordinate axes.</span>
<span id="cb26-596"><a href="#cb26-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-597"><a href="#cb26-597" aria-hidden="true" tabindex="-1"></a>**Requirements:**</span>
<span id="cb26-598"><a href="#cb26-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-599"><a href="#cb26-599" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Define variables <span class="in">`a`</span>, <span class="in">`b`</span>, <span class="in">`c`</span> at the top of your shader (hardcoded values are fine—we're not building a GUI yet)</span>
<span id="cb26-600"><a href="#cb26-600" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Draw the $x$-axis and $y$-axis as thin lines using the implicit line technique: $|y| &lt; \epsilon$ for the $x$-axis, $|x| &lt; \epsilon$ for the $y$-axis</span>
<span id="cb26-601"><a href="#cb26-601" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Plot the parabola $y = ax^2 + bx + c$ as a thicker curve</span>
<span id="cb26-602"><a href="#cb26-602" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Use distinct colors for axes (suggest a neutral gray) and parabola (suggest something bright)</span>
<span id="cb26-603"><a href="#cb26-603" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The visualization should work for any reasonable values of $a$, $b$, $c$—make sure to test edge cases!</span>
<span id="cb26-604"><a href="#cb26-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-605"><a href="#cb26-605" aria-hidden="true" tabindex="-1"></a>**What it should look like:** A coordinate plane with thin gray axes, and a colored curve tracing out your parabola. The entire parabola should be visible in your viewing window (you may need to adjust your scaling factor depending on your parameters). </span>
<span id="cb26-606"><a href="#cb26-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-607"><a href="#cb26-607" aria-hidden="true" tabindex="-1"></a>**Test cases to verify:** </span>
<span id="cb26-608"><a href="#cb26-608" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$a=1, b=0, c=0$ (standard parabola opening upward)</span>
<span id="cb26-609"><a href="#cb26-609" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$a=-1, b=0, c=1$ (downward-opening parabola shifted up)</span>
<span id="cb26-610"><a href="#cb26-610" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$a=0.5, b=1, c=-0.5$ (general case with all parameters nonzero)</span>
<span id="cb26-611"><a href="#cb26-611" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$a=0, b=1, c=0$ (degenerate case—just a line! Your code should handle this gracefully)</span>
<span id="cb26-612"><a href="#cb26-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-613"><a href="#cb26-613" aria-hidden="true" tabindex="-1"></a>**Suggested approach:**</span>
<span id="cb26-614"><a href="#cb26-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-615"><a href="#cb26-615" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb26-616"><a href="#cb26-616" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb26-617"><a href="#cb26-617" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb26-618"><a href="#cb26-618" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb26-619"><a href="#cb26-619" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb26-620"><a href="#cb26-620" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb26-621"><a href="#cb26-621" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb26-622"><a href="#cb26-622" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;</span></span>
<span id="cb26-623"><a href="#cb26-623" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-624"><a href="#cb26-624" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define parameters</span></span>
<span id="cb26-625"><a href="#cb26-625" aria-hidden="true" tabindex="-1"></a><span class="in">    float a = 1.0;</span></span>
<span id="cb26-626"><a href="#cb26-626" aria-hidden="true" tabindex="-1"></a><span class="in">    float b = 0.0;</span></span>
<span id="cb26-627"><a href="#cb26-627" aria-hidden="true" tabindex="-1"></a><span class="in">    float c = 0.0;</span></span>
<span id="cb26-628"><a href="#cb26-628" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-629"><a href="#cb26-629" aria-hidden="true" tabindex="-1"></a><span class="in">    // Background</span></span>
<span id="cb26-630"><a href="#cb26-630" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.1, 0.1, 0.15);</span></span>
<span id="cb26-631"><a href="#cb26-631" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-632"><a href="#cb26-632" aria-hidden="true" tabindex="-1"></a><span class="in">    // Axes</span></span>
<span id="cb26-633"><a href="#cb26-633" aria-hidden="true" tabindex="-1"></a><span class="in">    float axis_thickness = 0.02;</span></span>
<span id="cb26-634"><a href="#cb26-634" aria-hidden="true" tabindex="-1"></a><span class="in">    float x_axis_mask = abs(p.y) &lt; axis_thickness ? 1.0 : 0.0;</span></span>
<span id="cb26-635"><a href="#cb26-635" aria-hidden="true" tabindex="-1"></a><span class="in">    float y_axis_mask = abs(p.x) &lt; axis_thickness ? 1.0 : 0.0;</span></span>
<span id="cb26-636"><a href="#cb26-636" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 axis_color = vec3(0.3, 0.3, 0.3);</span></span>
<span id="cb26-637"><a href="#cb26-637" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-638"><a href="#cb26-638" aria-hidden="true" tabindex="-1"></a><span class="in">    // Parabola: F(x,y) = y - (ax² + bx + c) = 0</span></span>
<span id="cb26-639"><a href="#cb26-639" aria-hidden="true" tabindex="-1"></a><span class="in">    float F = p.y - (a * p.x * p.x + b * p.x + c);</span></span>
<span id="cb26-640"><a href="#cb26-640" aria-hidden="true" tabindex="-1"></a><span class="in">    float curve_thickness = 0.08;</span></span>
<span id="cb26-641"><a href="#cb26-641" aria-hidden="true" tabindex="-1"></a><span class="in">    float parabola_mask = abs(F) &lt; curve_thickness ? 1.0 : 0.0;</span></span>
<span id="cb26-642"><a href="#cb26-642" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 parabola_color = vec3(1.0, 0.8, 0.0);</span></span>
<span id="cb26-643"><a href="#cb26-643" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-644"><a href="#cb26-644" aria-hidden="true" tabindex="-1"></a><span class="in">    // Combine (axes behind parabola)</span></span>
<span id="cb26-645"><a href="#cb26-645" aria-hidden="true" tabindex="-1"></a><span class="in">    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));</span></span>
<span id="cb26-646"><a href="#cb26-646" aria-hidden="true" tabindex="-1"></a><span class="in">    color = mix(color, parabola_color, parabola_mask);</span></span>
<span id="cb26-647"><a href="#cb26-647" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb26-648"><a href="#cb26-648" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb26-649"><a href="#cb26-649" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb26-650"><a href="#cb26-650" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-651"><a href="#cb26-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-652"><a href="#cb26-652" aria-hidden="true" tabindex="-1"></a>Try different values of $a$, $b$, $c$ and verify your grapher works correctly! What happens with negative $a$? What about $b \neq 0$? Make sure the axes and parabola remain visible for all parameter values you try. If the parabola goes off-screen, you may need to adjust your coordinate scaling in the setup.</span>
<span id="cb26-653"><a href="#cb26-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-654"><a href="#cb26-654" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #1: Animated Curve Family</span></span>
<span id="cb26-655"><a href="#cb26-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-656"><a href="#cb26-656" aria-hidden="true" tabindex="-1"></a>Create a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build geometric intuition!</span>
<span id="cb26-657"><a href="#cb26-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-658"><a href="#cb26-658" aria-hidden="true" tabindex="-1"></a>**Easier options:**</span>
<span id="cb26-659"><a href="#cb26-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-660"><a href="#cb26-660" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Circle family**: Draw circles of varying radii: $x^2 + y^2 = r^2$ where $r = 1 + 0.5\sin(\text{iTime})$. Simple but mesmerizing!</span>
<span id="cb26-661"><a href="#cb26-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-662"><a href="#cb26-662" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Rotating ellipse**: $(x\cos\theta + y\sin\theta)^2/a^2 + (-x\sin\theta + y\cos\theta)^2/b^2 = 1$ with $\theta = \text{iTime}$. Watch an ellipse rotate continuously.</span>
<span id="cb26-663"><a href="#cb26-663" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-664"><a href="#cb26-664" aria-hidden="true" tabindex="-1"></a>**More challenging options:**</span>
<span id="cb26-665"><a href="#cb26-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-666"><a href="#cb26-666" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Lissajous curves**: Use parametric equations $x = A\sin(at + \delta)$, $y = B\sin(bt)$ and animate $\delta$ with <span class="in">`iTime`</span>. To render a parametric curve implicitly, you'll need to be clever—one approach is to sample many points along the curve and draw circles at each point (we'll learn better techniques for this later).</span>
<span id="cb26-667"><a href="#cb26-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-668"><a href="#cb26-668" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Cassini ovals**: $(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4$. Fix $c = 1$ and vary $a$ with <span class="in">`iTime`</span>. Watch the curve transition from two separate loops to a single figure-eight-like shape as $a$ passes through the critical value $a = c$!</span>
<span id="cb26-669"><a href="#cb26-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-670"><a href="#cb26-670" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Cubic curves**: Take $y^2 = x^3 + ax + b$ and vary one parameter with <span class="in">`iTime`</span>. The topology of the curve changes dramatically as you pass through singular values—this is the beginning of the theory of elliptic curves!</span>
<span id="cb26-671"><a href="#cb26-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-672"><a href="#cb26-672" aria-hidden="true" tabindex="-1"></a>Use <span class="in">`iTime`</span> creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes (these are the singularities of the family)!</span>
<span id="cb26-673"><a href="#cb26-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-674"><a href="#cb26-674" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #2: Beautiful Tiling Pattern</span></span>
<span id="cb26-675"><a href="#cb26-675" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-676"><a href="#cb26-676" aria-hidden="true" tabindex="-1"></a>Design an aesthetically pleasing tiling pattern using the <span class="in">`mod()`</span> technique. This is your chance to be creative and make something visually striking!</span>
<span id="cb26-677"><a href="#cb26-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-678"><a href="#cb26-678" aria-hidden="true" tabindex="-1"></a>**Requirements:**</span>
<span id="cb26-679"><a href="#cb26-679" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-680"><a href="#cb26-680" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Create a non-trivial pattern within a fundamental domain (a single tile)</span>
<span id="cb26-681"><a href="#cb26-681" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Use <span class="in">`mod()`</span> to repeat it across the plane</span>
<span id="cb26-682"><a href="#cb26-682" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The pattern should tile seamlessly—edges must match up so there are no visible discontinuities at tile boundaries</span>
<span id="cb26-683"><a href="#cb26-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-684"><a href="#cb26-684" aria-hidden="true" tabindex="-1"></a>**Ideas to get you started:**</span>
<span id="cb26-685"><a href="#cb26-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-686"><a href="#cb26-686" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Geometric patterns**: Nested circles, polygons approximated by implicit curves, star shapes using angular coordinates</span>
<span id="cb26-687"><a href="#cb26-687" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Color gradients**: Use <span class="in">`cell_id`</span> to vary colors smoothly across tiles, creating large-scale gradient effects superimposed on the local pattern</span>
<span id="cb26-688"><a href="#cb26-688" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Multiple implicit curves**: Combine several curves within each tile using boolean operations (intersection, union, etc.)</span>
<span id="cb26-689"><a href="#cb26-689" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Symmetry**: Use <span class="in">`abs()`</span> to create reflections within tiles—this is a simple way to get complex patterns with built-in symmetry</span>
<span id="cb26-690"><a href="#cb26-690" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Distance-based effects**: Make features pulse or fade based on <span class="in">`iTime`</span> and their position in the grid—create waves propagating across the tiling</span>
<span id="cb26-691"><a href="#cb26-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-692"><a href="#cb26-692" aria-hidden="true" tabindex="-1"></a>**Advanced challenge**: Can you create a pattern that has different symmetries in different tiles? For example, alternate between rotational and reflectional symmetry using the checkerboard <span class="in">`cell_id`</span> technique. Or create a pattern where the colors vary smoothly across the entire infinite tiling, creating a large-scale gradient effect that's independent of the tile boundaries?</span>
<span id="cb26-693"><a href="#cb26-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-694"><a href="#cb26-694" aria-hidden="true" tabindex="-1"></a>Think about Islamic geometric patterns, Escher tilings, or quasiperiodic tilings (though true quasiperiodicity requires techniques beyond simple <span class="in">`mod`</span>—we'll see that on Day 3!). The goal is to create something mathematically interesting and visually beautiful.</span>
<span id="cb26-695"><a href="#cb26-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-696"><a href="#cb26-696" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb26-697"><a href="#cb26-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-698"><a href="#cb26-698" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking Ahead</span></span>
<span id="cb26-699"><a href="#cb26-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-700"><a href="#cb26-700" aria-hidden="true" tabindex="-1"></a>Tomorrow we'll use these techniques to explore **complex dynamics** and **geometric transformations**:</span>
<span id="cb26-701"><a href="#cb26-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-702"><a href="#cb26-702" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Mandelbrot and Julia sets**: Using the implicit curve technique to visualize the boundary of escape sets for complex iteration</span>
<span id="cb26-703"><a href="#cb26-703" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Circle inversions**: A geometric transformation that takes lines and circles to lines and circles, creating beautiful fractal-like patterns</span>
<span id="cb26-704"><a href="#cb26-704" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Apollonian gasket**: An infinite packing of circles constructed via repeated inversions—a stunning example of how simple geometric rules create intricate structures</span>
<span id="cb26-705"><a href="#cb26-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-706"><a href="#cb26-706" aria-hidden="true" tabindex="-1"></a>The coordinate systems, distance fields, and implicit curve techniques you've learned today will be the foundation for everything to come. Make sure you're comfortable with:</span>
<span id="cb26-707"><a href="#cb26-707" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-708"><a href="#cb26-708" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Setting up coordinates (the standard four-step transformation from <span class="in">`fragCoord`</span> to centered, aspect-corrected <span class="in">`p`</span>)</span>
<span id="cb26-709"><a href="#cb26-709" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Computing distances with <span class="in">`length()`</span> and dot products</span>
<span id="cb26-710"><a href="#cb26-710" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Using <span class="in">`mod()`</span> for repetition and understanding the separation of global <span class="in">`cell_id`</span> and local <span class="in">`cell_p`</span></span>
<span id="cb26-711"><a href="#cb26-711" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Conditionally coloring based on mathematical expressions, using both explicit conditionals and smooth interpolation with <span class="in">`smoothstep`</span></span>
<span id="cb26-712"><a href="#cb26-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-713"><a href="#cb26-713" aria-hidden="true" tabindex="-1"></a>If any of these feel shaky, now is the time to practice! Work through the homework problems, experiment with variations, and make sure you understand not just *how* the code works but *why* the mathematics gives the visual results you see. Everything this week builds on this foundation.</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>