<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; Day 4: Introduction to 3D Rendering – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./day5a.html" rel="next">
<link href="./day3.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-86daaaaad7353f9cc0c554efc1dd6d94.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-f8dc6eab18fde03278982b0b35885446.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ed04f5f1653af6df52378e13bfdac05e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-d37bfdfd9a2222927534875c15a9020f.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./day4.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/yourusername/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Euclidean Geometry</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Fractals and Hyperbolic Geometry</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day4.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./debug-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Debugging</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">4.1</span> Overview</a></li>
  <li><a href="#camera-and-ray-setup" id="toc-camera-and-ray-setup" class="nav-link" data-scroll-target="#camera-and-ray-setup"><span class="header-section-number">4.2</span> Camera and Ray Setup</a>
  <ul class="collapse">
  <li><a href="#the-rendering-equation-simplified" id="toc-the-rendering-equation-simplified" class="nav-link" data-scroll-target="#the-rendering-equation-simplified">The Rendering Equation (Simplified)</a></li>
  <li><a href="#coordinate-system" id="toc-coordinate-system" class="nav-link" data-scroll-target="#coordinate-system">Coordinate System</a></li>
  <li><a href="#camera-model" id="toc-camera-model" class="nav-link" data-scroll-target="#camera-model">Camera Model</a></li>
  <li><a href="#ray-generation" id="toc-ray-generation" class="nav-link" data-scroll-target="#ray-generation">Ray Generation</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  <li><a href="#points-along-a-ray" id="toc-points-along-a-ray" class="nav-link" data-scroll-target="#points-along-a-ray">Points Along a Ray</a></li>
  </ul></li>
  <li><a href="#analytical-ray-sphere-intersection" id="toc-analytical-ray-sphere-intersection" class="nav-link" data-scroll-target="#analytical-ray-sphere-intersection"><span class="header-section-number">4.3</span> Analytical Ray-Sphere Intersection</a>
  <ul class="collapse">
  <li><a href="#the-sphere-equation" id="toc-the-sphere-equation" class="nav-link" data-scroll-target="#the-sphere-equation">The Sphere Equation</a></li>
  <li><a href="#setting-up-the-intersection" id="toc-setting-up-the-intersection" class="nav-link" data-scroll-target="#setting-up-the-intersection">Setting Up the Intersection</a></li>
  <li><a href="#solving-the-quadratic" id="toc-solving-the-quadratic" class="nav-link" data-scroll-target="#solving-the-quadratic">Solving the Quadratic</a></li>
  <li><a href="#implementation-1" id="toc-implementation-1" class="nav-link" data-scroll-target="#implementation-1">Implementation</a></li>
  <li><a href="#rendering-the-sphere" id="toc-rendering-the-sphere" class="nav-link" data-scroll-target="#rendering-the-sphere">Rendering the Sphere</a></li>
  </ul></li>
  <li><a href="#adding-lighting-the-surface-normal" id="toc-adding-lighting-the-surface-normal" class="nav-link" data-scroll-target="#adding-lighting-the-surface-normal"><span class="header-section-number">4.4</span> Adding Lighting: The Surface Normal</a>
  <ul class="collapse">
  <li><a href="#computing-the-normal" id="toc-computing-the-normal" class="nav-link" data-scroll-target="#computing-the-normal">Computing the Normal</a></li>
  <li><a href="#diffuse-lighting" id="toc-diffuse-lighting" class="nav-link" data-scroll-target="#diffuse-lighting">Diffuse Lighting</a></li>
  <li><a href="#implementation-with-lighting" id="toc-implementation-with-lighting" class="nav-link" data-scroll-target="#implementation-with-lighting">Implementation with Lighting</a></li>
  </ul></li>
  <li><a href="#ray-torus-intersection" id="toc-ray-torus-intersection" class="nav-link" data-scroll-target="#ray-torus-intersection"><span class="header-section-number">4.5</span> Ray-Torus Intersection</a>
  <ul class="collapse">
  <li><a href="#the-torus-equation" id="toc-the-torus-equation" class="nav-link" data-scroll-target="#the-torus-equation">The Torus Equation</a></li>
  <li><a href="#computing-the-gradient-normal" id="toc-computing-the-gradient-normal" class="nav-link" data-scroll-target="#computing-the-gradient-normal">Computing the Gradient (Normal)</a></li>
  <li><a href="#implementation-2" id="toc-implementation-2" class="nav-link" data-scroll-target="#implementation-2">Implementation</a></li>
  <li><a href="#finding-the-intersection" id="toc-finding-the-intersection" class="nav-link" data-scroll-target="#finding-the-intersection">Finding the Intersection</a></li>
  <li><a href="#rendering-the-torus" id="toc-rendering-the-torus" class="nav-link" data-scroll-target="#rendering-the-torus">Rendering the Torus</a></li>
  </ul></li>
  <li><a href="#motivation-for-raymarching" id="toc-motivation-for-raymarching" class="nav-link" data-scroll-target="#motivation-for-raymarching"><span class="header-section-number">4.6</span> Motivation for Raymarching</a>
  <ul class="collapse">
  <li><a href="#the-problem-with-analytical-methods" id="toc-the-problem-with-analytical-methods" class="nav-link" data-scroll-target="#the-problem-with-analytical-methods">The Problem with Analytical Methods</a></li>
  </ul></li>
  <li><a href="#signed-distance-functions-sdfs" id="toc-signed-distance-functions-sdfs" class="nav-link" data-scroll-target="#signed-distance-functions-sdfs"><span class="header-section-number">4.7</span> Signed Distance Functions (SDFs)</a>
  <ul class="collapse">
  <li><a href="#definition" id="toc-definition" class="nav-link" data-scroll-target="#definition">Definition</a></li>
  <li><a href="#why-sdfs" id="toc-why-sdfs" class="nav-link" data-scroll-target="#why-sdfs">Why SDFs?</a></li>
  <li><a href="#sdf-for-a-sphere" id="toc-sdf-for-a-sphere" class="nav-link" data-scroll-target="#sdf-for-a-sphere">SDF for a Sphere</a></li>
  <li><a href="#sdf-for-a-box" id="toc-sdf-for-a-box" class="nav-link" data-scroll-target="#sdf-for-a-box">SDF for a Box</a></li>
  <li><a href="#sdf-for-a-plane" id="toc-sdf-for-a-plane" class="nav-link" data-scroll-target="#sdf-for-a-plane">SDF for a Plane</a></li>
  <li><a href="#sdf-for-a-torus" id="toc-sdf-for-a-torus" class="nav-link" data-scroll-target="#sdf-for-a-torus">SDF for a Torus</a></li>
  <li><a href="#other-primitives" id="toc-other-primitives" class="nav-link" data-scroll-target="#other-primitives">Other Primitives</a></li>
  </ul></li>
  <li><a href="#the-raymarching-algorithm" id="toc-the-raymarching-algorithm" class="nav-link" data-scroll-target="#the-raymarching-algorithm"><span class="header-section-number">4.8</span> The Raymarching Algorithm</a>
  <ul class="collapse">
  <li><a href="#sphere-tracing" id="toc-sphere-tracing" class="nav-link" data-scroll-target="#sphere-tracing">Sphere Tracing</a></li>
  <li><a href="#scene-sdf" id="toc-scene-sdf" class="nav-link" data-scroll-target="#scene-sdf">Scene SDF</a></li>
  </ul></li>
  <li><a href="#normal-estimation-via-gradient" id="toc-normal-estimation-via-gradient" class="nav-link" data-scroll-target="#normal-estimation-via-gradient"><span class="header-section-number">4.9</span> Normal Estimation via Gradient</a>
  <ul class="collapse">
  <li><a href="#the-gradient-as-normal" id="toc-the-gradient-as-normal" class="nav-link" data-scroll-target="#the-gradient-as-normal">The Gradient as Normal</a></li>
  <li><a href="#finite-difference-approximation" id="toc-finite-difference-approximation" class="nav-link" data-scroll-target="#finite-difference-approximation">Finite Difference Approximation</a></li>
  <li><a href="#implementation-3" id="toc-implementation-3" class="nav-link" data-scroll-target="#implementation-3">Implementation</a></li>
  </ul></li>
  <li><a href="#putting-it-all-together-raymarched-scenes" id="toc-putting-it-all-together-raymarched-scenes" class="nav-link" data-scroll-target="#putting-it-all-together-raymarched-scenes"><span class="header-section-number">4.10</span> Putting It All Together: Raymarched Scenes</a>
  <ul class="collapse">
  <li><a href="#scene-1-single-sphere" id="toc-scene-1-single-sphere" class="nav-link" data-scroll-target="#scene-1-single-sphere">Scene 1: Single Sphere</a></li>
  <li><a href="#scene-2-two-spheres" id="toc-scene-2-two-spheres" class="nav-link" data-scroll-target="#scene-2-two-spheres">Scene 2: Two Spheres</a></li>
  <li><a href="#scene-3-sphere-and-torus" id="toc-scene-3-sphere-and-torus" class="nav-link" data-scroll-target="#scene-3-sphere-and-torus">Scene 3: Sphere and Torus</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">4.11</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">4.12</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-algebraic-variety-rendering" id="toc-required-algebraic-variety-rendering" class="nav-link" data-scroll-target="#required-algebraic-variety-rendering">Required: Algebraic Variety Rendering</a></li>
  <li><a href="#optional-advanced-lighting-and-transformations" id="toc-optional-advanced-lighting-and-transformations" class="nav-link" data-scroll-target="#optional-advanced-lighting-and-transformations">Optional: Advanced Lighting and Transformations</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">4.13</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">4.1</span> Overview</h2>
<p>Today we enter the third dimension! We’ll learn how to set up a camera and cast rays from each pixel, then implement ray-object intersection testing. We’ll start with analytical methods (solving equations directly) for spheres and tori, then transition to raymarching with signed distance functions—a more flexible approach that will enable complex scenes.</p>
<p>By the end of today, you’ll be able to render implicit surfaces in 3D with basic lighting, setting the foundation for tomorrow’s advanced techniques.</p>
<hr>
</section>
<section id="camera-and-ray-setup" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="camera-and-ray-setup"><span class="header-section-number">4.2</span> Camera and Ray Setup</h2>
<section id="the-rendering-equation-simplified" class="level3">
<h3 class="anchored" data-anchor-id="the-rendering-equation-simplified">The Rendering Equation (Simplified)</h3>
<p>For each pixel, we need to: 1. Determine which ray in 3D space corresponds to that pixel 2. Find where (if anywhere) the ray intersects scene geometry 3. Compute the color based on surface properties and lighting</p>
</section>
<section id="coordinate-system" class="level3">
<h3 class="anchored" data-anchor-id="coordinate-system">Coordinate System</h3>
<p>We’ll use the Three.js convention: - Y-axis points up - Z-axis points toward the camera (out of the screen) - X-axis points right - This is a right-handed coordinate system</p>
</section>
<section id="camera-model" class="level3">
<h3 class="anchored" data-anchor-id="camera-model">Camera Model</h3>
<p>We’ll use a simple pinhole camera model: - Camera positioned at the origin (for now) - Looking down the -Z axis - Field of view (FOV) determines the viewing frustum</p>
</section>
<section id="ray-generation" class="level3">
<h3 class="anchored" data-anchor-id="ray-generation">Ray Generation</h3>
<p>For a pixel at normalized coordinates <span class="math inline">\((u, v) \in [-1, 1]^2\)</span>, we generate a ray with: - <strong>Origin</strong>: <span class="math inline">\(\mathbf{o} = (0, 0, 0)\)</span> (camera position) - <strong>Direction</strong>: <span class="math inline">\(\mathbf{d} = \text{normalize}(u \cdot \text{right}, v \cdot \text{up}, -\text{focal length})\)</span></p>
<p>The focal length relates to field of view: for FOV angle <span class="math inline">\(\theta\)</span>, we have <span class="math inline">\(\text{focal length} = 1 / \tan(\theta/2)\)</span>.</p>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Ray <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> origin<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> direction<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Ray <span class="fu">getRay</span><span class="op">(</span><span class="dt">vec2</span> fragCoord<span class="op">,</span> <span class="dt">vec2</span> resolution<span class="op">,</span> <span class="dt">float</span> fov<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Normalize to [-1, 1]</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> <span class="op">(</span>fragCoord <span class="op">/</span> resolution<span class="op">)</span> <span class="op">*</span> <span class="fl">2.0</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Correct for aspect ratio</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> resolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> resolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute focal length from FOV</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> focalLength <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="bu">tan</span><span class="op">(</span><span class="bu">radians</span><span class="op">(</span>fov<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ray from origin through pixel</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    Ray ray<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    ray<span class="op">.</span><span class="fu">origin</span> <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    ray<span class="op">.</span><span class="fu">direction</span> <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>uv<span class="op">.</span><span class="fu">x</span><span class="op">,</span> uv<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="op">-</span>focalLength<span class="op">));</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> ray<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="points-along-a-ray" class="level3">
<h3 class="anchored" data-anchor-id="points-along-a-ray">Points Along a Ray</h3>
<p>A parametric ray can be written as: <span class="math display">\[\mathbf{L}(t) = \mathbf{o} + t\mathbf{d}\]</span></p>
<p>where <span class="math inline">\(\mathbf{o}\)</span> is the origin, <span class="math inline">\(\mathbf{d}\)</span> is the direction, and <span class="math inline">\(t \geq 0\)</span> is the parameter.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">rayPoint</span><span class="op">(</span>Ray ray<span class="op">,</span> <span class="dt">float</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> ray<span class="op">.</span><span class="fu">origin</span> <span class="op">+</span> t <span class="op">*</span> ray<span class="op">.</span><span class="fu">direction</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="analytical-ray-sphere-intersection" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="analytical-ray-sphere-intersection"><span class="header-section-number">4.3</span> Analytical Ray-Sphere Intersection</h2>
<section id="the-sphere-equation" class="level3">
<h3 class="anchored" data-anchor-id="the-sphere-equation">The Sphere Equation</h3>
<p>A sphere of radius <span class="math inline">\(r\)</span> centered at the origin is defined implicitly by: <span class="math display">\[x^2 + y^2 + z^2 = r^2\]</span></p>
<p>Or more compactly: <span class="math inline">\(|\mathbf{p}|^2 = r^2\)</span> for points <span class="math inline">\(\mathbf{p}\)</span> on the surface.</p>
</section>
<section id="setting-up-the-intersection" class="level3">
<h3 class="anchored" data-anchor-id="setting-up-the-intersection">Setting Up the Intersection</h3>
<p>We want to find where the ray <span class="math inline">\(\mathbf{L}(t) = \mathbf{o} + t\mathbf{d}\)</span> intersects the sphere. Substituting the ray equation into the sphere equation: <span class="math display">\[|\mathbf{o} + t\mathbf{d}|^2 = r^2\]</span></p>
<p>Expanding: <span class="math display">\[(\mathbf{o} + t\mathbf{d}) \cdot (\mathbf{o} + t\mathbf{d}) = r^2\]</span> <span class="math display">\[|\mathbf{o}|^2 + 2t(\mathbf{o} \cdot \mathbf{d}) + t^2|\mathbf{d}|^2 = r^2\]</span></p>
<p>This is a quadratic equation in <span class="math inline">\(t\)</span>: <span class="math display">\[at^2 + bt + c = 0\]</span></p>
<p>where: - <span class="math inline">\(a = |\mathbf{d}|^2\)</span> (which is 1 if <span class="math inline">\(\mathbf{d}\)</span> is normalized) - <span class="math inline">\(b = 2(\mathbf{o} \cdot \mathbf{d})\)</span> - <span class="math inline">\(c = |\mathbf{o}|^2 - r^2\)</span></p>
</section>
<section id="solving-the-quadratic" class="level3">
<h3 class="anchored" data-anchor-id="solving-the-quadratic">Solving the Quadratic</h3>
<p>The solutions are: <span class="math display">\[t = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}\]</span></p>
<p>The discriminant <span class="math inline">\(\Delta = b^2 - 4ac\)</span> tells us: - <span class="math inline">\(\Delta &lt; 0\)</span>: no intersection (ray misses sphere) - <span class="math inline">\(\Delta = 0\)</span>: one intersection (ray is tangent) - <span class="math inline">\(\Delta &gt; 0\)</span>: two intersections (ray enters and exits sphere)</p>
<p>We want the smaller positive <span class="math inline">\(t\)</span> (the closer intersection point).</p>
</section>
<section id="implementation-1" class="level3">
<h3 class="anchored" data-anchor-id="implementation-1">Implementation</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">intersectSphere</span><span class="op">(</span>Ray ray<span class="op">,</span> <span class="dt">vec3</span> center<span class="op">,</span> <span class="dt">float</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> oc <span class="op">=</span> ray<span class="op">.</span><span class="fu">origin</span> <span class="op">-</span> center<span class="op">;</span>  <span class="co">// o - c (sphere center)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>ray<span class="op">.</span><span class="fu">direction</span><span class="op">,</span> ray<span class="op">.</span><span class="fu">direction</span><span class="op">);</span>  <span class="co">// Should be 1 if normalized</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> b <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="bu">dot</span><span class="op">(</span>oc<span class="op">,</span> ray<span class="op">.</span><span class="fu">direction</span><span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> c <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>oc<span class="op">,</span> oc<span class="op">)</span> <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> discriminant <span class="op">=</span> b <span class="op">*</span> b <span class="op">-</span> <span class="fl">4.0</span> <span class="op">*</span> a <span class="op">*</span> c<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>discriminant <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">;</span>  <span class="co">// No intersection</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the closer intersection</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t1 <span class="op">=</span> <span class="op">(-</span>b <span class="op">-</span> <span class="bu">sqrt</span><span class="op">(</span>discriminant<span class="op">))</span> <span class="op">/</span> <span class="op">(</span><span class="fl">2.0</span> <span class="op">*</span> a<span class="op">);</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t2 <span class="op">=</span> <span class="op">(-</span>b <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span>discriminant<span class="op">))</span> <span class="op">/</span> <span class="op">(</span><span class="fl">2.0</span> <span class="op">*</span> a<span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return the closest positive t</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>t1 <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> t1<span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>t2 <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> t2<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">;</span>  <span class="co">// Behind camera</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="rendering-the-sphere" class="level3">
<h3 class="anchored" data-anchor-id="rendering-the-sphere">Rendering the Sphere</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Setup ray</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    Ray ray <span class="op">=</span> <span class="fu">getRay</span><span class="op">(</span>fragCoord<span class="op">,</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">,</span> <span class="fl">45.0</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sphere parameters</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> sphereCenter <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">3.0</span><span class="op">);</span>  <span class="co">// In front of camera</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sphereRadius <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Test intersection</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="fu">intersectSphere</span><span class="op">(</span>ray<span class="op">,</span> sphereCenter<span class="op">,</span> sphereRadius<span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>t <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Hit the sphere!</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// Red</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Background</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span>  <span class="co">// Dark blue</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Result:</strong> You should see a red disk on a blue background. But it looks flat—we can’t see that it’s a sphere!</p>
<hr>
</section>
</section>
<section id="adding-lighting-the-surface-normal" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="adding-lighting-the-surface-normal"><span class="header-section-number">4.4</span> Adding Lighting: The Surface Normal</h2>
<section id="computing-the-normal" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-normal">Computing the Normal</h3>
<p>For a sphere centered at <span class="math inline">\(\mathbf{c}\)</span>, the outward normal at a point <span class="math inline">\(\mathbf{p}\)</span> on the surface is: <span class="math display">\[\mathbf{n} = \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|} = \frac{\mathbf{p} - \mathbf{c}}{r}\]</span></p>
<p>This is just the vector from the center to the surface point, normalized.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">sphereNormal</span><span class="op">(</span><span class="dt">vec3</span> point<span class="op">,</span> <span class="dt">vec3</span> center<span class="op">,</span> <span class="dt">float</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>point <span class="op">-</span> center<span class="op">)</span> <span class="op">/</span> radius<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="diffuse-lighting" class="level3">
<h3 class="anchored" data-anchor-id="diffuse-lighting">Diffuse Lighting</h3>
<p>The simplest lighting model: <strong>Lambertian diffuse shading</strong>. The brightness depends on the angle between the surface normal <span class="math inline">\(\mathbf{n}\)</span> and the light direction <span class="math inline">\(\mathbf{l}\)</span>: <span class="math display">\[\text{brightness} = \max(0, \mathbf{n} \cdot \mathbf{l})\]</span></p>
<p>The <span class="math inline">\(\max(0, \cdots)\)</span> ensures we don’t get negative light (surfaces facing away from the light are dark).</p>
</section>
<section id="implementation-with-lighting" class="level3">
<h3 class="anchored" data-anchor-id="implementation-with-lighting">Implementation with Lighting</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    Ray ray <span class="op">=</span> <span class="fu">getRay</span><span class="op">(</span>fragCoord<span class="op">,</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">,</span> <span class="fl">45.0</span><span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> sphereCenter <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">3.0</span><span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sphereRadius <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="fu">intersectSphere</span><span class="op">(</span>ray<span class="op">,</span> sphereCenter<span class="op">,</span> sphereRadius<span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>t <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Compute intersection point</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> hitPoint <span class="op">=</span> <span class="fu">rayPoint</span><span class="op">(</span>ray<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Compute normal</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> normal <span class="op">=</span> <span class="fu">sphereNormal</span><span class="op">(</span>hitPoint<span class="op">,</span> sphereCenter<span class="op">,</span> sphereRadius<span class="op">);</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Light direction (fixed, from above and to the right)</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> lightDir <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Diffuse lighting</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> diffuse <span class="op">=</span> <span class="bu">max</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="bu">dot</span><span class="op">(</span>normal<span class="op">,</span> lightDir<span class="op">));</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Color the sphere</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> sphereColor <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// Red</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> sphereColor <span class="op">*</span> diffuse<span class="op">;</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add a bit of ambient light so dark side isn't completely black</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        color <span class="op">+=</span> sphereColor <span class="op">*</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Result:</strong> Now the sphere looks 3D! The lighting reveals its curvature.</p>
<hr>
</section>
</section>
<section id="ray-torus-intersection" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="ray-torus-intersection"><span class="header-section-number">4.5</span> Ray-Torus Intersection</h2>
<section id="the-torus-equation" class="level3">
<h3 class="anchored" data-anchor-id="the-torus-equation">The Torus Equation</h3>
<p>A torus with major radius <span class="math inline">\(R\)</span> (center to tube center) and minor radius <span class="math inline">\(r\)</span> (tube radius) centered at the origin with axis along the Y-axis has the implicit equation: <span class="math display">\[\left(\sqrt{x^2 + z^2} - R\right)^2 + y^2 = r^2\]</span></p>
<p>Or equivalently: <span class="math display">\[\left(|\mathbf{p}_{xz}| - R\right)^2 + p_y^2 = r^2\]</span></p>
<p>where <span class="math inline">\(\mathbf{p}_{xz} = (p_x, p_z)\)</span> is the projection onto the XZ-plane.</p>
</section>
<section id="computing-the-gradient-normal" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-gradient-normal">Computing the Gradient (Normal)</h3>
<p>The gradient of the implicit function <span class="math inline">\(F(x, y, z) = \left(\sqrt{x^2 + z^2} - R\right)^2 + y^2 - r^2\)</span> gives the normal direction.</p>
<p>Let <span class="math inline">\(q = \sqrt{x^2 + z^2}\)</span>. Then:</p>
<p><span class="math display">\[\frac{\partial F}{\partial x} = 2\left(q - R\right) \cdot \frac{x}{q}\]</span></p>
<p><span class="math display">\[\frac{\partial F}{\partial y} = 2y\]</span></p>
<p><span class="math display">\[\frac{\partial F}{\partial z} = 2\left(q - R\right) \cdot \frac{z}{q}\]</span></p>
<p>The normal is: <span class="math display">\[\mathbf{n} = \nabla F = \left(\frac{\partial F}{\partial x}, \frac{\partial F}{\partial y}, \frac{\partial F}{\partial z}\right)\]</span></p>
<p>normalized to unit length.</p>
</section>
<section id="implementation-2" class="level3">
<h3 class="anchored" data-anchor-id="implementation-2">Implementation</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">torusNormal</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> majorRadius<span class="op">,</span> <span class="dt">float</span> minorRadius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Project to XZ plane</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> pxz <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> p<span class="op">.</span><span class="fu">z</span><span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> q <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>pxz<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Gradient components</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> factor <span class="op">=</span> q <span class="op">-</span> majorRadius<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> grad<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    grad<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> factor <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> q<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    grad<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    grad<span class="op">.</span><span class="fu">z</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> factor <span class="op">*</span> p<span class="op">.</span><span class="fu">z</span> <span class="op">/</span> q<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">normalize</span><span class="op">(</span>grad<span class="op">);</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="finding-the-intersection" class="level3">
<h3 class="anchored" data-anchor-id="finding-the-intersection">Finding the Intersection</h3>
<p>Finding the exact intersection between a ray and a torus requires solving a <strong>quartic equation</strong> (degree 4 polynomial). This is algebraically messy!</p>
<p>We can: 1. Use a numerical root-finding method (Newton’s method, bisection) 2. Or… use a different approach (foreshadowing: raymarching!)</p>
<p>For now, let’s implement a simple bisection method to find the intersection:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">torusImplicit</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> R<span class="op">,</span> <span class="dt">float</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> pxz <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> p<span class="op">.</span><span class="fu">z</span><span class="op">);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> q <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>pxz<span class="op">)</span> <span class="op">-</span> R<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> q <span class="op">*</span> q <span class="op">+</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> r <span class="op">*</span> r<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">intersectTorus</span><span class="op">(</span>Ray ray<span class="op">,</span> <span class="dt">float</span> majorRadius<span class="op">,</span> <span class="dt">float</span> minorRadius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Bisection method to find root of F(ray(t)) = 0</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> tMin <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> tMax <span class="op">=</span> <span class="fl">10.0</span><span class="op">;</span>  <span class="co">// Search range</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if there's a sign change (indicating a root exists)</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fMin <span class="op">=</span> <span class="fu">torusImplicit</span><span class="op">(</span><span class="fu">rayPoint</span><span class="op">(</span>ray<span class="op">,</span> tMin<span class="op">),</span> majorRadius<span class="op">,</span> minorRadius<span class="op">);</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> fMax <span class="op">=</span> <span class="fu">torusImplicit</span><span class="op">(</span><span class="fu">rayPoint</span><span class="op">(</span>ray<span class="op">,</span> tMax<span class="op">),</span> majorRadius<span class="op">,</span> minorRadius<span class="op">);</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>fMin <span class="op">*</span> fMax <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">;</span>  <span class="co">// No intersection in range</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Bisection</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">50</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> tMid <span class="op">=</span> <span class="op">(</span>tMin <span class="op">+</span> tMax<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> fMid <span class="op">=</span> <span class="fu">torusImplicit</span><span class="op">(</span><span class="fu">rayPoint</span><span class="op">(</span>ray<span class="op">,</span> tMid<span class="op">),</span> majorRadius<span class="op">,</span> minorRadius<span class="op">);</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span><span class="bu">abs</span><span class="op">(</span>fMid<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.001</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> tMid<span class="op">;</span>  <span class="co">// Found intersection</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span>fMin <span class="op">*</span> fMid <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            tMax <span class="op">=</span> tMid<span class="op">;</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>            fMax <span class="op">=</span> fMid<span class="op">;</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>            tMin <span class="op">=</span> tMid<span class="op">;</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>            fMin <span class="op">=</span> fMid<span class="op">;</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>tMin <span class="op">+</span> tMax<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span>  <span class="co">// Best estimate</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="rendering-the-torus" class="level3">
<h3 class="anchored" data-anchor-id="rendering-the-torus">Rendering the Torus</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    Ray ray <span class="op">=</span> <span class="fu">getRay</span><span class="op">(</span>fragCoord<span class="op">,</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">,</span> <span class="fl">45.0</span><span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Torus parameters</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> majorRadius <span class="op">=</span> <span class="fl">1.5</span><span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> minorRadius <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> torusCenter <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">4.0</span><span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Adjust ray for torus center (translate)</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    Ray torusRay <span class="op">=</span> ray<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    torusRay<span class="op">.</span><span class="fu">origin</span> <span class="op">=</span> ray<span class="op">.</span><span class="fu">origin</span> <span class="op">-</span> torusCenter<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="fu">intersectTorus</span><span class="op">(</span>torusRay<span class="op">,</span> majorRadius<span class="op">,</span> minorRadius<span class="op">);</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>t <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> hitPoint <span class="op">=</span> <span class="fu">rayPoint</span><span class="op">(</span>torusRay<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> normal <span class="op">=</span> <span class="fu">torusNormal</span><span class="op">(</span>hitPoint<span class="op">,</span> majorRadius<span class="op">,</span> minorRadius<span class="op">);</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> lightDir <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> diffuse <span class="op">=</span> <span class="bu">max</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="bu">dot</span><span class="op">(</span>normal<span class="op">,</span> lightDir<span class="op">));</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> torusColor <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.7</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Cyan</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> torusColor <span class="op">*</span> diffuse <span class="op">+</span> torusColor <span class="op">*</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Result:</strong> A beautiful cyan torus with proper 3D lighting!</p>
<hr>
</section>
</section>
<section id="motivation-for-raymarching" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="motivation-for-raymarching"><span class="header-section-number">4.6</span> Motivation for Raymarching</h2>
<section id="the-problem-with-analytical-methods" class="level3">
<h3 class="anchored" data-anchor-id="the-problem-with-analytical-methods">The Problem with Analytical Methods</h3>
<p>Notice what we had to do: - <strong>Sphere:</strong> Solve a quadratic equation (manageable) - <strong>Torus:</strong> Solve a quartic equation (we used bisection instead) - <strong>Arbitrary implicit surface:</strong> Could be any degree polynomial, or transcendental!</p>
<p>Moreover, combining objects is difficult: - How do we render two spheres? Check each separately, take the closer one. - How do we render the <strong>union</strong> of a sphere and torus? Check both, take closer. - How do we render the <strong>intersection</strong> (only where both objects exist)? Much harder! - How about <strong>smooth blending</strong> between objects? Nearly impossible analytically.</p>
<p>We need a more flexible approach that works for: - Arbitrary implicit surfaces - Complex compositions of objects - Procedurally defined geometry</p>
<p><strong>Enter: Raymarching with Signed Distance Functions</strong></p>
<hr>
</section>
</section>
<section id="signed-distance-functions-sdfs" class="level2" data-number="4.7">
<h2 data-number="4.7" class="anchored" data-anchor-id="signed-distance-functions-sdfs"><span class="header-section-number">4.7</span> Signed Distance Functions (SDFs)</h2>
<section id="definition" class="level3">
<h3 class="anchored" data-anchor-id="definition">Definition</h3>
<p>A <strong>signed distance function</strong> <span class="math inline">\(d: \mathbb{R}^3 \to \mathbb{R}\)</span> gives the distance from any point in space to the closest point on a surface: - <span class="math inline">\(d(\mathbf{p}) &gt; 0\)</span> if <span class="math inline">\(\mathbf{p}\)</span> is outside the surface - <span class="math inline">\(d(\mathbf{p}) = 0\)</span> if <span class="math inline">\(\mathbf{p}\)</span> is on the surface - <span class="math inline">\(d(\mathbf{p}) &lt; 0\)</span> if <span class="math inline">\(\mathbf{p}\)</span> is inside the surface</p>
<p>Importantly, <span class="math inline">\(|d(\mathbf{p})|\)</span> is the actual Euclidean distance to the surface.</p>
</section>
<section id="why-sdfs" class="level3">
<h3 class="anchored" data-anchor-id="why-sdfs">Why SDFs?</h3>
<p>SDFs have a crucial property: if we’re at a point <span class="math inline">\(\mathbf{p}\)</span> and the nearest surface is distance <span class="math inline">\(d\)</span> away, we can safely move <span class="math inline">\(d\)</span> units along any direction without hitting anything.</p>
<p>This enables <strong>sphere tracing</strong>: we march along the ray, taking steps proportional to the SDF value, guaranteed not to overshoot the surface.</p>
</section>
<section id="sdf-for-a-sphere" class="level3">
<h3 class="anchored" data-anchor-id="sdf-for-a-sphere">SDF for a Sphere</h3>
<p>For a sphere of radius <span class="math inline">\(r\)</span> centered at <span class="math inline">\(\mathbf{c}\)</span>: <span class="math display">\[d(\mathbf{p}) = |\mathbf{p} - \mathbf{c}| - r\]</span></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdSphere</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">vec3</span> center<span class="op">,</span> <span class="dt">float</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> center<span class="op">)</span> <span class="op">-</span> radius<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sdf-for-a-box" class="level3">
<h3 class="anchored" data-anchor-id="sdf-for-a-box">SDF for a Box</h3>
<p>For an axis-aligned box centered at the origin with half-extents <span class="math inline">\(\mathbf{b} = (b_x, b_y, b_z)\)</span>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdBox</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">vec3</span> center<span class="op">,</span> <span class="dt">vec3</span> halfExtents<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> q <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> center<span class="op">)</span> <span class="op">-</span> halfExtents<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span><span class="bu">max</span><span class="op">(</span>q<span class="op">,</span> <span class="fl">0.0</span><span class="op">))</span> <span class="op">+</span> <span class="bu">min</span><span class="op">(</span><span class="bu">max</span><span class="op">(</span>q<span class="op">.</span><span class="fu">x</span><span class="op">,</span> <span class="bu">max</span><span class="op">(</span>q<span class="op">.</span><span class="fu">y</span><span class="op">,</span> q<span class="op">.</span><span class="fu">z</span><span class="op">)),</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>(This formula handles both inside and outside the box correctly.)</p>
</section>
<section id="sdf-for-a-plane" class="level3">
<h3 class="anchored" data-anchor-id="sdf-for-a-plane">SDF for a Plane</h3>
<p>For an infinite plane with normal <span class="math inline">\(\mathbf{n}\)</span> (unit vector) passing through point <span class="math inline">\(\mathbf{p}_0\)</span>: <span class="math display">\[d(\mathbf{p}) = (\mathbf{p} - \mathbf{p}_0) \cdot \mathbf{n}\]</span></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdPlane</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">vec3</span> planePoint<span class="op">,</span> <span class="dt">vec3</span> normal<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">dot</span><span class="op">(</span>p <span class="op">-</span> planePoint<span class="op">,</span> normal<span class="op">);</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For the XZ-plane (Y = 0):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdPlaneY</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> height<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> height<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sdf-for-a-torus" class="level3">
<h3 class="anchored" data-anchor-id="sdf-for-a-torus">SDF for a Torus</h3>
<p>For a torus with major radius <span class="math inline">\(R\)</span> and minor radius <span class="math inline">\(r\)</span>, axis along Y:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdTorus</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">vec3</span> center<span class="op">,</span> <span class="dt">float</span> majorRadius<span class="op">,</span> <span class="dt">float</span> minorRadius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> q <span class="op">=</span> p <span class="op">-</span> center<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> pxz <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>q<span class="op">.</span><span class="fu">x</span><span class="op">,</span> q<span class="op">.</span><span class="fu">z</span><span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>pxz<span class="op">)</span> <span class="op">-</span> majorRadius<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">length</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>d<span class="op">,</span> q<span class="op">.</span><span class="fu">y</span><span class="op">))</span> <span class="op">-</span> minorRadius<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="other-primitives" class="level3">
<h3 class="anchored" data-anchor-id="other-primitives">Other Primitives</h3>
<p>Many more SDFs exist! Cylinders, capsules, cones, ellipsoids, etc. See resources like <a href="https://iquilezles.org/articles/distfunctions/">Inigo Quilez’s SDF functions</a>.</p>
<hr>
</section>
</section>
<section id="the-raymarching-algorithm" class="level2" data-number="4.8">
<h2 data-number="4.8" class="anchored" data-anchor-id="the-raymarching-algorithm"><span class="header-section-number">4.8</span> The Raymarching Algorithm</h2>
<section id="sphere-tracing" class="level3">
<h3 class="anchored" data-anchor-id="sphere-tracing">Sphere Tracing</h3>
<p>The algorithm: 1. Start at the ray origin 2. Evaluate the SDF at the current point 3. March forward along the ray by that distance 4. Repeat until: - We’re very close to the surface (SDF ≈ 0) → hit! - We’ve marched too far → miss - We’ve taken too many steps → give up</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HitInfo <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> hit<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t<span class="op">;</span>        <span class="co">// Distance along ray</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> position<span class="op">;</span>  <span class="co">// Hit position</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>HitInfo <span class="fu">raymarch</span><span class="op">(</span>Ray ray<span class="op">,</span> <span class="dt">float</span> maxDist<span class="op">,</span> <span class="dt">int</span> maxSteps<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    HitInfo info<span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    info<span class="op">.</span><span class="fu">hit</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> maxSteps<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> pos <span class="op">=</span> <span class="fu">rayPoint</span><span class="op">(</span>ray<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Evaluate scene SDF (define this based on your scene)</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> d <span class="op">=</span> <span class="fu">sceneSDF</span><span class="op">(</span>pos<span class="op">);</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Close enough to surface?</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span><span class="bu">abs</span><span class="op">(</span>d<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.001</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            info<span class="op">.</span><span class="fu">hit</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>            info<span class="op">.</span><span class="fu">t</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>            info<span class="op">.</span><span class="fu">position</span> <span class="op">=</span> pos<span class="op">;</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">return</span> info<span class="op">;</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// March forward</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        t <span class="op">+=</span> d<span class="op">;</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Too far?</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="op">(</span>t <span class="op">&gt;</span> maxDist<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>            <span class="kw">break</span><span class="op">;</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> info<span class="op">;</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="scene-sdf" class="level3">
<h3 class="anchored" data-anchor-id="scene-sdf">Scene SDF</h3>
<p>For a scene with multiple objects, we take the minimum distance to any object:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sceneSDF</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sphere at (0, 0, -3)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sphere <span class="op">=</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">3.0</span><span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ground plane</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> ground <span class="op">=</span> <span class="fu">sdPlaneY</span><span class="op">(</span>p<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Return minimum distance</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">min</span><span class="op">(</span>sphere<span class="op">,</span> ground<span class="op">);</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="normal-estimation-via-gradient" class="level2" data-number="4.9">
<h2 data-number="4.9" class="anchored" data-anchor-id="normal-estimation-via-gradient"><span class="header-section-number">4.9</span> Normal Estimation via Gradient</h2>
<section id="the-gradient-as-normal" class="level3">
<h3 class="anchored" data-anchor-id="the-gradient-as-normal">The Gradient as Normal</h3>
<p>For an implicit surface <span class="math inline">\(F(\mathbf{p}) = 0\)</span>, the gradient <span class="math inline">\(\nabla F\)</span> is perpendicular to the surface (it’s the normal direction).</p>
<p>For an SDF <span class="math inline">\(d(\mathbf{p})\)</span>, the gradient points away from the surface: <span class="math display">\[\mathbf{n} = \nabla d = \left(\frac{\partial d}{\partial x}, \frac{\partial d}{\partial y}, \frac{\partial d}{\partial z}\right)\]</span></p>
</section>
<section id="finite-difference-approximation" class="level3">
<h3 class="anchored" data-anchor-id="finite-difference-approximation">Finite Difference Approximation</h3>
<p>We estimate each partial derivative using finite differences: <span class="math display">\[\frac{\partial d}{\partial x} \approx \frac{d(x + \epsilon, y, z) - d(x - \epsilon, y, z)}{2\epsilon}\]</span></p>
<p>and similarly for <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span>.</p>
</section>
<section id="implementation-3" class="level3">
<h3 class="anchored" data-anchor-id="implementation-3">Implementation</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">estimateNormal</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> epsilon<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sample SDF at nearby points</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dx <span class="op">=</span> <span class="fu">sceneSDF</span><span class="op">(</span>p <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span>epsilon<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">))</span> <span class="op">-</span> <span class="fu">sceneSDF</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec3</span><span class="op">(</span>epsilon<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">));</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dy <span class="op">=</span> <span class="fu">sceneSDF</span><span class="op">(</span>p <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> epsilon<span class="op">,</span> <span class="fl">0.0</span><span class="op">))</span> <span class="op">-</span> <span class="fu">sceneSDF</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> epsilon<span class="op">,</span> <span class="fl">0.0</span><span class="op">));</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dz <span class="op">=</span> <span class="fu">sceneSDF</span><span class="op">(</span>p <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> epsilon<span class="op">))</span> <span class="op">-</span> <span class="fu">sceneSDF</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> epsilon<span class="op">));</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>dx<span class="op">,</span> dy<span class="op">,</span> dz<span class="op">));</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Typical choice: <span class="math inline">\(\epsilon \approx 0.001\)</span>.</p>
<hr>
</section>
</section>
<section id="putting-it-all-together-raymarched-scenes" class="level2" data-number="4.10">
<h2 data-number="4.10" class="anchored" data-anchor-id="putting-it-all-together-raymarched-scenes"><span class="header-section-number">4.10</span> Putting It All Together: Raymarched Scenes</h2>
<section id="scene-1-single-sphere" class="level3">
<h3 class="anchored" data-anchor-id="scene-1-single-sphere">Scene 1: Single Sphere</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sceneSDF</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">3.0</span><span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    Ray ray <span class="op">=</span> <span class="fu">getRay</span><span class="op">(</span>fragCoord<span class="op">,</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">,</span> <span class="fl">45.0</span><span class="op">);</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    HitInfo hit <span class="op">=</span> <span class="fu">raymarch</span><span class="op">(</span>ray<span class="op">,</span> <span class="fl">100.0</span><span class="op">,</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>hit<span class="op">.</span><span class="fu">hit</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> normal <span class="op">=</span> <span class="fu">estimateNormal</span><span class="op">(</span>hit<span class="op">.</span><span class="fu">position</span><span class="op">,</span> <span class="fl">0.001</span><span class="op">);</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> lightDir <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">float</span> diffuse <span class="op">=</span> <span class="bu">max</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="bu">dot</span><span class="op">(</span>normal<span class="op">,</span> lightDir<span class="op">));</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec3</span> objectColor <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> objectColor <span class="op">*</span> diffuse <span class="op">+</span> objectColor <span class="op">*</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="scene-2-two-spheres" class="level3">
<h3 class="anchored" data-anchor-id="scene-2-two-spheres">Scene 2: Two Spheres</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sceneSDF</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sphere1 <span class="op">=</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(-</span><span class="fl">1.2</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">3.0</span><span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sphere2 <span class="op">=</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.2</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">3.0</span><span class="op">),</span> <span class="fl">0.8</span><span class="op">);</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">min</span><span class="op">(</span>sphere1<span class="op">,</span> sphere2<span class="op">);</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Just change the scene SDF! The raymarching and lighting code stays the same.</p>
</section>
<section id="scene-3-sphere-and-torus" class="level3">
<h3 class="anchored" data-anchor-id="scene-3-sphere-and-torus">Scene 3: Sphere and Torus</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sceneSDF</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sphere <span class="op">=</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">4.0</span><span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> torus <span class="op">=</span> <span class="fu">sdTorus</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">4.0</span><span class="op">),</span> <span class="fl">1.5</span><span class="op">,</span> <span class="fl">0.4</span><span class="op">);</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">min</span><span class="op">(</span>sphere<span class="op">,</span> torus<span class="op">);</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Different object colors:</strong> To color objects differently, we need to track which object was hit. One approach:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Return both distance and object ID</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">sceneSDF</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> sphere <span class="op">=</span> <span class="fu">sdSphere</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">4.0</span><span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> torus <span class="op">=</span> <span class="fu">sdTorus</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">4.0</span><span class="op">),</span> <span class="fl">1.5</span><span class="op">,</span> <span class="fl">0.4</span><span class="op">);</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>sphere <span class="op">&lt;</span> torus<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>sphere<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// ID = 1 for sphere</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>torus<span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span>   <span class="co">// ID = 2 for torus</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Then in main shader, use the ID to choose color</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="summary" class="level2" data-number="4.11">
<h2 data-number="4.11" class="anchored" data-anchor-id="summary"><span class="header-section-number">4.11</span> Summary</h2>
<p>Today we covered:</p>
<ol type="1">
<li><strong>Camera and ray setup</strong>: Generating rays from pixel coordinates with a simple pinhole camera</li>
<li><strong>Analytical intersection</strong>: Solving equations directly for spheres and tori</li>
<li><strong>Lighting introduction</strong>: Using surface normals and dot product for diffuse shading</li>
<li><strong>Signed distance functions</strong>: A flexible representation of geometry as distance fields</li>
<li><strong>Raymarching algorithm</strong>: Sphere tracing to render SDFs efficiently</li>
<li><strong>Normal estimation</strong>: Computing gradients via finite differences</li>
<li><strong>Scene composition</strong>: Combining multiple objects by taking minimum distance</li>
</ol>
<p>Key insights: - Analytical methods require solving equations (quadratic, quartic, etc.) - SDFs provide a unified framework for any geometry - Raymarching works for arbitrary implicit surfaces - The same lighting technique applies to both approaches - Composition is trivial with SDFs (just take minimum)</p>
<p>Tomorrow we’ll explore advanced raymarching techniques: domain operations, boolean operations, and 3D fractals!</p>
<hr>
</section>
<section id="homework" class="level2" data-number="4.12">
<h2 data-number="4.12" class="anchored" data-anchor-id="homework"><span class="header-section-number">4.12</span> Homework</h2>
<section id="required-algebraic-variety-rendering" class="level3">
<h3 class="anchored" data-anchor-id="required-algebraic-variety-rendering">Required: Algebraic Variety Rendering</h3>
<p>Choose an interesting polynomial implicit surface and render it using ray intersection.</p>
<p><strong>Suggestions:</strong> - Degree 3: Torus-like surfaces, saddles - Degree 4: Quartic surfaces with interesting topology (Klein bottle projections, etc.)</p>
<p><strong>Implementation approach:</strong></p>
<ol type="1">
<li><strong>Define your implicit function</strong> <span class="math inline">\(F(x, y, z) = 0\)</span></li>
</ol>
<p>Example - a quartic surface:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">implicitFunction</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Example: (x^2 + y^2 + z^2)^2 - (x^2 + y^2 - 2z^2)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> r2 <span class="op">*</span> r2 <span class="op">-</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">z</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">z</span><span class="op">);</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><strong>Implement a root-finding method</strong> (bisection or Newton’s method)</li>
</ol>
<p>Bisection template:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">intersectImplicit</span><span class="op">(</span>Ray ray<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> tMin <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> tMax <span class="op">=</span> <span class="fl">10.0</span><span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Bisection loop similar to torus example]</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Find where implicitFunction(rayPoint(ray, t)) = 0</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li><strong>Compute the gradient for normals</strong></li>
</ol>
<p><span class="math display">\[\nabla F = \left(\frac{\partial F}{\partial x}, \frac{\partial F}{\partial y}, \frac{\partial F}{\partial z}\right)\]</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">implicitNormal</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> epsilon<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dx <span class="op">=</span> <span class="fu">implicitFunction</span><span class="op">(</span>p <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span>epsilon<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">))</span> <span class="op">-</span> <span class="fu">implicitFunction</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec3</span><span class="op">(</span>epsilon<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dy <span class="op">=</span> <span class="fu">implicitFunction</span><span class="op">(</span>p <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> epsilon<span class="op">,</span> <span class="dv">0</span><span class="op">))</span> <span class="op">-</span> <span class="fu">implicitFunction</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> epsilon<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dz <span class="op">=</span> <span class="fu">implicitFunction</span><span class="op">(</span>p <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> epsilon<span class="op">))</span> <span class="op">-</span> <span class="fu">implicitFunction</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec3</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> epsilon<span class="op">));</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span>dx<span class="op">,</span> dy<span class="op">,</span> dz<span class="op">));</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="4" type="1">
<li><strong>Optimization: Bounding sphere</strong> (optional but recommended)</li>
</ol>
<p>To avoid checking the entire ray, use a bounding sphere:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If point is outside bounding sphere, return sphere's SDF</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">// If point is inside, compute the actual implicit function</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">boundedImplicit</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> boundingSphere <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">)</span> <span class="op">-</span> <span class="fl">3.0</span><span class="op">;</span>  <span class="co">// Sphere of radius 3</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="op">(</span>boundingSphere <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> boundingSphere<span class="op">;</span>  <span class="co">// Outside, use sphere distance</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">implicitFunction</span><span class="op">(</span>p<span class="op">);</span>  <span class="co">// Inside, compute actual</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Expected output:</strong> A rendering of your chosen algebraic surface with proper lighting showing its geometric features.</p>
</section>
<section id="optional-advanced-lighting-and-transformations" class="level3">
<h3 class="anchored" data-anchor-id="optional-advanced-lighting-and-transformations">Optional: Advanced Lighting and Transformations</h3>
<p>Pick one or more to explore:</p>
<section id="specular-lighting-phong-model" class="level4">
<h4 class="anchored" data-anchor-id="specular-lighting-phong-model">1. Specular Lighting (Phong Model)</h4>
<p>Add specular highlights using the Phong reflection model: <span class="math display">\[\text{specular} = (\mathbf{r} \cdot \mathbf{v})^n\]</span></p>
<p>where: - <span class="math inline">\(\mathbf{r}\)</span> is the reflected light direction: <span class="math inline">\(\mathbf{r} = 2(\mathbf{n} \cdot \mathbf{l})\mathbf{n} - \mathbf{l}\)</span> - <span class="math inline">\(\mathbf{v}\)</span> is the view direction (toward camera): <span class="math inline">\(\mathbf{v} = -\text{ray.direction}\)</span> - <span class="math inline">\(n\)</span> is the shininess exponent (try 32 or 64)</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> r <span class="op">=</span> <span class="bu">reflect</span><span class="op">(-</span>lightDir<span class="op">,</span> normal<span class="op">);</span>  <span class="co">// GLSL has reflect built-in</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> specular <span class="op">=</span> <span class="bu">pow</span><span class="op">(</span><span class="bu">max</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="bu">dot</span><span class="op">(</span>r<span class="op">,</span> viewDir<span class="op">)),</span> <span class="fl">32.0</span><span class="op">);</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> specular<span class="op">;</span>  <span class="co">// Add white specular highlight</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="rotation-matrices" class="level4">
<h4 class="anchored" data-anchor-id="rotation-matrices">2. Rotation Matrices</h4>
<p>Transform objects using rotation matrices.</p>
<p><strong>Rotation around Y-axis by angle θ:</strong> <span class="math display">\[R_y(\theta) = \begin{pmatrix}
\cos\theta &amp; 0 &amp; \sin\theta \\
0 &amp; 1 &amp; 0 \\
-\sin\theta &amp; 0 &amp; \cos\theta
\end{pmatrix}\]</span></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> <span class="fu">rotateY</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">float</span> angle<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> c <span class="op">=</span> <span class="bu">cos</span><span class="op">(</span>angle<span class="op">);</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> s <span class="op">=</span> <span class="bu">sin</span><span class="op">(</span>angle<span class="op">);</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec3</span><span class="op">(</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> c <span class="op">+</span> p<span class="op">.</span><span class="fu">z</span> <span class="op">*</span> s<span class="op">,</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        p<span class="op">.</span><span class="fu">y</span><span class="op">,</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> s <span class="op">+</span> p<span class="op">.</span><span class="fu">z</span> <span class="op">*</span> c</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Use in SDF:</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">sdRotatedTorus</span><span class="op">(</span><span class="dt">vec3</span> p<span class="op">,</span> <span class="dt">vec3</span> center<span class="op">,</span> <span class="dt">float</span> angle<span class="op">,</span> <span class="dt">float</span> R<span class="op">,</span> <span class="dt">float</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> q <span class="op">=</span> <span class="fu">rotateY</span><span class="op">(</span>p <span class="op">-</span> center<span class="op">,</span> angle<span class="op">);</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">sdTorus</span><span class="op">(</span>q<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">),</span> R<span class="op">,</span> r<span class="op">);</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="complex-scene" class="level4">
<h4 class="anchored" data-anchor-id="complex-scene">3. Complex Scene</h4>
<p>Create a scene with multiple transformed objects: - Multiple spheres at different positions - Rotated boxes or tori - A ground plane - Experiment with composition</p>
<hr>
</section>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="4.13">
<h2 data-number="4.13" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">4.13</span> Looking Ahead</h2>
<p>Tomorrow (Day 5) we’ll explore advanced raymarching techniques: - Domain operations (repetition, symmetry) for creating infinite patterns - Boolean operations (union, intersection, smooth blending) - 3D fractals via iterated folding (Menger sponge) - Creating complex scenes from simple primitives</p>
<p>You’ll leave with a toolkit for rendering virtually any geometry you can imagine!</p>
<p>Make sure you’re comfortable with: - The raymarching algorithm (it’s the foundation for Day 5) - SDF composition (taking min/max for combinations) - Normal estimation via gradients - Basic lighting (diffuse shading)</p>
<p>See you tomorrow!</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./day3.html" class="pagination-link" aria-label="Day 3: Fractals and Hyperbolic Geometry">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Fractals and Hyperbolic Geometry</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./day5a.html" class="pagination-link" aria-label="Day 5a">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb28" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 4: Introduction to 3D Rendering</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>Today we enter the third dimension! We'll learn how to set up a camera and cast rays from each pixel, then implement ray-object intersection testing. We'll start with analytical methods (solving equations directly) for spheres and tori, then transition to raymarching with signed distance functions—a more flexible approach that will enable complex scenes.</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll be able to render implicit surfaces in 3D with basic lighting, setting the foundation for tomorrow's advanced techniques.</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Camera and Ray Setup</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Rendering Equation (Simplified)</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>For each pixel, we need to:</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Determine which ray in 3D space corresponds to that pixel</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Find where (if anywhere) the ray intersects scene geometry</span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Compute the color based on surface properties and lighting</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a><span class="fu">### Coordinate System</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>We'll use the Three.js convention:</span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Y-axis points up</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Z-axis points toward the camera (out of the screen)</span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>X-axis points right</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>This is a right-handed coordinate system</span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="fu">### Camera Model</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>We'll use a simple pinhole camera model:</span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Camera positioned at the origin (for now)</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Looking down the -Z axis</span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Field of view (FOV) determines the viewing frustum</span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a><span class="fu">### Ray Generation</span></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>For a pixel at normalized coordinates $(u, v) \in <span class="co">[</span><span class="ot">-1, 1</span><span class="co">]</span>^2$, we generate a ray with:</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Origin**: $\mathbf{o} = (0, 0, 0)$ (camera position)</span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Direction**: $\mathbf{d} = \text{normalize}(u \cdot \text{right}, v \cdot \text{up}, -\text{focal length})$</span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>The focal length relates to field of view: for FOV angle $\theta$, we have $\text{focal length} = 1 / \tan(\theta/2)$.</span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a><span class="in">struct Ray {</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 origin;</span></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 direction;</span></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a><span class="in">Ray getRay(vec2 fragCoord, vec2 resolution, float fov) {</span></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a><span class="in">    // Normalize to [-1, 1]</span></span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = (fragCoord / resolution) * 2.0 - 1.0;</span></span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a><span class="in">    // Correct for aspect ratio</span></span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= resolution.x / resolution.y;</span></span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a><span class="in">    // Compute focal length from FOV</span></span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a><span class="in">    float focalLength = 1.0 / tan(radians(fov) / 2.0);</span></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a><span class="in">    // Ray from origin through pixel</span></span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a><span class="in">    Ray ray;</span></span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a><span class="in">    ray.origin = vec3(0.0, 0.0, 0.0);</span></span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a><span class="in">    ray.direction = normalize(vec3(uv.x, uv.y, -focalLength));</span></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a><span class="in">    return ray;</span></span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a><span class="fu">### Points Along a Ray</span></span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a>A parametric ray can be written as:</span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a>$$\mathbf{L}(t) = \mathbf{o} + t\mathbf{d}$$</span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-75"><a href="#cb28-75" aria-hidden="true" tabindex="-1"></a>where $\mathbf{o}$ is the origin, $\mathbf{d}$ is the direction, and $t \geq 0$ is the parameter.</span>
<span id="cb28-76"><a href="#cb28-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-77"><a href="#cb28-77" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-78"><a href="#cb28-78" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 rayPoint(Ray ray, float t) {</span></span>
<span id="cb28-79"><a href="#cb28-79" aria-hidden="true" tabindex="-1"></a><span class="in">    return ray.origin + t * ray.direction;</span></span>
<span id="cb28-80"><a href="#cb28-80" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-81"><a href="#cb28-81" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-82"><a href="#cb28-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-83"><a href="#cb28-83" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-84"><a href="#cb28-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-85"><a href="#cb28-85" aria-hidden="true" tabindex="-1"></a><span class="fu">## Analytical Ray-Sphere Intersection</span></span>
<span id="cb28-86"><a href="#cb28-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-87"><a href="#cb28-87" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Sphere Equation</span></span>
<span id="cb28-88"><a href="#cb28-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-89"><a href="#cb28-89" aria-hidden="true" tabindex="-1"></a>A sphere of radius $r$ centered at the origin is defined implicitly by:</span>
<span id="cb28-90"><a href="#cb28-90" aria-hidden="true" tabindex="-1"></a>$$x^2 + y^2 + z^2 = r^2$$</span>
<span id="cb28-91"><a href="#cb28-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-92"><a href="#cb28-92" aria-hidden="true" tabindex="-1"></a>Or more compactly: $|\mathbf{p}|^2 = r^2$ for points $\mathbf{p}$ on the surface.</span>
<span id="cb28-93"><a href="#cb28-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-94"><a href="#cb28-94" aria-hidden="true" tabindex="-1"></a><span class="fu">### Setting Up the Intersection</span></span>
<span id="cb28-95"><a href="#cb28-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-96"><a href="#cb28-96" aria-hidden="true" tabindex="-1"></a>We want to find where the ray $\mathbf{L}(t) = \mathbf{o} + t\mathbf{d}$ intersects the sphere. Substituting the ray equation into the sphere equation:</span>
<span id="cb28-97"><a href="#cb28-97" aria-hidden="true" tabindex="-1"></a>$$|\mathbf{o} + t\mathbf{d}|^2 = r^2$$</span>
<span id="cb28-98"><a href="#cb28-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-99"><a href="#cb28-99" aria-hidden="true" tabindex="-1"></a>Expanding:</span>
<span id="cb28-100"><a href="#cb28-100" aria-hidden="true" tabindex="-1"></a>$$(\mathbf{o} + t\mathbf{d}) \cdot (\mathbf{o} + t\mathbf{d}) = r^2$$</span>
<span id="cb28-101"><a href="#cb28-101" aria-hidden="true" tabindex="-1"></a>$$|\mathbf{o}|^2 + 2t(\mathbf{o} \cdot \mathbf{d}) + t^2|\mathbf{d}|^2 = r^2$$</span>
<span id="cb28-102"><a href="#cb28-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-103"><a href="#cb28-103" aria-hidden="true" tabindex="-1"></a>This is a quadratic equation in $t$:</span>
<span id="cb28-104"><a href="#cb28-104" aria-hidden="true" tabindex="-1"></a>$$at^2 + bt + c = 0$$</span>
<span id="cb28-105"><a href="#cb28-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-106"><a href="#cb28-106" aria-hidden="true" tabindex="-1"></a>where:</span>
<span id="cb28-107"><a href="#cb28-107" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$a = |\mathbf{d}|^2$ (which is 1 if $\mathbf{d}$ is normalized)</span>
<span id="cb28-108"><a href="#cb28-108" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$b = 2(\mathbf{o} \cdot \mathbf{d})$</span>
<span id="cb28-109"><a href="#cb28-109" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$c = |\mathbf{o}|^2 - r^2$</span>
<span id="cb28-110"><a href="#cb28-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-111"><a href="#cb28-111" aria-hidden="true" tabindex="-1"></a><span class="fu">### Solving the Quadratic</span></span>
<span id="cb28-112"><a href="#cb28-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-113"><a href="#cb28-113" aria-hidden="true" tabindex="-1"></a>The solutions are:</span>
<span id="cb28-114"><a href="#cb28-114" aria-hidden="true" tabindex="-1"></a>$$t = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$</span>
<span id="cb28-115"><a href="#cb28-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-116"><a href="#cb28-116" aria-hidden="true" tabindex="-1"></a>The discriminant $\Delta = b^2 - 4ac$ tells us:</span>
<span id="cb28-117"><a href="#cb28-117" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\Delta &lt; 0$: no intersection (ray misses sphere)</span>
<span id="cb28-118"><a href="#cb28-118" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\Delta = 0$: one intersection (ray is tangent)</span>
<span id="cb28-119"><a href="#cb28-119" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\Delta &gt; 0$: two intersections (ray enters and exits sphere)</span>
<span id="cb28-120"><a href="#cb28-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-121"><a href="#cb28-121" aria-hidden="true" tabindex="-1"></a>We want the smaller positive $t$ (the closer intersection point).</span>
<span id="cb28-122"><a href="#cb28-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-123"><a href="#cb28-123" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb28-124"><a href="#cb28-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-125"><a href="#cb28-125" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-126"><a href="#cb28-126" aria-hidden="true" tabindex="-1"></a><span class="in">float intersectSphere(Ray ray, vec3 center, float radius) {</span></span>
<span id="cb28-127"><a href="#cb28-127" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 oc = ray.origin - center;  // o - c (sphere center)</span></span>
<span id="cb28-128"><a href="#cb28-128" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-129"><a href="#cb28-129" aria-hidden="true" tabindex="-1"></a><span class="in">    float a = dot(ray.direction, ray.direction);  // Should be 1 if normalized</span></span>
<span id="cb28-130"><a href="#cb28-130" aria-hidden="true" tabindex="-1"></a><span class="in">    float b = 2.0 * dot(oc, ray.direction);</span></span>
<span id="cb28-131"><a href="#cb28-131" aria-hidden="true" tabindex="-1"></a><span class="in">    float c = dot(oc, oc) - radius * radius;</span></span>
<span id="cb28-132"><a href="#cb28-132" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-133"><a href="#cb28-133" aria-hidden="true" tabindex="-1"></a><span class="in">    float discriminant = b * b - 4.0 * a * c;</span></span>
<span id="cb28-134"><a href="#cb28-134" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-135"><a href="#cb28-135" aria-hidden="true" tabindex="-1"></a><span class="in">    if (discriminant &lt; 0.0) {</span></span>
<span id="cb28-136"><a href="#cb28-136" aria-hidden="true" tabindex="-1"></a><span class="in">        return -1.0;  // No intersection</span></span>
<span id="cb28-137"><a href="#cb28-137" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-138"><a href="#cb28-138" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-139"><a href="#cb28-139" aria-hidden="true" tabindex="-1"></a><span class="in">    // Return the closer intersection</span></span>
<span id="cb28-140"><a href="#cb28-140" aria-hidden="true" tabindex="-1"></a><span class="in">    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);</span></span>
<span id="cb28-141"><a href="#cb28-141" aria-hidden="true" tabindex="-1"></a><span class="in">    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);</span></span>
<span id="cb28-142"><a href="#cb28-142" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-143"><a href="#cb28-143" aria-hidden="true" tabindex="-1"></a><span class="in">    // Return the closest positive t</span></span>
<span id="cb28-144"><a href="#cb28-144" aria-hidden="true" tabindex="-1"></a><span class="in">    if (t1 &gt; 0.0) return t1;</span></span>
<span id="cb28-145"><a href="#cb28-145" aria-hidden="true" tabindex="-1"></a><span class="in">    if (t2 &gt; 0.0) return t2;</span></span>
<span id="cb28-146"><a href="#cb28-146" aria-hidden="true" tabindex="-1"></a><span class="in">    return -1.0;  // Behind camera</span></span>
<span id="cb28-147"><a href="#cb28-147" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-148"><a href="#cb28-148" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-149"><a href="#cb28-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-150"><a href="#cb28-150" aria-hidden="true" tabindex="-1"></a><span class="fu">### Rendering the Sphere</span></span>
<span id="cb28-151"><a href="#cb28-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-152"><a href="#cb28-152" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-153"><a href="#cb28-153" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-154"><a href="#cb28-154" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-155"><a href="#cb28-155" aria-hidden="true" tabindex="-1"></a><span class="in">    // Setup ray</span></span>
<span id="cb28-156"><a href="#cb28-156" aria-hidden="true" tabindex="-1"></a><span class="in">    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);</span></span>
<span id="cb28-157"><a href="#cb28-157" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-158"><a href="#cb28-158" aria-hidden="true" tabindex="-1"></a><span class="in">    // Sphere parameters</span></span>
<span id="cb28-159"><a href="#cb28-159" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);  // In front of camera</span></span>
<span id="cb28-160"><a href="#cb28-160" aria-hidden="true" tabindex="-1"></a><span class="in">    float sphereRadius = 1.0;</span></span>
<span id="cb28-161"><a href="#cb28-161" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-162"><a href="#cb28-162" aria-hidden="true" tabindex="-1"></a><span class="in">    // Test intersection</span></span>
<span id="cb28-163"><a href="#cb28-163" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = intersectSphere(ray, sphereCenter, sphereRadius);</span></span>
<span id="cb28-164"><a href="#cb28-164" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-165"><a href="#cb28-165" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color;</span></span>
<span id="cb28-166"><a href="#cb28-166" aria-hidden="true" tabindex="-1"></a><span class="in">    if (t &gt; 0.0) {</span></span>
<span id="cb28-167"><a href="#cb28-167" aria-hidden="true" tabindex="-1"></a><span class="in">        // Hit the sphere!</span></span>
<span id="cb28-168"><a href="#cb28-168" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 0.0, 0.0);  // Red</span></span>
<span id="cb28-169"><a href="#cb28-169" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb28-170"><a href="#cb28-170" aria-hidden="true" tabindex="-1"></a><span class="in">        // Background</span></span>
<span id="cb28-171"><a href="#cb28-171" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.1, 0.1, 0.2);  // Dark blue</span></span>
<span id="cb28-172"><a href="#cb28-172" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-173"><a href="#cb28-173" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-174"><a href="#cb28-174" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-175"><a href="#cb28-175" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-176"><a href="#cb28-176" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-177"><a href="#cb28-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-178"><a href="#cb28-178" aria-hidden="true" tabindex="-1"></a>**Result:** You should see a red disk on a blue background. But it looks flat—we can't see that it's a sphere!</span>
<span id="cb28-179"><a href="#cb28-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-180"><a href="#cb28-180" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-181"><a href="#cb28-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-182"><a href="#cb28-182" aria-hidden="true" tabindex="-1"></a><span class="fu">## Adding Lighting: The Surface Normal</span></span>
<span id="cb28-183"><a href="#cb28-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-184"><a href="#cb28-184" aria-hidden="true" tabindex="-1"></a><span class="fu">### Computing the Normal</span></span>
<span id="cb28-185"><a href="#cb28-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-186"><a href="#cb28-186" aria-hidden="true" tabindex="-1"></a>For a sphere centered at $\mathbf{c}$, the outward normal at a point $\mathbf{p}$ on the surface is:</span>
<span id="cb28-187"><a href="#cb28-187" aria-hidden="true" tabindex="-1"></a>$$\mathbf{n} = \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|} = \frac{\mathbf{p} - \mathbf{c}}{r}$$</span>
<span id="cb28-188"><a href="#cb28-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-189"><a href="#cb28-189" aria-hidden="true" tabindex="-1"></a>This is just the vector from the center to the surface point, normalized.</span>
<span id="cb28-190"><a href="#cb28-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-191"><a href="#cb28-191" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-192"><a href="#cb28-192" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 sphereNormal(vec3 point, vec3 center, float radius) {</span></span>
<span id="cb28-193"><a href="#cb28-193" aria-hidden="true" tabindex="-1"></a><span class="in">    return (point - center) / radius;</span></span>
<span id="cb28-194"><a href="#cb28-194" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-195"><a href="#cb28-195" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-196"><a href="#cb28-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-197"><a href="#cb28-197" aria-hidden="true" tabindex="-1"></a><span class="fu">### Diffuse Lighting</span></span>
<span id="cb28-198"><a href="#cb28-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-199"><a href="#cb28-199" aria-hidden="true" tabindex="-1"></a>The simplest lighting model: **Lambertian diffuse shading**. The brightness depends on the angle between the surface normal $\mathbf{n}$ and the light direction $\mathbf{l}$:</span>
<span id="cb28-200"><a href="#cb28-200" aria-hidden="true" tabindex="-1"></a>$$\text{brightness} = \max(0, \mathbf{n} \cdot \mathbf{l})$$</span>
<span id="cb28-201"><a href="#cb28-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-202"><a href="#cb28-202" aria-hidden="true" tabindex="-1"></a>The $\max(0, \cdots)$ ensures we don't get negative light (surfaces facing away from the light are dark).</span>
<span id="cb28-203"><a href="#cb28-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-204"><a href="#cb28-204" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation with Lighting</span></span>
<span id="cb28-205"><a href="#cb28-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-206"><a href="#cb28-206" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-207"><a href="#cb28-207" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-208"><a href="#cb28-208" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-209"><a href="#cb28-209" aria-hidden="true" tabindex="-1"></a><span class="in">    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);</span></span>
<span id="cb28-210"><a href="#cb28-210" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-211"><a href="#cb28-211" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);</span></span>
<span id="cb28-212"><a href="#cb28-212" aria-hidden="true" tabindex="-1"></a><span class="in">    float sphereRadius = 1.0;</span></span>
<span id="cb28-213"><a href="#cb28-213" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-214"><a href="#cb28-214" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = intersectSphere(ray, sphereCenter, sphereRadius);</span></span>
<span id="cb28-215"><a href="#cb28-215" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-216"><a href="#cb28-216" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color;</span></span>
<span id="cb28-217"><a href="#cb28-217" aria-hidden="true" tabindex="-1"></a><span class="in">    if (t &gt; 0.0) {</span></span>
<span id="cb28-218"><a href="#cb28-218" aria-hidden="true" tabindex="-1"></a><span class="in">        // Compute intersection point</span></span>
<span id="cb28-219"><a href="#cb28-219" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 hitPoint = rayPoint(ray, t);</span></span>
<span id="cb28-220"><a href="#cb28-220" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-221"><a href="#cb28-221" aria-hidden="true" tabindex="-1"></a><span class="in">        // Compute normal</span></span>
<span id="cb28-222"><a href="#cb28-222" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 normal = sphereNormal(hitPoint, sphereCenter, sphereRadius);</span></span>
<span id="cb28-223"><a href="#cb28-223" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-224"><a href="#cb28-224" aria-hidden="true" tabindex="-1"></a><span class="in">        // Light direction (fixed, from above and to the right)</span></span>
<span id="cb28-225"><a href="#cb28-225" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));</span></span>
<span id="cb28-226"><a href="#cb28-226" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-227"><a href="#cb28-227" aria-hidden="true" tabindex="-1"></a><span class="in">        // Diffuse lighting</span></span>
<span id="cb28-228"><a href="#cb28-228" aria-hidden="true" tabindex="-1"></a><span class="in">        float diffuse = max(0.0, dot(normal, lightDir));</span></span>
<span id="cb28-229"><a href="#cb28-229" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-230"><a href="#cb28-230" aria-hidden="true" tabindex="-1"></a><span class="in">        // Color the sphere</span></span>
<span id="cb28-231"><a href="#cb28-231" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 sphereColor = vec3(1.0, 0.0, 0.0);  // Red</span></span>
<span id="cb28-232"><a href="#cb28-232" aria-hidden="true" tabindex="-1"></a><span class="in">        color = sphereColor * diffuse;</span></span>
<span id="cb28-233"><a href="#cb28-233" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-234"><a href="#cb28-234" aria-hidden="true" tabindex="-1"></a><span class="in">        // Add a bit of ambient light so dark side isn't completely black</span></span>
<span id="cb28-235"><a href="#cb28-235" aria-hidden="true" tabindex="-1"></a><span class="in">        color += sphereColor * 0.1;</span></span>
<span id="cb28-236"><a href="#cb28-236" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb28-237"><a href="#cb28-237" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.1, 0.1, 0.2);</span></span>
<span id="cb28-238"><a href="#cb28-238" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-239"><a href="#cb28-239" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-240"><a href="#cb28-240" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-241"><a href="#cb28-241" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-242"><a href="#cb28-242" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-243"><a href="#cb28-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-244"><a href="#cb28-244" aria-hidden="true" tabindex="-1"></a>**Result:** Now the sphere looks 3D! The lighting reveals its curvature.</span>
<span id="cb28-245"><a href="#cb28-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-246"><a href="#cb28-246" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-247"><a href="#cb28-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-248"><a href="#cb28-248" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ray-Torus Intersection</span></span>
<span id="cb28-249"><a href="#cb28-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-250"><a href="#cb28-250" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Torus Equation</span></span>
<span id="cb28-251"><a href="#cb28-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-252"><a href="#cb28-252" aria-hidden="true" tabindex="-1"></a>A torus with major radius $R$ (center to tube center) and minor radius $r$ (tube radius) centered at the origin with axis along the Y-axis has the implicit equation:</span>
<span id="cb28-253"><a href="#cb28-253" aria-hidden="true" tabindex="-1"></a>$$\left(\sqrt{x^2 + z^2} - R\right)^2 + y^2 = r^2$$</span>
<span id="cb28-254"><a href="#cb28-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-255"><a href="#cb28-255" aria-hidden="true" tabindex="-1"></a>Or equivalently:</span>
<span id="cb28-256"><a href="#cb28-256" aria-hidden="true" tabindex="-1"></a>$$\left(|\mathbf{p}_{xz}| - R\right)^2 + p_y^2 = r^2$$</span>
<span id="cb28-257"><a href="#cb28-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-258"><a href="#cb28-258" aria-hidden="true" tabindex="-1"></a>where $\mathbf{p}_{xz} = (p_x, p_z)$ is the projection onto the XZ-plane.</span>
<span id="cb28-259"><a href="#cb28-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-260"><a href="#cb28-260" aria-hidden="true" tabindex="-1"></a><span class="fu">### Computing the Gradient (Normal)</span></span>
<span id="cb28-261"><a href="#cb28-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-262"><a href="#cb28-262" aria-hidden="true" tabindex="-1"></a>The gradient of the implicit function $F(x, y, z) = \left(\sqrt{x^2 + z^2} - R\right)^2 + y^2 - r^2$ gives the normal direction.</span>
<span id="cb28-263"><a href="#cb28-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-264"><a href="#cb28-264" aria-hidden="true" tabindex="-1"></a>Let $q = \sqrt{x^2 + z^2}$. Then:</span>
<span id="cb28-265"><a href="#cb28-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-266"><a href="#cb28-266" aria-hidden="true" tabindex="-1"></a>$$\frac{\partial F}{\partial x} = 2\left(q - R\right) \cdot \frac{x}{q}$$</span>
<span id="cb28-267"><a href="#cb28-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-268"><a href="#cb28-268" aria-hidden="true" tabindex="-1"></a>$$\frac{\partial F}{\partial y} = 2y$$</span>
<span id="cb28-269"><a href="#cb28-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-270"><a href="#cb28-270" aria-hidden="true" tabindex="-1"></a>$$\frac{\partial F}{\partial z} = 2\left(q - R\right) \cdot \frac{z}{q}$$</span>
<span id="cb28-271"><a href="#cb28-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-272"><a href="#cb28-272" aria-hidden="true" tabindex="-1"></a>The normal is:</span>
<span id="cb28-273"><a href="#cb28-273" aria-hidden="true" tabindex="-1"></a>$$\mathbf{n} = \nabla F = \left(\frac{\partial F}{\partial x}, \frac{\partial F}{\partial y}, \frac{\partial F}{\partial z}\right)$$</span>
<span id="cb28-274"><a href="#cb28-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-275"><a href="#cb28-275" aria-hidden="true" tabindex="-1"></a>normalized to unit length.</span>
<span id="cb28-276"><a href="#cb28-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-277"><a href="#cb28-277" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb28-278"><a href="#cb28-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-279"><a href="#cb28-279" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-280"><a href="#cb28-280" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 torusNormal(vec3 p, float majorRadius, float minorRadius) {</span></span>
<span id="cb28-281"><a href="#cb28-281" aria-hidden="true" tabindex="-1"></a><span class="in">    // Project to XZ plane</span></span>
<span id="cb28-282"><a href="#cb28-282" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 pxz = vec2(p.x, p.z);</span></span>
<span id="cb28-283"><a href="#cb28-283" aria-hidden="true" tabindex="-1"></a><span class="in">    float q = length(pxz);</span></span>
<span id="cb28-284"><a href="#cb28-284" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-285"><a href="#cb28-285" aria-hidden="true" tabindex="-1"></a><span class="in">    // Gradient components</span></span>
<span id="cb28-286"><a href="#cb28-286" aria-hidden="true" tabindex="-1"></a><span class="in">    float factor = q - majorRadius;</span></span>
<span id="cb28-287"><a href="#cb28-287" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 grad;</span></span>
<span id="cb28-288"><a href="#cb28-288" aria-hidden="true" tabindex="-1"></a><span class="in">    grad.x = 2.0 * factor * p.x / q;</span></span>
<span id="cb28-289"><a href="#cb28-289" aria-hidden="true" tabindex="-1"></a><span class="in">    grad.y = 2.0 * p.y;</span></span>
<span id="cb28-290"><a href="#cb28-290" aria-hidden="true" tabindex="-1"></a><span class="in">    grad.z = 2.0 * factor * p.z / q;</span></span>
<span id="cb28-291"><a href="#cb28-291" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-292"><a href="#cb28-292" aria-hidden="true" tabindex="-1"></a><span class="in">    return normalize(grad);</span></span>
<span id="cb28-293"><a href="#cb28-293" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-294"><a href="#cb28-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-295"><a href="#cb28-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-296"><a href="#cb28-296" aria-hidden="true" tabindex="-1"></a><span class="fu">### Finding the Intersection</span></span>
<span id="cb28-297"><a href="#cb28-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-298"><a href="#cb28-298" aria-hidden="true" tabindex="-1"></a>Finding the exact intersection between a ray and a torus requires solving a **quartic equation** (degree 4 polynomial). This is algebraically messy!</span>
<span id="cb28-299"><a href="#cb28-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-300"><a href="#cb28-300" aria-hidden="true" tabindex="-1"></a>We can:</span>
<span id="cb28-301"><a href="#cb28-301" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Use a numerical root-finding method (Newton's method, bisection)</span>
<span id="cb28-302"><a href="#cb28-302" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Or... use a different approach (foreshadowing: raymarching!)</span>
<span id="cb28-303"><a href="#cb28-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-304"><a href="#cb28-304" aria-hidden="true" tabindex="-1"></a>For now, let's implement a simple bisection method to find the intersection:</span>
<span id="cb28-305"><a href="#cb28-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-306"><a href="#cb28-306" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-307"><a href="#cb28-307" aria-hidden="true" tabindex="-1"></a><span class="in">float torusImplicit(vec3 p, float R, float r) {</span></span>
<span id="cb28-308"><a href="#cb28-308" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 pxz = vec2(p.x, p.z);</span></span>
<span id="cb28-309"><a href="#cb28-309" aria-hidden="true" tabindex="-1"></a><span class="in">    float q = length(pxz) - R;</span></span>
<span id="cb28-310"><a href="#cb28-310" aria-hidden="true" tabindex="-1"></a><span class="in">    return q * q + p.y * p.y - r * r;</span></span>
<span id="cb28-311"><a href="#cb28-311" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-312"><a href="#cb28-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-313"><a href="#cb28-313" aria-hidden="true" tabindex="-1"></a><span class="in">float intersectTorus(Ray ray, float majorRadius, float minorRadius) {</span></span>
<span id="cb28-314"><a href="#cb28-314" aria-hidden="true" tabindex="-1"></a><span class="in">    // Bisection method to find root of F(ray(t)) = 0</span></span>
<span id="cb28-315"><a href="#cb28-315" aria-hidden="true" tabindex="-1"></a><span class="in">    float tMin = 0.0;</span></span>
<span id="cb28-316"><a href="#cb28-316" aria-hidden="true" tabindex="-1"></a><span class="in">    float tMax = 10.0;  // Search range</span></span>
<span id="cb28-317"><a href="#cb28-317" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-318"><a href="#cb28-318" aria-hidden="true" tabindex="-1"></a><span class="in">    // Check if there's a sign change (indicating a root exists)</span></span>
<span id="cb28-319"><a href="#cb28-319" aria-hidden="true" tabindex="-1"></a><span class="in">    float fMin = torusImplicit(rayPoint(ray, tMin), majorRadius, minorRadius);</span></span>
<span id="cb28-320"><a href="#cb28-320" aria-hidden="true" tabindex="-1"></a><span class="in">    float fMax = torusImplicit(rayPoint(ray, tMax), majorRadius, minorRadius);</span></span>
<span id="cb28-321"><a href="#cb28-321" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-322"><a href="#cb28-322" aria-hidden="true" tabindex="-1"></a><span class="in">    if (fMin * fMax &gt; 0.0) {</span></span>
<span id="cb28-323"><a href="#cb28-323" aria-hidden="true" tabindex="-1"></a><span class="in">        return -1.0;  // No intersection in range</span></span>
<span id="cb28-324"><a href="#cb28-324" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-325"><a href="#cb28-325" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-326"><a href="#cb28-326" aria-hidden="true" tabindex="-1"></a><span class="in">    // Bisection</span></span>
<span id="cb28-327"><a href="#cb28-327" aria-hidden="true" tabindex="-1"></a><span class="in">    for (int i = 0; i &lt; 50; i++) {</span></span>
<span id="cb28-328"><a href="#cb28-328" aria-hidden="true" tabindex="-1"></a><span class="in">        float tMid = (tMin + tMax) / 2.0;</span></span>
<span id="cb28-329"><a href="#cb28-329" aria-hidden="true" tabindex="-1"></a><span class="in">        float fMid = torusImplicit(rayPoint(ray, tMid), majorRadius, minorRadius);</span></span>
<span id="cb28-330"><a href="#cb28-330" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-331"><a href="#cb28-331" aria-hidden="true" tabindex="-1"></a><span class="in">        if (abs(fMid) &lt; 0.001) {</span></span>
<span id="cb28-332"><a href="#cb28-332" aria-hidden="true" tabindex="-1"></a><span class="in">            return tMid;  // Found intersection</span></span>
<span id="cb28-333"><a href="#cb28-333" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb28-334"><a href="#cb28-334" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-335"><a href="#cb28-335" aria-hidden="true" tabindex="-1"></a><span class="in">        if (fMin * fMid &lt; 0.0) {</span></span>
<span id="cb28-336"><a href="#cb28-336" aria-hidden="true" tabindex="-1"></a><span class="in">            tMax = tMid;</span></span>
<span id="cb28-337"><a href="#cb28-337" aria-hidden="true" tabindex="-1"></a><span class="in">            fMax = fMid;</span></span>
<span id="cb28-338"><a href="#cb28-338" aria-hidden="true" tabindex="-1"></a><span class="in">        } else {</span></span>
<span id="cb28-339"><a href="#cb28-339" aria-hidden="true" tabindex="-1"></a><span class="in">            tMin = tMid;</span></span>
<span id="cb28-340"><a href="#cb28-340" aria-hidden="true" tabindex="-1"></a><span class="in">            fMin = fMid;</span></span>
<span id="cb28-341"><a href="#cb28-341" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb28-342"><a href="#cb28-342" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-343"><a href="#cb28-343" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-344"><a href="#cb28-344" aria-hidden="true" tabindex="-1"></a><span class="in">    return (tMin + tMax) / 2.0;  // Best estimate</span></span>
<span id="cb28-345"><a href="#cb28-345" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-346"><a href="#cb28-346" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-347"><a href="#cb28-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-348"><a href="#cb28-348" aria-hidden="true" tabindex="-1"></a><span class="fu">### Rendering the Torus</span></span>
<span id="cb28-349"><a href="#cb28-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-350"><a href="#cb28-350" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-351"><a href="#cb28-351" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-352"><a href="#cb28-352" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-353"><a href="#cb28-353" aria-hidden="true" tabindex="-1"></a><span class="in">    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);</span></span>
<span id="cb28-354"><a href="#cb28-354" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-355"><a href="#cb28-355" aria-hidden="true" tabindex="-1"></a><span class="in">    // Torus parameters</span></span>
<span id="cb28-356"><a href="#cb28-356" aria-hidden="true" tabindex="-1"></a><span class="in">    float majorRadius = 1.5;</span></span>
<span id="cb28-357"><a href="#cb28-357" aria-hidden="true" tabindex="-1"></a><span class="in">    float minorRadius = 0.5;</span></span>
<span id="cb28-358"><a href="#cb28-358" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 torusCenter = vec3(0.0, 0.0, -4.0);</span></span>
<span id="cb28-359"><a href="#cb28-359" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-360"><a href="#cb28-360" aria-hidden="true" tabindex="-1"></a><span class="in">    // Adjust ray for torus center (translate)</span></span>
<span id="cb28-361"><a href="#cb28-361" aria-hidden="true" tabindex="-1"></a><span class="in">    Ray torusRay = ray;</span></span>
<span id="cb28-362"><a href="#cb28-362" aria-hidden="true" tabindex="-1"></a><span class="in">    torusRay.origin = ray.origin - torusCenter;</span></span>
<span id="cb28-363"><a href="#cb28-363" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-364"><a href="#cb28-364" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = intersectTorus(torusRay, majorRadius, minorRadius);</span></span>
<span id="cb28-365"><a href="#cb28-365" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-366"><a href="#cb28-366" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color;</span></span>
<span id="cb28-367"><a href="#cb28-367" aria-hidden="true" tabindex="-1"></a><span class="in">    if (t &gt; 0.0) {</span></span>
<span id="cb28-368"><a href="#cb28-368" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 hitPoint = rayPoint(torusRay, t);</span></span>
<span id="cb28-369"><a href="#cb28-369" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 normal = torusNormal(hitPoint, majorRadius, minorRadius);</span></span>
<span id="cb28-370"><a href="#cb28-370" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-371"><a href="#cb28-371" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));</span></span>
<span id="cb28-372"><a href="#cb28-372" aria-hidden="true" tabindex="-1"></a><span class="in">        float diffuse = max(0.0, dot(normal, lightDir));</span></span>
<span id="cb28-373"><a href="#cb28-373" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-374"><a href="#cb28-374" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 torusColor = vec3(0.0, 0.7, 1.0);  // Cyan</span></span>
<span id="cb28-375"><a href="#cb28-375" aria-hidden="true" tabindex="-1"></a><span class="in">        color = torusColor * diffuse + torusColor * 0.1;</span></span>
<span id="cb28-376"><a href="#cb28-376" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb28-377"><a href="#cb28-377" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.1, 0.1, 0.2);</span></span>
<span id="cb28-378"><a href="#cb28-378" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-379"><a href="#cb28-379" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-380"><a href="#cb28-380" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-381"><a href="#cb28-381" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-382"><a href="#cb28-382" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-383"><a href="#cb28-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-384"><a href="#cb28-384" aria-hidden="true" tabindex="-1"></a>**Result:** A beautiful cyan torus with proper 3D lighting!</span>
<span id="cb28-385"><a href="#cb28-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-386"><a href="#cb28-386" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-387"><a href="#cb28-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-388"><a href="#cb28-388" aria-hidden="true" tabindex="-1"></a><span class="fu">## Motivation for Raymarching</span></span>
<span id="cb28-389"><a href="#cb28-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-390"><a href="#cb28-390" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Problem with Analytical Methods</span></span>
<span id="cb28-391"><a href="#cb28-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-392"><a href="#cb28-392" aria-hidden="true" tabindex="-1"></a>Notice what we had to do:</span>
<span id="cb28-393"><a href="#cb28-393" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Sphere:** Solve a quadratic equation (manageable)</span>
<span id="cb28-394"><a href="#cb28-394" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Torus:** Solve a quartic equation (we used bisection instead)</span>
<span id="cb28-395"><a href="#cb28-395" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Arbitrary implicit surface:** Could be any degree polynomial, or transcendental!</span>
<span id="cb28-396"><a href="#cb28-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-397"><a href="#cb28-397" aria-hidden="true" tabindex="-1"></a>Moreover, combining objects is difficult:</span>
<span id="cb28-398"><a href="#cb28-398" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How do we render two spheres? Check each separately, take the closer one.</span>
<span id="cb28-399"><a href="#cb28-399" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How do we render the **union** of a sphere and torus? Check both, take closer.</span>
<span id="cb28-400"><a href="#cb28-400" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How do we render the **intersection** (only where both objects exist)? Much harder!</span>
<span id="cb28-401"><a href="#cb28-401" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How about **smooth blending** between objects? Nearly impossible analytically.</span>
<span id="cb28-402"><a href="#cb28-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-403"><a href="#cb28-403" aria-hidden="true" tabindex="-1"></a>We need a more flexible approach that works for:</span>
<span id="cb28-404"><a href="#cb28-404" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Arbitrary implicit surfaces</span>
<span id="cb28-405"><a href="#cb28-405" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Complex compositions of objects</span>
<span id="cb28-406"><a href="#cb28-406" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Procedurally defined geometry</span>
<span id="cb28-407"><a href="#cb28-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-408"><a href="#cb28-408" aria-hidden="true" tabindex="-1"></a>**Enter: Raymarching with Signed Distance Functions**</span>
<span id="cb28-409"><a href="#cb28-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-410"><a href="#cb28-410" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-411"><a href="#cb28-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-412"><a href="#cb28-412" aria-hidden="true" tabindex="-1"></a><span class="fu">## Signed Distance Functions (SDFs)</span></span>
<span id="cb28-413"><a href="#cb28-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-414"><a href="#cb28-414" aria-hidden="true" tabindex="-1"></a><span class="fu">### Definition</span></span>
<span id="cb28-415"><a href="#cb28-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-416"><a href="#cb28-416" aria-hidden="true" tabindex="-1"></a>A **signed distance function** $d: \mathbb{R}^3 \to \mathbb{R}$ gives the distance from any point in space to the closest point on a surface:</span>
<span id="cb28-417"><a href="#cb28-417" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$d(\mathbf{p}) &gt; 0$ if $\mathbf{p}$ is outside the surface</span>
<span id="cb28-418"><a href="#cb28-418" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$d(\mathbf{p}) = 0$ if $\mathbf{p}$ is on the surface</span>
<span id="cb28-419"><a href="#cb28-419" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$d(\mathbf{p}) &lt; 0$ if $\mathbf{p}$ is inside the surface</span>
<span id="cb28-420"><a href="#cb28-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-421"><a href="#cb28-421" aria-hidden="true" tabindex="-1"></a>Importantly, $|d(\mathbf{p})|$ is the actual Euclidean distance to the surface.</span>
<span id="cb28-422"><a href="#cb28-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-423"><a href="#cb28-423" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why SDFs?</span></span>
<span id="cb28-424"><a href="#cb28-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-425"><a href="#cb28-425" aria-hidden="true" tabindex="-1"></a>SDFs have a crucial property: if we're at a point $\mathbf{p}$ and the nearest surface is distance $d$ away, we can safely move $d$ units along any direction without hitting anything.</span>
<span id="cb28-426"><a href="#cb28-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-427"><a href="#cb28-427" aria-hidden="true" tabindex="-1"></a>This enables **sphere tracing**: we march along the ray, taking steps proportional to the SDF value, guaranteed not to overshoot the surface.</span>
<span id="cb28-428"><a href="#cb28-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-429"><a href="#cb28-429" aria-hidden="true" tabindex="-1"></a><span class="fu">### SDF for a Sphere</span></span>
<span id="cb28-430"><a href="#cb28-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-431"><a href="#cb28-431" aria-hidden="true" tabindex="-1"></a>For a sphere of radius $r$ centered at $\mathbf{c}$:</span>
<span id="cb28-432"><a href="#cb28-432" aria-hidden="true" tabindex="-1"></a>$$d(\mathbf{p}) = |\mathbf{p} - \mathbf{c}| - r$$</span>
<span id="cb28-433"><a href="#cb28-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-434"><a href="#cb28-434" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-435"><a href="#cb28-435" aria-hidden="true" tabindex="-1"></a><span class="in">float sdSphere(vec3 p, vec3 center, float radius) {</span></span>
<span id="cb28-436"><a href="#cb28-436" aria-hidden="true" tabindex="-1"></a><span class="in">    return length(p - center) - radius;</span></span>
<span id="cb28-437"><a href="#cb28-437" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-438"><a href="#cb28-438" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-439"><a href="#cb28-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-440"><a href="#cb28-440" aria-hidden="true" tabindex="-1"></a><span class="fu">### SDF for a Box</span></span>
<span id="cb28-441"><a href="#cb28-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-442"><a href="#cb28-442" aria-hidden="true" tabindex="-1"></a>For an axis-aligned box centered at the origin with half-extents $\mathbf{b} = (b_x, b_y, b_z)$:</span>
<span id="cb28-443"><a href="#cb28-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-444"><a href="#cb28-444" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-445"><a href="#cb28-445" aria-hidden="true" tabindex="-1"></a><span class="in">float sdBox(vec3 p, vec3 center, vec3 halfExtents) {</span></span>
<span id="cb28-446"><a href="#cb28-446" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 q = abs(p - center) - halfExtents;</span></span>
<span id="cb28-447"><a href="#cb28-447" aria-hidden="true" tabindex="-1"></a><span class="in">    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);</span></span>
<span id="cb28-448"><a href="#cb28-448" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-449"><a href="#cb28-449" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-450"><a href="#cb28-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-451"><a href="#cb28-451" aria-hidden="true" tabindex="-1"></a>(This formula handles both inside and outside the box correctly.)</span>
<span id="cb28-452"><a href="#cb28-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-453"><a href="#cb28-453" aria-hidden="true" tabindex="-1"></a><span class="fu">### SDF for a Plane</span></span>
<span id="cb28-454"><a href="#cb28-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-455"><a href="#cb28-455" aria-hidden="true" tabindex="-1"></a>For an infinite plane with normal $\mathbf{n}$ (unit vector) passing through point $\mathbf{p}_0$:</span>
<span id="cb28-456"><a href="#cb28-456" aria-hidden="true" tabindex="-1"></a>$$d(\mathbf{p}) = (\mathbf{p} - \mathbf{p}_0) \cdot \mathbf{n}$$</span>
<span id="cb28-457"><a href="#cb28-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-458"><a href="#cb28-458" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-459"><a href="#cb28-459" aria-hidden="true" tabindex="-1"></a><span class="in">float sdPlane(vec3 p, vec3 planePoint, vec3 normal) {</span></span>
<span id="cb28-460"><a href="#cb28-460" aria-hidden="true" tabindex="-1"></a><span class="in">    return dot(p - planePoint, normal);</span></span>
<span id="cb28-461"><a href="#cb28-461" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-462"><a href="#cb28-462" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-463"><a href="#cb28-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-464"><a href="#cb28-464" aria-hidden="true" tabindex="-1"></a>For the XZ-plane (Y = 0):</span>
<span id="cb28-465"><a href="#cb28-465" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-466"><a href="#cb28-466" aria-hidden="true" tabindex="-1"></a><span class="in">float sdPlaneY(vec3 p, float height) {</span></span>
<span id="cb28-467"><a href="#cb28-467" aria-hidden="true" tabindex="-1"></a><span class="in">    return p.y - height;</span></span>
<span id="cb28-468"><a href="#cb28-468" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-469"><a href="#cb28-469" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-470"><a href="#cb28-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-471"><a href="#cb28-471" aria-hidden="true" tabindex="-1"></a><span class="fu">### SDF for a Torus</span></span>
<span id="cb28-472"><a href="#cb28-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-473"><a href="#cb28-473" aria-hidden="true" tabindex="-1"></a>For a torus with major radius $R$ and minor radius $r$, axis along Y:</span>
<span id="cb28-474"><a href="#cb28-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-475"><a href="#cb28-475" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-476"><a href="#cb28-476" aria-hidden="true" tabindex="-1"></a><span class="in">float sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {</span></span>
<span id="cb28-477"><a href="#cb28-477" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 q = p - center;</span></span>
<span id="cb28-478"><a href="#cb28-478" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 pxz = vec2(q.x, q.z);</span></span>
<span id="cb28-479"><a href="#cb28-479" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(pxz) - majorRadius;</span></span>
<span id="cb28-480"><a href="#cb28-480" aria-hidden="true" tabindex="-1"></a><span class="in">    return length(vec2(d, q.y)) - minorRadius;</span></span>
<span id="cb28-481"><a href="#cb28-481" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-482"><a href="#cb28-482" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-483"><a href="#cb28-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-484"><a href="#cb28-484" aria-hidden="true" tabindex="-1"></a><span class="fu">### Other Primitives</span></span>
<span id="cb28-485"><a href="#cb28-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-486"><a href="#cb28-486" aria-hidden="true" tabindex="-1"></a>Many more SDFs exist! Cylinders, capsules, cones, ellipsoids, etc. See resources like <span class="co">[</span><span class="ot">Inigo Quilez's SDF functions</span><span class="co">](https://iquilezles.org/articles/distfunctions/)</span>.</span>
<span id="cb28-487"><a href="#cb28-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-488"><a href="#cb28-488" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-489"><a href="#cb28-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-490"><a href="#cb28-490" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Raymarching Algorithm</span></span>
<span id="cb28-491"><a href="#cb28-491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-492"><a href="#cb28-492" aria-hidden="true" tabindex="-1"></a><span class="fu">### Sphere Tracing</span></span>
<span id="cb28-493"><a href="#cb28-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-494"><a href="#cb28-494" aria-hidden="true" tabindex="-1"></a>The algorithm:</span>
<span id="cb28-495"><a href="#cb28-495" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Start at the ray origin</span>
<span id="cb28-496"><a href="#cb28-496" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Evaluate the SDF at the current point</span>
<span id="cb28-497"><a href="#cb28-497" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>March forward along the ray by that distance</span>
<span id="cb28-498"><a href="#cb28-498" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Repeat until:</span>
<span id="cb28-499"><a href="#cb28-499" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>We're very close to the surface (SDF ≈ 0) → hit!</span>
<span id="cb28-500"><a href="#cb28-500" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>We've marched too far → miss</span>
<span id="cb28-501"><a href="#cb28-501" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>We've taken too many steps → give up</span>
<span id="cb28-502"><a href="#cb28-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-503"><a href="#cb28-503" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-504"><a href="#cb28-504" aria-hidden="true" tabindex="-1"></a><span class="in">struct HitInfo {</span></span>
<span id="cb28-505"><a href="#cb28-505" aria-hidden="true" tabindex="-1"></a><span class="in">    bool hit;</span></span>
<span id="cb28-506"><a href="#cb28-506" aria-hidden="true" tabindex="-1"></a><span class="in">    float t;        // Distance along ray</span></span>
<span id="cb28-507"><a href="#cb28-507" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 position;  // Hit position</span></span>
<span id="cb28-508"><a href="#cb28-508" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb28-509"><a href="#cb28-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-510"><a href="#cb28-510" aria-hidden="true" tabindex="-1"></a><span class="in">HitInfo raymarch(Ray ray, float maxDist, int maxSteps) {</span></span>
<span id="cb28-511"><a href="#cb28-511" aria-hidden="true" tabindex="-1"></a><span class="in">    HitInfo info;</span></span>
<span id="cb28-512"><a href="#cb28-512" aria-hidden="true" tabindex="-1"></a><span class="in">    info.hit = false;</span></span>
<span id="cb28-513"><a href="#cb28-513" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-514"><a href="#cb28-514" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = 0.0;</span></span>
<span id="cb28-515"><a href="#cb28-515" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-516"><a href="#cb28-516" aria-hidden="true" tabindex="-1"></a><span class="in">    for (int i = 0; i &lt; maxSteps; i++) {</span></span>
<span id="cb28-517"><a href="#cb28-517" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 pos = rayPoint(ray, t);</span></span>
<span id="cb28-518"><a href="#cb28-518" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-519"><a href="#cb28-519" aria-hidden="true" tabindex="-1"></a><span class="in">        // Evaluate scene SDF (define this based on your scene)</span></span>
<span id="cb28-520"><a href="#cb28-520" aria-hidden="true" tabindex="-1"></a><span class="in">        float d = sceneSDF(pos);</span></span>
<span id="cb28-521"><a href="#cb28-521" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-522"><a href="#cb28-522" aria-hidden="true" tabindex="-1"></a><span class="in">        // Close enough to surface?</span></span>
<span id="cb28-523"><a href="#cb28-523" aria-hidden="true" tabindex="-1"></a><span class="in">        if (abs(d) &lt; 0.001) {</span></span>
<span id="cb28-524"><a href="#cb28-524" aria-hidden="true" tabindex="-1"></a><span class="in">            info.hit = true;</span></span>
<span id="cb28-525"><a href="#cb28-525" aria-hidden="true" tabindex="-1"></a><span class="in">            info.t = t;</span></span>
<span id="cb28-526"><a href="#cb28-526" aria-hidden="true" tabindex="-1"></a><span class="in">            info.position = pos;</span></span>
<span id="cb28-527"><a href="#cb28-527" aria-hidden="true" tabindex="-1"></a><span class="in">            return info;</span></span>
<span id="cb28-528"><a href="#cb28-528" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb28-529"><a href="#cb28-529" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-530"><a href="#cb28-530" aria-hidden="true" tabindex="-1"></a><span class="in">        // March forward</span></span>
<span id="cb28-531"><a href="#cb28-531" aria-hidden="true" tabindex="-1"></a><span class="in">        t += d;</span></span>
<span id="cb28-532"><a href="#cb28-532" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-533"><a href="#cb28-533" aria-hidden="true" tabindex="-1"></a><span class="in">        // Too far?</span></span>
<span id="cb28-534"><a href="#cb28-534" aria-hidden="true" tabindex="-1"></a><span class="in">        if (t &gt; maxDist) {</span></span>
<span id="cb28-535"><a href="#cb28-535" aria-hidden="true" tabindex="-1"></a><span class="in">            break;</span></span>
<span id="cb28-536"><a href="#cb28-536" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb28-537"><a href="#cb28-537" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-538"><a href="#cb28-538" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-539"><a href="#cb28-539" aria-hidden="true" tabindex="-1"></a><span class="in">    return info;</span></span>
<span id="cb28-540"><a href="#cb28-540" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-541"><a href="#cb28-541" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-542"><a href="#cb28-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-543"><a href="#cb28-543" aria-hidden="true" tabindex="-1"></a><span class="fu">### Scene SDF</span></span>
<span id="cb28-544"><a href="#cb28-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-545"><a href="#cb28-545" aria-hidden="true" tabindex="-1"></a>For a scene with multiple objects, we take the minimum distance to any object:</span>
<span id="cb28-546"><a href="#cb28-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-547"><a href="#cb28-547" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-548"><a href="#cb28-548" aria-hidden="true" tabindex="-1"></a><span class="in">float sceneSDF(vec3 p) {</span></span>
<span id="cb28-549"><a href="#cb28-549" aria-hidden="true" tabindex="-1"></a><span class="in">    // Sphere at (0, 0, -3)</span></span>
<span id="cb28-550"><a href="#cb28-550" aria-hidden="true" tabindex="-1"></a><span class="in">    float sphere = sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);</span></span>
<span id="cb28-551"><a href="#cb28-551" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-552"><a href="#cb28-552" aria-hidden="true" tabindex="-1"></a><span class="in">    // Ground plane</span></span>
<span id="cb28-553"><a href="#cb28-553" aria-hidden="true" tabindex="-1"></a><span class="in">    float ground = sdPlaneY(p, -1.0);</span></span>
<span id="cb28-554"><a href="#cb28-554" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-555"><a href="#cb28-555" aria-hidden="true" tabindex="-1"></a><span class="in">    // Return minimum distance</span></span>
<span id="cb28-556"><a href="#cb28-556" aria-hidden="true" tabindex="-1"></a><span class="in">    return min(sphere, ground);</span></span>
<span id="cb28-557"><a href="#cb28-557" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-558"><a href="#cb28-558" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-559"><a href="#cb28-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-560"><a href="#cb28-560" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-561"><a href="#cb28-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-562"><a href="#cb28-562" aria-hidden="true" tabindex="-1"></a><span class="fu">## Normal Estimation via Gradient</span></span>
<span id="cb28-563"><a href="#cb28-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-564"><a href="#cb28-564" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Gradient as Normal</span></span>
<span id="cb28-565"><a href="#cb28-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-566"><a href="#cb28-566" aria-hidden="true" tabindex="-1"></a>For an implicit surface $F(\mathbf{p}) = 0$, the gradient $\nabla F$ is perpendicular to the surface (it's the normal direction).</span>
<span id="cb28-567"><a href="#cb28-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-568"><a href="#cb28-568" aria-hidden="true" tabindex="-1"></a>For an SDF $d(\mathbf{p})$, the gradient points away from the surface:</span>
<span id="cb28-569"><a href="#cb28-569" aria-hidden="true" tabindex="-1"></a>$$\mathbf{n} = \nabla d = \left(\frac{\partial d}{\partial x}, \frac{\partial d}{\partial y}, \frac{\partial d}{\partial z}\right)$$</span>
<span id="cb28-570"><a href="#cb28-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-571"><a href="#cb28-571" aria-hidden="true" tabindex="-1"></a><span class="fu">### Finite Difference Approximation</span></span>
<span id="cb28-572"><a href="#cb28-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-573"><a href="#cb28-573" aria-hidden="true" tabindex="-1"></a>We estimate each partial derivative using finite differences:</span>
<span id="cb28-574"><a href="#cb28-574" aria-hidden="true" tabindex="-1"></a>$$\frac{\partial d}{\partial x} \approx \frac{d(x + \epsilon, y, z) - d(x - \epsilon, y, z)}{2\epsilon}$$</span>
<span id="cb28-575"><a href="#cb28-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-576"><a href="#cb28-576" aria-hidden="true" tabindex="-1"></a>and similarly for $y$ and $z$.</span>
<span id="cb28-577"><a href="#cb28-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-578"><a href="#cb28-578" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb28-579"><a href="#cb28-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-580"><a href="#cb28-580" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-581"><a href="#cb28-581" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 estimateNormal(vec3 p, float epsilon) {</span></span>
<span id="cb28-582"><a href="#cb28-582" aria-hidden="true" tabindex="-1"></a><span class="in">    // Sample SDF at nearby points</span></span>
<span id="cb28-583"><a href="#cb28-583" aria-hidden="true" tabindex="-1"></a><span class="in">    float dx = sceneSDF(p + vec3(epsilon, 0.0, 0.0)) - sceneSDF(p - vec3(epsilon, 0.0, 0.0));</span></span>
<span id="cb28-584"><a href="#cb28-584" aria-hidden="true" tabindex="-1"></a><span class="in">    float dy = sceneSDF(p + vec3(0.0, epsilon, 0.0)) - sceneSDF(p - vec3(0.0, epsilon, 0.0));</span></span>
<span id="cb28-585"><a href="#cb28-585" aria-hidden="true" tabindex="-1"></a><span class="in">    float dz = sceneSDF(p + vec3(0.0, 0.0, epsilon)) - sceneSDF(p - vec3(0.0, 0.0, epsilon));</span></span>
<span id="cb28-586"><a href="#cb28-586" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-587"><a href="#cb28-587" aria-hidden="true" tabindex="-1"></a><span class="in">    return normalize(vec3(dx, dy, dz));</span></span>
<span id="cb28-588"><a href="#cb28-588" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-589"><a href="#cb28-589" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-590"><a href="#cb28-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-591"><a href="#cb28-591" aria-hidden="true" tabindex="-1"></a>Typical choice: $\epsilon \approx 0.001$.</span>
<span id="cb28-592"><a href="#cb28-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-593"><a href="#cb28-593" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-594"><a href="#cb28-594" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-595"><a href="#cb28-595" aria-hidden="true" tabindex="-1"></a><span class="fu">## Putting It All Together: Raymarched Scenes</span></span>
<span id="cb28-596"><a href="#cb28-596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-597"><a href="#cb28-597" aria-hidden="true" tabindex="-1"></a><span class="fu">### Scene 1: Single Sphere</span></span>
<span id="cb28-598"><a href="#cb28-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-599"><a href="#cb28-599" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-600"><a href="#cb28-600" aria-hidden="true" tabindex="-1"></a><span class="in">float sceneSDF(vec3 p) {</span></span>
<span id="cb28-601"><a href="#cb28-601" aria-hidden="true" tabindex="-1"></a><span class="in">    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);</span></span>
<span id="cb28-602"><a href="#cb28-602" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-603"><a href="#cb28-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-604"><a href="#cb28-604" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb28-605"><a href="#cb28-605" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb28-606"><a href="#cb28-606" aria-hidden="true" tabindex="-1"></a><span class="in">    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);</span></span>
<span id="cb28-607"><a href="#cb28-607" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-608"><a href="#cb28-608" aria-hidden="true" tabindex="-1"></a><span class="in">    HitInfo hit = raymarch(ray, 100.0, 100);</span></span>
<span id="cb28-609"><a href="#cb28-609" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-610"><a href="#cb28-610" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color;</span></span>
<span id="cb28-611"><a href="#cb28-611" aria-hidden="true" tabindex="-1"></a><span class="in">    if (hit.hit) {</span></span>
<span id="cb28-612"><a href="#cb28-612" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 normal = estimateNormal(hit.position, 0.001);</span></span>
<span id="cb28-613"><a href="#cb28-613" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));</span></span>
<span id="cb28-614"><a href="#cb28-614" aria-hidden="true" tabindex="-1"></a><span class="in">        float diffuse = max(0.0, dot(normal, lightDir));</span></span>
<span id="cb28-615"><a href="#cb28-615" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb28-616"><a href="#cb28-616" aria-hidden="true" tabindex="-1"></a><span class="in">        vec3 objectColor = vec3(1.0, 0.0, 0.0);</span></span>
<span id="cb28-617"><a href="#cb28-617" aria-hidden="true" tabindex="-1"></a><span class="in">        color = objectColor * diffuse + objectColor * 0.1;</span></span>
<span id="cb28-618"><a href="#cb28-618" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb28-619"><a href="#cb28-619" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.1, 0.1, 0.2);</span></span>
<span id="cb28-620"><a href="#cb28-620" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-621"><a href="#cb28-621" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-622"><a href="#cb28-622" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb28-623"><a href="#cb28-623" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-624"><a href="#cb28-624" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-625"><a href="#cb28-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-626"><a href="#cb28-626" aria-hidden="true" tabindex="-1"></a><span class="fu">### Scene 2: Two Spheres</span></span>
<span id="cb28-627"><a href="#cb28-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-628"><a href="#cb28-628" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-629"><a href="#cb28-629" aria-hidden="true" tabindex="-1"></a><span class="in">float sceneSDF(vec3 p) {</span></span>
<span id="cb28-630"><a href="#cb28-630" aria-hidden="true" tabindex="-1"></a><span class="in">    float sphere1 = sdSphere(p, vec3(-1.2, 0.0, -3.0), 1.0);</span></span>
<span id="cb28-631"><a href="#cb28-631" aria-hidden="true" tabindex="-1"></a><span class="in">    float sphere2 = sdSphere(p, vec3(1.2, 0.0, -3.0), 0.8);</span></span>
<span id="cb28-632"><a href="#cb28-632" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-633"><a href="#cb28-633" aria-hidden="true" tabindex="-1"></a><span class="in">    return min(sphere1, sphere2);</span></span>
<span id="cb28-634"><a href="#cb28-634" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-635"><a href="#cb28-635" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-636"><a href="#cb28-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-637"><a href="#cb28-637" aria-hidden="true" tabindex="-1"></a>Just change the scene SDF! The raymarching and lighting code stays the same.</span>
<span id="cb28-638"><a href="#cb28-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-639"><a href="#cb28-639" aria-hidden="true" tabindex="-1"></a><span class="fu">### Scene 3: Sphere and Torus</span></span>
<span id="cb28-640"><a href="#cb28-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-641"><a href="#cb28-641" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-642"><a href="#cb28-642" aria-hidden="true" tabindex="-1"></a><span class="in">float sceneSDF(vec3 p) {</span></span>
<span id="cb28-643"><a href="#cb28-643" aria-hidden="true" tabindex="-1"></a><span class="in">    float sphere = sdSphere(p, vec3(0.0, 1.0, -4.0), 1.0);</span></span>
<span id="cb28-644"><a href="#cb28-644" aria-hidden="true" tabindex="-1"></a><span class="in">    float torus = sdTorus(p, vec3(0.0, -0.5, -4.0), 1.5, 0.4);</span></span>
<span id="cb28-645"><a href="#cb28-645" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-646"><a href="#cb28-646" aria-hidden="true" tabindex="-1"></a><span class="in">    return min(sphere, torus);</span></span>
<span id="cb28-647"><a href="#cb28-647" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-648"><a href="#cb28-648" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-649"><a href="#cb28-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-650"><a href="#cb28-650" aria-hidden="true" tabindex="-1"></a>**Different object colors:** To color objects differently, we need to track which object was hit. One approach:</span>
<span id="cb28-651"><a href="#cb28-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-652"><a href="#cb28-652" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-653"><a href="#cb28-653" aria-hidden="true" tabindex="-1"></a><span class="in">// Return both distance and object ID</span></span>
<span id="cb28-654"><a href="#cb28-654" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 sceneSDF(vec3 p) {</span></span>
<span id="cb28-655"><a href="#cb28-655" aria-hidden="true" tabindex="-1"></a><span class="in">    float sphere = sdSphere(p, vec3(0.0, 1.0, -4.0), 1.0);</span></span>
<span id="cb28-656"><a href="#cb28-656" aria-hidden="true" tabindex="-1"></a><span class="in">    float torus = sdTorus(p, vec3(0.0, -0.5, -4.0), 1.5, 0.4);</span></span>
<span id="cb28-657"><a href="#cb28-657" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-658"><a href="#cb28-658" aria-hidden="true" tabindex="-1"></a><span class="in">    if (sphere &lt; torus) {</span></span>
<span id="cb28-659"><a href="#cb28-659" aria-hidden="true" tabindex="-1"></a><span class="in">        return vec2(sphere, 1.0);  // ID = 1 for sphere</span></span>
<span id="cb28-660"><a href="#cb28-660" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb28-661"><a href="#cb28-661" aria-hidden="true" tabindex="-1"></a><span class="in">        return vec2(torus, 2.0);   // ID = 2 for torus</span></span>
<span id="cb28-662"><a href="#cb28-662" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-663"><a href="#cb28-663" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-664"><a href="#cb28-664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-665"><a href="#cb28-665" aria-hidden="true" tabindex="-1"></a><span class="in">// Then in main shader, use the ID to choose color</span></span>
<span id="cb28-666"><a href="#cb28-666" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-667"><a href="#cb28-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-668"><a href="#cb28-668" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-669"><a href="#cb28-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-670"><a href="#cb28-670" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb28-671"><a href="#cb28-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-672"><a href="#cb28-672" aria-hidden="true" tabindex="-1"></a>Today we covered:</span>
<span id="cb28-673"><a href="#cb28-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-674"><a href="#cb28-674" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Camera and ray setup**: Generating rays from pixel coordinates with a simple pinhole camera</span>
<span id="cb28-675"><a href="#cb28-675" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Analytical intersection**: Solving equations directly for spheres and tori</span>
<span id="cb28-676"><a href="#cb28-676" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Lighting introduction**: Using surface normals and dot product for diffuse shading</span>
<span id="cb28-677"><a href="#cb28-677" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Signed distance functions**: A flexible representation of geometry as distance fields</span>
<span id="cb28-678"><a href="#cb28-678" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Raymarching algorithm**: Sphere tracing to render SDFs efficiently</span>
<span id="cb28-679"><a href="#cb28-679" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**Normal estimation**: Computing gradients via finite differences</span>
<span id="cb28-680"><a href="#cb28-680" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**Scene composition**: Combining multiple objects by taking minimum distance</span>
<span id="cb28-681"><a href="#cb28-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-682"><a href="#cb28-682" aria-hidden="true" tabindex="-1"></a>Key insights:</span>
<span id="cb28-683"><a href="#cb28-683" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Analytical methods require solving equations (quadratic, quartic, etc.)</span>
<span id="cb28-684"><a href="#cb28-684" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>SDFs provide a unified framework for any geometry</span>
<span id="cb28-685"><a href="#cb28-685" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Raymarching works for arbitrary implicit surfaces</span>
<span id="cb28-686"><a href="#cb28-686" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The same lighting technique applies to both approaches</span>
<span id="cb28-687"><a href="#cb28-687" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Composition is trivial with SDFs (just take minimum)</span>
<span id="cb28-688"><a href="#cb28-688" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-689"><a href="#cb28-689" aria-hidden="true" tabindex="-1"></a>Tomorrow we'll explore advanced raymarching techniques: domain operations, boolean operations, and 3D fractals!</span>
<span id="cb28-690"><a href="#cb28-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-691"><a href="#cb28-691" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-692"><a href="#cb28-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-693"><a href="#cb28-693" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb28-694"><a href="#cb28-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-695"><a href="#cb28-695" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Algebraic Variety Rendering</span></span>
<span id="cb28-696"><a href="#cb28-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-697"><a href="#cb28-697" aria-hidden="true" tabindex="-1"></a>Choose an interesting polynomial implicit surface and render it using ray intersection.</span>
<span id="cb28-698"><a href="#cb28-698" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-699"><a href="#cb28-699" aria-hidden="true" tabindex="-1"></a>**Suggestions:**</span>
<span id="cb28-700"><a href="#cb28-700" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Degree 3: Torus-like surfaces, saddles</span>
<span id="cb28-701"><a href="#cb28-701" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Degree 4: Quartic surfaces with interesting topology (Klein bottle projections, etc.)</span>
<span id="cb28-702"><a href="#cb28-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-703"><a href="#cb28-703" aria-hidden="true" tabindex="-1"></a>**Implementation approach:**</span>
<span id="cb28-704"><a href="#cb28-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-705"><a href="#cb28-705" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Define your implicit function** $F(x, y, z) = 0$</span>
<span id="cb28-706"><a href="#cb28-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-707"><a href="#cb28-707" aria-hidden="true" tabindex="-1"></a>Example - a quartic surface:</span>
<span id="cb28-708"><a href="#cb28-708" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-709"><a href="#cb28-709" aria-hidden="true" tabindex="-1"></a><span class="in">float implicitFunction(vec3 p) {</span></span>
<span id="cb28-710"><a href="#cb28-710" aria-hidden="true" tabindex="-1"></a><span class="in">    // Example: (x^2 + y^2 + z^2)^2 - (x^2 + y^2 - 2z^2)</span></span>
<span id="cb28-711"><a href="#cb28-711" aria-hidden="true" tabindex="-1"></a><span class="in">    float r2 = dot(p, p);</span></span>
<span id="cb28-712"><a href="#cb28-712" aria-hidden="true" tabindex="-1"></a><span class="in">    return r2 * r2 - (p.x * p.x + p.y * p.y - 2.0 * p.z * p.z);</span></span>
<span id="cb28-713"><a href="#cb28-713" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-714"><a href="#cb28-714" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-715"><a href="#cb28-715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-716"><a href="#cb28-716" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Implement a root-finding method** (bisection or Newton's method)</span>
<span id="cb28-717"><a href="#cb28-717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-718"><a href="#cb28-718" aria-hidden="true" tabindex="-1"></a>Bisection template:</span>
<span id="cb28-719"><a href="#cb28-719" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-720"><a href="#cb28-720" aria-hidden="true" tabindex="-1"></a><span class="in">float intersectImplicit(Ray ray) {</span></span>
<span id="cb28-721"><a href="#cb28-721" aria-hidden="true" tabindex="-1"></a><span class="in">    float tMin = 0.0;</span></span>
<span id="cb28-722"><a href="#cb28-722" aria-hidden="true" tabindex="-1"></a><span class="in">    float tMax = 10.0;</span></span>
<span id="cb28-723"><a href="#cb28-723" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb28-724"><a href="#cb28-724" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Bisection loop similar to torus example]</span></span>
<span id="cb28-725"><a href="#cb28-725" aria-hidden="true" tabindex="-1"></a><span class="in">    // Find where implicitFunction(rayPoint(ray, t)) = 0</span></span>
<span id="cb28-726"><a href="#cb28-726" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-727"><a href="#cb28-727" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-728"><a href="#cb28-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-729"><a href="#cb28-729" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Compute the gradient for normals**</span>
<span id="cb28-730"><a href="#cb28-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-731"><a href="#cb28-731" aria-hidden="true" tabindex="-1"></a>$$\nabla F = \left(\frac{\partial F}{\partial x}, \frac{\partial F}{\partial y}, \frac{\partial F}{\partial z}\right)$$</span>
<span id="cb28-732"><a href="#cb28-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-733"><a href="#cb28-733" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-734"><a href="#cb28-734" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 implicitNormal(vec3 p, float epsilon) {</span></span>
<span id="cb28-735"><a href="#cb28-735" aria-hidden="true" tabindex="-1"></a><span class="in">    float dx = implicitFunction(p + vec3(epsilon, 0, 0)) - implicitFunction(p - vec3(epsilon, 0, 0));</span></span>
<span id="cb28-736"><a href="#cb28-736" aria-hidden="true" tabindex="-1"></a><span class="in">    float dy = implicitFunction(p + vec3(0, epsilon, 0)) - implicitFunction(p - vec3(0, epsilon, 0));</span></span>
<span id="cb28-737"><a href="#cb28-737" aria-hidden="true" tabindex="-1"></a><span class="in">    float dz = implicitFunction(p + vec3(0, 0, epsilon)) - implicitFunction(p - vec3(0, 0, epsilon));</span></span>
<span id="cb28-738"><a href="#cb28-738" aria-hidden="true" tabindex="-1"></a><span class="in">    return normalize(vec3(dx, dy, dz));</span></span>
<span id="cb28-739"><a href="#cb28-739" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-740"><a href="#cb28-740" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-741"><a href="#cb28-741" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-742"><a href="#cb28-742" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Optimization: Bounding sphere** (optional but recommended)</span>
<span id="cb28-743"><a href="#cb28-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-744"><a href="#cb28-744" aria-hidden="true" tabindex="-1"></a>To avoid checking the entire ray, use a bounding sphere:</span>
<span id="cb28-745"><a href="#cb28-745" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-746"><a href="#cb28-746" aria-hidden="true" tabindex="-1"></a><span class="in">// If point is outside bounding sphere, return sphere's SDF</span></span>
<span id="cb28-747"><a href="#cb28-747" aria-hidden="true" tabindex="-1"></a><span class="in">// If point is inside, compute the actual implicit function</span></span>
<span id="cb28-748"><a href="#cb28-748" aria-hidden="true" tabindex="-1"></a><span class="in">float boundedImplicit(vec3 p) {</span></span>
<span id="cb28-749"><a href="#cb28-749" aria-hidden="true" tabindex="-1"></a><span class="in">    float boundingSphere = length(p) - 3.0;  // Sphere of radius 3</span></span>
<span id="cb28-750"><a href="#cb28-750" aria-hidden="true" tabindex="-1"></a><span class="in">    if (boundingSphere &gt; 0.0) {</span></span>
<span id="cb28-751"><a href="#cb28-751" aria-hidden="true" tabindex="-1"></a><span class="in">        return boundingSphere;  // Outside, use sphere distance</span></span>
<span id="cb28-752"><a href="#cb28-752" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb28-753"><a href="#cb28-753" aria-hidden="true" tabindex="-1"></a><span class="in">    return implicitFunction(p);  // Inside, compute actual</span></span>
<span id="cb28-754"><a href="#cb28-754" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-755"><a href="#cb28-755" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-756"><a href="#cb28-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-757"><a href="#cb28-757" aria-hidden="true" tabindex="-1"></a>**Expected output:** A rendering of your chosen algebraic surface with proper lighting showing its geometric features.</span>
<span id="cb28-758"><a href="#cb28-758" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-759"><a href="#cb28-759" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional: Advanced Lighting and Transformations</span></span>
<span id="cb28-760"><a href="#cb28-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-761"><a href="#cb28-761" aria-hidden="true" tabindex="-1"></a>Pick one or more to explore:</span>
<span id="cb28-762"><a href="#cb28-762" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-763"><a href="#cb28-763" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 1. Specular Lighting (Phong Model)</span></span>
<span id="cb28-764"><a href="#cb28-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-765"><a href="#cb28-765" aria-hidden="true" tabindex="-1"></a>Add specular highlights using the Phong reflection model:</span>
<span id="cb28-766"><a href="#cb28-766" aria-hidden="true" tabindex="-1"></a>$$\text{specular} = (\mathbf{r} \cdot \mathbf{v})^n$$</span>
<span id="cb28-767"><a href="#cb28-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-768"><a href="#cb28-768" aria-hidden="true" tabindex="-1"></a>where:</span>
<span id="cb28-769"><a href="#cb28-769" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\mathbf{r}$ is the reflected light direction: $\mathbf{r} = 2(\mathbf{n} \cdot \mathbf{l})\mathbf{n} - \mathbf{l}$</span>
<span id="cb28-770"><a href="#cb28-770" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\mathbf{v}$ is the view direction (toward camera): $\mathbf{v} = -\text{ray.direction}$</span>
<span id="cb28-771"><a href="#cb28-771" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$n$ is the shininess exponent (try 32 or 64)</span>
<span id="cb28-772"><a href="#cb28-772" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-773"><a href="#cb28-773" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-774"><a href="#cb28-774" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 r = reflect(-lightDir, normal);  // GLSL has reflect built-in</span></span>
<span id="cb28-775"><a href="#cb28-775" aria-hidden="true" tabindex="-1"></a><span class="in">float specular = pow(max(0.0, dot(r, viewDir)), 32.0);</span></span>
<span id="cb28-776"><a href="#cb28-776" aria-hidden="true" tabindex="-1"></a><span class="in">color += vec3(1.0) * specular;  // Add white specular highlight</span></span>
<span id="cb28-777"><a href="#cb28-777" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-778"><a href="#cb28-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-779"><a href="#cb28-779" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 2. Rotation Matrices</span></span>
<span id="cb28-780"><a href="#cb28-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-781"><a href="#cb28-781" aria-hidden="true" tabindex="-1"></a>Transform objects using rotation matrices.</span>
<span id="cb28-782"><a href="#cb28-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-783"><a href="#cb28-783" aria-hidden="true" tabindex="-1"></a>**Rotation around Y-axis by angle θ:**</span>
<span id="cb28-784"><a href="#cb28-784" aria-hidden="true" tabindex="-1"></a>$$R_y(\theta) = \begin{pmatrix}</span>
<span id="cb28-785"><a href="#cb28-785" aria-hidden="true" tabindex="-1"></a>\cos\theta &amp; 0 &amp; \sin\theta <span class="sc">\\</span></span>
<span id="cb28-786"><a href="#cb28-786" aria-hidden="true" tabindex="-1"></a>0 &amp; 1 &amp; 0 <span class="sc">\\</span></span>
<span id="cb28-787"><a href="#cb28-787" aria-hidden="true" tabindex="-1"></a>-\sin\theta &amp; 0 &amp; \cos\theta</span>
<span id="cb28-788"><a href="#cb28-788" aria-hidden="true" tabindex="-1"></a>\end{pmatrix}$$</span>
<span id="cb28-789"><a href="#cb28-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-790"><a href="#cb28-790" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb28-791"><a href="#cb28-791" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 rotateY(vec3 p, float angle) {</span></span>
<span id="cb28-792"><a href="#cb28-792" aria-hidden="true" tabindex="-1"></a><span class="in">    float c = cos(angle);</span></span>
<span id="cb28-793"><a href="#cb28-793" aria-hidden="true" tabindex="-1"></a><span class="in">    float s = sin(angle);</span></span>
<span id="cb28-794"><a href="#cb28-794" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec3(</span></span>
<span id="cb28-795"><a href="#cb28-795" aria-hidden="true" tabindex="-1"></a><span class="in">        p.x * c + p.z * s,</span></span>
<span id="cb28-796"><a href="#cb28-796" aria-hidden="true" tabindex="-1"></a><span class="in">        p.y,</span></span>
<span id="cb28-797"><a href="#cb28-797" aria-hidden="true" tabindex="-1"></a><span class="in">        -p.x * s + p.z * c</span></span>
<span id="cb28-798"><a href="#cb28-798" aria-hidden="true" tabindex="-1"></a><span class="in">    );</span></span>
<span id="cb28-799"><a href="#cb28-799" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-800"><a href="#cb28-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-801"><a href="#cb28-801" aria-hidden="true" tabindex="-1"></a><span class="in">// Use in SDF:</span></span>
<span id="cb28-802"><a href="#cb28-802" aria-hidden="true" tabindex="-1"></a><span class="in">float sdRotatedTorus(vec3 p, vec3 center, float angle, float R, float r) {</span></span>
<span id="cb28-803"><a href="#cb28-803" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 q = rotateY(p - center, angle);</span></span>
<span id="cb28-804"><a href="#cb28-804" aria-hidden="true" tabindex="-1"></a><span class="in">    return sdTorus(q, vec3(0.0), R, r);</span></span>
<span id="cb28-805"><a href="#cb28-805" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb28-806"><a href="#cb28-806" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb28-807"><a href="#cb28-807" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-808"><a href="#cb28-808" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 3. Complex Scene</span></span>
<span id="cb28-809"><a href="#cb28-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-810"><a href="#cb28-810" aria-hidden="true" tabindex="-1"></a>Create a scene with multiple transformed objects:</span>
<span id="cb28-811"><a href="#cb28-811" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Multiple spheres at different positions</span>
<span id="cb28-812"><a href="#cb28-812" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Rotated boxes or tori</span>
<span id="cb28-813"><a href="#cb28-813" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A ground plane</span>
<span id="cb28-814"><a href="#cb28-814" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Experiment with composition</span>
<span id="cb28-815"><a href="#cb28-815" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-816"><a href="#cb28-816" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb28-817"><a href="#cb28-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-818"><a href="#cb28-818" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking Ahead</span></span>
<span id="cb28-819"><a href="#cb28-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-820"><a href="#cb28-820" aria-hidden="true" tabindex="-1"></a>Tomorrow (Day 5) we'll explore advanced raymarching techniques:</span>
<span id="cb28-821"><a href="#cb28-821" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Domain operations (repetition, symmetry) for creating infinite patterns</span>
<span id="cb28-822"><a href="#cb28-822" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Boolean operations (union, intersection, smooth blending)</span>
<span id="cb28-823"><a href="#cb28-823" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>3D fractals via iterated folding (Menger sponge)</span>
<span id="cb28-824"><a href="#cb28-824" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Creating complex scenes from simple primitives</span>
<span id="cb28-825"><a href="#cb28-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-826"><a href="#cb28-826" aria-hidden="true" tabindex="-1"></a>You'll leave with a toolkit for rendering virtually any geometry you can imagine!</span>
<span id="cb28-827"><a href="#cb28-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-828"><a href="#cb28-828" aria-hidden="true" tabindex="-1"></a>Make sure you're comfortable with:</span>
<span id="cb28-829"><a href="#cb28-829" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The raymarching algorithm (it's the foundation for Day 5)</span>
<span id="cb28-830"><a href="#cb28-830" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>SDF composition (taking min/max for combinations)</span>
<span id="cb28-831"><a href="#cb28-831" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Normal estimation via gradients</span>
<span id="cb28-832"><a href="#cb28-832" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Basic lighting (diffuse shading)</span>
<span id="cb28-833"><a href="#cb28-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-834"><a href="#cb28-834" aria-hidden="true" tabindex="-1"></a>See you tomorrow!</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>