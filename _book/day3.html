<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Day 3: Geometric Tilings in Euclidean and Hyperbolic Space – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./day4.html" rel="next">
<link href="./day2.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-86daaaaad7353f9cc0c554efc1dd6d94.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-f8dc6eab18fde03278982b0b35885446.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ed04f5f1653af6df52378e13bfdac05e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-d37bfdfd9a2222927534875c15a9020f.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./day3.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/yourusername/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./debug-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Debugging</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">3.1</span> Overview</a></li>
  <li><a href="#euclidean-triangle-tiling" id="toc-euclidean-triangle-tiling" class="nav-link" data-scroll-target="#euclidean-triangle-tiling"><span class="header-section-number">3.2</span> Euclidean Triangle Tiling</a>
  <ul class="collapse">
  <li><a href="#the-fundamental-domain" id="toc-the-fundamental-domain" class="nav-link" data-scroll-target="#the-fundamental-domain">The Fundamental Domain</a></li>
  <li><a href="#setting-up-the-triangle" id="toc-setting-up-the-triangle" class="nav-link" data-scroll-target="#setting-up-the-triangle">Setting Up the Triangle</a></li>
  <li><a href="#reflection-across-a-line" id="toc-reflection-across-a-line" class="nav-link" data-scroll-target="#reflection-across-a-line">Reflection Across a Line</a></li>
  <li><a href="#iterative-folding-into-the-triangle" id="toc-iterative-folding-into-the-triangle" class="nav-link" data-scroll-target="#iterative-folding-into-the-triangle">Iterative Folding into the Triangle</a></li>
  <li><a href="#visualization-euclidean-tiling" id="toc-visualization-euclidean-tiling" class="nav-link" data-scroll-target="#visualization-euclidean-tiling">Visualization: Euclidean Tiling</a></li>
  </ul></li>
  <li><a href="#hyperbolic-geometry-models-and-metrics" id="toc-hyperbolic-geometry-models-and-metrics" class="nav-link" data-scroll-target="#hyperbolic-geometry-models-and-metrics"><span class="header-section-number">3.3</span> Hyperbolic Geometry: Models and Metrics</a>
  <ul class="collapse">
  <li><a href="#the-upper-half-plane-model" id="toc-the-upper-half-plane-model" class="nav-link" data-scroll-target="#the-upper-half-plane-model">The Upper Half-Plane Model</a></li>
  <li><a href="#geodesics-in-the-upper-half-plane" id="toc-geodesics-in-the-upper-half-plane" class="nav-link" data-scroll-target="#geodesics-in-the-upper-half-plane">Geodesics in the Upper Half-Plane</a></li>
  <li><a href="#hyperbolic-distance" id="toc-hyperbolic-distance" class="nav-link" data-scroll-target="#hyperbolic-distance">Hyperbolic Distance</a></li>
  <li><a href="#the-poincaré-disk-model" id="toc-the-poincaré-disk-model" class="nav-link" data-scroll-target="#the-poincaré-disk-model">The Poincaré Disk Model</a></li>
  <li><a href="#converting-between-models" id="toc-converting-between-models" class="nav-link" data-scroll-target="#converting-between-models">Converting Between Models</a></li>
  </ul></li>
  <li><a href="#the-23-triangle-in-the-upper-half-plane" id="toc-the-23-triangle-in-the-upper-half-plane" class="nav-link" data-scroll-target="#the-23-triangle-in-the-upper-half-plane"><span class="header-section-number">3.4</span> The (2,3,∞) Triangle in the Upper Half-Plane</a>
  <ul class="collapse">
  <li><a href="#triangle-setup" id="toc-triangle-setup" class="nav-link" data-scroll-target="#triangle-setup">Triangle Setup</a></li>
  <li><a href="#checking-if-a-point-is-in-the-triangle" id="toc-checking-if-a-point-is-in-the-triangle" class="nav-link" data-scroll-target="#checking-if-a-point-is-in-the-triangle">Checking if a Point is in the Triangle</a></li>
  <li><a href="#reflection-across-geodesics" id="toc-reflection-across-geodesics" class="nav-link" data-scroll-target="#reflection-across-geodesics">Reflection Across Geodesics</a></li>
  <li><a href="#folding-into-the-fundamental-domain" id="toc-folding-into-the-fundamental-domain" class="nav-link" data-scroll-target="#folding-into-the-fundamental-domain">Folding into the Fundamental Domain</a></li>
  <li><a href="#visualization-hyperbolic-tiling" id="toc-visualization-hyperbolic-tiling" class="nav-link" data-scroll-target="#visualization-hyperbolic-tiling">Visualization: Hyperbolic Tiling</a></li>
  </ul></li>
  <li><a href="#visualizing-in-the-poincaré-disk" id="toc-visualizing-in-the-poincaré-disk" class="nav-link" data-scroll-target="#visualizing-in-the-poincaré-disk"><span class="header-section-number">3.5</span> Visualizing in the Poincaré Disk</a>
  <ul class="collapse">
  <li><a href="#by-precomposition" id="toc-by-precomposition" class="nav-link" data-scroll-target="#by-precomposition">By Precomposition</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">3.6</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">3.7</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-drawing-geodesics-and-hyperbolic-disks" id="toc-required-drawing-geodesics-and-hyperbolic-disks" class="nav-link" data-scroll-target="#required-drawing-geodesics-and-hyperbolic-disks">Required: Drawing Geodesics and Hyperbolic Disks</a></li>
  <li><a href="#required-drawing-triangle-edges-and-vertices" id="toc-required-drawing-triangle-edges-and-vertices" class="nav-link" data-scroll-target="#required-drawing-triangle-edges-and-vertices">Required: Drawing Triangle Edges and Vertices</a></li>
  <li><a href="#required-model-conversion-and-möbius-transformation" id="toc-required-model-conversion-and-möbius-transformation" class="nav-link" data-scroll-target="#required-model-conversion-and-möbius-transformation">Required: Model Conversion and Möbius Transformation</a></li>
  <li><a href="#optional-advanced-hyperbolic-explorations" id="toc-optional-advanced-hyperbolic-explorations" class="nav-link" data-scroll-target="#optional-advanced-hyperbolic-explorations">Optional: Advanced Hyperbolic Explorations</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">3.8</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">3.1</span> Overview</h2>
<p>Today we explore geometric tilings through reflection operations. We’ll start with triangle tilings in Euclidean space, then venture into hyperbolic geometry where the same techniques produce dramatically different patterns. We’ll work primarily in the upper half-plane model, learning to compute with geodesics and the hyperbolic metric, then transform our work into the Poincaré disk for visualization.</p>
<p>By the end of today, you’ll understand how reflection-based tiling algorithms work across different geometries, and have working implementations of both Euclidean and hyperbolic tilings.</p>
<hr>
</section>
<section id="euclidean-triangle-tiling" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="euclidean-triangle-tiling"><span class="header-section-number">3.2</span> Euclidean Triangle Tiling</h2>
<section id="the-fundamental-domain" class="level3">
<h3 class="anchored" data-anchor-id="the-fundamental-domain">The Fundamental Domain</h3>
<p>An equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can: 1. Reflect across its three edges 2. Repeat this process on the resulting triangles 3. Fill the entire plane with copies of the original triangle</p>
<p>This is a <strong>tiling by reflection</strong>: the entire plane is covered by reflected copies of our fundamental domain.</p>
</section>
<section id="setting-up-the-triangle" class="level3">
<h3 class="anchored" data-anchor-id="setting-up-the-triangle">Setting Up the Triangle</h3>
<p>Let’s work with an equilateral triangle with vertices at: <span class="math display">\[v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)\]</span></p>
<p>This triangle has side length <span class="math inline">\(\sqrt{3}\)</span> and is centered at the origin.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define triangle vertices</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v0 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v1 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span>  <span class="co">// -sqrt(3)/2 ≈ -0.866</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v2 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="reflection-across-a-line" class="level3">
<h3 class="anchored" data-anchor-id="reflection-across-a-line">Reflection Across a Line</h3>
<p>To reflect a point <span class="math inline">\(p\)</span> across a line through the origin with unit normal <span class="math inline">\(\mathbf{n}\)</span>, we use: <span class="math display">\[p' = p - 2(\mathbf{n} \cdot p)\mathbf{n}\]</span></p>
<p>For a line through two points (an edge of our triangle), we: 1. Compute the edge direction 2. Find the perpendicular (normal to the edge) 3. Check which side of the line we’re on 4. Reflect if necessary</p>
<p><strong>Implementation for one edge:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectAcrossEdge</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">vec2</span> v0<span class="op">,</span> <span class="dt">vec2</span> v1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Edge direction</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> edge <span class="op">=</span> v1 <span class="op">-</span> v0<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Normal to edge (perpendicular, pointing outward)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="bu">normalize</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(-</span>edge<span class="op">.</span><span class="fu">y</span><span class="op">,</span> edge<span class="op">.</span><span class="fu">x</span><span class="op">));</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Signed distance to line</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p <span class="op">-</span> v0<span class="op">,</span> normal<span class="op">);</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reflect if on the wrong side (dist &lt; 0)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> dist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="iterative-folding-into-the-triangle" class="level3">
<h3 class="anchored" data-anchor-id="iterative-folding-into-the-triangle">Iterative Folding into the Triangle</h3>
<p>We repeatedly reflect <span class="math inline">\(p\)</span> across the three edges until it lands inside the fundamental domain:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">foldToTriangle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">int</span> maxIter<span class="op">,</span> <span class="dt">out</span> <span class="dt">int</span> foldCount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> v0 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> v1 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> v2 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> maxIter<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across each edge if necessary</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectAcrossEdge</span><span class="op">(</span>p<span class="op">,</span> v0<span class="op">,</span> v1<span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectAcrossEdge</span><span class="op">(</span>p<span class="op">,</span> v1<span class="op">,</span> v2<span class="op">);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectAcrossEdge</span><span class="op">(</span>p<span class="op">,</span> v2<span class="op">,</span> v0<span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check if we're done (no more reflections)</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="visualization-euclidean-tiling" class="level3">
<h3 class="anchored" data-anchor-id="visualization-euclidean-tiling">Visualization: Euclidean Tiling</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold to fundamental domain</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p_folded <span class="op">=</span> <span class="fu">foldToTriangle</span><span class="op">(</span>p<span class="op">,</span> <span class="dv">20</span><span class="op">,</span> foldCount<span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">10.0</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span>  <span class="co">// Use palette function from Day 2</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The result: a beautiful triangular tiling of the plane, colored by how many reflections were needed to reach the fundamental domain!</p>
<hr>
</section>
</section>
<section id="hyperbolic-geometry-models-and-metrics" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="hyperbolic-geometry-models-and-metrics"><span class="header-section-number">3.3</span> Hyperbolic Geometry: Models and Metrics</h2>
<section id="the-upper-half-plane-model" class="level3">
<h3 class="anchored" data-anchor-id="the-upper-half-plane-model">The Upper Half-Plane Model</h3>
<p>The upper half-plane model <span class="math inline">\(\mathbb{H}^2\)</span> consists of complex numbers with positive imaginary part: <span class="math display">\[\mathbb{H}^2 = \{z \in \mathbb{C} : \text{Im}(z) &gt; 0\}\]</span></p>
<p>The hyperbolic metric is: <span class="math display">\[ds^2 = \frac{dx^2 + dy^2}{y^2} = \frac{|dz|^2}{(\text{Im}(z))^2}\]</span></p>
<p>This metric “blows up” as we approach the real axis (the boundary at infinity), making the geometry shrink near <span class="math inline">\(y = 0\)</span>.</p>
</section>
<section id="geodesics-in-the-upper-half-plane" class="level3">
<h3 class="anchored" data-anchor-id="geodesics-in-the-upper-half-plane">Geodesics in the Upper Half-Plane</h3>
<p>Geodesics (hyperbolic “straight lines”) in <span class="math inline">\(\mathbb{H}^2\)</span> are: 1. Vertical lines <span class="math inline">\(\{x = c\}\)</span> for constant <span class="math inline">\(c\)</span> 2. Semicircles centered on the real axis, perpendicular to it</p>
<p>For a semicircle of radius <span class="math inline">\(R\)</span> centered at <span class="math inline">\((c, 0)\)</span>, the equation is: <span class="math display">\[(x - c)^2 + y^2 = R^2, \quad y &gt; 0\]</span></p>
</section>
<section id="hyperbolic-distance" class="level3">
<h3 class="anchored" data-anchor-id="hyperbolic-distance">Hyperbolic Distance</h3>
<p>The distance between two points <span class="math inline">\(z, w \in \mathbb{H}^2\)</span> is: <span class="math display">\[d(z, w) = \text{arcosh}\left(1 + \frac{|z - w|^2}{2 \cdot \text{Im}(z) \cdot \text{Im}(w)}\right)\]</span></p>
<p>In GLSL:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> diff2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>z <span class="op">-</span> w<span class="op">,</span> z <span class="op">-</span> w<span class="op">);</span>  <span class="co">// |z - w|²</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">;</span>    <span class="co">// 2·Im(z)·Im(w)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> arg <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> diff2 <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">log</span><span class="op">(</span>arg <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span>arg <span class="op">*</span> arg <span class="op">-</span> <span class="fl">1.0</span><span class="op">));</span>  <span class="co">// acosh(x) = log(x + sqrt(x²-1))</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="the-poincaré-disk-model" class="level3">
<h3 class="anchored" data-anchor-id="the-poincaré-disk-model">The Poincaré Disk Model</h3>
<p>The Poincaré disk model consists of the interior of the unit disk: <span class="math display">\[\mathbb{D}^2 = \{z \in \mathbb{C} : |z| &lt; 1\}\]</span></p>
<p>The metric is: <span class="math display">\[ds^2 = \frac{4(dx^2 + dy^2)}{(1 - |z|^2)^2}\]</span></p>
<p>Geodesics are circular arcs perpendicular to the unit circle (or diameters).</p>
</section>
<section id="converting-between-models" class="level3">
<h3 class="anchored" data-anchor-id="converting-between-models">Converting Between Models</h3>
<p>The Cayley transform maps the upper half-plane to the disk: <span class="math display">\[w = \frac{z - i}{z + i}\]</span></p>
<p>The inverse is: <span class="math display">\[z = i\frac{1 + w}{1 - w}\]</span></p>
<p>In GLSL (using complex arithmetic from Day 2):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">uhpToDisk</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// w = (z - i) / (z + i)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> numerator <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>      <span class="co">// z - i</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> denominator <span class="op">=</span> z <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>    <span class="co">// z + i</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>numerator<span class="op">,</span> denominator<span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">diskToUHP</span><span class="op">(</span><span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// z = i(1 + w) / (1 - w)</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> numerator <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">)</span> <span class="op">+</span> w<span class="op">;</span>      <span class="co">// i + iw  </span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    numerator <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span>numerator<span class="op">.</span><span class="fu">y</span><span class="op">,</span> numerator<span class="op">.</span><span class="fu">x</span><span class="op">);</span>  <span class="co">// Multiply by i</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> denominator <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">-</span> w<span class="op">;</span>    <span class="co">// 1 - w</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>numerator<span class="op">,</span> denominator<span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="the-23-triangle-in-the-upper-half-plane" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="the-23-triangle-in-the-upper-half-plane"><span class="header-section-number">3.4</span> The (2,3,∞) Triangle in the Upper Half-Plane</h2>
<section id="triangle-setup" class="level3">
<h3 class="anchored" data-anchor-id="triangle-setup">Triangle Setup</h3>
<p>For our first hyperbolic tiling, we’ll use a triangle with particularly nice edges in the upper half-plane: - <strong>Bottom edge</strong>: Unit semicircle centered at origin (equation: <span class="math inline">\(x^2 + y^2 = 1\)</span>, <span class="math inline">\(y &gt; 0\)</span>) - <strong>Left edge</strong>: Vertical geodesic at <span class="math inline">\(x = -1\)</span> - <strong>Right edge</strong>: Vertical geodesic at <span class="math inline">\(x = 1\)</span></p>
<p>This creates a hyperbolic triangle with one ideal vertex (at infinity on the <span class="math inline">\(y\)</span>-axis) and two finite vertices.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Geodesic <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span>  <span class="co">// 0 = vertical line, 1 = semicircle</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> data<span class="op">;</span>  <span class="co">// For vertical: (x_pos, unused), for semicircle: (center_x, radius)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">setupTriangle</span><span class="op">(</span><span class="dt">out</span> Geodesic g1<span class="op">,</span> <span class="dt">out</span> Geodesic g2<span class="op">,</span> <span class="dt">out</span> Geodesic g3<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    g1<span class="op">.</span><span class="fu">type</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// Semicircle</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    g1<span class="op">.</span><span class="fu">data</span> <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Center at origin, radius 1</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    g2<span class="op">.</span><span class="fu">type</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Vertical line</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    g2<span class="op">.</span><span class="fu">data</span> <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// At x = -1</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    g3<span class="op">.</span><span class="fu">type</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Vertical line</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    g3<span class="op">.</span><span class="fu">data</span> <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// At x = 1</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="checking-if-a-point-is-in-the-triangle" class="level3">
<h3 class="anchored" data-anchor-id="checking-if-a-point-is-in-the-triangle">Checking if a Point is in the Triangle</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">inTriangle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Above the semicircle: x² + y² &gt; 1</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> aboveSemicircle <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">)</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Between vertical lines: -1 &lt; x &lt; 1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> betweenLines <span class="op">=</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> aboveSemicircle <span class="op">&amp;&amp;</span> betweenLines<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="reflection-across-geodesics" class="level3">
<h3 class="anchored" data-anchor-id="reflection-across-geodesics">Reflection Across Geodesics</h3>
<p><strong>Reflection across a vertical line <span class="math inline">\(x = c\)</span>:</strong> <span class="math display">\[\text{reflect}(x + iy) = (2c - x) + iy\]</span></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectVertical</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">float</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">2.0</span> <span class="op">*</span> c <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> p<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Reflection across a semicircle (circle inversion from yesterday!):</strong> For a circle of radius <span class="math inline">\(R\)</span> centered at <span class="math inline">\((c_x, 0)\)</span>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectCircle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">vec2</span> center<span class="op">,</span> <span class="dt">float</span> radius<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> diff <span class="op">=</span> p <span class="op">-</span> center<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>diff<span class="op">,</span> diff<span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> center <span class="op">+</span> <span class="op">(</span>radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> diff <span class="op">/</span> r2<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="folding-into-the-fundamental-domain" class="level3">
<h3 class="anchored" data-anchor-id="folding-into-the-fundamental-domain">Folding into the Fundamental Domain</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">foldToHyperbolicTriangle</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> <span class="dt">int</span> maxIter<span class="op">,</span> <span class="dt">out</span> <span class="dt">int</span> foldCount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> maxIter<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> folded <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across left vertical line if needed</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">reflectVertical</span><span class="op">(</span>p<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            folded <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across right vertical line if needed</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">reflectVertical</span><span class="op">(</span>p<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            folded <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across semicircle if needed</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">1.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="fu">reflectCircle</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>            folded <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>folded<span class="op">)</span> foldCount<span class="op">++;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">break</span><span class="op">;</span>  <span class="co">// In fundamental domain</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="visualization-hyperbolic-tiling" class="level3">
<h3 class="anchored" data-anchor-id="visualization-hyperbolic-tiling">Visualization: Hyperbolic Tiling</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup - map to upper half-plane</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Shift up so y &gt; 0</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold to fundamental domain</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount<span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p_folded <span class="op">=</span> <span class="fu">foldToHyperbolicTriangle</span><span class="op">(</span>p<span class="op">,</span> <span class="dv">20</span><span class="op">,</span> foldCount<span class="op">);</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">10.0</span><span class="op">;</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Highlight fundamental domain</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inTriangle</span><span class="op">(</span>p_folded<span class="op">))</span> <span class="op">{</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The result: a beautiful hyperbolic tiling! Notice how the triangles appear to shrink near the real axis—they’re all the same hyperbolic size, but Euclidean distances compress.</p>
<hr>
</section>
</section>
<section id="visualizing-in-the-poincaré-disk" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="visualizing-in-the-poincaré-disk"><span class="header-section-number">3.5</span> Visualizing in the Poincaré Disk</h2>
<p>Now we’ll see the same tiling in a different model by converting coordinates.</p>
<section id="by-precomposition" class="level3">
<h3 class="anchored" data-anchor-id="by-precomposition">By Precomposition</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup - map to disk</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Only render inside unit disk</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>uv<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span><span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert disk coordinates to upper half-plane</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> <span class="fu">diskToUHP</span><span class="op">(</span>uv<span class="op">);</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now do all computations in UHP</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p_folded <span class="op">=</span> <span class="fu">foldToHyperbolicTriangle</span><span class="op">(</span>p<span class="op">,</span> <span class="dv">20</span><span class="op">,</span> foldCount<span class="op">);</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">10.0</span><span class="op">;</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">palette</span><span class="op">(</span>t<span class="op">);</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inTriangle</span><span class="op">(</span>p_folded<span class="op">))</span> <span class="op">{</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The tiling now appears in the Poincaré disk—the same mathematical object displayed in a different model!</p>
<hr>
</section>
</section>
<section id="summary" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="summary"><span class="header-section-number">3.6</span> Summary</h2>
<p>Today we covered:</p>
<ol type="1">
<li><strong>Euclidean triangle tiling</strong>: Using reflections to tile the plane with equilateral triangles</li>
<li><strong>Hyperbolic geometry models</strong>: Upper half-plane and Poincaré disk, with metrics and geodesics</li>
<li><strong>Coordinate transformations</strong>: Cayley transform connecting the two models</li>
<li><strong>Hyperbolic triangle tiling</strong>: Using reflections (including circle inversion) to tile hyperbolic space</li>
<li><strong>Multiple representations</strong>: Same tiling visualized in different models</li>
</ol>
<p>Key insights: - <strong>Reflection-based tilings work in any geometry</strong> with the appropriate reflection operations - <strong>Circle inversion</strong> (from Day 2) is fundamental to hyperbolic geometry - <strong>The same mathematical object looks different</strong> in different models - <strong>Geodesics replace straight lines</strong> as the fundamental “straight” paths</p>
<p>The algorithmic structure is identical across geometries—only the reflection operations change!</p>
<hr>
</section>
<section id="homework" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="homework"><span class="header-section-number">3.7</span> Homework</h2>
<section id="required-drawing-geodesics-and-hyperbolic-disks" class="level3">
<h3 class="anchored" data-anchor-id="required-drawing-geodesics-and-hyperbolic-disks">Required: Drawing Geodesics and Hyperbolic Disks</h3>
<p>Implement visualization of basic hyperbolic objects to understand the geometry.</p>
<p><strong>Part 1: Draw several geodesics in the upper half-plane</strong></p>
<p>Vertical lines are easy:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Distance to vertical line x = c</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> distToVertical <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> c<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>distToVertical <span class="op">&lt;</span> thickness<span class="op">)</span> color <span class="op">=</span> geodesicColor<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Semicircular geodesics require the implicit equation:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Semicircle: (x - cx)² + y² = R², with y &gt; 0</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> distToSemicircle <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">sqrt</span><span class="op">((</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> cx<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> cx<span class="op">)</span> <span class="op">+</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">-</span> R<span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>distToSemicircle <span class="op">&lt;</span> thickness <span class="op">&amp;&amp;</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> color <span class="op">=</span> geodesicColor<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Draw several of each type to visualize the geodesic structure.</p>
<p><strong>Part 2: Draw hyperbolic disks</strong></p>
<p>A hyperbolic disk of radius <span class="math inline">\(r\)</span> centered at <span class="math inline">\(z_0\)</span> is the set: <span class="math display">\[\{z : d_{\text{hyp}}(z, z_0) &lt; r\}\]</span></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span>p<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> radius<span class="op">)</span> color <span class="op">=</span> diskColor<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Draw several disks at different locations and with the same hyperbolic radius. Observe how they appear smaller (in Euclidean sense) near the boundary—this demonstrates the metric’s behavior.</p>
<p><strong>Part 3: Visualize metric distortion</strong></p>
<p>Create a grid of hyperbolic disks of equal hyperbolic radius. Watch how their Euclidean sizes vary across the half-plane.</p>
<p><strong>Optional enhancement:</strong> Repeat in Poincaré disk model by precomposition.</p>
</section>
<section id="required-drawing-triangle-edges-and-vertices" class="level3">
<h3 class="anchored" data-anchor-id="required-drawing-triangle-edges-and-vertices">Required: Drawing Triangle Edges and Vertices</h3>
<p>Enhance your hyperbolic tiling by drawing the triangle boundaries.</p>
<p><strong>Task:</strong> For each point, compute the distance to the three geodesics forming your triangle boundary. If the distance is below a threshold, color it as an edge.</p>
<p><strong>Implementation hints:</strong></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Distance to vertical line</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d1 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> <span class="op">(-</span><span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d2 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Distance to semicircle (already have this from Part 1)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d3 <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p<span class="op">)</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> edgeThickness <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> onEdge <span class="op">=</span> <span class="op">(</span>d1 <span class="op">&lt;</span> edgeThickness<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>d2 <span class="op">&lt;</span> edgeThickness<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>d3 <span class="op">&lt;</span> edgeThickness<span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>onEdge<span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White edges</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For vertices, compute Euclidean distance to the three vertex positions and draw small circles.</p>
<p><strong>Expected output:</strong> Your tiling with clearly visible triangle boundaries, making the tessellation structure explicit.</p>
</section>
<section id="required-model-conversion-and-möbius-transformation" class="level3">
<h3 class="anchored" data-anchor-id="required-model-conversion-and-möbius-transformation">Required: Model Conversion and Möbius Transformation</h3>
<p>Work with different representations of hyperbolic space.</p>
<p><strong>Part 1: Convert your tiling to Poincaré disk</strong></p>
<p>You already have the transformation functions. Create a shader that displays your hyperbolic tiling in the disk model and compare the visual appearance.</p>
<p><strong>Part 2: Apply a Möbius transformation</strong></p>
<p>A Möbius transformation has the form: <span class="math display">\[z \mapsto \frac{az + b}{cz + d}, \quad ad - bc = 1\]</span></p>
<p>These are isometries of hyperbolic space—they permute the tiles but preserve the geometry.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">mobius</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">,</span> <span class="dt">vec2</span> c<span class="op">,</span> <span class="dt">vec2</span> d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> num <span class="op">=</span> <span class="fu">cadd</span><span class="op">(</span><span class="fu">cmul</span><span class="op">(</span>a<span class="op">,</span> z<span class="op">),</span> b<span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> den <span class="op">=</span> <span class="fu">cadd</span><span class="op">(</span><span class="fu">cmul</span><span class="op">(</span>c<span class="op">,</span> z<span class="op">),</span> d<span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>num<span class="op">,</span> den<span class="op">);</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Try some interesting transformations: - Translation: <span class="math inline">\(z \mapsto z + 1\)</span> (in complex plane, not hyperbolic translation!) - Scaling: <span class="math inline">\(z \mapsto 2z\)</span> - Rotation: <span class="math inline">\(z \mapsto e^{i\theta} z\)</span></p>
<p>Apply to your tiling:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Before folding:</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">mobius</span><span class="op">(</span>p<span class="op">,</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">2.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Watch how the tiling transforms!</p>
</section>
<section id="optional-advanced-hyperbolic-explorations" class="level3">
<h3 class="anchored" data-anchor-id="optional-advanced-hyperbolic-explorations">Optional: Advanced Hyperbolic Explorations</h3>
<p>Choose one or more:</p>
<section id="different-triangle-groups" class="level4">
<h4 class="anchored" data-anchor-id="different-triangle-groups">1. Different Triangle Groups</h4>
<p>Implement different hyperbolic triangle groups. The <span class="math inline">\((p, q, r)\)</span> notation indicates angles <span class="math inline">\(\pi/p\)</span>, <span class="math inline">\(\pi/q\)</span>, <span class="math inline">\(\pi/r\)</span> at the three vertices.</p>
<p>Famous examples: - <span class="math inline">\((2, 3, 7)\)</span>: Creates Escher-like tilings - <span class="math inline">\((2, 4, 6)\)</span>: Different symmetry structure - <span class="math inline">\((3, 3, 3)\)</span>: Equilateral hyperbolic triangle</p>
<p>Each requires setting up different geodesics for the triangle edges.</p>
</section>
<section id="klein-model" class="level4">
<h4 class="anchored" data-anchor-id="klein-model">2. Klein Model</h4>
<p>The Klein model represents hyperbolic space where geodesics are Euclidean straight lines (but angles are distorted).</p>
<p>Convert from Poincaré disk to Klein: <span class="math display">\[w = \frac{2z}{1 + |z|^2}\]</span></p>
<p>Visualize your tiling in this model and observe how geodesics become straight!</p>
</section>
<section id="decorated-tiles" class="level4">
<h4 class="anchored" data-anchor-id="decorated-tiles">3. Decorated Tiles</h4>
<p>Add patterns inside each triangle (like Escher’s Circle Limit prints). Use barycentric coordinates or distance from edges to create decorations within the fundamental domain.</p>
</section>
<section id="conformal-mapping-art" class="level4">
<h4 class="anchored" data-anchor-id="conformal-mapping-art">4. Conformal Mapping Art</h4>
<p>Use complex analysis to map the disk to other regions (strips, annuli, etc.) and visualize hyperbolic geometry in exotic coordinate systems.</p>
<hr>
</section>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">3.8</span> Looking Ahead</h2>
<p>Tomorrow we move to 3D! We’ll learn raymarching and signed distance functions to render implicit surfaces. The geometric intuition from reflections and distance computations will carry over, but now in three dimensions with lighting and shading.</p>
<p>Make sure you’re comfortable with: - Reflection operations (these generalize to 3D) - Distance computations (both Euclidean and hyperbolic) - Iterative algorithms for geometric structures - Working with different coordinate systems/models</p>
<p>See you tomorrow!</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./day2.html" class="pagination-link" aria-label="Day 2: Complex Dynamics and Iterated Inversions">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./day4.html" class="pagination-link" aria-label="Day 4: Introduction to 3D Rendering">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb20" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>Today we explore geometric tilings through reflection operations. We'll start with triangle tilings in Euclidean space, then venture into hyperbolic geometry where the same techniques produce dramatically different patterns. We'll work primarily in the upper half-plane model, learning to compute with geodesics and the hyperbolic metric, then transform our work into the Poincaré disk for visualization.</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll understand how reflection-based tiling algorithms work across different geometries, and have working implementations of both Euclidean and hyperbolic tilings.</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## Euclidean Triangle Tiling</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Fundamental Domain</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>An equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can:</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Reflect across its three edges</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Repeat this process on the resulting triangles</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Fill the entire plane with copies of the original triangle</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>This is a **tiling by reflection**: the entire plane is covered by reflected copies of our fundamental domain.</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="fu">### Setting Up the Triangle</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>Let's work with an equilateral triangle with vertices at:</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>$$v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)$$</span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>This triangle has side length $\sqrt{3}$ and is centered at the origin.</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="in">// Define triangle vertices</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v0 = vec2(0.0, 1.0);</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v2 = vec2(0.866, -0.5);</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a><span class="fu">### Reflection Across a Line</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>To reflect a point $p$ across a line through the origin with unit normal $\mathbf{n}$, we use:</span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>$$p' = p - 2(\mathbf{n} \cdot p)\mathbf{n}$$</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>For a line through two points (an edge of our triangle), we:</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Compute the edge direction</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Find the perpendicular (normal to the edge)</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Check which side of the line we're on</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Reflect if necessary</span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>**Implementation for one edge:**</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectAcrossEdge(vec2 p, vec2 v0, vec2 v1) {</span></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a><span class="in">    // Edge direction</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 edge = v1 - v0;</span></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a><span class="in">    // Normal to edge (perpendicular, pointing outward)</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 normal = normalize(vec2(-edge.y, edge.x));</span></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a><span class="in">    // Signed distance to line</span></span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist = dot(p - v0, normal);</span></span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a><span class="in">    // Reflect if on the wrong side (dist &lt; 0)</span></span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a><span class="in">    if(dist &lt; 0.0) {</span></span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a><span class="in">        p = p - 2.0 * dist * normal;</span></span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a><span class="in">    return p;</span></span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true" tabindex="-1"></a><span class="fu">### Iterative Folding into the Triangle</span></span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true" tabindex="-1"></a>We repeatedly reflect $p$ across the three edges until it lands inside the fundamental domain:</span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {</span></span>
<span id="cb20-75"><a href="#cb20-75" aria-hidden="true" tabindex="-1"></a><span class="in">    foldCount = 0;</span></span>
<span id="cb20-76"><a href="#cb20-76" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-77"><a href="#cb20-77" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 v0 = vec2(0.0, 1.0);</span></span>
<span id="cb20-78"><a href="#cb20-78" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 v1 = vec2(-0.866, -0.5);</span></span>
<span id="cb20-79"><a href="#cb20-79" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 v2 = vec2(0.866, -0.5);</span></span>
<span id="cb20-80"><a href="#cb20-80" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-81"><a href="#cb20-81" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; maxIter; i++) {</span></span>
<span id="cb20-82"><a href="#cb20-82" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 p_old = p;</span></span>
<span id="cb20-83"><a href="#cb20-83" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb20-84"><a href="#cb20-84" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across each edge if necessary</span></span>
<span id="cb20-85"><a href="#cb20-85" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectAcrossEdge(p, v0, v1);</span></span>
<span id="cb20-86"><a href="#cb20-86" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectAcrossEdge(p, v1, v2);</span></span>
<span id="cb20-87"><a href="#cb20-87" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectAcrossEdge(p, v2, v0);</span></span>
<span id="cb20-88"><a href="#cb20-88" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb20-89"><a href="#cb20-89" aria-hidden="true" tabindex="-1"></a><span class="in">        // Check if we're done (no more reflections)</span></span>
<span id="cb20-90"><a href="#cb20-90" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - p_old) &lt; 0.0001) break;</span></span>
<span id="cb20-91"><a href="#cb20-91" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb20-92"><a href="#cb20-92" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb20-93"><a href="#cb20-93" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb20-94"><a href="#cb20-94" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-95"><a href="#cb20-95" aria-hidden="true" tabindex="-1"></a><span class="in">    return p;</span></span>
<span id="cb20-96"><a href="#cb20-96" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-97"><a href="#cb20-97" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-98"><a href="#cb20-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-99"><a href="#cb20-99" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualization: Euclidean Tiling</span></span>
<span id="cb20-100"><a href="#cb20-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-101"><a href="#cb20-101" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-102"><a href="#cb20-102" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb20-103"><a href="#cb20-103" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb20-104"><a href="#cb20-104" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb20-105"><a href="#cb20-105" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb20-106"><a href="#cb20-106" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb20-107"><a href="#cb20-107" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb20-108"><a href="#cb20-108" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb20-109"><a href="#cb20-109" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-110"><a href="#cb20-110" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold to fundamental domain</span></span>
<span id="cb20-111"><a href="#cb20-111" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount;</span></span>
<span id="cb20-112"><a href="#cb20-112" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p_folded = foldToTriangle(p, 20, foldCount);</span></span>
<span id="cb20-113"><a href="#cb20-113" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-114"><a href="#cb20-114" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb20-115"><a href="#cb20-115" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 10.0;</span></span>
<span id="cb20-116"><a href="#cb20-116" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);  // Use palette function from Day 2</span></span>
<span id="cb20-117"><a href="#cb20-117" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-118"><a href="#cb20-118" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb20-119"><a href="#cb20-119" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-120"><a href="#cb20-120" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-121"><a href="#cb20-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-122"><a href="#cb20-122" aria-hidden="true" tabindex="-1"></a>The result: a beautiful triangular tiling of the plane, colored by how many reflections were needed to reach the fundamental domain!</span>
<span id="cb20-123"><a href="#cb20-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-124"><a href="#cb20-124" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb20-125"><a href="#cb20-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-126"><a href="#cb20-126" aria-hidden="true" tabindex="-1"></a><span class="fu">## Hyperbolic Geometry: Models and Metrics</span></span>
<span id="cb20-127"><a href="#cb20-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-128"><a href="#cb20-128" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Upper Half-Plane Model</span></span>
<span id="cb20-129"><a href="#cb20-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-130"><a href="#cb20-130" aria-hidden="true" tabindex="-1"></a>The upper half-plane model $\mathbb{H}^2$ consists of complex numbers with positive imaginary part:</span>
<span id="cb20-131"><a href="#cb20-131" aria-hidden="true" tabindex="-1"></a>$$\mathbb{H}^2 = <span class="sc">\{</span>z \in \mathbb{C} : \text{Im}(z) &gt; 0<span class="sc">\}</span>$$</span>
<span id="cb20-132"><a href="#cb20-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-133"><a href="#cb20-133" aria-hidden="true" tabindex="-1"></a>The hyperbolic metric is:</span>
<span id="cb20-134"><a href="#cb20-134" aria-hidden="true" tabindex="-1"></a>$$ds^2 = \frac{dx^2 + dy^2}{y^2} = \frac{|dz|^2}{(\text{Im}(z))^2}$$</span>
<span id="cb20-135"><a href="#cb20-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-136"><a href="#cb20-136" aria-hidden="true" tabindex="-1"></a>This metric "blows up" as we approach the real axis (the boundary at infinity), making the geometry shrink near $y = 0$.</span>
<span id="cb20-137"><a href="#cb20-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-138"><a href="#cb20-138" aria-hidden="true" tabindex="-1"></a><span class="fu">### Geodesics in the Upper Half-Plane</span></span>
<span id="cb20-139"><a href="#cb20-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-140"><a href="#cb20-140" aria-hidden="true" tabindex="-1"></a>Geodesics (hyperbolic "straight lines") in $\mathbb{H}^2$ are:</span>
<span id="cb20-141"><a href="#cb20-141" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Vertical lines $<span class="sc">\{</span>x = c<span class="sc">\}</span>$ for constant $c$</span>
<span id="cb20-142"><a href="#cb20-142" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Semicircles centered on the real axis, perpendicular to it</span>
<span id="cb20-143"><a href="#cb20-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-144"><a href="#cb20-144" aria-hidden="true" tabindex="-1"></a>For a semicircle of radius $R$ centered at $(c, 0)$, the equation is:</span>
<span id="cb20-145"><a href="#cb20-145" aria-hidden="true" tabindex="-1"></a>$$(x - c)^2 + y^2 = R^2, \quad y &gt; 0$$</span>
<span id="cb20-146"><a href="#cb20-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-147"><a href="#cb20-147" aria-hidden="true" tabindex="-1"></a><span class="fu">### Hyperbolic Distance</span></span>
<span id="cb20-148"><a href="#cb20-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-149"><a href="#cb20-149" aria-hidden="true" tabindex="-1"></a>The distance between two points $z, w \in \mathbb{H}^2$ is:</span>
<span id="cb20-150"><a href="#cb20-150" aria-hidden="true" tabindex="-1"></a>$$d(z, w) = \text{arcosh}\left(1 + \frac{|z - w|^2}{2 \cdot \text{Im}(z) \cdot \text{Im}(w)}\right)$$</span>
<span id="cb20-151"><a href="#cb20-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-152"><a href="#cb20-152" aria-hidden="true" tabindex="-1"></a>In GLSL:</span>
<span id="cb20-153"><a href="#cb20-153" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-154"><a href="#cb20-154" aria-hidden="true" tabindex="-1"></a><span class="in">float hyperbolicDistance(vec2 z, vec2 w) {</span></span>
<span id="cb20-155"><a href="#cb20-155" aria-hidden="true" tabindex="-1"></a><span class="in">    float diff2 = dot(z - w, z - w);  // |z - w|²</span></span>
<span id="cb20-156"><a href="#cb20-156" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = 2.0 * z.y * w.y;    // 2·Im(z)·Im(w)</span></span>
<span id="cb20-157"><a href="#cb20-157" aria-hidden="true" tabindex="-1"></a><span class="in">    float arg = 1.0 + diff2 / denom;</span></span>
<span id="cb20-158"><a href="#cb20-158" aria-hidden="true" tabindex="-1"></a><span class="in">    return log(arg + sqrt(arg * arg - 1.0));  // acosh(x) = log(x + sqrt(x²-1))</span></span>
<span id="cb20-159"><a href="#cb20-159" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-160"><a href="#cb20-160" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-161"><a href="#cb20-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-162"><a href="#cb20-162" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Poincaré Disk Model</span></span>
<span id="cb20-163"><a href="#cb20-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-164"><a href="#cb20-164" aria-hidden="true" tabindex="-1"></a>The Poincaré disk model consists of the interior of the unit disk:</span>
<span id="cb20-165"><a href="#cb20-165" aria-hidden="true" tabindex="-1"></a>$$\mathbb{D}^2 = <span class="sc">\{</span>z \in \mathbb{C} : |z| &lt; 1<span class="sc">\}</span>$$</span>
<span id="cb20-166"><a href="#cb20-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-167"><a href="#cb20-167" aria-hidden="true" tabindex="-1"></a>The metric is:</span>
<span id="cb20-168"><a href="#cb20-168" aria-hidden="true" tabindex="-1"></a>$$ds^2 = \frac{4(dx^2 + dy^2)}{(1 - |z|^2)^2}$$</span>
<span id="cb20-169"><a href="#cb20-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-170"><a href="#cb20-170" aria-hidden="true" tabindex="-1"></a>Geodesics are circular arcs perpendicular to the unit circle (or diameters).</span>
<span id="cb20-171"><a href="#cb20-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-172"><a href="#cb20-172" aria-hidden="true" tabindex="-1"></a><span class="fu">### Converting Between Models</span></span>
<span id="cb20-173"><a href="#cb20-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-174"><a href="#cb20-174" aria-hidden="true" tabindex="-1"></a>The Cayley transform maps the upper half-plane to the disk:</span>
<span id="cb20-175"><a href="#cb20-175" aria-hidden="true" tabindex="-1"></a>$$w = \frac{z - i}{z + i}$$</span>
<span id="cb20-176"><a href="#cb20-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-177"><a href="#cb20-177" aria-hidden="true" tabindex="-1"></a>The inverse is:</span>
<span id="cb20-178"><a href="#cb20-178" aria-hidden="true" tabindex="-1"></a>$$z = i\frac{1 + w}{1 - w}$$</span>
<span id="cb20-179"><a href="#cb20-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-180"><a href="#cb20-180" aria-hidden="true" tabindex="-1"></a>In GLSL (using complex arithmetic from Day 2):</span>
<span id="cb20-181"><a href="#cb20-181" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-182"><a href="#cb20-182" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 uhpToDisk(vec2 z) {</span></span>
<span id="cb20-183"><a href="#cb20-183" aria-hidden="true" tabindex="-1"></a><span class="in">    // w = (z - i) / (z + i)</span></span>
<span id="cb20-184"><a href="#cb20-184" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 numerator = z - vec2(0.0, 1.0);      // z - i</span></span>
<span id="cb20-185"><a href="#cb20-185" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 denominator = z + vec2(0.0, 1.0);    // z + i</span></span>
<span id="cb20-186"><a href="#cb20-186" aria-hidden="true" tabindex="-1"></a><span class="in">    return cdiv(numerator, denominator);</span></span>
<span id="cb20-187"><a href="#cb20-187" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-188"><a href="#cb20-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-189"><a href="#cb20-189" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 diskToUHP(vec2 w) {</span></span>
<span id="cb20-190"><a href="#cb20-190" aria-hidden="true" tabindex="-1"></a><span class="in">    // z = i(1 + w) / (1 - w)</span></span>
<span id="cb20-191"><a href="#cb20-191" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 numerator = vec2(0.0, 1.0) + w;      // i + iw  </span></span>
<span id="cb20-192"><a href="#cb20-192" aria-hidden="true" tabindex="-1"></a><span class="in">    numerator = vec2(-numerator.y, numerator.x);  // Multiply by i</span></span>
<span id="cb20-193"><a href="#cb20-193" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 denominator = vec2(1.0, 0.0) - w;    // 1 - w</span></span>
<span id="cb20-194"><a href="#cb20-194" aria-hidden="true" tabindex="-1"></a><span class="in">    return cdiv(numerator, denominator);</span></span>
<span id="cb20-195"><a href="#cb20-195" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-196"><a href="#cb20-196" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-197"><a href="#cb20-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-198"><a href="#cb20-198" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb20-199"><a href="#cb20-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-200"><a href="#cb20-200" aria-hidden="true" tabindex="-1"></a><span class="fu">## The (2,3,∞) Triangle in the Upper Half-Plane</span></span>
<span id="cb20-201"><a href="#cb20-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-202"><a href="#cb20-202" aria-hidden="true" tabindex="-1"></a><span class="fu">### Triangle Setup</span></span>
<span id="cb20-203"><a href="#cb20-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-204"><a href="#cb20-204" aria-hidden="true" tabindex="-1"></a>For our first hyperbolic tiling, we'll use a triangle with particularly nice edges in the upper half-plane:</span>
<span id="cb20-205"><a href="#cb20-205" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Bottom edge**: Unit semicircle centered at origin (equation: $x^2 + y^2 = 1$, $y &gt; 0$)</span>
<span id="cb20-206"><a href="#cb20-206" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Left edge**: Vertical geodesic at $x = -1$</span>
<span id="cb20-207"><a href="#cb20-207" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Right edge**: Vertical geodesic at $x = 1$</span>
<span id="cb20-208"><a href="#cb20-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-209"><a href="#cb20-209" aria-hidden="true" tabindex="-1"></a>This creates a hyperbolic triangle with one ideal vertex (at infinity on the $y$-axis) and two finite vertices.</span>
<span id="cb20-210"><a href="#cb20-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-211"><a href="#cb20-211" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-212"><a href="#cb20-212" aria-hidden="true" tabindex="-1"></a><span class="in">struct Geodesic {</span></span>
<span id="cb20-213"><a href="#cb20-213" aria-hidden="true" tabindex="-1"></a><span class="in">    int type;  // 0 = vertical line, 1 = semicircle</span></span>
<span id="cb20-214"><a href="#cb20-214" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 data;  // For vertical: (x_pos, unused), for semicircle: (center_x, radius)</span></span>
<span id="cb20-215"><a href="#cb20-215" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb20-216"><a href="#cb20-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-217"><a href="#cb20-217" aria-hidden="true" tabindex="-1"></a><span class="in">void setupTriangle(out Geodesic g1, out Geodesic g2, out Geodesic g3) {</span></span>
<span id="cb20-218"><a href="#cb20-218" aria-hidden="true" tabindex="-1"></a><span class="in">    g1.type = 1;  // Semicircle</span></span>
<span id="cb20-219"><a href="#cb20-219" aria-hidden="true" tabindex="-1"></a><span class="in">    g1.data = vec2(0.0, 1.0);  // Center at origin, radius 1</span></span>
<span id="cb20-220"><a href="#cb20-220" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-221"><a href="#cb20-221" aria-hidden="true" tabindex="-1"></a><span class="in">    g2.type = 0;  // Vertical line</span></span>
<span id="cb20-222"><a href="#cb20-222" aria-hidden="true" tabindex="-1"></a><span class="in">    g2.data = vec2(-1.0, 0.0);  // At x = -1</span></span>
<span id="cb20-223"><a href="#cb20-223" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-224"><a href="#cb20-224" aria-hidden="true" tabindex="-1"></a><span class="in">    g3.type = 0;  // Vertical line</span></span>
<span id="cb20-225"><a href="#cb20-225" aria-hidden="true" tabindex="-1"></a><span class="in">    g3.data = vec2(1.0, 0.0);  // At x = 1</span></span>
<span id="cb20-226"><a href="#cb20-226" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-227"><a href="#cb20-227" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-228"><a href="#cb20-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-229"><a href="#cb20-229" aria-hidden="true" tabindex="-1"></a><span class="fu">### Checking if a Point is in the Triangle</span></span>
<span id="cb20-230"><a href="#cb20-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-231"><a href="#cb20-231" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-232"><a href="#cb20-232" aria-hidden="true" tabindex="-1"></a><span class="in">bool inTriangle(vec2 p) {</span></span>
<span id="cb20-233"><a href="#cb20-233" aria-hidden="true" tabindex="-1"></a><span class="in">    // Above the semicircle: x² + y² &gt; 1</span></span>
<span id="cb20-234"><a href="#cb20-234" aria-hidden="true" tabindex="-1"></a><span class="in">    bool aboveSemicircle = dot(p, p) &gt; 1.0;</span></span>
<span id="cb20-235"><a href="#cb20-235" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-236"><a href="#cb20-236" aria-hidden="true" tabindex="-1"></a><span class="in">    // Between vertical lines: -1 &lt; x &lt; 1</span></span>
<span id="cb20-237"><a href="#cb20-237" aria-hidden="true" tabindex="-1"></a><span class="in">    bool betweenLines = (p.x &gt; -1.0) &amp;&amp; (p.x &lt; 1.0);</span></span>
<span id="cb20-238"><a href="#cb20-238" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-239"><a href="#cb20-239" aria-hidden="true" tabindex="-1"></a><span class="in">    return aboveSemicircle &amp;&amp; betweenLines;</span></span>
<span id="cb20-240"><a href="#cb20-240" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-241"><a href="#cb20-241" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-242"><a href="#cb20-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-243"><a href="#cb20-243" aria-hidden="true" tabindex="-1"></a><span class="fu">### Reflection Across Geodesics</span></span>
<span id="cb20-244"><a href="#cb20-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-245"><a href="#cb20-245" aria-hidden="true" tabindex="-1"></a>**Reflection across a vertical line $x = c$:**</span>
<span id="cb20-246"><a href="#cb20-246" aria-hidden="true" tabindex="-1"></a>$$\text{reflect}(x + iy) = (2c - x) + iy$$</span>
<span id="cb20-247"><a href="#cb20-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-248"><a href="#cb20-248" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-249"><a href="#cb20-249" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectVertical(vec2 p, float c) {</span></span>
<span id="cb20-250"><a href="#cb20-250" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(2.0 * c - p.x, p.y);</span></span>
<span id="cb20-251"><a href="#cb20-251" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-252"><a href="#cb20-252" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-253"><a href="#cb20-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-254"><a href="#cb20-254" aria-hidden="true" tabindex="-1"></a>**Reflection across a semicircle (circle inversion from yesterday!):**</span>
<span id="cb20-255"><a href="#cb20-255" aria-hidden="true" tabindex="-1"></a>For a circle of radius $R$ centered at $(c_x, 0)$:</span>
<span id="cb20-256"><a href="#cb20-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-257"><a href="#cb20-257" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-258"><a href="#cb20-258" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectCircle(vec2 p, vec2 center, float radius) {</span></span>
<span id="cb20-259"><a href="#cb20-259" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 diff = p - center;</span></span>
<span id="cb20-260"><a href="#cb20-260" aria-hidden="true" tabindex="-1"></a><span class="in">    float r2 = dot(diff, diff);</span></span>
<span id="cb20-261"><a href="#cb20-261" aria-hidden="true" tabindex="-1"></a><span class="in">    return center + (radius * radius) * diff / r2;</span></span>
<span id="cb20-262"><a href="#cb20-262" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-263"><a href="#cb20-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-264"><a href="#cb20-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-265"><a href="#cb20-265" aria-hidden="true" tabindex="-1"></a><span class="fu">### Folding into the Fundamental Domain</span></span>
<span id="cb20-266"><a href="#cb20-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-267"><a href="#cb20-267" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-268"><a href="#cb20-268" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 foldToHyperbolicTriangle(vec2 p, int maxIter, out int foldCount) {</span></span>
<span id="cb20-269"><a href="#cb20-269" aria-hidden="true" tabindex="-1"></a><span class="in">    foldCount = 0;</span></span>
<span id="cb20-270"><a href="#cb20-270" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-271"><a href="#cb20-271" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; maxIter; i++) {</span></span>
<span id="cb20-272"><a href="#cb20-272" aria-hidden="true" tabindex="-1"></a><span class="in">        bool folded = false;</span></span>
<span id="cb20-273"><a href="#cb20-273" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb20-274"><a href="#cb20-274" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across left vertical line if needed</span></span>
<span id="cb20-275"><a href="#cb20-275" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &lt; -1.0) {</span></span>
<span id="cb20-276"><a href="#cb20-276" aria-hidden="true" tabindex="-1"></a><span class="in">            p = reflectVertical(p, -1.0);</span></span>
<span id="cb20-277"><a href="#cb20-277" aria-hidden="true" tabindex="-1"></a><span class="in">            folded = true;</span></span>
<span id="cb20-278"><a href="#cb20-278" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb20-279"><a href="#cb20-279" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb20-280"><a href="#cb20-280" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across right vertical line if needed</span></span>
<span id="cb20-281"><a href="#cb20-281" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &gt; 1.0) {</span></span>
<span id="cb20-282"><a href="#cb20-282" aria-hidden="true" tabindex="-1"></a><span class="in">            p = reflectVertical(p, 1.0);</span></span>
<span id="cb20-283"><a href="#cb20-283" aria-hidden="true" tabindex="-1"></a><span class="in">            folded = true;</span></span>
<span id="cb20-284"><a href="#cb20-284" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb20-285"><a href="#cb20-285" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb20-286"><a href="#cb20-286" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across semicircle if needed</span></span>
<span id="cb20-287"><a href="#cb20-287" aria-hidden="true" tabindex="-1"></a><span class="in">        if(dot(p, p) &lt; 1.0) {</span></span>
<span id="cb20-288"><a href="#cb20-288" aria-hidden="true" tabindex="-1"></a><span class="in">            p = reflectCircle(p, vec2(0.0, 0.0), 1.0);</span></span>
<span id="cb20-289"><a href="#cb20-289" aria-hidden="true" tabindex="-1"></a><span class="in">            folded = true;</span></span>
<span id="cb20-290"><a href="#cb20-290" aria-hidden="true" tabindex="-1"></a><span class="in">        }</span></span>
<span id="cb20-291"><a href="#cb20-291" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb20-292"><a href="#cb20-292" aria-hidden="true" tabindex="-1"></a><span class="in">        if(folded) foldCount++;</span></span>
<span id="cb20-293"><a href="#cb20-293" aria-hidden="true" tabindex="-1"></a><span class="in">        else break;  // In fundamental domain</span></span>
<span id="cb20-294"><a href="#cb20-294" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb20-295"><a href="#cb20-295" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-296"><a href="#cb20-296" aria-hidden="true" tabindex="-1"></a><span class="in">    return p;</span></span>
<span id="cb20-297"><a href="#cb20-297" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-298"><a href="#cb20-298" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-299"><a href="#cb20-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-300"><a href="#cb20-300" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualization: Hyperbolic Tiling</span></span>
<span id="cb20-301"><a href="#cb20-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-302"><a href="#cb20-302" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-303"><a href="#cb20-303" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb20-304"><a href="#cb20-304" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb20-305"><a href="#cb20-305" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup - map to upper half-plane</span></span>
<span id="cb20-306"><a href="#cb20-306" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb20-307"><a href="#cb20-307" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb20-308"><a href="#cb20-308" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb20-309"><a href="#cb20-309" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-310"><a href="#cb20-310" aria-hidden="true" tabindex="-1"></a><span class="in">    // Shift up so y &gt; 0</span></span>
<span id="cb20-311"><a href="#cb20-311" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv + vec2(0.0, 1.5);</span></span>
<span id="cb20-312"><a href="#cb20-312" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-313"><a href="#cb20-313" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold to fundamental domain</span></span>
<span id="cb20-314"><a href="#cb20-314" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount;</span></span>
<span id="cb20-315"><a href="#cb20-315" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);</span></span>
<span id="cb20-316"><a href="#cb20-316" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-317"><a href="#cb20-317" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb20-318"><a href="#cb20-318" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 10.0;</span></span>
<span id="cb20-319"><a href="#cb20-319" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb20-320"><a href="#cb20-320" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-321"><a href="#cb20-321" aria-hidden="true" tabindex="-1"></a><span class="in">    // Highlight fundamental domain</span></span>
<span id="cb20-322"><a href="#cb20-322" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inTriangle(p_folded)) {</span></span>
<span id="cb20-323"><a href="#cb20-323" aria-hidden="true" tabindex="-1"></a><span class="in">        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);</span></span>
<span id="cb20-324"><a href="#cb20-324" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb20-325"><a href="#cb20-325" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-326"><a href="#cb20-326" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb20-327"><a href="#cb20-327" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-328"><a href="#cb20-328" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-329"><a href="#cb20-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-330"><a href="#cb20-330" aria-hidden="true" tabindex="-1"></a>The result: a beautiful hyperbolic tiling! Notice how the triangles appear to shrink near the real axis—they're all the same hyperbolic size, but Euclidean distances compress.</span>
<span id="cb20-331"><a href="#cb20-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-332"><a href="#cb20-332" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb20-333"><a href="#cb20-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-334"><a href="#cb20-334" aria-hidden="true" tabindex="-1"></a><span class="fu">## Visualizing in the Poincaré Disk</span></span>
<span id="cb20-335"><a href="#cb20-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-336"><a href="#cb20-336" aria-hidden="true" tabindex="-1"></a>Now we'll see the same tiling in a different model by converting coordinates.</span>
<span id="cb20-337"><a href="#cb20-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-338"><a href="#cb20-338" aria-hidden="true" tabindex="-1"></a><span class="fu">### By Precomposition</span></span>
<span id="cb20-339"><a href="#cb20-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-340"><a href="#cb20-340" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-341"><a href="#cb20-341" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb20-342"><a href="#cb20-342" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb20-343"><a href="#cb20-343" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup - map to disk</span></span>
<span id="cb20-344"><a href="#cb20-344" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb20-345"><a href="#cb20-345" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 2.0;</span></span>
<span id="cb20-346"><a href="#cb20-346" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb20-347"><a href="#cb20-347" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-348"><a href="#cb20-348" aria-hidden="true" tabindex="-1"></a><span class="in">    // Only render inside unit disk</span></span>
<span id="cb20-349"><a href="#cb20-349" aria-hidden="true" tabindex="-1"></a><span class="in">    if(length(uv) &gt;= 1.0) {</span></span>
<span id="cb20-350"><a href="#cb20-350" aria-hidden="true" tabindex="-1"></a><span class="in">        fragColor = vec4(0.0, 0.0, 0.0, 1.0);</span></span>
<span id="cb20-351"><a href="#cb20-351" aria-hidden="true" tabindex="-1"></a><span class="in">        return;</span></span>
<span id="cb20-352"><a href="#cb20-352" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb20-353"><a href="#cb20-353" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-354"><a href="#cb20-354" aria-hidden="true" tabindex="-1"></a><span class="in">    // Convert disk coordinates to upper half-plane</span></span>
<span id="cb20-355"><a href="#cb20-355" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = diskToUHP(uv);</span></span>
<span id="cb20-356"><a href="#cb20-356" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-357"><a href="#cb20-357" aria-hidden="true" tabindex="-1"></a><span class="in">    // Now do all computations in UHP</span></span>
<span id="cb20-358"><a href="#cb20-358" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount;</span></span>
<span id="cb20-359"><a href="#cb20-359" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);</span></span>
<span id="cb20-360"><a href="#cb20-360" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-361"><a href="#cb20-361" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb20-362"><a href="#cb20-362" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 10.0;</span></span>
<span id="cb20-363"><a href="#cb20-363" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = palette(t);</span></span>
<span id="cb20-364"><a href="#cb20-364" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-365"><a href="#cb20-365" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inTriangle(p_folded)) {</span></span>
<span id="cb20-366"><a href="#cb20-366" aria-hidden="true" tabindex="-1"></a><span class="in">        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);</span></span>
<span id="cb20-367"><a href="#cb20-367" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb20-368"><a href="#cb20-368" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb20-369"><a href="#cb20-369" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb20-370"><a href="#cb20-370" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-371"><a href="#cb20-371" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-372"><a href="#cb20-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-373"><a href="#cb20-373" aria-hidden="true" tabindex="-1"></a>The tiling now appears in the Poincaré disk—the same mathematical object displayed in a different model!</span>
<span id="cb20-374"><a href="#cb20-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-375"><a href="#cb20-375" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb20-376"><a href="#cb20-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-377"><a href="#cb20-377" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb20-378"><a href="#cb20-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-379"><a href="#cb20-379" aria-hidden="true" tabindex="-1"></a>Today we covered:</span>
<span id="cb20-380"><a href="#cb20-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-381"><a href="#cb20-381" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Euclidean triangle tiling**: Using reflections to tile the plane with equilateral triangles</span>
<span id="cb20-382"><a href="#cb20-382" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Hyperbolic geometry models**: Upper half-plane and Poincaré disk, with metrics and geodesics</span>
<span id="cb20-383"><a href="#cb20-383" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Coordinate transformations**: Cayley transform connecting the two models</span>
<span id="cb20-384"><a href="#cb20-384" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Hyperbolic triangle tiling**: Using reflections (including circle inversion) to tile hyperbolic space</span>
<span id="cb20-385"><a href="#cb20-385" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Multiple representations**: Same tiling visualized in different models</span>
<span id="cb20-386"><a href="#cb20-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-387"><a href="#cb20-387" aria-hidden="true" tabindex="-1"></a>Key insights:</span>
<span id="cb20-388"><a href="#cb20-388" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Reflection-based tilings work in any geometry** with the appropriate reflection operations</span>
<span id="cb20-389"><a href="#cb20-389" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Circle inversion** (from Day 2) is fundamental to hyperbolic geometry</span>
<span id="cb20-390"><a href="#cb20-390" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**The same mathematical object looks different** in different models</span>
<span id="cb20-391"><a href="#cb20-391" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Geodesics replace straight lines** as the fundamental "straight" paths</span>
<span id="cb20-392"><a href="#cb20-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-393"><a href="#cb20-393" aria-hidden="true" tabindex="-1"></a>The algorithmic structure is identical across geometries—only the reflection operations change!</span>
<span id="cb20-394"><a href="#cb20-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-395"><a href="#cb20-395" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb20-396"><a href="#cb20-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-397"><a href="#cb20-397" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb20-398"><a href="#cb20-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-399"><a href="#cb20-399" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Drawing Geodesics and Hyperbolic Disks</span></span>
<span id="cb20-400"><a href="#cb20-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-401"><a href="#cb20-401" aria-hidden="true" tabindex="-1"></a>Implement visualization of basic hyperbolic objects to understand the geometry.</span>
<span id="cb20-402"><a href="#cb20-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-403"><a href="#cb20-403" aria-hidden="true" tabindex="-1"></a>**Part 1: Draw several geodesics in the upper half-plane**</span>
<span id="cb20-404"><a href="#cb20-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-405"><a href="#cb20-405" aria-hidden="true" tabindex="-1"></a>Vertical lines are easy:</span>
<span id="cb20-406"><a href="#cb20-406" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-407"><a href="#cb20-407" aria-hidden="true" tabindex="-1"></a><span class="in">// Distance to vertical line x = c</span></span>
<span id="cb20-408"><a href="#cb20-408" aria-hidden="true" tabindex="-1"></a><span class="in">float distToVertical = abs(p.x - c);</span></span>
<span id="cb20-409"><a href="#cb20-409" aria-hidden="true" tabindex="-1"></a><span class="in">if(distToVertical &lt; thickness) color = geodesicColor;</span></span>
<span id="cb20-410"><a href="#cb20-410" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-411"><a href="#cb20-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-412"><a href="#cb20-412" aria-hidden="true" tabindex="-1"></a>Semicircular geodesics require the implicit equation:</span>
<span id="cb20-413"><a href="#cb20-413" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-414"><a href="#cb20-414" aria-hidden="true" tabindex="-1"></a><span class="in">// Semicircle: (x - cx)² + y² = R², with y &gt; 0</span></span>
<span id="cb20-415"><a href="#cb20-415" aria-hidden="true" tabindex="-1"></a><span class="in">float distToSemicircle = abs(sqrt((p.x - cx) * (p.x - cx) + p.y * p.y) - R);</span></span>
<span id="cb20-416"><a href="#cb20-416" aria-hidden="true" tabindex="-1"></a><span class="in">if(distToSemicircle &lt; thickness &amp;&amp; p.y &gt; 0.0) color = geodesicColor;</span></span>
<span id="cb20-417"><a href="#cb20-417" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-418"><a href="#cb20-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-419"><a href="#cb20-419" aria-hidden="true" tabindex="-1"></a>Draw several of each type to visualize the geodesic structure.</span>
<span id="cb20-420"><a href="#cb20-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-421"><a href="#cb20-421" aria-hidden="true" tabindex="-1"></a>**Part 2: Draw hyperbolic disks**</span>
<span id="cb20-422"><a href="#cb20-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-423"><a href="#cb20-423" aria-hidden="true" tabindex="-1"></a>A hyperbolic disk of radius $r$ centered at $z_0$ is the set:</span>
<span id="cb20-424"><a href="#cb20-424" aria-hidden="true" tabindex="-1"></a>$$<span class="sc">\{</span>z : d_{\text{hyp}}(z, z_0) &lt; r<span class="sc">\}</span>$$</span>
<span id="cb20-425"><a href="#cb20-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-426"><a href="#cb20-426" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-427"><a href="#cb20-427" aria-hidden="true" tabindex="-1"></a><span class="in">float d = hyperbolicDistance(p, center);</span></span>
<span id="cb20-428"><a href="#cb20-428" aria-hidden="true" tabindex="-1"></a><span class="in">if(d &lt; radius) color = diskColor;</span></span>
<span id="cb20-429"><a href="#cb20-429" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-430"><a href="#cb20-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-431"><a href="#cb20-431" aria-hidden="true" tabindex="-1"></a>Draw several disks at different locations and with the same hyperbolic radius. Observe how they appear smaller (in Euclidean sense) near the boundary—this demonstrates the metric's behavior.</span>
<span id="cb20-432"><a href="#cb20-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-433"><a href="#cb20-433" aria-hidden="true" tabindex="-1"></a>**Part 3: Visualize metric distortion**</span>
<span id="cb20-434"><a href="#cb20-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-435"><a href="#cb20-435" aria-hidden="true" tabindex="-1"></a>Create a grid of hyperbolic disks of equal hyperbolic radius. Watch how their Euclidean sizes vary across the half-plane.</span>
<span id="cb20-436"><a href="#cb20-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-437"><a href="#cb20-437" aria-hidden="true" tabindex="-1"></a>**Optional enhancement:** Repeat in Poincaré disk model by precomposition.</span>
<span id="cb20-438"><a href="#cb20-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-439"><a href="#cb20-439" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Drawing Triangle Edges and Vertices</span></span>
<span id="cb20-440"><a href="#cb20-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-441"><a href="#cb20-441" aria-hidden="true" tabindex="-1"></a>Enhance your hyperbolic tiling by drawing the triangle boundaries.</span>
<span id="cb20-442"><a href="#cb20-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-443"><a href="#cb20-443" aria-hidden="true" tabindex="-1"></a>**Task:**</span>
<span id="cb20-444"><a href="#cb20-444" aria-hidden="true" tabindex="-1"></a>For each point, compute the distance to the three geodesics forming your triangle boundary. If the distance is below a threshold, color it as an edge.</span>
<span id="cb20-445"><a href="#cb20-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-446"><a href="#cb20-446" aria-hidden="true" tabindex="-1"></a>**Implementation hints:**</span>
<span id="cb20-447"><a href="#cb20-447" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-448"><a href="#cb20-448" aria-hidden="true" tabindex="-1"></a><span class="in">// Distance to vertical line</span></span>
<span id="cb20-449"><a href="#cb20-449" aria-hidden="true" tabindex="-1"></a><span class="in">float d1 = abs(p.x - (-1.0));</span></span>
<span id="cb20-450"><a href="#cb20-450" aria-hidden="true" tabindex="-1"></a><span class="in">float d2 = abs(p.x - 1.0);</span></span>
<span id="cb20-451"><a href="#cb20-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-452"><a href="#cb20-452" aria-hidden="true" tabindex="-1"></a><span class="in">// Distance to semicircle (already have this from Part 1)</span></span>
<span id="cb20-453"><a href="#cb20-453" aria-hidden="true" tabindex="-1"></a><span class="in">float d3 = abs(length(p) - 1.0);</span></span>
<span id="cb20-454"><a href="#cb20-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-455"><a href="#cb20-455" aria-hidden="true" tabindex="-1"></a><span class="in">float edgeThickness = 0.05;</span></span>
<span id="cb20-456"><a href="#cb20-456" aria-hidden="true" tabindex="-1"></a><span class="in">bool onEdge = (d1 &lt; edgeThickness) || (d2 &lt; edgeThickness) || (d3 &lt; edgeThickness);</span></span>
<span id="cb20-457"><a href="#cb20-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-458"><a href="#cb20-458" aria-hidden="true" tabindex="-1"></a><span class="in">if(onEdge) color = vec3(1.0, 1.0, 1.0);  // White edges</span></span>
<span id="cb20-459"><a href="#cb20-459" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-460"><a href="#cb20-460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-461"><a href="#cb20-461" aria-hidden="true" tabindex="-1"></a>For vertices, compute Euclidean distance to the three vertex positions and draw small circles.</span>
<span id="cb20-462"><a href="#cb20-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-463"><a href="#cb20-463" aria-hidden="true" tabindex="-1"></a>**Expected output:** Your tiling with clearly visible triangle boundaries, making the tessellation structure explicit.</span>
<span id="cb20-464"><a href="#cb20-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-465"><a href="#cb20-465" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Model Conversion and Möbius Transformation</span></span>
<span id="cb20-466"><a href="#cb20-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-467"><a href="#cb20-467" aria-hidden="true" tabindex="-1"></a>Work with different representations of hyperbolic space.</span>
<span id="cb20-468"><a href="#cb20-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-469"><a href="#cb20-469" aria-hidden="true" tabindex="-1"></a>**Part 1: Convert your tiling to Poincaré disk**</span>
<span id="cb20-470"><a href="#cb20-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-471"><a href="#cb20-471" aria-hidden="true" tabindex="-1"></a>You already have the transformation functions. Create a shader that displays your hyperbolic tiling in the disk model and compare the visual appearance.</span>
<span id="cb20-472"><a href="#cb20-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-473"><a href="#cb20-473" aria-hidden="true" tabindex="-1"></a>**Part 2: Apply a Möbius transformation**</span>
<span id="cb20-474"><a href="#cb20-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-475"><a href="#cb20-475" aria-hidden="true" tabindex="-1"></a>A Möbius transformation has the form:</span>
<span id="cb20-476"><a href="#cb20-476" aria-hidden="true" tabindex="-1"></a>$$z \mapsto \frac{az + b}{cz + d}, \quad ad - bc = 1$$</span>
<span id="cb20-477"><a href="#cb20-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-478"><a href="#cb20-478" aria-hidden="true" tabindex="-1"></a>These are isometries of hyperbolic space—they permute the tiles but preserve the geometry.</span>
<span id="cb20-479"><a href="#cb20-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-480"><a href="#cb20-480" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-481"><a href="#cb20-481" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {</span></span>
<span id="cb20-482"><a href="#cb20-482" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 num = cadd(cmul(a, z), b);</span></span>
<span id="cb20-483"><a href="#cb20-483" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 den = cadd(cmul(c, z), d);</span></span>
<span id="cb20-484"><a href="#cb20-484" aria-hidden="true" tabindex="-1"></a><span class="in">    return cdiv(num, den);</span></span>
<span id="cb20-485"><a href="#cb20-485" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb20-486"><a href="#cb20-486" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-487"><a href="#cb20-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-488"><a href="#cb20-488" aria-hidden="true" tabindex="-1"></a>Try some interesting transformations:</span>
<span id="cb20-489"><a href="#cb20-489" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Translation: $z \mapsto z + 1$ (in complex plane, not hyperbolic translation!)</span>
<span id="cb20-490"><a href="#cb20-490" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Scaling: $z \mapsto 2z$</span>
<span id="cb20-491"><a href="#cb20-491" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Rotation: $z \mapsto e^{i\theta} z$</span>
<span id="cb20-492"><a href="#cb20-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-493"><a href="#cb20-493" aria-hidden="true" tabindex="-1"></a>Apply to your tiling:</span>
<span id="cb20-494"><a href="#cb20-494" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb20-495"><a href="#cb20-495" aria-hidden="true" tabindex="-1"></a><span class="in">// Before folding:</span></span>
<span id="cb20-496"><a href="#cb20-496" aria-hidden="true" tabindex="-1"></a><span class="in">p = mobius(p, vec2(2.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(1.0, 0.0));</span></span>
<span id="cb20-497"><a href="#cb20-497" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-498"><a href="#cb20-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-499"><a href="#cb20-499" aria-hidden="true" tabindex="-1"></a>Watch how the tiling transforms!</span>
<span id="cb20-500"><a href="#cb20-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-501"><a href="#cb20-501" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional: Advanced Hyperbolic Explorations</span></span>
<span id="cb20-502"><a href="#cb20-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-503"><a href="#cb20-503" aria-hidden="true" tabindex="-1"></a>Choose one or more:</span>
<span id="cb20-504"><a href="#cb20-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-505"><a href="#cb20-505" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 1. Different Triangle Groups</span></span>
<span id="cb20-506"><a href="#cb20-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-507"><a href="#cb20-507" aria-hidden="true" tabindex="-1"></a>Implement different hyperbolic triangle groups. The $(p, q, r)$ notation indicates angles $\pi/p$, $\pi/q$, $\pi/r$ at the three vertices.</span>
<span id="cb20-508"><a href="#cb20-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-509"><a href="#cb20-509" aria-hidden="true" tabindex="-1"></a>Famous examples:</span>
<span id="cb20-510"><a href="#cb20-510" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(2, 3, 7)$: Creates Escher-like tilings</span>
<span id="cb20-511"><a href="#cb20-511" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(2, 4, 6)$: Different symmetry structure</span>
<span id="cb20-512"><a href="#cb20-512" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(3, 3, 3)$: Equilateral hyperbolic triangle</span>
<span id="cb20-513"><a href="#cb20-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-514"><a href="#cb20-514" aria-hidden="true" tabindex="-1"></a>Each requires setting up different geodesics for the triangle edges.</span>
<span id="cb20-515"><a href="#cb20-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-516"><a href="#cb20-516" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 2. Klein Model</span></span>
<span id="cb20-517"><a href="#cb20-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-518"><a href="#cb20-518" aria-hidden="true" tabindex="-1"></a>The Klein model represents hyperbolic space where geodesics are Euclidean straight lines (but angles are distorted).</span>
<span id="cb20-519"><a href="#cb20-519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-520"><a href="#cb20-520" aria-hidden="true" tabindex="-1"></a>Convert from Poincaré disk to Klein: </span>
<span id="cb20-521"><a href="#cb20-521" aria-hidden="true" tabindex="-1"></a>$$w = \frac{2z}{1 + |z|^2}$$</span>
<span id="cb20-522"><a href="#cb20-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-523"><a href="#cb20-523" aria-hidden="true" tabindex="-1"></a>Visualize your tiling in this model and observe how geodesics become straight!</span>
<span id="cb20-524"><a href="#cb20-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-525"><a href="#cb20-525" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 3. Decorated Tiles</span></span>
<span id="cb20-526"><a href="#cb20-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-527"><a href="#cb20-527" aria-hidden="true" tabindex="-1"></a>Add patterns inside each triangle (like Escher's Circle Limit prints). Use barycentric coordinates or distance from edges to create decorations within the fundamental domain.</span>
<span id="cb20-528"><a href="#cb20-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-529"><a href="#cb20-529" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 4. Conformal Mapping Art</span></span>
<span id="cb20-530"><a href="#cb20-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-531"><a href="#cb20-531" aria-hidden="true" tabindex="-1"></a>Use complex analysis to map the disk to other regions (strips, annuli, etc.) and visualize hyperbolic geometry in exotic coordinate systems.</span>
<span id="cb20-532"><a href="#cb20-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-533"><a href="#cb20-533" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb20-534"><a href="#cb20-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-535"><a href="#cb20-535" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking Ahead</span></span>
<span id="cb20-536"><a href="#cb20-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-537"><a href="#cb20-537" aria-hidden="true" tabindex="-1"></a>Tomorrow we move to 3D! We'll learn raymarching and signed distance functions to render implicit surfaces. The geometric intuition from reflections and distance computations will carry over, but now in three dimensions with lighting and shading.</span>
<span id="cb20-538"><a href="#cb20-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-539"><a href="#cb20-539" aria-hidden="true" tabindex="-1"></a>Make sure you're comfortable with:</span>
<span id="cb20-540"><a href="#cb20-540" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Reflection operations (these generalize to 3D)</span>
<span id="cb20-541"><a href="#cb20-541" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Distance computations (both Euclidean and hyperbolic)</span>
<span id="cb20-542"><a href="#cb20-542" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Iterative algorithms for geometric structures</span>
<span id="cb20-543"><a href="#cb20-543" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Working with different coordinate systems/models</span>
<span id="cb20-544"><a href="#cb20-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-545"><a href="#cb20-545" aria-hidden="true" tabindex="-1"></a>See you tomorrow!</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>