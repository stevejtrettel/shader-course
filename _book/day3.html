<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Day 3: Geometric Tilings in Euclidean and Hyperbolic Space – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./day4.html" rel="next">
<link href="./day2.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-86daaaaad7353f9cc0c554efc1dd6d94.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-f8dc6eab18fde03278982b0b35885446.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ed04f5f1653af6df52378e13bfdac05e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-d37bfdfd9a2222927534875c15a9020f.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./day3.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/yourusername/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1-rewrite.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./debug-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Debugging</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./folding-fractals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Folding Fractals</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./schottky.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Schottky Groups, Möbius Maps, and GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">3.1</span> Overview</a></li>
  <li><a href="#part-1-reflection-and-tilings-in-euclidean-geometry" id="toc-part-1-reflection-and-tilings-in-euclidean-geometry" class="nav-link" data-scroll-target="#part-1-reflection-and-tilings-in-euclidean-geometry"><span class="header-section-number">3.2</span> Part 1: Reflection and Tilings in Euclidean Geometry</a>
  <ul class="collapse">
  <li><a href="#starting-simple-the-folding-algorithm" id="toc-starting-simple-the-folding-algorithm" class="nav-link" data-scroll-target="#starting-simple-the-folding-algorithm">Starting Simple: The Folding Algorithm</a></li>
  <li><a href="#abstracting-half-spaces" id="toc-abstracting-half-spaces" class="nav-link" data-scroll-target="#abstracting-half-spaces">Abstracting: Half-Spaces</a></li>
  <li><a href="#square-tiling-with-half-spaces" id="toc-square-tiling-with-half-spaces" class="nav-link" data-scroll-target="#square-tiling-with-half-spaces">Square Tiling with Half-Spaces</a></li>
  <li><a href="#triangle-tiling" id="toc-triangle-tiling" class="nav-link" data-scroll-target="#triangle-tiling">Triangle Tiling</a></li>
  </ul></li>
  <li><a href="#part-2-hyperbolic-geometry" id="toc-part-2-hyperbolic-geometry" class="nav-link" data-scroll-target="#part-2-hyperbolic-geometry"><span class="header-section-number">3.3</span> Part 2: Hyperbolic Geometry</a>
  <ul class="collapse">
  <li><a href="#introduction-to-hyperbolic-geometry" id="toc-introduction-to-hyperbolic-geometry" class="nav-link" data-scroll-target="#introduction-to-hyperbolic-geometry">Introduction to Hyperbolic Geometry</a></li>
  <li><a href="#the-upper-half-plane-model" id="toc-the-upper-half-plane-model" class="nav-link" data-scroll-target="#the-upper-half-plane-model">The Upper Half-Plane Model</a></li>
  <li><a href="#geodesics-and-reflections" id="toc-geodesics-and-reflections" class="nav-link" data-scroll-target="#geodesics-and-reflections">Geodesics and Reflections</a></li>
  <li><a href="#the-23-triangle" id="toc-the-23-triangle" class="nav-link" data-scroll-target="#the-23-triangle">The (2,3,∞) Triangle</a></li>
  <li><a href="#the-poincaré-disk-model" id="toc-the-poincaré-disk-model" class="nav-link" data-scroll-target="#the-poincaré-disk-model">The Poincaré Disk Model</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">3.4</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">3.5</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-1-euclidean-triangle-tiling-with-edges-and-vertices" id="toc-required-1-euclidean-triangle-tiling-with-edges-and-vertices" class="nav-link" data-scroll-target="#required-1-euclidean-triangle-tiling-with-edges-and-vertices">Required #1: Euclidean Triangle Tiling with Edges and Vertices</a></li>
  <li><a href="#required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" id="toc-required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" class="nav-link" data-scroll-target="#required-2-hyperbolic-triangle-tiling-with-edges-and-vertices">Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</a></li>
  <li><a href="#required-3-model-conversions" id="toc-required-3-model-conversions" class="nav-link" data-scroll-target="#required-3-model-conversions">Required #3: Model Conversions</a></li>
  <li><a href="#required-4-different-triangle-groups" id="toc-required-4-different-triangle-groups" class="nav-link" data-scroll-target="#required-4-different-triangle-groups">Required #4: Different Triangle Groups</a></li>
  <li><a href="#optional-exercise-unified-abstractions" id="toc-optional-exercise-unified-abstractions" class="nav-link" data-scroll-target="#optional-exercise-unified-abstractions">Optional Exercise: Unified Abstractions</a></li>
  <li><a href="#optional-decorated-tiles" id="toc-optional-decorated-tiles" class="nav-link" data-scroll-target="#optional-decorated-tiles">Optional: Decorated Tiles</a></li>
  <li><a href="#optional-pentagon-tilings" id="toc-optional-pentagon-tilings" class="nav-link" data-scroll-target="#optional-pentagon-tilings">Optional: Pentagon Tilings</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">3.1</span> Overview</h2>
<p>Today we explore geometric tilings through reflection operations. We’ll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.</p>
<p>The key insight: <strong>the algorithm stays the same across geometries—only the reflection operations change.</strong> This mirrors what we saw yesterday with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region.</p>
<p>By the end of today, you’ll understand: - How to construct reflections using linear algebra - The folding algorithm for creating tilings - The structure of hyperbolic geometry in the upper half-plane model - How to implement hyperbolic triangle tilings using the same algorithmic pattern - How to convert between different models of hyperbolic space</p>
<hr>
</section>
<section id="part-1-reflection-and-tilings-in-euclidean-geometry" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="part-1-reflection-and-tilings-in-euclidean-geometry"><span class="header-section-number">3.2</span> Part 1: Reflection and Tilings in Euclidean Geometry</h2>
<section id="starting-simple-the-folding-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="starting-simple-the-folding-algorithm">Starting Simple: The Folding Algorithm</h3>
<p>Before we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.</p>
<section id="tiling-a-strip" class="level4">
<h4 class="anchored" data-anchor-id="tiling-a-strip">Tiling a Strip</h4>
<p>Imagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip <span class="math inline">\(0 &lt; x &lt; 1\)</span>—and reflect any point outside this strip back inside.</p>
<p>The algorithm is remarkably simple: - If <span class="math inline">\(x &lt; 0\)</span>, reflect across <span class="math inline">\(x = 0\)</span> - If <span class="math inline">\(x &gt; 1\)</span>, reflect across <span class="math inline">\(x = 1\)</span><br>
- Repeat until the point stops moving</p>
<p>For a vertical line at <span class="math inline">\(x = c\)</span>, reflection just flips the <span class="math inline">\(x\)</span>-coordinate: <span class="math inline">\((x, y) \mapsto (2c - x, y)\)</span>.</p>
<p>Here’s a complete shader:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Standard coordinate setup</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the strip [0, 1]</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Dark background</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A circle in the strip</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">));</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Yellow circle</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw the boundary lines</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.02</span> <span class="op">||</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.</p>
<hr>
</section>
<section id="square-tiling" class="level4">
<h4 class="anchored" data-anchor-id="square-tiling">Square Tiling</h4>
<p>Let’s extend to two dimensions. Now we have four boundaries: <span class="math inline">\(x = 0\)</span>, <span class="math inline">\(x = 1\)</span>, <span class="math inline">\(y = 0\)</span>, and <span class="math inline">\(y = 1\)</span>. Same algorithm, just more boundaries to check:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square [0,1] × [0,1]</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're done</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">8.0</span><span class="op">;</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> t <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">)));</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">,</span> d<span class="op">));</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw boundaries</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> border <span class="op">=</span> <span class="bu">min</span><span class="op">(</span><span class="bu">min</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> <span class="fl">1.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">),</span> <span class="bu">min</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">1.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span><span class="op">));</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>border <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Perfect! A full 2D tiling. The color gradient shows how many reflections were needed.</p>
<p>Notice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain.</p>
<hr>
</section>
</section>
<section id="abstracting-half-spaces" class="level3">
<h3 class="anchored" data-anchor-id="abstracting-half-spaces">Abstracting: Half-Spaces</h3>
<p>Looking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.</p>
<section id="what-is-a-half-space" class="level4">
<h4 class="anchored" data-anchor-id="what-is-a-half-space">What is a Half-Space?</h4>
<p>A <strong>half-space</strong> is one side of a line. Any line <span class="math inline">\(ax + by = c\)</span> divides the plane into two regions: - Points where <span class="math inline">\(ax + by &lt; c\)</span> - Points where <span class="math inline">\(ax + by &gt; c\)</span></p>
<p>We’ll encode a half-space by storing the line parameters and which side we want:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span>  <span class="co">// Line parameters: ax + by = c</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span>     <span class="co">// +1 or -1 for which side</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A Note on Redundancy
</div>
</div>
<div class="callout-body-container callout-body">
<p>This representation is actually redundant: we could fix the convention to always use <span class="math inline">\(ax + by &lt; c\)</span> (side implicit) and just flip signs of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> to get the other side. For example, <span class="math inline">\(x &lt; 1\)</span> is the same as <span class="math inline">\(-x &gt; -1\)</span>.</p>
<p>But having an explicit <code>side</code> parameter is convenient for clarity, and will be essential when we move to hyperbolic geometry where the sign-flipping doesn’t work as cleanly. The small redundancy is worth the flexibility!</p>
</div>
</div>
</section>
<section id="the-reflection-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-reflection-formula">The Reflection Formula</h4>
<p>To reflect a point <span class="math inline">\(\mathbf{p} = (x, y)\)</span> across the line <span class="math inline">\(ax + by = c\)</span>, we use linear algebra. The normal vector to the line is <span class="math inline">\(\mathbf{n} = (a, b)\)</span>. After normalizing to <span class="math inline">\(\hat{\mathbf{n}} = \mathbf{n}/|\mathbf{n}|\)</span>, the reflection formula is:</p>
<p><span class="math display">\[\mathbf{p}' = \mathbf{p} - 2d\hat{\mathbf{n}}\]</span></p>
<p>where <span class="math inline">\(d\)</span> is the signed distance from <span class="math inline">\(\mathbf{p}\)</span> to the line: <span class="math display">\[d = \frac{ax + by - c}{\sqrt{a^2 + b^2}}\]</span></p>
<p>This is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.</p>
</section>
<section id="implementation" class="level4">
<h4 class="anchored" data-anchor-id="implementation">Implementation</h4>
<p>Let’s write a function that reflects into a half-space—checking if we’re on the right side, and only reflecting if necessary:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute which side of the line we're on</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're already on the correct side</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span>  <span class="co">// Already inside, nothing to do</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We're on the wrong side - reflect across the boundary line</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This function encapsulates the entire pattern: check if we’re on the correct side, and only reflect if we’re not.</p>
<hr>
</section>
</section>
<section id="square-tiling-with-half-spaces" class="level3">
<h3 class="anchored" data-anchor-id="square-tiling-with-half-spaces">Square Tiling with Half-Spaces</h3>
<p>Let’s rewrite our square tiling using this abstraction. For the square <span class="math inline">\([0, 1] \times [0, 1]\)</span>, we need four half-spaces:</p>
<ul>
<li><p><strong>Left edge</strong> (<span class="math inline">\(x = 0\)</span>): We want <span class="math inline">\(x &gt; 0\)</span><br>
Line: <span class="math inline">\(x = 0\)</span> means <span class="math inline">\(1 \cdot x + 0 \cdot y = 0\)</span><br>
For <span class="math inline">\(x &gt; 0\)</span>: <span class="math inline">\((x - 0) \cdot (-1) &lt; 0\)</span> ✓<br>
So: <code>HalfSpace(1.0, 0.0, 0.0, -1.0)</code></p></li>
<li><p><strong>Right edge</strong> (<span class="math inline">\(x = 1\)</span>): We want <span class="math inline">\(x &lt; 1\)</span><br>
So: <code>HalfSpace(1.0, 0.0, 1.0, 1.0)</code></p></li>
<li><p><strong>Bottom and top</strong>: Similarly for <span class="math inline">\(y\)</span></p></li>
</ul>
<p>Complete shader:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define the four half-spaces for our square [0,1]×[0,1]</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    HalfSpace left   <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// x &gt; 0</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    HalfSpace right  <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// x &lt; 1</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    HalfSpace bottom <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// y &gt; 0</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    HalfSpace top    <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// y &lt; 1</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> left<span class="op">);</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> bottom<span class="op">);</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> top<span class="op">);</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're inside</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">8.0</span><span class="op">;</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> t <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">)));</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">,</span> d<span class="op">));</span></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw boundaries</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> border <span class="op">=</span> <span class="bu">min</span><span class="op">(</span><span class="bu">min</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">,</span> <span class="fl">1.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">),</span> <span class="bu">min</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">1.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span><span class="op">));</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>border <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This looks identical to before, but now our code is flexible. The beauty: <strong>changing from a square to a triangle only requires changing the half-space definitions!</strong></p>
<hr>
</section>
<section id="triangle-tiling" class="level3">
<h3 class="anchored" data-anchor-id="triangle-tiling">Triangle Tiling</h3>
<p>Now we’re ready for triangles. We’ll use an equilateral triangle with vertices: <span class="math display">\[v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)\]</span></p>
<section id="computing-half-spaces-from-edges" class="level4">
<h4 class="anchored" data-anchor-id="computing-half-spaces-from-edges">Computing Half-Spaces from Edges</h4>
<p>For each edge, we compute the line parameters. The math (shown in the callout below) gives us:</p>
<p><strong>Edge from <span class="math inline">\(v_0\)</span> to <span class="math inline">\(v_1\)</span>:</strong> <code>HalfSpace(1.5, -0.866, -0.866, -1.0)</code><br>
<strong>Edge from <span class="math inline">\(v_1\)</span> to <span class="math inline">\(v_2\)</span>:</strong> <code>HalfSpace(0.0, 1.732, -0.866, -1.0)</code><br>
<strong>Edge from <span class="math inline">\(v_2\)</span> to <span class="math inline">\(v_0\)</span>:</strong> <code>HalfSpace(-1.5, -0.866, -0.866, -1.0)</code></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Derivation of Half-Space Parameters
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>For edge from <span class="math inline">\(v_0 = (0, 1)\)</span> to <span class="math inline">\(v_1 = (-0.866, -0.5)\)</span>: - Edge direction: <span class="math inline">\(\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\)</span> - Perpendicular (90° CCW): <span class="math inline">\(\mathbf{n} = (-d_y, d_x) = (1.5, -0.866)\)</span> - Line: <span class="math inline">\(1.5x - 0.866y = c\)</span> where <span class="math inline">\(c = \mathbf{n} \cdot v_0 = -0.866\)</span> - For origin (inside): <span class="math inline">\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\)</span> - Want inside when <span class="math inline">\((ax + by - c) &lt; 0\)</span>, so <code>side = -1.0</code></p>
<p>Similar calculations for the other two edges.</p>
</div>
</div>
</div>
<p>Here’s the complete triangle tiling shader:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define three half-spaces for the triangle edges</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs1 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs2 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.732</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs3 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(-</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the triangle</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're inside</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">10.0</span><span class="op">;</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> t <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">)));</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Beautiful! An infinite tiling of equilateral triangles.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Power of Abstraction
</div>
</div>
<div class="callout-body-container callout-body">
<p>Compare this to our square shader. The algorithm is <em>identical</em>: 1. Define boundaries as half-spaces 2. Repeatedly reflect into each half-space<br>
3. Check for convergence 4. Color based on iteration count</p>
<p>We changed from squares to triangles by just changing the half-space definitions. This is mathematical abstraction at work!</p>
</div>
</div>
<p>This completes our Euclidean foundation. We’ve seen: 1. The folding algorithm in concrete examples 2. The half-space abstraction that makes it general 3. Convergence checking by detecting when points stop moving</p>
<p>Next, we’ll take this exact algorithmic structure into hyperbolic geometry!</p>
<hr>
</section>
</section>
</section>
<section id="part-2-hyperbolic-geometry" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="part-2-hyperbolic-geometry"><span class="header-section-number">3.3</span> Part 2: Hyperbolic Geometry</h2>
<section id="introduction-to-hyperbolic-geometry" class="level3">
<h3 class="anchored" data-anchor-id="introduction-to-hyperbolic-geometry">Introduction to Hyperbolic Geometry</h3>
<p>Hyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant <strong>negative curvature</strong>. It was discovered independently in the early 1800s by János Bolyai, Nikolai Lobachevsky, and Carl Friedrich Gauss.</p>
<p>Hyperbolic geometry appears throughout modern mathematics: - <strong>Moduli spaces</strong> and Teichmüller theory - <strong>Kleinian groups</strong> and complex dynamics<br>
- <strong>Low-dimensional topology</strong> (3-manifolds, knot theory) - <strong>Number theory</strong> (modular forms and the upper half-plane) - <strong>General relativity</strong> (negative curvature spacetimes)</p>
<p>Key properties that distinguish hyperbolic geometry: - Triangle angles sum to <strong>less than</strong> <span class="math inline">\(\pi\)</span> (not exactly <span class="math inline">\(\pi\)</span> as in Euclidean) - <strong>Exponential growth</strong>: The circumference of a circle grows exponentially with its radius - Given a line and a point not on it, there are <strong>infinitely many</strong> lines through the point parallel to the given line</p>
<p>This “extra room” in hyperbolic space allows for richer tiling structures than Euclidean geometry.</p>
<hr>
</section>
<section id="the-upper-half-plane-model" class="level3">
<h3 class="anchored" data-anchor-id="the-upper-half-plane-model">The Upper Half-Plane Model</h3>
<p>We’ll work in the <strong>upper half-plane model</strong> of hyperbolic geometry, denoted <span class="math inline">\(\mathbb{H}^2\)</span>:</p>
<p><span class="math display">\[\mathbb{H}^2 = \{z = x + iy \in \mathbb{C} : y &gt; 0\}\]</span></p>
<p>This is just complex numbers with positive imaginary part. The <strong>real axis</strong> <span class="math inline">\(\{y = 0\}\)</span> forms the boundary “at infinity”—it’s not actually part of the hyperbolic plane, but represents points infinitely far away.</p>
<p>The <strong>hyperbolic metric</strong> (which measures distances and angles) is: <span class="math display">\[ds^2 = \frac{dx^2 + dy^2}{y^2}\]</span></p>
<p>This makes <span class="math inline">\(\mathbb{H}^2\)</span> a complete Riemannian manifold with constant curvature <span class="math inline">\(-1\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Understanding the Metric
</div>
</div>
<div class="callout-body-container callout-body">
<p>The factor <span class="math inline">\(1/y^2\)</span> means Euclidean distances are scaled by <span class="math inline">\(1/y\)</span>. As <span class="math inline">\(y \to 0\)</span> (approaching the real axis), this scaling factor blows up—the boundary is infinitely far away in hyperbolic distance.</p>
<p>Think of it this way: An ant at height <span class="math inline">\(y = 1\)</span> that walks down to height <span class="math inline">\(y = 0.01\)</span> travels a huge hyperbolic distance, even though the Euclidean distance is small. This “compression” near the boundary creates the extra “room” that makes hyperbolic geometry so different from Euclidean geometry.</p>
<p>The metric is <strong>conformal</strong> to the Euclidean metric—it preserves angles but not lengths. A triangle that looks like it has the right angles when you draw it actually does have those angles hyperbolically!</p>
</div>
</div>
<hr>
</section>
<section id="geodesics-and-reflections" class="level3">
<h3 class="anchored" data-anchor-id="geodesics-and-reflections">Geodesics and Reflections</h3>
<section id="geodesics-in-the-upper-half-plane" class="level4">
<h4 class="anchored" data-anchor-id="geodesics-in-the-upper-half-plane">Geodesics in the Upper Half-Plane</h4>
<p><strong>Geodesics</strong> (the “straight lines” of hyperbolic geometry—curves that locally minimize distance) in <span class="math inline">\(\mathbb{H}^2\)</span> have exactly two forms:</p>
<ol type="1">
<li><strong>Vertical lines</strong>: <span class="math inline">\(\{x = c\}\)</span> for any constant <span class="math inline">\(c \in \mathbb{R}\)</span></li>
<li><strong>Semicircles</strong>: Centered on the real axis, perpendicular to it</li>
</ol>
<p>These are curves that meet the boundary at right angles. Every geodesic is determined by where it intersects the boundary (the real axis).</p>
</section>
<section id="reflection-across-vertical-lines" class="level4">
<h4 class="anchored" data-anchor-id="reflection-across-vertical-lines">Reflection Across Vertical Lines</h4>
<p>For a vertical geodesic at <span class="math inline">\(x = c\)</span>, reflection is simple—just flip the <span class="math inline">\(x\)</span>-coordinate: <span class="math display">\[\text{reflect}_{x=c}(x + iy) = (2c - x) + iy\]</span></p>
<p>This is exactly what we had in Euclidean geometry! Now we implement it with our half-space convention:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> x_pos<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're on the correct side</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> x_pos<span class="op">)</span> <span class="op">*</span> side <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> z<span class="op">;</span>  <span class="co">// Already on correct side</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reflect across the vertical line</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x_pos <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>side</code> parameter works the same way: <code>side = -1.0</code> means we want <span class="math inline">\(x &gt; x_{\text{pos}}\)</span>, and <code>side = 1.0</code> means <span class="math inline">\(x &lt; x_{\text{pos}}\)</span>.</p>
</section>
<section id="reflection-across-semicircles" class="level4">
<h4 class="anchored" data-anchor-id="reflection-across-semicircles">Reflection Across Semicircles</h4>
<p>For a semicircular geodesic with endpoints <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> on the real axis, we use <strong>circle inversion from Day 2!</strong></p>
<p>The semicircle has: - Center: <span class="math inline">\(c = (p + q)/2\)</span> - Radius: <span class="math inline">\(R = |p - q|/2\)</span></p>
<p>The inversion formula is: <span class="math display">\[z \mapsto c + R^2 \frac{z - c}{|z - c|^2}\]</span></p>
<p>This is exactly the same as yesterday’s Apollonian gasket! The code is nearly identical:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Semicircle from p to q on real axis</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check which side we're on</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> rel <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>rel<span class="op">,</span> rel<span class="op">);</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// side = 1.0 means outside circle, side = -1.0 means inside</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>dist2 <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> side <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> z<span class="op">;</span>  <span class="co">// Already on correct side</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle inversion (from Day 2!)</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> center<span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    z <span class="op">/=</span> radius<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    z <span class="op">/=</span> <span class="bu">dot</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">);</span>    <span class="co">// The inversion step</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    z <span class="op">*=</span> radius<span class="op">;</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">+=</span> center<span class="op">;</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The semicircle case uses the same circle inversion we implemented yesterday—same formula, new geometric interpretation!</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Algorithmic Connection to Day 2
</div>
</div>
<div class="callout-body-container callout-body">
<p>Notice the pattern across all three days:</p>
<p><strong>Day 2 (Apollonian gasket)</strong>: - Setup: Three circles defining regions - Algorithm: If outside a region, invert through its boundary circle - Iterate until stable</p>
<p><strong>Day 3, Euclidean</strong>: - Setup: Half-spaces (lines) defining a region<br>
- Algorithm: If outside the region, reflect across the boundary - Iterate until point stops moving</p>
<p><strong>Day 3, Hyperbolic</strong>: - Setup: Half-spaces (vertical lines and semicircles) defining a region - Algorithm: If outside the region, reflect across the boundary (using line reflection OR circle inversion) - Iterate until point stops moving</p>
<p>The pattern is universal: <strong>iteratively apply a geometric transformation to move into a desired region</strong>. The specific transformations change (circle inversion, line reflection, hyperbolic reflection), but the algorithmic structure remains the same!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="the-23-triangle" class="level3">
<h3 class="anchored" data-anchor-id="the-23-triangle">The (2,3,∞) Triangle</h3>
<p>Let’s build our first hyperbolic triangle tiling. The notation <span class="math inline">\((2,3,\infty)\)</span> means the triangle has angles <span class="math inline">\(\pi/2\)</span>, <span class="math inline">\(\pi/3\)</span>, and <span class="math inline">\(0\)</span> (an ideal vertex at infinity).</p>
<p>We’ll use a particularly nice configuration in the upper half-plane: - <strong>Left boundary</strong>: Vertical line at <span class="math inline">\(x = -1\)</span> - <strong>Right boundary</strong>: Vertical line at <span class="math inline">\(x = 1\)</span><br>
- <strong>Bottom boundary</strong>: Unit semicircle from <span class="math inline">\(-1\)</span> to <span class="math inline">\(1\)</span></p>
<p>This creates a triangle with two finite vertices (where the vertical lines meet the semicircle) and one ideal vertex at <span class="math inline">\(\infty\)</span> (straight up the <span class="math inline">\(y\)</span>-axis).</p>
<p>Here’s the complete shader:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> x_pos<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> x_pos<span class="op">)</span> <span class="op">*</span> side <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x_pos <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> rel <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>rel<span class="op">,</span> rel<span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>dist2 <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> side <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> center<span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    z <span class="op">/=</span> radius<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    z <span class="op">/=</span> <span class="bu">dot</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">);</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    z <span class="op">*=</span> radius<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">+=</span> center<span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Shift to upper half-plane (need y &gt; 0)</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the (2,3,∞) triangle</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">50</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> z_old <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across left vertical line (x = -1, want x &gt; -1)</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across right vertical line (x = 1, want x &lt; 1)</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across semicircle (from -1 to 1, want outside/above)</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're inside</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>z <span class="op">-</span> z_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by fold count parity</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parity <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span><span class="dt">float</span><span class="op">(</span>foldCount<span class="op">),</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>parity <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.9</span><span class="op">);</span>  <span class="co">// Light blue</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Darker blue</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Darken if below the real axis (outside hyperbolic space)</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>z<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>        color <span class="op">*=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis <span class="math inline">\(y = 0\)</span>)—they’re all the same hyperbolic size, but Euclidean distances compress due to the metric.</p>
<p>The alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Compare to Euclidean
</div>
</div>
<div class="callout-body-container callout-body">
<p>Look at the structure of this shader compared to the Euclidean triangle tiling:</p>
<p><strong>Euclidean:</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Hyperbolic:</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.</p>
</div>
</div>
<hr>
</section>
<section id="the-poincaré-disk-model" class="level3">
<h3 class="anchored" data-anchor-id="the-poincaré-disk-model">The Poincaré Disk Model</h3>
<p>The upper half-plane model is unbounded—it extends infinitely upward. The <strong>Poincaré disk model</strong> solves this by fitting all of hyperbolic space inside the unit disk.</p>
<p><strong>Definition</strong>: <span class="math inline">\(\mathbb{D}^2 = \{z \in \mathbb{C} : |z| &lt; 1\}\)</span></p>
<p>The interior of the unit disk represents all of hyperbolic space, and the boundary circle <span class="math inline">\(|z| = 1\)</span> represents points at infinity.</p>
<section id="the-cayley-transform" class="level4">
<h4 class="anchored" data-anchor-id="the-cayley-transform">The Cayley Transform</h4>
<p>The <strong>Cayley transform</strong> is a Möbius transformation that maps between these two models:</p>
<p><strong>From upper half-plane to disk</strong>: <span class="math display">\[w = \frac{z - i}{z + i}\]</span></p>
<p><strong>From disk to upper half-plane</strong>: <span class="math display">\[z = i\frac{1 + w}{1 - w}\]</span></p>
<p>These formulas use complex arithmetic, which we implemented on Day 2:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">,</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cdiv</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>b<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>a<span class="op">,</span> b<span class="op">),</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">diskToUHP</span><span class="op">(</span><span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// z = i(1 + w) / (1 - w)</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> num <span class="op">=</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">+</span> w<span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> den <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">-</span> w<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>num<span class="op">,</span> den<span class="op">);</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="visualization-in-the-disk" class="level4">
<h4 class="anchored" data-anchor-id="visualization-in-the-disk">Visualization in the Disk</h4>
<p>Here’s a powerful technique: we can do all our computations in the upper half-plane model, but view the result in the disk model. We just convert coordinates at the start:</p>
<ol type="1">
<li>Pixel coordinates → Disk coordinates</li>
<li>Disk → Upper half-plane (using <code>diskToUHP</code>)</li>
<li>Compute tiling in UHP</li>
<li>Display result</li>
</ol>
<p>Here’s the complete shader for viewing the tiling in the Poincaré disk:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> x_pos<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> x_pos<span class="op">)</span> <span class="op">*</span> side <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x_pos <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> rel <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>rel<span class="op">,</span> rel<span class="op">);</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>dist2 <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> side <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> center<span class="op">;</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    z <span class="op">/=</span> radius<span class="op">;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    z <span class="op">/=</span> <span class="bu">dot</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">);</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    z <span class="op">*=</span> radius<span class="op">;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">+=</span> center<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">,</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cdiv</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>b<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span><span class="bu">dot</span><span class="op">(</span>a<span class="op">,</span> b<span class="op">),</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">diskToUHP</span><span class="op">(</span><span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> num <span class="op">=</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">+</span> w<span class="op">);</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> den <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">-</span> w<span class="op">;</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>num<span class="op">,</span> den<span class="op">);</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Setup for disk viewing</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> <span class="op">(</span>fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Only render inside unit disk</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>uv<span class="op">)</span> <span class="op">&gt;=</span> <span class="fl">1.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>        fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span><span class="op">;</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert disk coordinates to upper half-plane</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> <span class="fu">diskToUHP</span><span class="op">(</span>uv<span class="op">);</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now do all computations in UHP</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">50</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> z_old <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>z <span class="op">-</span> z_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by parity</span></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parity <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span><span class="dt">float</span><span class="op">(</span>foldCount<span class="op">),</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>parity <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.9</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The tiling now appears in a bounded disk! All of hyperbolic space fits in this circle. Compare it to the upper half-plane view—it’s the same mathematical tiling, just displayed in a different coordinate system.</p>
<p>Notice how triangles near the boundary of the disk look very small—they’re approaching infinity in hyperbolic terms, and the compression becomes extreme.</p>
<hr>
</section>
</section>
</section>
<section id="summary" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="summary"><span class="header-section-number">3.4</span> Summary</h2>
<p>Today we learned:</p>
<ol type="1">
<li><p><strong>The folding algorithm</strong>: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry</p></li>
<li><p><strong>Half-space structure</strong>: Boundary + side gives a unified way to encode regions in Euclidean geometry</p></li>
<li><p><strong>Hyperbolic geometry</strong>: Negative curvature space with two types of geodesics (vertical lines and semicircles)</p></li>
<li><p><strong>Two reflection functions</strong>: <code>reflectIntoVertical</code> and <code>reflectIntoCircular</code> parallel the Euclidean <code>reflectInto</code></p></li>
<li><p><strong>Connection to Day 2</strong>: Same algorithmic pattern as Apollonian gasket—iterate a transformation to move into desired region</p></li>
<li><p><strong>Multiple models</strong>: Converting between upper half-plane and Poincaré disk using the Cayley transform</p></li>
</ol>
<p><strong>Key insight</strong>: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!</p>
<hr>
</section>
<section id="homework" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="homework"><span class="header-section-number">3.5</span> Homework</h2>
<section id="required-1-euclidean-triangle-tiling-with-edges-and-vertices" class="level3">
<h3 class="anchored" data-anchor-id="required-1-euclidean-triangle-tiling-with-edges-and-vertices">Required #1: Euclidean Triangle Tiling with Edges and Vertices</h3>
<p><strong>Goal</strong>: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><strong>Implement distance to a half-space</strong>:</li>
</ol>
<div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> <span class="fu">distToHalfSpace</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>       <span class="kw">return</span> <span class="bu">abs</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> <span class="bu">length</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">));</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li><p><strong>Draw the triangle edges</strong>: Use the distance function to draw white lines along the three edges of your triangle.</p></li>
<li><p><strong>Draw the triangle vertices</strong>: Compute the vertices of your equilateral triangle and draw small circles at these locations. Use Euclidean distance: <code>length(p - vertex) &lt; 0.05</code>.</p></li>
<li><p><strong>Create an attractive color scheme</strong>: Color tiles based on fold count, parity, or distance to edges. Make it visually appealing!</p></li>
</ol>
<p><strong>Expected output</strong>: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.</p>
<p><strong>Bonus</strong>: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.</p>
<hr>
</section>
<section id="required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" class="level3">
<h3 class="anchored" data-anchor-id="required-2-hyperbolic-triangle-tiling-with-edges-and-vertices">Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</h3>
<p><strong>Goal</strong>: Create a beautiful hyperbolic triangle tiling with visible structure.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p><strong>Implement hyperbolic distance functions</strong>:</p>
<p><strong>Distance between two points</strong>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> diff2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>z <span class="op">-</span> w<span class="op">,</span> z <span class="op">-</span> w<span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> z<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> w<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> arg <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> diff2 <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">log</span><span class="op">(</span>arg <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span>arg <span class="op">*</span> arg <span class="op">-</span> <span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Distance to vertical geodesic</strong>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">distToVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">-=</span> c<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> secTheta <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>z<span class="op">)</span> <span class="op">/</span> <span class="bu">abs</span><span class="op">(</span>z<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">acosh</span><span class="op">(</span>secTheta<span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Distance to circular geodesic</strong>: Use a Möbius transformation to map the geodesic to a vertical line, then measure distance:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">applyMobius</span><span class="op">(</span><span class="dt">vec4</span> mob<span class="op">,</span> <span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a <span class="op">=</span> mob<span class="op">.</span><span class="fu">x</span><span class="op">,</span> b <span class="op">=</span> mob<span class="op">.</span><span class="fu">y</span><span class="op">,</span> c <span class="op">=</span> mob<span class="op">.</span><span class="fu">z</span><span class="op">,</span> d <span class="op">=</span> mob<span class="op">.</span><span class="fu">w</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> num <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">*</span> z <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span>b<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> den <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>c<span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">*</span> z <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span>d<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>num<span class="op">,</span> den<span class="op">);</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">distToCircularGeodesic</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec4</span> mob <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span>p<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span>q<span class="op">);</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> w <span class="op">=</span> <span class="fu">applyMobius</span><span class="op">(</span>mob<span class="op">,</span> z<span class="op">);</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">distToVertical</span><span class="op">(</span>w<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p><strong>Draw geodesic edges</strong>: Use these distance functions to draw the three edges of your (2,3,∞) triangle:</p></li>
</ol>
<div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> d1 <span class="op">=</span> <span class="fu">distToVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> d2 <span class="op">=</span> <span class="fu">distToVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> d3 <span class="op">=</span> <span class="fu">distToCircularGeodesic</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> edgeDist <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>d2<span class="op">,</span> d3<span class="op">));</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">if</span><span class="op">(</span>edgeDist <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>       color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White edges</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li><strong>Draw vertices</strong>: The finite vertices are at approximately <span class="math inline">\((-1, 0)\)</span> and <span class="math inline">\((1, 0)\)</span> on the real axis (actually infinitesimally above). Draw small hyperbolic disks around these points:</li>
</ol>
<div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> d1 <span class="op">=</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span>z<span class="op">,</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.01</span><span class="op">));</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> d2 <span class="op">=</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span>z<span class="op">,</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.01</span><span class="op">));</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">if</span><span class="op">(</span>d1 <span class="op">&lt;</span> <span class="fl">0.1</span> <span class="op">||</span> d2 <span class="op">&lt;</span> <span class="fl">0.1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>       color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// Yellow vertices</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="4" type="1">
<li><strong>Create an attractive color scheme</strong>: Make it beautiful!</li>
</ol>
<p><strong>Expected output</strong>: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.</p>
<p><strong>Bonus</strong>: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.</p>
<hr>
</section>
<section id="required-3-model-conversions" class="level3">
<h3 class="anchored" data-anchor-id="required-3-model-conversions">Required #3: Model Conversions</h3>
<p><strong>Goal</strong>: See the same tiling in different representations of hyperbolic space.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p><strong>Poincaré Disk</strong> (already provided in lecture): Verify it works with your tiling code.</p></li>
<li><p><strong>Klein Model</strong>: Implement the transformation from Poincaré disk: <span class="math display">\[w = \frac{2z}{1 + |z|^2}\]</span></p></li>
</ol>
<div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">vec2</span> <span class="fu">diskToKlein</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>       <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> <span class="bu">dot</span><span class="op">(</span>z<span class="op">,</span> z<span class="op">);</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>       <span class="kw">return</span> <span class="fl">2.0</span> <span class="op">*</span> z <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.</p>
<ol start="3" type="1">
<li><strong>Band Model</strong> (Optional): The transformation <span class="math inline">\(w = \tanh(z)\)</span> from Poincaré disk represents hyperbolic space as an infinite horizontal strip. Implement this and see how your tiling appears.</li>
</ol>
<p><strong>Deliverable</strong>: Show your (2,3,∞) tiling in at least the Poincaré disk and Klein model. Discuss what you observe about how the tiling appears in each model.</p>
<hr>
</section>
<section id="required-4-different-triangle-groups" class="level3">
<h3 class="anchored" data-anchor-id="required-4-different-triangle-groups">Required #4: Different Triangle Groups</h3>
<p><strong>Goal</strong>: Explore other hyperbolic tilings by implementing different triangle groups.</p>
<p><strong>The Challenge</strong>: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.</p>
<p><strong>Suggested triangles to try</strong>: - <strong>(2, 3, 7)</strong>: Creates Escher-like tilings with 7-fold symmetry—the most famous hyperbolic tiling - <strong>(2, 4, 6)</strong>: Different symmetry pattern - <strong>(3, 3, 3)</strong>: Equilateral hyperbolic triangle - <strong>(2, 5, 10)</strong>: Pentagonal patterns</p>
<p><strong>Approach</strong>:</p>
<p>The notation <span class="math inline">\((p, q, r)\)</span> means angles <span class="math inline">\(\pi/p\)</span>, <span class="math inline">\(\pi/q\)</span>, and <span class="math inline">\(\pi/r\)</span> at the three vertices.</p>
<p>Start with two geodesics in nice positions (e.g., a vertical line at <span class="math inline">\(x = c\)</span> and the imaginary axis). Now find the third geodesic such that: - It meets the first at angle <span class="math inline">\(\pi/p\)</span> - It meets the second at angle <span class="math inline">\(\pi/q\)</span> - The angle at the third vertex is <span class="math inline">\(\pi/r\)</span></p>
<p>Use the <strong>hyperbolic law of cosines</strong> for side lengths. If the side opposite angle <span class="math inline">\(\gamma\)</span> has length <span class="math inline">\(s_\gamma\)</span>: <span class="math display">\[\cosh(s_\gamma) = \frac{\cos(\gamma) + \cos(\alpha)\cos(\beta)}{\sin(\alpha)\sin(\beta)}\]</span></p>
<p>For angles <span class="math inline">\(\alpha = \pi/p\)</span>, <span class="math inline">\(\beta = \pi/q\)</span>, <span class="math inline">\(\gamma = \pi/r\)</span>, this gives you the hyperbolic side length. Then translate this into Euclidean coordinates for the third geodesic.</p>
<p><strong>Reference structure</strong>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Hyperbolic side length opposite angle r:</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> num <span class="op">=</span> <span class="bu">cos</span><span class="op">(</span>PI<span class="op">/</span>r<span class="op">)</span> <span class="op">+</span> <span class="bu">cos</span><span class="op">(</span>PI<span class="op">/</span>p<span class="op">)</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span>PI<span class="op">/</span>q<span class="op">);</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> denom <span class="op">=</span> <span class="bu">sin</span><span class="op">(</span>PI<span class="op">/</span>p<span class="op">)</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>PI<span class="op">/</span>q<span class="op">);</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> sr <span class="op">=</span> <span class="bu">acosh</span><span class="op">(</span>num <span class="op">/</span> denom<span class="op">);</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Convert hyperbolic length to Euclidean position</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">// (This requires careful geometric work!)</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> eucH <span class="op">=</span> <span class="bu">sin</span><span class="op">(</span>PI<span class="op">/</span>p<span class="op">)</span> <span class="op">*</span> <span class="bu">exp</span><span class="op">(</span>sr<span class="op">);</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> want <span class="op">=</span> eucH <span class="op">/</span> <span class="bu">tan</span><span class="op">(</span>PI<span class="op">/</span>q<span class="op">);</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co">// ... compute geodesic endpoints</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Deliverable</strong>: Working tilings for at least two different <span class="math inline">\((p,q,r)\)</span> groups. Include screenshots showing the different symmetry structures. Document any interesting observations about how the tilings differ.</p>
<hr>
</section>
<section id="optional-exercise-unified-abstractions" class="level3">
<h3 class="anchored" data-anchor-id="optional-exercise-unified-abstractions">Optional Exercise: Unified Abstractions</h3>
<p><strong>Part 1: Unified HalfSpace Struct</strong></p>
<p>Create a struct that handles BOTH Euclidean and hyperbolic half-spaces:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> type<span class="op">;</span>  <span class="co">// 0=Euclidean line, 1=vertical hyperbolic, 2=circular hyperbolic</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Parameters for all cases</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">,</span> side<span class="op">;</span>  <span class="co">// Euclidean line</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x_pos<span class="op">;</span>          <span class="co">// Vertical hyperbolic</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> p<span class="op">,</span> q<span class="op">;</span>           <span class="co">// Circular hyperbolic</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">type</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Euclidean reflection (your existing code)</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">type</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Vertical hyperbolic reflection</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Circular hyperbolic reflection</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Part 2: Triangle Struct</strong></p>
<p>Once you have a unified <code>HalfSpace</code>, create:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Triangle <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    HalfSpace a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> Triangle T<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> T<span class="op">.</span><span class="fu">a</span><span class="op">);</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> T<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> T<span class="op">.</span><span class="fu">c</span><span class="op">);</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now your folding loop is just <code>p = reflectInto(p, T)</code> for ANY geometry—Euclidean or hyperbolic!</p>
<p><strong>Goal</strong>: This exercise teaches abstraction and code organization. You’re building a single interface that works across multiple geometries, which is exactly how mathematical software should be structured.</p>
<hr>
</section>
<section id="optional-decorated-tiles" class="level3">
<h3 class="anchored" data-anchor-id="optional-decorated-tiles">Optional: Decorated Tiles</h3>
<p>Add patterns within the fundamental domain (Escher-style):</p>
<p><strong>Ideas</strong>: - Draw curves using distance from edges - Create radial patterns from vertices - Use hyperbolic distance to create concentric patterns - The pattern repeats automatically via reflections!</p>
<p><strong>Challenge</strong>: Create a tessellation that looks like Escher’s <em>Circle Limit</em> prints—fish or angels that tile the hyperbolic plane!</p>
<hr>
</section>
<section id="optional-pentagon-tilings" class="level3">
<h3 class="anchored" data-anchor-id="optional-pentagon-tilings">Optional: Pentagon Tilings</h3>
<p>Right-angled pentagons can tile hyperbolic space (impossible in Euclidean geometry!).</p>
<p><strong>Setup</strong>: Create five geodesics that all meet their neighbors at right angles and enclose a bounded region.</p>
<p><strong>Challenge</strong>: Computing geodesic positions given side lengths is complex. Start with a vertical line and a semicircle at right angles, then add three more geodesics using the constraint that adjacent geodesics meet orthogonally.</p>
<p><strong>Reward</strong>: Pentagons give very different aesthetic patterns than triangles!</p>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./day2.html" class="pagination-link" aria-label="Day 2: Complex Dynamics and Iterated Inversions">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./day4.html" class="pagination-link" aria-label="Day 4: Introduction to 3D Rendering">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb24" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>Today we explore geometric tilings through reflection operations. We'll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>The key insight: **the algorithm stays the same across geometries—only the reflection operations change.** This mirrors what we saw yesterday with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region.</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll understand:</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to construct reflections using linear algebra</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The folding algorithm for creating tilings</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The structure of hyperbolic geometry in the upper half-plane model</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to implement hyperbolic triangle tilings using the same algorithmic pattern</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to convert between different models of hyperbolic space</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1: Reflection and Tilings in Euclidean Geometry</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a><span class="fu">### Starting Simple: The Folding Algorithm</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>Before we dive into general theory, let's build intuition with the simplest possible example: creating a repeating strip pattern.</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Tiling a Strip</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>Imagine we want to tile the plane horizontally. We'll define a fundamental domain—the strip $0 &lt; x &lt; 1$—and reflect any point outside this strip back inside.</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>The algorithm is remarkably simple:</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $x &lt; 0$, reflect across $x = 0$</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $x &gt; 1$, reflect across $x = 1$  </span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Repeat until the point stops moving</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>For a vertical line at $x = c$, reflection just flips the $x$-coordinate: $(x, y) \mapsto (2c - x, y)$.</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>Here's a complete shader:</span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a><span class="in">    // Standard coordinate setup</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the strip [0, 1]</span></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &lt; 0.0) p.x = -p.x;</span></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &gt; 1.0) p.x = 2.0 - p.x;</span></span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw something in the fundamental domain</span></span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background</span></span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true" tabindex="-1"></a><span class="in">    // A circle in the strip</span></span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p - vec2(0.5, 0.0));</span></span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.3) {</span></span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 0.8, 0.3);  // Yellow circle</span></span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw the boundary lines</span></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true" tabindex="-1"></a><span class="in">    if(abs(p.x) &lt; 0.02 || abs(p.x - 1.0) &lt; 0.02) {</span></span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 1.0, 1.0);</span></span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true" tabindex="-1"></a>You should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.</span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-72"><a href="#cb24-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-73"><a href="#cb24-73" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Square Tiling</span></span>
<span id="cb24-74"><a href="#cb24-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-75"><a href="#cb24-75" aria-hidden="true" tabindex="-1"></a>Let's extend to two dimensions. Now we have four boundaries: $x = 0$, $x = 1$, $y = 0$, and $y = 1$. Same algorithm, just more boundaries to check:</span>
<span id="cb24-76"><a href="#cb24-76" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-77"><a href="#cb24-77" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb24-78"><a href="#cb24-78" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb24-79"><a href="#cb24-79" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb24-80"><a href="#cb24-80" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb24-81"><a href="#cb24-81" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb24-82"><a href="#cb24-82" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb24-83"><a href="#cb24-83" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb24-84"><a href="#cb24-84" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-85"><a href="#cb24-85" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the square [0,1] × [0,1]</span></span>
<span id="cb24-86"><a href="#cb24-86" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb24-87"><a href="#cb24-87" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb24-88"><a href="#cb24-88" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 p_old = p;</span></span>
<span id="cb24-89"><a href="#cb24-89" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-90"><a href="#cb24-90" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &lt; 0.0) p.x = -p.x;</span></span>
<span id="cb24-91"><a href="#cb24-91" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &gt; 1.0) p.x = 2.0 - p.x;</span></span>
<span id="cb24-92"><a href="#cb24-92" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.y &lt; 0.0) p.y = -p.y;</span></span>
<span id="cb24-93"><a href="#cb24-93" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.y &gt; 1.0) p.y = 2.0 - p.y;</span></span>
<span id="cb24-94"><a href="#cb24-94" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-95"><a href="#cb24-95" aria-hidden="true" tabindex="-1"></a><span class="in">        // If point didn't move, we're done</span></span>
<span id="cb24-96"><a href="#cb24-96" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - p_old) &lt; 0.0001) break;</span></span>
<span id="cb24-97"><a href="#cb24-97" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb24-98"><a href="#cb24-98" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-99"><a href="#cb24-99" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-100"><a href="#cb24-100" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb24-101"><a href="#cb24-101" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 8.0;</span></span>
<span id="cb24-102"><a href="#cb24-102" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));</span></span>
<span id="cb24-103"><a href="#cb24-103" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-104"><a href="#cb24-104" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw something in the fundamental domain</span></span>
<span id="cb24-105"><a href="#cb24-105" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p - vec2(0.5, 0.5));</span></span>
<span id="cb24-106"><a href="#cb24-106" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.3) {</span></span>
<span id="cb24-107"><a href="#cb24-107" aria-hidden="true" tabindex="-1"></a><span class="in">        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));</span></span>
<span id="cb24-108"><a href="#cb24-108" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-109"><a href="#cb24-109" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-110"><a href="#cb24-110" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw boundaries</span></span>
<span id="cb24-111"><a href="#cb24-111" aria-hidden="true" tabindex="-1"></a><span class="in">    float border = min(min(p.x, 1.0 - p.x), min(p.y, 1.0 - p.y));</span></span>
<span id="cb24-112"><a href="#cb24-112" aria-hidden="true" tabindex="-1"></a><span class="in">    if(border &lt; 0.02) {</span></span>
<span id="cb24-113"><a href="#cb24-113" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0);</span></span>
<span id="cb24-114"><a href="#cb24-114" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-115"><a href="#cb24-115" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-116"><a href="#cb24-116" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb24-117"><a href="#cb24-117" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-118"><a href="#cb24-118" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-119"><a href="#cb24-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-120"><a href="#cb24-120" aria-hidden="true" tabindex="-1"></a>Perfect! A full 2D tiling. The color gradient shows how many reflections were needed.</span>
<span id="cb24-121"><a href="#cb24-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-122"><a href="#cb24-122" aria-hidden="true" tabindex="-1"></a>Notice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain.</span>
<span id="cb24-123"><a href="#cb24-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-124"><a href="#cb24-124" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-125"><a href="#cb24-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-126"><a href="#cb24-126" aria-hidden="true" tabindex="-1"></a><span class="fu">### Abstracting: Half-Spaces</span></span>
<span id="cb24-127"><a href="#cb24-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-128"><a href="#cb24-128" aria-hidden="true" tabindex="-1"></a>Looking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let's abstract this pattern so we can handle arbitrary shapes.</span>
<span id="cb24-129"><a href="#cb24-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-130"><a href="#cb24-130" aria-hidden="true" tabindex="-1"></a><span class="fu">#### What is a Half-Space?</span></span>
<span id="cb24-131"><a href="#cb24-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-132"><a href="#cb24-132" aria-hidden="true" tabindex="-1"></a>A **half-space** is one side of a line. Any line $ax + by = c$ divides the plane into two regions:</span>
<span id="cb24-133"><a href="#cb24-133" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points where $ax + by &lt; c$</span>
<span id="cb24-134"><a href="#cb24-134" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points where $ax + by &gt; c$</span>
<span id="cb24-135"><a href="#cb24-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-136"><a href="#cb24-136" aria-hidden="true" tabindex="-1"></a>We'll encode a half-space by storing the line parameters and which side we want:</span>
<span id="cb24-137"><a href="#cb24-137" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-138"><a href="#cb24-138" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb24-139"><a href="#cb24-139" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;  // Line parameters: ax + by = c</span></span>
<span id="cb24-140"><a href="#cb24-140" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;     // +1 or -1 for which side</span></span>
<span id="cb24-141"><a href="#cb24-141" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb24-142"><a href="#cb24-142" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-143"><a href="#cb24-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-144"><a href="#cb24-144" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb24-145"><a href="#cb24-145" aria-hidden="true" tabindex="-1"></a><span class="fu">## A Note on Redundancy</span></span>
<span id="cb24-146"><a href="#cb24-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-147"><a href="#cb24-147" aria-hidden="true" tabindex="-1"></a>This representation is actually redundant: we could fix the convention to always use $ax + by &lt; c$ (side implicit) and just flip signs of $a$, $b$, $c$ to get the other side. For example, $x &lt; 1$ is the same as $-x &gt; -1$.</span>
<span id="cb24-148"><a href="#cb24-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-149"><a href="#cb24-149" aria-hidden="true" tabindex="-1"></a>But having an explicit <span class="in">`side`</span> parameter is convenient for clarity, and will be essential when we move to hyperbolic geometry where the sign-flipping doesn't work as cleanly. The small redundancy is worth the flexibility!</span>
<span id="cb24-150"><a href="#cb24-150" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb24-151"><a href="#cb24-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-152"><a href="#cb24-152" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Reflection Formula</span></span>
<span id="cb24-153"><a href="#cb24-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-154"><a href="#cb24-154" aria-hidden="true" tabindex="-1"></a>To reflect a point $\mathbf{p} = (x, y)$ across the line $ax + by = c$, we use linear algebra. The normal vector to the line is $\mathbf{n} = (a, b)$. After normalizing to $\hat{\mathbf{n}} = \mathbf{n}/|\mathbf{n}|$, the reflection formula is:</span>
<span id="cb24-155"><a href="#cb24-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-156"><a href="#cb24-156" aria-hidden="true" tabindex="-1"></a>$$\mathbf{p}' = \mathbf{p} - 2d\hat{\mathbf{n}}$$</span>
<span id="cb24-157"><a href="#cb24-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-158"><a href="#cb24-158" aria-hidden="true" tabindex="-1"></a>where $d$ is the signed distance from $\mathbf{p}$ to the line:</span>
<span id="cb24-159"><a href="#cb24-159" aria-hidden="true" tabindex="-1"></a>$$d = \frac{ax + by - c}{\sqrt{a^2 + b^2}}$$</span>
<span id="cb24-160"><a href="#cb24-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-161"><a href="#cb24-161" aria-hidden="true" tabindex="-1"></a>This is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.</span>
<span id="cb24-162"><a href="#cb24-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-163"><a href="#cb24-163" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Implementation</span></span>
<span id="cb24-164"><a href="#cb24-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-165"><a href="#cb24-165" aria-hidden="true" tabindex="-1"></a>Let's write a function that reflects into a half-space—checking if we're on the right side, and only reflecting if necessary:</span>
<span id="cb24-166"><a href="#cb24-166" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-167"><a href="#cb24-167" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, HalfSpace hs) {</span></span>
<span id="cb24-168"><a href="#cb24-168" aria-hidden="true" tabindex="-1"></a><span class="in">    // Compute which side of the line we're on</span></span>
<span id="cb24-169"><a href="#cb24-169" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb24-170"><a href="#cb24-170" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-171"><a href="#cb24-171" aria-hidden="true" tabindex="-1"></a><span class="in">    // Check if we're already on the correct side</span></span>
<span id="cb24-172"><a href="#cb24-172" aria-hidden="true" tabindex="-1"></a><span class="in">    if((value - hs.c) * hs.side &lt; 0.0) {</span></span>
<span id="cb24-173"><a href="#cb24-173" aria-hidden="true" tabindex="-1"></a><span class="in">        return p;  // Already inside, nothing to do</span></span>
<span id="cb24-174"><a href="#cb24-174" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-175"><a href="#cb24-175" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-176"><a href="#cb24-176" aria-hidden="true" tabindex="-1"></a><span class="in">    // We're on the wrong side - reflect across the boundary line</span></span>
<span id="cb24-177"><a href="#cb24-177" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 normal = vec2(hs.a, hs.b);</span></span>
<span id="cb24-178"><a href="#cb24-178" aria-hidden="true" tabindex="-1"></a><span class="in">    float norm = length(normal);</span></span>
<span id="cb24-179"><a href="#cb24-179" aria-hidden="true" tabindex="-1"></a><span class="in">    normal = normal / norm;</span></span>
<span id="cb24-180"><a href="#cb24-180" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-181"><a href="#cb24-181" aria-hidden="true" tabindex="-1"></a><span class="in">    float signedDist = (value - hs.c) / norm;</span></span>
<span id="cb24-182"><a href="#cb24-182" aria-hidden="true" tabindex="-1"></a><span class="in">    return p - 2.0 * signedDist * normal;</span></span>
<span id="cb24-183"><a href="#cb24-183" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-184"><a href="#cb24-184" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-185"><a href="#cb24-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-186"><a href="#cb24-186" aria-hidden="true" tabindex="-1"></a>This function encapsulates the entire pattern: check if we're on the correct side, and only reflect if we're not.</span>
<span id="cb24-187"><a href="#cb24-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-188"><a href="#cb24-188" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-189"><a href="#cb24-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-190"><a href="#cb24-190" aria-hidden="true" tabindex="-1"></a><span class="fu">### Square Tiling with Half-Spaces</span></span>
<span id="cb24-191"><a href="#cb24-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-192"><a href="#cb24-192" aria-hidden="true" tabindex="-1"></a>Let's rewrite our square tiling using this abstraction. For the square $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$, we need four half-spaces:</span>
<span id="cb24-193"><a href="#cb24-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-194"><a href="#cb24-194" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Left edge** ($x = 0$): We want $x &gt; 0$  </span>
<span id="cb24-195"><a href="#cb24-195" aria-hidden="true" tabindex="-1"></a>  Line: $x = 0$ means $1 \cdot x + 0 \cdot y = 0$  </span>
<span id="cb24-196"><a href="#cb24-196" aria-hidden="true" tabindex="-1"></a>  For $x &gt; 0$: $(x - 0) \cdot (-1) &lt; 0$ ✓  </span>
<span id="cb24-197"><a href="#cb24-197" aria-hidden="true" tabindex="-1"></a>  So: <span class="in">`HalfSpace(1.0, 0.0, 0.0, -1.0)`</span></span>
<span id="cb24-198"><a href="#cb24-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-199"><a href="#cb24-199" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Right edge** ($x = 1$): We want $x &lt; 1$  </span>
<span id="cb24-200"><a href="#cb24-200" aria-hidden="true" tabindex="-1"></a>  So: <span class="in">`HalfSpace(1.0, 0.0, 1.0, 1.0)`</span></span>
<span id="cb24-201"><a href="#cb24-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-202"><a href="#cb24-202" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Bottom and top**: Similarly for $y$</span>
<span id="cb24-203"><a href="#cb24-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-204"><a href="#cb24-204" aria-hidden="true" tabindex="-1"></a>Complete shader:</span>
<span id="cb24-205"><a href="#cb24-205" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-206"><a href="#cb24-206" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb24-207"><a href="#cb24-207" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;</span></span>
<span id="cb24-208"><a href="#cb24-208" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;</span></span>
<span id="cb24-209"><a href="#cb24-209" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb24-210"><a href="#cb24-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-211"><a href="#cb24-211" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, HalfSpace hs) {</span></span>
<span id="cb24-212"><a href="#cb24-212" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb24-213"><a href="#cb24-213" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-214"><a href="#cb24-214" aria-hidden="true" tabindex="-1"></a><span class="in">    if((value - hs.c) * hs.side &lt; 0.0) {</span></span>
<span id="cb24-215"><a href="#cb24-215" aria-hidden="true" tabindex="-1"></a><span class="in">        return p;</span></span>
<span id="cb24-216"><a href="#cb24-216" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-217"><a href="#cb24-217" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-218"><a href="#cb24-218" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 normal = vec2(hs.a, hs.b);</span></span>
<span id="cb24-219"><a href="#cb24-219" aria-hidden="true" tabindex="-1"></a><span class="in">    float norm = length(normal);</span></span>
<span id="cb24-220"><a href="#cb24-220" aria-hidden="true" tabindex="-1"></a><span class="in">    normal = normal / norm;</span></span>
<span id="cb24-221"><a href="#cb24-221" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-222"><a href="#cb24-222" aria-hidden="true" tabindex="-1"></a><span class="in">    float signedDist = (value - hs.c) / norm;</span></span>
<span id="cb24-223"><a href="#cb24-223" aria-hidden="true" tabindex="-1"></a><span class="in">    return p - 2.0 * signedDist * normal;</span></span>
<span id="cb24-224"><a href="#cb24-224" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-225"><a href="#cb24-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-226"><a href="#cb24-226" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb24-227"><a href="#cb24-227" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb24-228"><a href="#cb24-228" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb24-229"><a href="#cb24-229" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb24-230"><a href="#cb24-230" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb24-231"><a href="#cb24-231" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb24-232"><a href="#cb24-232" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb24-233"><a href="#cb24-233" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-234"><a href="#cb24-234" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define the four half-spaces for our square [0,1]×[0,1]</span></span>
<span id="cb24-235"><a href="#cb24-235" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0</span></span>
<span id="cb24-236"><a href="#cb24-236" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1</span></span>
<span id="cb24-237"><a href="#cb24-237" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0</span></span>
<span id="cb24-238"><a href="#cb24-238" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1</span></span>
<span id="cb24-239"><a href="#cb24-239" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-240"><a href="#cb24-240" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the square</span></span>
<span id="cb24-241"><a href="#cb24-241" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb24-242"><a href="#cb24-242" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb24-243"><a href="#cb24-243" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 p_old = p;</span></span>
<span id="cb24-244"><a href="#cb24-244" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-245"><a href="#cb24-245" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, left);</span></span>
<span id="cb24-246"><a href="#cb24-246" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, right);</span></span>
<span id="cb24-247"><a href="#cb24-247" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, bottom);</span></span>
<span id="cb24-248"><a href="#cb24-248" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, top);</span></span>
<span id="cb24-249"><a href="#cb24-249" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-250"><a href="#cb24-250" aria-hidden="true" tabindex="-1"></a><span class="in">        // If point didn't move, we're inside</span></span>
<span id="cb24-251"><a href="#cb24-251" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - p_old) &lt; 0.0001) break;</span></span>
<span id="cb24-252"><a href="#cb24-252" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb24-253"><a href="#cb24-253" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-254"><a href="#cb24-254" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-255"><a href="#cb24-255" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb24-256"><a href="#cb24-256" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 8.0;</span></span>
<span id="cb24-257"><a href="#cb24-257" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));</span></span>
<span id="cb24-258"><a href="#cb24-258" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-259"><a href="#cb24-259" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw something in the fundamental domain</span></span>
<span id="cb24-260"><a href="#cb24-260" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p - vec2(0.5, 0.5));</span></span>
<span id="cb24-261"><a href="#cb24-261" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.3) {</span></span>
<span id="cb24-262"><a href="#cb24-262" aria-hidden="true" tabindex="-1"></a><span class="in">        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));</span></span>
<span id="cb24-263"><a href="#cb24-263" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-264"><a href="#cb24-264" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-265"><a href="#cb24-265" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw boundaries</span></span>
<span id="cb24-266"><a href="#cb24-266" aria-hidden="true" tabindex="-1"></a><span class="in">    float border = min(min(p.x, 1.0 - p.x), min(p.y, 1.0 - p.y));</span></span>
<span id="cb24-267"><a href="#cb24-267" aria-hidden="true" tabindex="-1"></a><span class="in">    if(border &lt; 0.02) {</span></span>
<span id="cb24-268"><a href="#cb24-268" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0);</span></span>
<span id="cb24-269"><a href="#cb24-269" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-270"><a href="#cb24-270" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-271"><a href="#cb24-271" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb24-272"><a href="#cb24-272" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-273"><a href="#cb24-273" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-274"><a href="#cb24-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-275"><a href="#cb24-275" aria-hidden="true" tabindex="-1"></a>This looks identical to before, but now our code is flexible. The beauty: **changing from a square to a triangle only requires changing the half-space definitions!**</span>
<span id="cb24-276"><a href="#cb24-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-277"><a href="#cb24-277" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-278"><a href="#cb24-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-279"><a href="#cb24-279" aria-hidden="true" tabindex="-1"></a><span class="fu">### Triangle Tiling</span></span>
<span id="cb24-280"><a href="#cb24-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-281"><a href="#cb24-281" aria-hidden="true" tabindex="-1"></a>Now we're ready for triangles. We'll use an equilateral triangle with vertices:</span>
<span id="cb24-282"><a href="#cb24-282" aria-hidden="true" tabindex="-1"></a>$$v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)$$</span>
<span id="cb24-283"><a href="#cb24-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-284"><a href="#cb24-284" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Computing Half-Spaces from Edges</span></span>
<span id="cb24-285"><a href="#cb24-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-286"><a href="#cb24-286" aria-hidden="true" tabindex="-1"></a>For each edge, we compute the line parameters. The math (shown in the callout below) gives us:</span>
<span id="cb24-287"><a href="#cb24-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-288"><a href="#cb24-288" aria-hidden="true" tabindex="-1"></a>**Edge from $v_0$ to $v_1$:** <span class="in">`HalfSpace(1.5, -0.866, -0.866, -1.0)`</span>  </span>
<span id="cb24-289"><a href="#cb24-289" aria-hidden="true" tabindex="-1"></a>**Edge from $v_1$ to $v_2$:** <span class="in">`HalfSpace(0.0, 1.732, -0.866, -1.0)`</span>  </span>
<span id="cb24-290"><a href="#cb24-290" aria-hidden="true" tabindex="-1"></a>**Edge from $v_2$ to $v_0$:** <span class="in">`HalfSpace(-1.5, -0.866, -0.866, -1.0)`</span></span>
<span id="cb24-291"><a href="#cb24-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-292"><a href="#cb24-292" aria-hidden="true" tabindex="-1"></a>::: {.callout-note collapse="true"}</span>
<span id="cb24-293"><a href="#cb24-293" aria-hidden="true" tabindex="-1"></a><span class="fu">## Derivation of Half-Space Parameters</span></span>
<span id="cb24-294"><a href="#cb24-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-295"><a href="#cb24-295" aria-hidden="true" tabindex="-1"></a>For edge from $v_0 = (0, 1)$ to $v_1 = (-0.866, -0.5)$:</span>
<span id="cb24-296"><a href="#cb24-296" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Edge direction: $\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)$</span>
<span id="cb24-297"><a href="#cb24-297" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Perpendicular (90° CCW): $\mathbf{n} = (-d_y, d_x) = (1.5, -0.866)$</span>
<span id="cb24-298"><a href="#cb24-298" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Line: $1.5x - 0.866y = c$ where $c = \mathbf{n} \cdot v_0 = -0.866$</span>
<span id="cb24-299"><a href="#cb24-299" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>For origin (inside): $1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0$</span>
<span id="cb24-300"><a href="#cb24-300" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Want inside when $(ax + by - c) &lt; 0$, so <span class="in">`side = -1.0`</span></span>
<span id="cb24-301"><a href="#cb24-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-302"><a href="#cb24-302" aria-hidden="true" tabindex="-1"></a>Similar calculations for the other two edges.</span>
<span id="cb24-303"><a href="#cb24-303" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb24-304"><a href="#cb24-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-305"><a href="#cb24-305" aria-hidden="true" tabindex="-1"></a>Here's the complete triangle tiling shader:</span>
<span id="cb24-306"><a href="#cb24-306" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-307"><a href="#cb24-307" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb24-308"><a href="#cb24-308" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;</span></span>
<span id="cb24-309"><a href="#cb24-309" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;</span></span>
<span id="cb24-310"><a href="#cb24-310" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb24-311"><a href="#cb24-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-312"><a href="#cb24-312" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, HalfSpace hs) {</span></span>
<span id="cb24-313"><a href="#cb24-313" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb24-314"><a href="#cb24-314" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-315"><a href="#cb24-315" aria-hidden="true" tabindex="-1"></a><span class="in">    if((value - hs.c) * hs.side &lt; 0.0) {</span></span>
<span id="cb24-316"><a href="#cb24-316" aria-hidden="true" tabindex="-1"></a><span class="in">        return p;</span></span>
<span id="cb24-317"><a href="#cb24-317" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-318"><a href="#cb24-318" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-319"><a href="#cb24-319" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 normal = vec2(hs.a, hs.b);</span></span>
<span id="cb24-320"><a href="#cb24-320" aria-hidden="true" tabindex="-1"></a><span class="in">    float norm = length(normal);</span></span>
<span id="cb24-321"><a href="#cb24-321" aria-hidden="true" tabindex="-1"></a><span class="in">    normal = normal / norm;</span></span>
<span id="cb24-322"><a href="#cb24-322" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-323"><a href="#cb24-323" aria-hidden="true" tabindex="-1"></a><span class="in">    float signedDist = (value - hs.c) / norm;</span></span>
<span id="cb24-324"><a href="#cb24-324" aria-hidden="true" tabindex="-1"></a><span class="in">    return p - 2.0 * signedDist * normal;</span></span>
<span id="cb24-325"><a href="#cb24-325" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-326"><a href="#cb24-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-327"><a href="#cb24-327" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb24-328"><a href="#cb24-328" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb24-329"><a href="#cb24-329" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb24-330"><a href="#cb24-330" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb24-331"><a href="#cb24-331" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb24-332"><a href="#cb24-332" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb24-333"><a href="#cb24-333" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb24-334"><a href="#cb24-334" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-335"><a href="#cb24-335" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define three half-spaces for the triangle edges</span></span>
<span id="cb24-336"><a href="#cb24-336" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);</span></span>
<span id="cb24-337"><a href="#cb24-337" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);</span></span>
<span id="cb24-338"><a href="#cb24-338" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);</span></span>
<span id="cb24-339"><a href="#cb24-339" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-340"><a href="#cb24-340" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the triangle</span></span>
<span id="cb24-341"><a href="#cb24-341" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb24-342"><a href="#cb24-342" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb24-343"><a href="#cb24-343" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 p_old = p;</span></span>
<span id="cb24-344"><a href="#cb24-344" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-345"><a href="#cb24-345" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, hs1);</span></span>
<span id="cb24-346"><a href="#cb24-346" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, hs2);</span></span>
<span id="cb24-347"><a href="#cb24-347" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, hs3);</span></span>
<span id="cb24-348"><a href="#cb24-348" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-349"><a href="#cb24-349" aria-hidden="true" tabindex="-1"></a><span class="in">        // If point didn't move, we're inside</span></span>
<span id="cb24-350"><a href="#cb24-350" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - p_old) &lt; 0.0001) break;</span></span>
<span id="cb24-351"><a href="#cb24-351" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb24-352"><a href="#cb24-352" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-353"><a href="#cb24-353" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-354"><a href="#cb24-354" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb24-355"><a href="#cb24-355" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 10.0;</span></span>
<span id="cb24-356"><a href="#cb24-356" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));</span></span>
<span id="cb24-357"><a href="#cb24-357" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-358"><a href="#cb24-358" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb24-359"><a href="#cb24-359" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-360"><a href="#cb24-360" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-361"><a href="#cb24-361" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-362"><a href="#cb24-362" aria-hidden="true" tabindex="-1"></a>Beautiful! An infinite tiling of equilateral triangles.</span>
<span id="cb24-363"><a href="#cb24-363" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-364"><a href="#cb24-364" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb24-365"><a href="#cb24-365" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Power of Abstraction</span></span>
<span id="cb24-366"><a href="#cb24-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-367"><a href="#cb24-367" aria-hidden="true" tabindex="-1"></a>Compare this to our square shader. The algorithm is *identical*:</span>
<span id="cb24-368"><a href="#cb24-368" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Define boundaries as half-spaces</span>
<span id="cb24-369"><a href="#cb24-369" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Repeatedly reflect into each half-space  </span>
<span id="cb24-370"><a href="#cb24-370" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Check for convergence</span>
<span id="cb24-371"><a href="#cb24-371" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Color based on iteration count</span>
<span id="cb24-372"><a href="#cb24-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-373"><a href="#cb24-373" aria-hidden="true" tabindex="-1"></a>We changed from squares to triangles by just changing the half-space definitions. This is mathematical abstraction at work!</span>
<span id="cb24-374"><a href="#cb24-374" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb24-375"><a href="#cb24-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-376"><a href="#cb24-376" aria-hidden="true" tabindex="-1"></a>This completes our Euclidean foundation. We've seen:</span>
<span id="cb24-377"><a href="#cb24-377" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The folding algorithm in concrete examples</span>
<span id="cb24-378"><a href="#cb24-378" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The half-space abstraction that makes it general</span>
<span id="cb24-379"><a href="#cb24-379" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Convergence checking by detecting when points stop moving</span>
<span id="cb24-380"><a href="#cb24-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-381"><a href="#cb24-381" aria-hidden="true" tabindex="-1"></a>Next, we'll take this exact algorithmic structure into hyperbolic geometry!</span>
<span id="cb24-382"><a href="#cb24-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-383"><a href="#cb24-383" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-384"><a href="#cb24-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-385"><a href="#cb24-385" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2: Hyperbolic Geometry</span></span>
<span id="cb24-386"><a href="#cb24-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-387"><a href="#cb24-387" aria-hidden="true" tabindex="-1"></a><span class="fu">### Introduction to Hyperbolic Geometry</span></span>
<span id="cb24-388"><a href="#cb24-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-389"><a href="#cb24-389" aria-hidden="true" tabindex="-1"></a>Hyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant **negative curvature**. It was discovered independently in the early 1800s by János Bolyai, Nikolai Lobachevsky, and Carl Friedrich Gauss.</span>
<span id="cb24-390"><a href="#cb24-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-391"><a href="#cb24-391" aria-hidden="true" tabindex="-1"></a>Hyperbolic geometry appears throughout modern mathematics:</span>
<span id="cb24-392"><a href="#cb24-392" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Moduli spaces** and Teichmüller theory</span>
<span id="cb24-393"><a href="#cb24-393" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Kleinian groups** and complex dynamics  </span>
<span id="cb24-394"><a href="#cb24-394" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Low-dimensional topology** (3-manifolds, knot theory)</span>
<span id="cb24-395"><a href="#cb24-395" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Number theory** (modular forms and the upper half-plane)</span>
<span id="cb24-396"><a href="#cb24-396" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**General relativity** (negative curvature spacetimes)</span>
<span id="cb24-397"><a href="#cb24-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-398"><a href="#cb24-398" aria-hidden="true" tabindex="-1"></a>Key properties that distinguish hyperbolic geometry:</span>
<span id="cb24-399"><a href="#cb24-399" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Triangle angles sum to **less than** $\pi$ (not exactly $\pi$ as in Euclidean)</span>
<span id="cb24-400"><a href="#cb24-400" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Exponential growth**: The circumference of a circle grows exponentially with its radius</span>
<span id="cb24-401"><a href="#cb24-401" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Given a line and a point not on it, there are **infinitely many** lines through the point parallel to the given line</span>
<span id="cb24-402"><a href="#cb24-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-403"><a href="#cb24-403" aria-hidden="true" tabindex="-1"></a>This "extra room" in hyperbolic space allows for richer tiling structures than Euclidean geometry.</span>
<span id="cb24-404"><a href="#cb24-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-405"><a href="#cb24-405" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-406"><a href="#cb24-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-407"><a href="#cb24-407" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Upper Half-Plane Model</span></span>
<span id="cb24-408"><a href="#cb24-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-409"><a href="#cb24-409" aria-hidden="true" tabindex="-1"></a>We'll work in the **upper half-plane model** of hyperbolic geometry, denoted $\mathbb{H}^2$:</span>
<span id="cb24-410"><a href="#cb24-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-411"><a href="#cb24-411" aria-hidden="true" tabindex="-1"></a>$$\mathbb{H}^2 = <span class="sc">\{</span>z = x + iy \in \mathbb{C} : y &gt; 0<span class="sc">\}</span>$$</span>
<span id="cb24-412"><a href="#cb24-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-413"><a href="#cb24-413" aria-hidden="true" tabindex="-1"></a>This is just complex numbers with positive imaginary part. The **real axis** $<span class="sc">\{</span>y = 0<span class="sc">\}</span>$ forms the boundary "at infinity"—it's not actually part of the hyperbolic plane, but represents points infinitely far away.</span>
<span id="cb24-414"><a href="#cb24-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-415"><a href="#cb24-415" aria-hidden="true" tabindex="-1"></a>The **hyperbolic metric** (which measures distances and angles) is:</span>
<span id="cb24-416"><a href="#cb24-416" aria-hidden="true" tabindex="-1"></a>$$ds^2 = \frac{dx^2 + dy^2}{y^2}$$</span>
<span id="cb24-417"><a href="#cb24-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-418"><a href="#cb24-418" aria-hidden="true" tabindex="-1"></a>This makes $\mathbb{H}^2$ a complete Riemannian manifold with constant curvature $-1$.</span>
<span id="cb24-419"><a href="#cb24-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-420"><a href="#cb24-420" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb24-421"><a href="#cb24-421" aria-hidden="true" tabindex="-1"></a><span class="fu">## Understanding the Metric</span></span>
<span id="cb24-422"><a href="#cb24-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-423"><a href="#cb24-423" aria-hidden="true" tabindex="-1"></a>The factor $1/y^2$ means Euclidean distances are scaled by $1/y$. As $y \to 0$ (approaching the real axis), this scaling factor blows up—the boundary is infinitely far away in hyperbolic distance.</span>
<span id="cb24-424"><a href="#cb24-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-425"><a href="#cb24-425" aria-hidden="true" tabindex="-1"></a>Think of it this way: An ant at height $y = 1$ that walks down to height $y = 0.01$ travels a huge hyperbolic distance, even though the Euclidean distance is small. This "compression" near the boundary creates the extra "room" that makes hyperbolic geometry so different from Euclidean geometry.</span>
<span id="cb24-426"><a href="#cb24-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-427"><a href="#cb24-427" aria-hidden="true" tabindex="-1"></a>The metric is **conformal** to the Euclidean metric—it preserves angles but not lengths. A triangle that looks like it has the right angles when you draw it actually does have those angles hyperbolically!</span>
<span id="cb24-428"><a href="#cb24-428" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb24-429"><a href="#cb24-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-430"><a href="#cb24-430" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-431"><a href="#cb24-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-432"><a href="#cb24-432" aria-hidden="true" tabindex="-1"></a><span class="fu">### Geodesics and Reflections</span></span>
<span id="cb24-433"><a href="#cb24-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-434"><a href="#cb24-434" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Geodesics in the Upper Half-Plane</span></span>
<span id="cb24-435"><a href="#cb24-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-436"><a href="#cb24-436" aria-hidden="true" tabindex="-1"></a>**Geodesics** (the "straight lines" of hyperbolic geometry—curves that locally minimize distance) in $\mathbb{H}^2$ have exactly two forms:</span>
<span id="cb24-437"><a href="#cb24-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-438"><a href="#cb24-438" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Vertical lines**: $<span class="sc">\{</span>x = c<span class="sc">\}</span>$ for any constant $c \in \mathbb{R}$</span>
<span id="cb24-439"><a href="#cb24-439" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Semicircles**: Centered on the real axis, perpendicular to it</span>
<span id="cb24-440"><a href="#cb24-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-441"><a href="#cb24-441" aria-hidden="true" tabindex="-1"></a>These are curves that meet the boundary at right angles. Every geodesic is determined by where it intersects the boundary (the real axis).</span>
<span id="cb24-442"><a href="#cb24-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-443"><a href="#cb24-443" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Reflection Across Vertical Lines</span></span>
<span id="cb24-444"><a href="#cb24-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-445"><a href="#cb24-445" aria-hidden="true" tabindex="-1"></a>For a vertical geodesic at $x = c$, reflection is simple—just flip the $x$-coordinate:</span>
<span id="cb24-446"><a href="#cb24-446" aria-hidden="true" tabindex="-1"></a>$$\text{reflect}_{x=c}(x + iy) = (2c - x) + iy$$</span>
<span id="cb24-447"><a href="#cb24-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-448"><a href="#cb24-448" aria-hidden="true" tabindex="-1"></a>This is exactly what we had in Euclidean geometry! Now we implement it with our half-space convention:</span>
<span id="cb24-449"><a href="#cb24-449" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-450"><a href="#cb24-450" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoVertical(vec2 z, float x_pos, float side) {</span></span>
<span id="cb24-451"><a href="#cb24-451" aria-hidden="true" tabindex="-1"></a><span class="in">    // Check if we're on the correct side</span></span>
<span id="cb24-452"><a href="#cb24-452" aria-hidden="true" tabindex="-1"></a><span class="in">    if((z.x - x_pos) * side &lt; 0.0) {</span></span>
<span id="cb24-453"><a href="#cb24-453" aria-hidden="true" tabindex="-1"></a><span class="in">        return z;  // Already on correct side</span></span>
<span id="cb24-454"><a href="#cb24-454" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-455"><a href="#cb24-455" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-456"><a href="#cb24-456" aria-hidden="true" tabindex="-1"></a><span class="in">    // Reflect across the vertical line</span></span>
<span id="cb24-457"><a href="#cb24-457" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x = 2.0 * x_pos - z.x;</span></span>
<span id="cb24-458"><a href="#cb24-458" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb24-459"><a href="#cb24-459" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-460"><a href="#cb24-460" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-461"><a href="#cb24-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-462"><a href="#cb24-462" aria-hidden="true" tabindex="-1"></a>The <span class="in">`side`</span> parameter works the same way: <span class="in">`side = -1.0`</span> means we want $x &gt; x_{\text{pos}}$, and <span class="in">`side = 1.0`</span> means $x &lt; x_{\text{pos}}$.</span>
<span id="cb24-463"><a href="#cb24-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-464"><a href="#cb24-464" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Reflection Across Semicircles</span></span>
<span id="cb24-465"><a href="#cb24-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-466"><a href="#cb24-466" aria-hidden="true" tabindex="-1"></a>For a semicircular geodesic with endpoints $p$ and $q$ on the real axis, we use **circle inversion from Day 2!**</span>
<span id="cb24-467"><a href="#cb24-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-468"><a href="#cb24-468" aria-hidden="true" tabindex="-1"></a>The semicircle has:</span>
<span id="cb24-469"><a href="#cb24-469" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Center: $c = (p + q)/2$</span>
<span id="cb24-470"><a href="#cb24-470" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Radius: $R = |p - q|/2$</span>
<span id="cb24-471"><a href="#cb24-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-472"><a href="#cb24-472" aria-hidden="true" tabindex="-1"></a>The inversion formula is:</span>
<span id="cb24-473"><a href="#cb24-473" aria-hidden="true" tabindex="-1"></a>$$z \mapsto c + R^2 \frac{z - c}{|z - c|^2}$$</span>
<span id="cb24-474"><a href="#cb24-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-475"><a href="#cb24-475" aria-hidden="true" tabindex="-1"></a>This is exactly the same as yesterday's Apollonian gasket! The code is nearly identical:</span>
<span id="cb24-476"><a href="#cb24-476" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-477"><a href="#cb24-477" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoCircular(vec2 z, float p, float q, float side) {</span></span>
<span id="cb24-478"><a href="#cb24-478" aria-hidden="true" tabindex="-1"></a><span class="in">    // Semicircle from p to q on real axis</span></span>
<span id="cb24-479"><a href="#cb24-479" aria-hidden="true" tabindex="-1"></a><span class="in">    float center = (p + q) / 2.0;</span></span>
<span id="cb24-480"><a href="#cb24-480" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius = abs(p - q) / 2.0;</span></span>
<span id="cb24-481"><a href="#cb24-481" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-482"><a href="#cb24-482" aria-hidden="true" tabindex="-1"></a><span class="in">    // Check which side we're on</span></span>
<span id="cb24-483"><a href="#cb24-483" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 rel = z - vec2(center, 0.0);</span></span>
<span id="cb24-484"><a href="#cb24-484" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist2 = dot(rel, rel);</span></span>
<span id="cb24-485"><a href="#cb24-485" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-486"><a href="#cb24-486" aria-hidden="true" tabindex="-1"></a><span class="in">    // side = 1.0 means outside circle, side = -1.0 means inside</span></span>
<span id="cb24-487"><a href="#cb24-487" aria-hidden="true" tabindex="-1"></a><span class="in">    if((dist2 - radius * radius) * side &gt; 0.0) {</span></span>
<span id="cb24-488"><a href="#cb24-488" aria-hidden="true" tabindex="-1"></a><span class="in">        return z;  // Already on correct side</span></span>
<span id="cb24-489"><a href="#cb24-489" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-490"><a href="#cb24-490" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-491"><a href="#cb24-491" aria-hidden="true" tabindex="-1"></a><span class="in">    // Circle inversion (from Day 2!)</span></span>
<span id="cb24-492"><a href="#cb24-492" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x -= center;</span></span>
<span id="cb24-493"><a href="#cb24-493" aria-hidden="true" tabindex="-1"></a><span class="in">    z /= radius;</span></span>
<span id="cb24-494"><a href="#cb24-494" aria-hidden="true" tabindex="-1"></a><span class="in">    z /= dot(z, z);    // The inversion step</span></span>
<span id="cb24-495"><a href="#cb24-495" aria-hidden="true" tabindex="-1"></a><span class="in">    z *= radius;</span></span>
<span id="cb24-496"><a href="#cb24-496" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x += center;</span></span>
<span id="cb24-497"><a href="#cb24-497" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-498"><a href="#cb24-498" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb24-499"><a href="#cb24-499" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-500"><a href="#cb24-500" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-501"><a href="#cb24-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-502"><a href="#cb24-502" aria-hidden="true" tabindex="-1"></a>The semicircle case uses the same circle inversion we implemented yesterday—same formula, new geometric interpretation!</span>
<span id="cb24-503"><a href="#cb24-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-504"><a href="#cb24-504" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb24-505"><a href="#cb24-505" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Algorithmic Connection to Day 2</span></span>
<span id="cb24-506"><a href="#cb24-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-507"><a href="#cb24-507" aria-hidden="true" tabindex="-1"></a>Notice the pattern across all three days:</span>
<span id="cb24-508"><a href="#cb24-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-509"><a href="#cb24-509" aria-hidden="true" tabindex="-1"></a>**Day 2 (Apollonian gasket)**:</span>
<span id="cb24-510"><a href="#cb24-510" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Setup: Three circles defining regions</span>
<span id="cb24-511"><a href="#cb24-511" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Algorithm: If outside a region, invert through its boundary circle</span>
<span id="cb24-512"><a href="#cb24-512" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Iterate until stable</span>
<span id="cb24-513"><a href="#cb24-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-514"><a href="#cb24-514" aria-hidden="true" tabindex="-1"></a>**Day 3, Euclidean**:</span>
<span id="cb24-515"><a href="#cb24-515" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Setup: Half-spaces (lines) defining a region  </span>
<span id="cb24-516"><a href="#cb24-516" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Algorithm: If outside the region, reflect across the boundary</span>
<span id="cb24-517"><a href="#cb24-517" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Iterate until point stops moving</span>
<span id="cb24-518"><a href="#cb24-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-519"><a href="#cb24-519" aria-hidden="true" tabindex="-1"></a>**Day 3, Hyperbolic**:</span>
<span id="cb24-520"><a href="#cb24-520" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Setup: Half-spaces (vertical lines and semicircles) defining a region</span>
<span id="cb24-521"><a href="#cb24-521" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Algorithm: If outside the region, reflect across the boundary (using line reflection OR circle inversion)</span>
<span id="cb24-522"><a href="#cb24-522" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Iterate until point stops moving</span>
<span id="cb24-523"><a href="#cb24-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-524"><a href="#cb24-524" aria-hidden="true" tabindex="-1"></a>The pattern is universal: **iteratively apply a geometric transformation to move into a desired region**. The specific transformations change (circle inversion, line reflection, hyperbolic reflection), but the algorithmic structure remains the same!</span>
<span id="cb24-525"><a href="#cb24-525" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb24-526"><a href="#cb24-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-527"><a href="#cb24-527" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-528"><a href="#cb24-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-529"><a href="#cb24-529" aria-hidden="true" tabindex="-1"></a><span class="fu">### The (2,3,∞) Triangle</span></span>
<span id="cb24-530"><a href="#cb24-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-531"><a href="#cb24-531" aria-hidden="true" tabindex="-1"></a>Let's build our first hyperbolic triangle tiling. The notation $(2,3,\infty)$ means the triangle has angles $\pi/2$, $\pi/3$, and $0$ (an ideal vertex at infinity).</span>
<span id="cb24-532"><a href="#cb24-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-533"><a href="#cb24-533" aria-hidden="true" tabindex="-1"></a>We'll use a particularly nice configuration in the upper half-plane:</span>
<span id="cb24-534"><a href="#cb24-534" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Left boundary**: Vertical line at $x = -1$</span>
<span id="cb24-535"><a href="#cb24-535" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Right boundary**: Vertical line at $x = 1$  </span>
<span id="cb24-536"><a href="#cb24-536" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Bottom boundary**: Unit semicircle from $-1$ to $1$</span>
<span id="cb24-537"><a href="#cb24-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-538"><a href="#cb24-538" aria-hidden="true" tabindex="-1"></a>This creates a triangle with two finite vertices (where the vertical lines meet the semicircle) and one ideal vertex at $\infty$ (straight up the $y$-axis).</span>
<span id="cb24-539"><a href="#cb24-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-540"><a href="#cb24-540" aria-hidden="true" tabindex="-1"></a>Here's the complete shader:</span>
<span id="cb24-541"><a href="#cb24-541" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-542"><a href="#cb24-542" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoVertical(vec2 z, float x_pos, float side) {</span></span>
<span id="cb24-543"><a href="#cb24-543" aria-hidden="true" tabindex="-1"></a><span class="in">    if((z.x - x_pos) * side &lt; 0.0) return z;</span></span>
<span id="cb24-544"><a href="#cb24-544" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x = 2.0 * x_pos - z.x;</span></span>
<span id="cb24-545"><a href="#cb24-545" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb24-546"><a href="#cb24-546" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-547"><a href="#cb24-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-548"><a href="#cb24-548" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoCircular(vec2 z, float p, float q, float side) {</span></span>
<span id="cb24-549"><a href="#cb24-549" aria-hidden="true" tabindex="-1"></a><span class="in">    float center = (p + q) / 2.0;</span></span>
<span id="cb24-550"><a href="#cb24-550" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius = abs(p - q) / 2.0;</span></span>
<span id="cb24-551"><a href="#cb24-551" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 rel = z - vec2(center, 0.0);</span></span>
<span id="cb24-552"><a href="#cb24-552" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist2 = dot(rel, rel);</span></span>
<span id="cb24-553"><a href="#cb24-553" aria-hidden="true" tabindex="-1"></a><span class="in">    if((dist2 - radius * radius) * side &gt; 0.0) return z;</span></span>
<span id="cb24-554"><a href="#cb24-554" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-555"><a href="#cb24-555" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x -= center;</span></span>
<span id="cb24-556"><a href="#cb24-556" aria-hidden="true" tabindex="-1"></a><span class="in">    z /= radius;</span></span>
<span id="cb24-557"><a href="#cb24-557" aria-hidden="true" tabindex="-1"></a><span class="in">    z /= dot(z, z);</span></span>
<span id="cb24-558"><a href="#cb24-558" aria-hidden="true" tabindex="-1"></a><span class="in">    z *= radius;</span></span>
<span id="cb24-559"><a href="#cb24-559" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x += center;</span></span>
<span id="cb24-560"><a href="#cb24-560" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb24-561"><a href="#cb24-561" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-562"><a href="#cb24-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-563"><a href="#cb24-563" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb24-564"><a href="#cb24-564" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb24-565"><a href="#cb24-565" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb24-566"><a href="#cb24-566" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb24-567"><a href="#cb24-567" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb24-568"><a href="#cb24-568" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb24-569"><a href="#cb24-569" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-570"><a href="#cb24-570" aria-hidden="true" tabindex="-1"></a><span class="in">    // Shift to upper half-plane (need y &gt; 0)</span></span>
<span id="cb24-571"><a href="#cb24-571" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = uv + vec2(0.0, 1.5);</span></span>
<span id="cb24-572"><a href="#cb24-572" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-573"><a href="#cb24-573" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the (2,3,∞) triangle</span></span>
<span id="cb24-574"><a href="#cb24-574" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb24-575"><a href="#cb24-575" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 50; i++) {</span></span>
<span id="cb24-576"><a href="#cb24-576" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 z_old = z;</span></span>
<span id="cb24-577"><a href="#cb24-577" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-578"><a href="#cb24-578" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across left vertical line (x = -1, want x &gt; -1)</span></span>
<span id="cb24-579"><a href="#cb24-579" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoVertical(z, -1.0, -1.0);</span></span>
<span id="cb24-580"><a href="#cb24-580" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-581"><a href="#cb24-581" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across right vertical line (x = 1, want x &lt; 1)</span></span>
<span id="cb24-582"><a href="#cb24-582" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoVertical(z, 1.0, 1.0);</span></span>
<span id="cb24-583"><a href="#cb24-583" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-584"><a href="#cb24-584" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across semicircle (from -1 to 1, want outside/above)</span></span>
<span id="cb24-585"><a href="#cb24-585" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);</span></span>
<span id="cb24-586"><a href="#cb24-586" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-587"><a href="#cb24-587" aria-hidden="true" tabindex="-1"></a><span class="in">        // If point didn't move, we're inside</span></span>
<span id="cb24-588"><a href="#cb24-588" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(z - z_old) &lt; 0.0001) break;</span></span>
<span id="cb24-589"><a href="#cb24-589" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb24-590"><a href="#cb24-590" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-591"><a href="#cb24-591" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-592"><a href="#cb24-592" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color by fold count parity</span></span>
<span id="cb24-593"><a href="#cb24-593" aria-hidden="true" tabindex="-1"></a><span class="in">    float parity = mod(float(foldCount), 2.0);</span></span>
<span id="cb24-594"><a href="#cb24-594" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color;</span></span>
<span id="cb24-595"><a href="#cb24-595" aria-hidden="true" tabindex="-1"></a><span class="in">    if(parity &lt; 0.5) {</span></span>
<span id="cb24-596"><a href="#cb24-596" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.7, 0.8, 0.9);  // Light blue</span></span>
<span id="cb24-597"><a href="#cb24-597" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb24-598"><a href="#cb24-598" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.5, 0.6, 0.8);  // Darker blue</span></span>
<span id="cb24-599"><a href="#cb24-599" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-600"><a href="#cb24-600" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-601"><a href="#cb24-601" aria-hidden="true" tabindex="-1"></a><span class="in">    // Darken if below the real axis (outside hyperbolic space)</span></span>
<span id="cb24-602"><a href="#cb24-602" aria-hidden="true" tabindex="-1"></a><span class="in">    if(z.y &lt; 0.0) {</span></span>
<span id="cb24-603"><a href="#cb24-603" aria-hidden="true" tabindex="-1"></a><span class="in">        color *= 0.3;</span></span>
<span id="cb24-604"><a href="#cb24-604" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-605"><a href="#cb24-605" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-606"><a href="#cb24-606" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb24-607"><a href="#cb24-607" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-608"><a href="#cb24-608" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-609"><a href="#cb24-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-610"><a href="#cb24-610" aria-hidden="true" tabindex="-1"></a>You should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis $y = 0$)—they're all the same hyperbolic size, but Euclidean distances compress due to the metric.</span>
<span id="cb24-611"><a href="#cb24-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-612"><a href="#cb24-612" aria-hidden="true" tabindex="-1"></a>The alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</span>
<span id="cb24-613"><a href="#cb24-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-614"><a href="#cb24-614" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb24-615"><a href="#cb24-615" aria-hidden="true" tabindex="-1"></a><span class="fu">## Compare to Euclidean</span></span>
<span id="cb24-616"><a href="#cb24-616" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-617"><a href="#cb24-617" aria-hidden="true" tabindex="-1"></a>Look at the structure of this shader compared to the Euclidean triangle tiling:</span>
<span id="cb24-618"><a href="#cb24-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-619"><a href="#cb24-619" aria-hidden="true" tabindex="-1"></a>**Euclidean:**</span>
<span id="cb24-620"><a href="#cb24-620" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-621"><a href="#cb24-621" aria-hidden="true" tabindex="-1"></a><span class="in">p = reflectInto(p, hs1);</span></span>
<span id="cb24-622"><a href="#cb24-622" aria-hidden="true" tabindex="-1"></a><span class="in">p = reflectInto(p, hs2);</span></span>
<span id="cb24-623"><a href="#cb24-623" aria-hidden="true" tabindex="-1"></a><span class="in">p = reflectInto(p, hs3);</span></span>
<span id="cb24-624"><a href="#cb24-624" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-625"><a href="#cb24-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-626"><a href="#cb24-626" aria-hidden="true" tabindex="-1"></a>**Hyperbolic:**</span>
<span id="cb24-627"><a href="#cb24-627" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-628"><a href="#cb24-628" aria-hidden="true" tabindex="-1"></a><span class="in">z = reflectIntoVertical(z, -1.0, -1.0);</span></span>
<span id="cb24-629"><a href="#cb24-629" aria-hidden="true" tabindex="-1"></a><span class="in">z = reflectIntoVertical(z, 1.0, 1.0);</span></span>
<span id="cb24-630"><a href="#cb24-630" aria-hidden="true" tabindex="-1"></a><span class="in">z = reflectIntoCircular(z, -1.0, 1.0, 1.0);</span></span>
<span id="cb24-631"><a href="#cb24-631" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-632"><a href="#cb24-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-633"><a href="#cb24-633" aria-hidden="true" tabindex="-1"></a>The algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.</span>
<span id="cb24-634"><a href="#cb24-634" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb24-635"><a href="#cb24-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-636"><a href="#cb24-636" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-637"><a href="#cb24-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-638"><a href="#cb24-638" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Poincaré Disk Model</span></span>
<span id="cb24-639"><a href="#cb24-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-640"><a href="#cb24-640" aria-hidden="true" tabindex="-1"></a>The upper half-plane model is unbounded—it extends infinitely upward. The **Poincaré disk model** solves this by fitting all of hyperbolic space inside the unit disk.</span>
<span id="cb24-641"><a href="#cb24-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-642"><a href="#cb24-642" aria-hidden="true" tabindex="-1"></a>**Definition**: $\mathbb{D}^2 = <span class="sc">\{</span>z \in \mathbb{C} : |z| &lt; 1<span class="sc">\}</span>$</span>
<span id="cb24-643"><a href="#cb24-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-644"><a href="#cb24-644" aria-hidden="true" tabindex="-1"></a>The interior of the unit disk represents all of hyperbolic space, and the boundary circle $|z| = 1$ represents points at infinity.</span>
<span id="cb24-645"><a href="#cb24-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-646"><a href="#cb24-646" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Cayley Transform</span></span>
<span id="cb24-647"><a href="#cb24-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-648"><a href="#cb24-648" aria-hidden="true" tabindex="-1"></a>The **Cayley transform** is a Möbius transformation that maps between these two models:</span>
<span id="cb24-649"><a href="#cb24-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-650"><a href="#cb24-650" aria-hidden="true" tabindex="-1"></a>**From upper half-plane to disk**:</span>
<span id="cb24-651"><a href="#cb24-651" aria-hidden="true" tabindex="-1"></a>$$w = \frac{z - i}{z + i}$$</span>
<span id="cb24-652"><a href="#cb24-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-653"><a href="#cb24-653" aria-hidden="true" tabindex="-1"></a>**From disk to upper half-plane**:</span>
<span id="cb24-654"><a href="#cb24-654" aria-hidden="true" tabindex="-1"></a>$$z = i\frac{1 + w}{1 - w}$$</span>
<span id="cb24-655"><a href="#cb24-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-656"><a href="#cb24-656" aria-hidden="true" tabindex="-1"></a>These formulas use complex arithmetic, which we implemented on Day 2:</span>
<span id="cb24-657"><a href="#cb24-657" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-658"><a href="#cb24-658" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cmul(vec2 a, vec2 b) {</span></span>
<span id="cb24-659"><a href="#cb24-659" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);</span></span>
<span id="cb24-660"><a href="#cb24-660" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-661"><a href="#cb24-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-662"><a href="#cb24-662" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cdiv(vec2 a, vec2 b) {</span></span>
<span id="cb24-663"><a href="#cb24-663" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = dot(b, b);</span></span>
<span id="cb24-664"><a href="#cb24-664" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / denom;</span></span>
<span id="cb24-665"><a href="#cb24-665" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-666"><a href="#cb24-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-667"><a href="#cb24-667" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 diskToUHP(vec2 w) {</span></span>
<span id="cb24-668"><a href="#cb24-668" aria-hidden="true" tabindex="-1"></a><span class="in">    // z = i(1 + w) / (1 - w)</span></span>
<span id="cb24-669"><a href="#cb24-669" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 num = cmul(vec2(0.0, 1.0), vec2(1.0, 0.0) + w);</span></span>
<span id="cb24-670"><a href="#cb24-670" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 den = vec2(1.0, 0.0) - w;</span></span>
<span id="cb24-671"><a href="#cb24-671" aria-hidden="true" tabindex="-1"></a><span class="in">    return cdiv(num, den);</span></span>
<span id="cb24-672"><a href="#cb24-672" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-673"><a href="#cb24-673" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-674"><a href="#cb24-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-675"><a href="#cb24-675" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Visualization in the Disk</span></span>
<span id="cb24-676"><a href="#cb24-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-677"><a href="#cb24-677" aria-hidden="true" tabindex="-1"></a>Here's a powerful technique: we can do all our computations in the upper half-plane model, but view the result in the disk model. We just convert coordinates at the start:</span>
<span id="cb24-678"><a href="#cb24-678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-679"><a href="#cb24-679" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Pixel coordinates → Disk coordinates</span>
<span id="cb24-680"><a href="#cb24-680" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Disk → Upper half-plane (using <span class="in">`diskToUHP`</span>)</span>
<span id="cb24-681"><a href="#cb24-681" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Compute tiling in UHP</span>
<span id="cb24-682"><a href="#cb24-682" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Display result</span>
<span id="cb24-683"><a href="#cb24-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-684"><a href="#cb24-684" aria-hidden="true" tabindex="-1"></a>Here's the complete shader for viewing the tiling in the Poincaré disk:</span>
<span id="cb24-685"><a href="#cb24-685" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-686"><a href="#cb24-686" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoVertical(vec2 z, float x_pos, float side) {</span></span>
<span id="cb24-687"><a href="#cb24-687" aria-hidden="true" tabindex="-1"></a><span class="in">    if((z.x - x_pos) * side &lt; 0.0) return z;</span></span>
<span id="cb24-688"><a href="#cb24-688" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x = 2.0 * x_pos - z.x;</span></span>
<span id="cb24-689"><a href="#cb24-689" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb24-690"><a href="#cb24-690" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-691"><a href="#cb24-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-692"><a href="#cb24-692" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoCircular(vec2 z, float p, float q, float side) {</span></span>
<span id="cb24-693"><a href="#cb24-693" aria-hidden="true" tabindex="-1"></a><span class="in">    float center = (p + q) / 2.0;</span></span>
<span id="cb24-694"><a href="#cb24-694" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius = abs(p - q) / 2.0;</span></span>
<span id="cb24-695"><a href="#cb24-695" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 rel = z - vec2(center, 0.0);</span></span>
<span id="cb24-696"><a href="#cb24-696" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist2 = dot(rel, rel);</span></span>
<span id="cb24-697"><a href="#cb24-697" aria-hidden="true" tabindex="-1"></a><span class="in">    if((dist2 - radius * radius) * side &gt; 0.0) return z;</span></span>
<span id="cb24-698"><a href="#cb24-698" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-699"><a href="#cb24-699" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x -= center;</span></span>
<span id="cb24-700"><a href="#cb24-700" aria-hidden="true" tabindex="-1"></a><span class="in">    z /= radius;</span></span>
<span id="cb24-701"><a href="#cb24-701" aria-hidden="true" tabindex="-1"></a><span class="in">    z /= dot(z, z);</span></span>
<span id="cb24-702"><a href="#cb24-702" aria-hidden="true" tabindex="-1"></a><span class="in">    z *= radius;</span></span>
<span id="cb24-703"><a href="#cb24-703" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x += center;</span></span>
<span id="cb24-704"><a href="#cb24-704" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb24-705"><a href="#cb24-705" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-706"><a href="#cb24-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-707"><a href="#cb24-707" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cmul(vec2 a, vec2 b) {</span></span>
<span id="cb24-708"><a href="#cb24-708" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);</span></span>
<span id="cb24-709"><a href="#cb24-709" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-710"><a href="#cb24-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-711"><a href="#cb24-711" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cdiv(vec2 a, vec2 b) {</span></span>
<span id="cb24-712"><a href="#cb24-712" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = dot(b, b);</span></span>
<span id="cb24-713"><a href="#cb24-713" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / denom;</span></span>
<span id="cb24-714"><a href="#cb24-714" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-715"><a href="#cb24-715" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-716"><a href="#cb24-716" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 diskToUHP(vec2 w) {</span></span>
<span id="cb24-717"><a href="#cb24-717" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 num = cmul(vec2(0.0, 1.0), vec2(1.0, 0.0) + w);</span></span>
<span id="cb24-718"><a href="#cb24-718" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 den = vec2(1.0, 0.0) - w;</span></span>
<span id="cb24-719"><a href="#cb24-719" aria-hidden="true" tabindex="-1"></a><span class="in">    return cdiv(num, den);</span></span>
<span id="cb24-720"><a href="#cb24-720" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-721"><a href="#cb24-721" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-722"><a href="#cb24-722" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb24-723"><a href="#cb24-723" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb24-724"><a href="#cb24-724" aria-hidden="true" tabindex="-1"></a><span class="in">    // Setup for disk viewing</span></span>
<span id="cb24-725"><a href="#cb24-725" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0;</span></span>
<span id="cb24-726"><a href="#cb24-726" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb24-727"><a href="#cb24-727" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-728"><a href="#cb24-728" aria-hidden="true" tabindex="-1"></a><span class="in">    // Only render inside unit disk</span></span>
<span id="cb24-729"><a href="#cb24-729" aria-hidden="true" tabindex="-1"></a><span class="in">    if(length(uv) &gt;= 1.0) {</span></span>
<span id="cb24-730"><a href="#cb24-730" aria-hidden="true" tabindex="-1"></a><span class="in">        fragColor = vec4(0.0, 0.0, 0.0, 1.0);</span></span>
<span id="cb24-731"><a href="#cb24-731" aria-hidden="true" tabindex="-1"></a><span class="in">        return;</span></span>
<span id="cb24-732"><a href="#cb24-732" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-733"><a href="#cb24-733" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-734"><a href="#cb24-734" aria-hidden="true" tabindex="-1"></a><span class="in">    // Convert disk coordinates to upper half-plane</span></span>
<span id="cb24-735"><a href="#cb24-735" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = diskToUHP(uv);</span></span>
<span id="cb24-736"><a href="#cb24-736" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-737"><a href="#cb24-737" aria-hidden="true" tabindex="-1"></a><span class="in">    // Now do all computations in UHP</span></span>
<span id="cb24-738"><a href="#cb24-738" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb24-739"><a href="#cb24-739" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 50; i++) {</span></span>
<span id="cb24-740"><a href="#cb24-740" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 z_old = z;</span></span>
<span id="cb24-741"><a href="#cb24-741" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-742"><a href="#cb24-742" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoVertical(z, -1.0, -1.0);</span></span>
<span id="cb24-743"><a href="#cb24-743" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoVertical(z, 1.0, 1.0);</span></span>
<span id="cb24-744"><a href="#cb24-744" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);</span></span>
<span id="cb24-745"><a href="#cb24-745" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb24-746"><a href="#cb24-746" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(z - z_old) &lt; 0.0001) break;</span></span>
<span id="cb24-747"><a href="#cb24-747" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb24-748"><a href="#cb24-748" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-749"><a href="#cb24-749" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-750"><a href="#cb24-750" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color by parity</span></span>
<span id="cb24-751"><a href="#cb24-751" aria-hidden="true" tabindex="-1"></a><span class="in">    float parity = mod(float(foldCount), 2.0);</span></span>
<span id="cb24-752"><a href="#cb24-752" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (parity &lt; 0.5) ? vec3(0.7, 0.8, 0.9) : vec3(0.5, 0.6, 0.8);</span></span>
<span id="cb24-753"><a href="#cb24-753" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb24-754"><a href="#cb24-754" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb24-755"><a href="#cb24-755" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-756"><a href="#cb24-756" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-757"><a href="#cb24-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-758"><a href="#cb24-758" aria-hidden="true" tabindex="-1"></a>The tiling now appears in a bounded disk! All of hyperbolic space fits in this circle. Compare it to the upper half-plane view—it's the same mathematical tiling, just displayed in a different coordinate system.</span>
<span id="cb24-759"><a href="#cb24-759" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-760"><a href="#cb24-760" aria-hidden="true" tabindex="-1"></a>Notice how triangles near the boundary of the disk look very small—they're approaching infinity in hyperbolic terms, and the compression becomes extreme.</span>
<span id="cb24-761"><a href="#cb24-761" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-762"><a href="#cb24-762" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-763"><a href="#cb24-763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-764"><a href="#cb24-764" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb24-765"><a href="#cb24-765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-766"><a href="#cb24-766" aria-hidden="true" tabindex="-1"></a>Today we learned:</span>
<span id="cb24-767"><a href="#cb24-767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-768"><a href="#cb24-768" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**The folding algorithm**: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry</span>
<span id="cb24-769"><a href="#cb24-769" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-770"><a href="#cb24-770" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Half-space structure**: Boundary + side gives a unified way to encode regions in Euclidean geometry</span>
<span id="cb24-771"><a href="#cb24-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-772"><a href="#cb24-772" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Hyperbolic geometry**: Negative curvature space with two types of geodesics (vertical lines and semicircles)</span>
<span id="cb24-773"><a href="#cb24-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-774"><a href="#cb24-774" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Two reflection functions**: <span class="in">`reflectIntoVertical`</span> and <span class="in">`reflectIntoCircular`</span> parallel the Euclidean <span class="in">`reflectInto`</span></span>
<span id="cb24-775"><a href="#cb24-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-776"><a href="#cb24-776" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Connection to Day 2**: Same algorithmic pattern as Apollonian gasket—iterate a transformation to move into desired region</span>
<span id="cb24-777"><a href="#cb24-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-778"><a href="#cb24-778" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**Multiple models**: Converting between upper half-plane and Poincaré disk using the Cayley transform</span>
<span id="cb24-779"><a href="#cb24-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-780"><a href="#cb24-780" aria-hidden="true" tabindex="-1"></a>**Key insight**: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!</span>
<span id="cb24-781"><a href="#cb24-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-782"><a href="#cb24-782" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-783"><a href="#cb24-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-784"><a href="#cb24-784" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb24-785"><a href="#cb24-785" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-786"><a href="#cb24-786" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #1: Euclidean Triangle Tiling with Edges and Vertices</span></span>
<span id="cb24-787"><a href="#cb24-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-788"><a href="#cb24-788" aria-hidden="true" tabindex="-1"></a>**Goal**: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.</span>
<span id="cb24-789"><a href="#cb24-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-790"><a href="#cb24-790" aria-hidden="true" tabindex="-1"></a>**Tasks**:</span>
<span id="cb24-791"><a href="#cb24-791" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-792"><a href="#cb24-792" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Implement distance to a half-space**:</span>
<span id="cb24-793"><a href="#cb24-793" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-794"><a href="#cb24-794" aria-hidden="true" tabindex="-1"></a><span class="in">   float distToHalfSpace(vec2 p, HalfSpace hs) {</span></span>
<span id="cb24-795"><a href="#cb24-795" aria-hidden="true" tabindex="-1"></a><span class="in">       return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));</span></span>
<span id="cb24-796"><a href="#cb24-796" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-797"><a href="#cb24-797" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-798"><a href="#cb24-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-799"><a href="#cb24-799" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Draw the triangle edges**: Use the distance function to draw white lines along the three edges of your triangle.</span>
<span id="cb24-800"><a href="#cb24-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-801"><a href="#cb24-801" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Draw the triangle vertices**: Compute the vertices of your equilateral triangle and draw small circles at these locations. Use Euclidean distance: <span class="in">`length(p - vertex) &lt; 0.05`</span>.</span>
<span id="cb24-802"><a href="#cb24-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-803"><a href="#cb24-803" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Create an attractive color scheme**: Color tiles based on fold count, parity, or distance to edges. Make it visually appealing!</span>
<span id="cb24-804"><a href="#cb24-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-805"><a href="#cb24-805" aria-hidden="true" tabindex="-1"></a>**Expected output**: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.</span>
<span id="cb24-806"><a href="#cb24-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-807"><a href="#cb24-807" aria-hidden="true" tabindex="-1"></a>**Bonus**: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.</span>
<span id="cb24-808"><a href="#cb24-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-809"><a href="#cb24-809" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-810"><a href="#cb24-810" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-811"><a href="#cb24-811" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</span></span>
<span id="cb24-812"><a href="#cb24-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-813"><a href="#cb24-813" aria-hidden="true" tabindex="-1"></a>**Goal**: Create a beautiful hyperbolic triangle tiling with visible structure.</span>
<span id="cb24-814"><a href="#cb24-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-815"><a href="#cb24-815" aria-hidden="true" tabindex="-1"></a>**Tasks**:</span>
<span id="cb24-816"><a href="#cb24-816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-817"><a href="#cb24-817" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Implement hyperbolic distance functions**:</span>
<span id="cb24-818"><a href="#cb24-818" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-819"><a href="#cb24-819" aria-hidden="true" tabindex="-1"></a>   **Distance between two points**:</span>
<span id="cb24-820"><a href="#cb24-820" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-821"><a href="#cb24-821" aria-hidden="true" tabindex="-1"></a><span class="in">   float hyperbolicDistance(vec2 z, vec2 w) {</span></span>
<span id="cb24-822"><a href="#cb24-822" aria-hidden="true" tabindex="-1"></a><span class="in">       float diff2 = dot(z - w, z - w);</span></span>
<span id="cb24-823"><a href="#cb24-823" aria-hidden="true" tabindex="-1"></a><span class="in">       float denom = 2.0 * z.y * w.y;</span></span>
<span id="cb24-824"><a href="#cb24-824" aria-hidden="true" tabindex="-1"></a><span class="in">       float arg = 1.0 + diff2 / denom;</span></span>
<span id="cb24-825"><a href="#cb24-825" aria-hidden="true" tabindex="-1"></a><span class="in">       return log(arg + sqrt(arg * arg - 1.0));</span></span>
<span id="cb24-826"><a href="#cb24-826" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-827"><a href="#cb24-827" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-828"><a href="#cb24-828" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-829"><a href="#cb24-829" aria-hidden="true" tabindex="-1"></a>   **Distance to vertical geodesic**:</span>
<span id="cb24-830"><a href="#cb24-830" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-831"><a href="#cb24-831" aria-hidden="true" tabindex="-1"></a><span class="in">   float distToVertical(vec2 z, float c) {</span></span>
<span id="cb24-832"><a href="#cb24-832" aria-hidden="true" tabindex="-1"></a><span class="in">       z.x -= c;</span></span>
<span id="cb24-833"><a href="#cb24-833" aria-hidden="true" tabindex="-1"></a><span class="in">       float secTheta = length(z) / abs(z.y);</span></span>
<span id="cb24-834"><a href="#cb24-834" aria-hidden="true" tabindex="-1"></a><span class="in">       return acosh(secTheta);</span></span>
<span id="cb24-835"><a href="#cb24-835" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-836"><a href="#cb24-836" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-837"><a href="#cb24-837" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-838"><a href="#cb24-838" aria-hidden="true" tabindex="-1"></a>   **Distance to circular geodesic**: Use a Möbius transformation to map the geodesic to a vertical line, then measure distance:</span>
<span id="cb24-839"><a href="#cb24-839" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-840"><a href="#cb24-840" aria-hidden="true" tabindex="-1"></a><span class="in">   vec2 applyMobius(vec4 mob, vec2 z) {</span></span>
<span id="cb24-841"><a href="#cb24-841" aria-hidden="true" tabindex="-1"></a><span class="in">       float a = mob.x, b = mob.y, c = mob.z, d = mob.w;</span></span>
<span id="cb24-842"><a href="#cb24-842" aria-hidden="true" tabindex="-1"></a><span class="in">       vec2 num = vec2(a, 0.0) * z + vec2(b, 0.0);</span></span>
<span id="cb24-843"><a href="#cb24-843" aria-hidden="true" tabindex="-1"></a><span class="in">       vec2 den = vec2(c, 0.0) * z + vec2(d, 0.0);</span></span>
<span id="cb24-844"><a href="#cb24-844" aria-hidden="true" tabindex="-1"></a><span class="in">       return cdiv(num, den);</span></span>
<span id="cb24-845"><a href="#cb24-845" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-846"><a href="#cb24-846" aria-hidden="true" tabindex="-1"></a><span class="in">   </span></span>
<span id="cb24-847"><a href="#cb24-847" aria-hidden="true" tabindex="-1"></a><span class="in">   float distToCircularGeodesic(vec2 z, float p, float q) {</span></span>
<span id="cb24-848"><a href="#cb24-848" aria-hidden="true" tabindex="-1"></a><span class="in">       vec4 mob = vec4(1.0, -p, 1.0, -q);</span></span>
<span id="cb24-849"><a href="#cb24-849" aria-hidden="true" tabindex="-1"></a><span class="in">       vec2 w = applyMobius(mob, z);</span></span>
<span id="cb24-850"><a href="#cb24-850" aria-hidden="true" tabindex="-1"></a><span class="in">       return distToVertical(w, 0.0);</span></span>
<span id="cb24-851"><a href="#cb24-851" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-852"><a href="#cb24-852" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-853"><a href="#cb24-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-854"><a href="#cb24-854" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Draw geodesic edges**: Use these distance functions to draw the three edges of your (2,3,∞) triangle:</span>
<span id="cb24-855"><a href="#cb24-855" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-856"><a href="#cb24-856" aria-hidden="true" tabindex="-1"></a><span class="in">   float d1 = distToVertical(z, -1.0);</span></span>
<span id="cb24-857"><a href="#cb24-857" aria-hidden="true" tabindex="-1"></a><span class="in">   float d2 = distToVertical(z, 1.0);</span></span>
<span id="cb24-858"><a href="#cb24-858" aria-hidden="true" tabindex="-1"></a><span class="in">   float d3 = distToCircularGeodesic(z, -1.0, 1.0);</span></span>
<span id="cb24-859"><a href="#cb24-859" aria-hidden="true" tabindex="-1"></a><span class="in">   float edgeDist = min(d1, min(d2, d3));</span></span>
<span id="cb24-860"><a href="#cb24-860" aria-hidden="true" tabindex="-1"></a><span class="in">   </span></span>
<span id="cb24-861"><a href="#cb24-861" aria-hidden="true" tabindex="-1"></a><span class="in">   if(edgeDist &lt; 0.02) {</span></span>
<span id="cb24-862"><a href="#cb24-862" aria-hidden="true" tabindex="-1"></a><span class="in">       color = vec3(1.0);  // White edges</span></span>
<span id="cb24-863"><a href="#cb24-863" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-864"><a href="#cb24-864" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-865"><a href="#cb24-865" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-866"><a href="#cb24-866" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Draw vertices**: The finite vertices are at approximately $(-1, 0)$ and $(1, 0)$ on the real axis (actually infinitesimally above). Draw small hyperbolic disks around these points:</span>
<span id="cb24-867"><a href="#cb24-867" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-868"><a href="#cb24-868" aria-hidden="true" tabindex="-1"></a><span class="in">   float d1 = hyperbolicDistance(z, vec2(-1.0, 0.01));</span></span>
<span id="cb24-869"><a href="#cb24-869" aria-hidden="true" tabindex="-1"></a><span class="in">   float d2 = hyperbolicDistance(z, vec2(1.0, 0.01));</span></span>
<span id="cb24-870"><a href="#cb24-870" aria-hidden="true" tabindex="-1"></a><span class="in">   if(d1 &lt; 0.1 || d2 &lt; 0.1) {</span></span>
<span id="cb24-871"><a href="#cb24-871" aria-hidden="true" tabindex="-1"></a><span class="in">       color = vec3(1.0, 1.0, 0.0);  // Yellow vertices</span></span>
<span id="cb24-872"><a href="#cb24-872" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-873"><a href="#cb24-873" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-874"><a href="#cb24-874" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-875"><a href="#cb24-875" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Create an attractive color scheme**: Make it beautiful!</span>
<span id="cb24-876"><a href="#cb24-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-877"><a href="#cb24-877" aria-hidden="true" tabindex="-1"></a>**Expected output**: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.</span>
<span id="cb24-878"><a href="#cb24-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-879"><a href="#cb24-879" aria-hidden="true" tabindex="-1"></a>**Bonus**: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.</span>
<span id="cb24-880"><a href="#cb24-880" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-881"><a href="#cb24-881" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-882"><a href="#cb24-882" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-883"><a href="#cb24-883" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #3: Model Conversions</span></span>
<span id="cb24-884"><a href="#cb24-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-885"><a href="#cb24-885" aria-hidden="true" tabindex="-1"></a>**Goal**: See the same tiling in different representations of hyperbolic space.</span>
<span id="cb24-886"><a href="#cb24-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-887"><a href="#cb24-887" aria-hidden="true" tabindex="-1"></a>**Tasks**:</span>
<span id="cb24-888"><a href="#cb24-888" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-889"><a href="#cb24-889" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Poincaré Disk** (already provided in lecture): Verify it works with your tiling code.</span>
<span id="cb24-890"><a href="#cb24-890" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-891"><a href="#cb24-891" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Klein Model**: Implement the transformation from Poincaré disk:</span>
<span id="cb24-892"><a href="#cb24-892" aria-hidden="true" tabindex="-1"></a>   $$w = \frac{2z}{1 + |z|^2}$$</span>
<span id="cb24-893"><a href="#cb24-893" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-894"><a href="#cb24-894" aria-hidden="true" tabindex="-1"></a><span class="in">   vec2 diskToKlein(vec2 z) {</span></span>
<span id="cb24-895"><a href="#cb24-895" aria-hidden="true" tabindex="-1"></a><span class="in">       float denom = 1.0 + dot(z, z);</span></span>
<span id="cb24-896"><a href="#cb24-896" aria-hidden="true" tabindex="-1"></a><span class="in">       return 2.0 * z / denom;</span></span>
<span id="cb24-897"><a href="#cb24-897" aria-hidden="true" tabindex="-1"></a><span class="in">   }</span></span>
<span id="cb24-898"><a href="#cb24-898" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-899"><a href="#cb24-899" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb24-900"><a href="#cb24-900" aria-hidden="true" tabindex="-1"></a>   In the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.</span>
<span id="cb24-901"><a href="#cb24-901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-902"><a href="#cb24-902" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Band Model** (Optional): The transformation $w = \tanh(z)$ from Poincaré disk represents hyperbolic space as an infinite horizontal strip. Implement this and see how your tiling appears.</span>
<span id="cb24-903"><a href="#cb24-903" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-904"><a href="#cb24-904" aria-hidden="true" tabindex="-1"></a>**Deliverable**: Show your (2,3,∞) tiling in at least the Poincaré disk and Klein model. Discuss what you observe about how the tiling appears in each model.</span>
<span id="cb24-905"><a href="#cb24-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-906"><a href="#cb24-906" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-907"><a href="#cb24-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-908"><a href="#cb24-908" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #4: Different Triangle Groups</span></span>
<span id="cb24-909"><a href="#cb24-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-910"><a href="#cb24-910" aria-hidden="true" tabindex="-1"></a>**Goal**: Explore other hyperbolic tilings by implementing different triangle groups.</span>
<span id="cb24-911"><a href="#cb24-911" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-912"><a href="#cb24-912" aria-hidden="true" tabindex="-1"></a>**The Challenge**: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.</span>
<span id="cb24-913"><a href="#cb24-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-914"><a href="#cb24-914" aria-hidden="true" tabindex="-1"></a>**Suggested triangles to try**:</span>
<span id="cb24-915"><a href="#cb24-915" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**(2, 3, 7)**: Creates Escher-like tilings with 7-fold symmetry—the most famous hyperbolic tiling</span>
<span id="cb24-916"><a href="#cb24-916" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**(2, 4, 6)**: Different symmetry pattern</span>
<span id="cb24-917"><a href="#cb24-917" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**(3, 3, 3)**: Equilateral hyperbolic triangle</span>
<span id="cb24-918"><a href="#cb24-918" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**(2, 5, 10)**: Pentagonal patterns</span>
<span id="cb24-919"><a href="#cb24-919" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-920"><a href="#cb24-920" aria-hidden="true" tabindex="-1"></a>**Approach**:</span>
<span id="cb24-921"><a href="#cb24-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-922"><a href="#cb24-922" aria-hidden="true" tabindex="-1"></a>The notation $(p, q, r)$ means angles $\pi/p$, $\pi/q$, and $\pi/r$ at the three vertices.</span>
<span id="cb24-923"><a href="#cb24-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-924"><a href="#cb24-924" aria-hidden="true" tabindex="-1"></a>Start with two geodesics in nice positions (e.g., a vertical line at $x = c$ and the imaginary axis). Now find the third geodesic such that:</span>
<span id="cb24-925"><a href="#cb24-925" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>It meets the first at angle $\pi/p$</span>
<span id="cb24-926"><a href="#cb24-926" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>It meets the second at angle $\pi/q$</span>
<span id="cb24-927"><a href="#cb24-927" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The angle at the third vertex is $\pi/r$</span>
<span id="cb24-928"><a href="#cb24-928" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-929"><a href="#cb24-929" aria-hidden="true" tabindex="-1"></a>Use the **hyperbolic law of cosines** for side lengths. If the side opposite angle $\gamma$ has length $s_\gamma$:</span>
<span id="cb24-930"><a href="#cb24-930" aria-hidden="true" tabindex="-1"></a>$$\cosh(s_\gamma) = \frac{\cos(\gamma) + \cos(\alpha)\cos(\beta)}{\sin(\alpha)\sin(\beta)}$$</span>
<span id="cb24-931"><a href="#cb24-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-932"><a href="#cb24-932" aria-hidden="true" tabindex="-1"></a>For angles $\alpha = \pi/p$, $\beta = \pi/q$, $\gamma = \pi/r$, this gives you the hyperbolic side length. Then translate this into Euclidean coordinates for the third geodesic.</span>
<span id="cb24-933"><a href="#cb24-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-934"><a href="#cb24-934" aria-hidden="true" tabindex="-1"></a>**Reference structure**:</span>
<span id="cb24-935"><a href="#cb24-935" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-936"><a href="#cb24-936" aria-hidden="true" tabindex="-1"></a><span class="in">// Hyperbolic side length opposite angle r:</span></span>
<span id="cb24-937"><a href="#cb24-937" aria-hidden="true" tabindex="-1"></a><span class="in">float num = cos(PI/r) + cos(PI/p) * cos(PI/q);</span></span>
<span id="cb24-938"><a href="#cb24-938" aria-hidden="true" tabindex="-1"></a><span class="in">float denom = sin(PI/p) * sin(PI/q);</span></span>
<span id="cb24-939"><a href="#cb24-939" aria-hidden="true" tabindex="-1"></a><span class="in">float sr = acosh(num / denom);</span></span>
<span id="cb24-940"><a href="#cb24-940" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-941"><a href="#cb24-941" aria-hidden="true" tabindex="-1"></a><span class="in">// Convert hyperbolic length to Euclidean position</span></span>
<span id="cb24-942"><a href="#cb24-942" aria-hidden="true" tabindex="-1"></a><span class="in">// (This requires careful geometric work!)</span></span>
<span id="cb24-943"><a href="#cb24-943" aria-hidden="true" tabindex="-1"></a><span class="in">float eucH = sin(PI/p) * exp(sr);</span></span>
<span id="cb24-944"><a href="#cb24-944" aria-hidden="true" tabindex="-1"></a><span class="in">float want = eucH / tan(PI/q);</span></span>
<span id="cb24-945"><a href="#cb24-945" aria-hidden="true" tabindex="-1"></a><span class="in">// ... compute geodesic endpoints</span></span>
<span id="cb24-946"><a href="#cb24-946" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-947"><a href="#cb24-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-948"><a href="#cb24-948" aria-hidden="true" tabindex="-1"></a>**Deliverable**: Working tilings for at least two different $(p,q,r)$ groups. Include screenshots showing the different symmetry structures. Document any interesting observations about how the tilings differ.</span>
<span id="cb24-949"><a href="#cb24-949" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-950"><a href="#cb24-950" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-951"><a href="#cb24-951" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-952"><a href="#cb24-952" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional Exercise: Unified Abstractions</span></span>
<span id="cb24-953"><a href="#cb24-953" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-954"><a href="#cb24-954" aria-hidden="true" tabindex="-1"></a>**Part 1: Unified HalfSpace Struct**</span>
<span id="cb24-955"><a href="#cb24-955" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-956"><a href="#cb24-956" aria-hidden="true" tabindex="-1"></a>Create a struct that handles BOTH Euclidean and hyperbolic half-spaces:</span>
<span id="cb24-957"><a href="#cb24-957" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-958"><a href="#cb24-958" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb24-959"><a href="#cb24-959" aria-hidden="true" tabindex="-1"></a><span class="in">    int type;  // 0=Euclidean line, 1=vertical hyperbolic, 2=circular hyperbolic</span></span>
<span id="cb24-960"><a href="#cb24-960" aria-hidden="true" tabindex="-1"></a><span class="in">    // Parameters for all cases</span></span>
<span id="cb24-961"><a href="#cb24-961" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c, side;  // Euclidean line</span></span>
<span id="cb24-962"><a href="#cb24-962" aria-hidden="true" tabindex="-1"></a><span class="in">    float x_pos;          // Vertical hyperbolic</span></span>
<span id="cb24-963"><a href="#cb24-963" aria-hidden="true" tabindex="-1"></a><span class="in">    float p, q;           // Circular hyperbolic</span></span>
<span id="cb24-964"><a href="#cb24-964" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb24-965"><a href="#cb24-965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-966"><a href="#cb24-966" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, HalfSpace hs) {</span></span>
<span id="cb24-967"><a href="#cb24-967" aria-hidden="true" tabindex="-1"></a><span class="in">    if(hs.type == 0) {</span></span>
<span id="cb24-968"><a href="#cb24-968" aria-hidden="true" tabindex="-1"></a><span class="in">        // Euclidean reflection (your existing code)</span></span>
<span id="cb24-969"><a href="#cb24-969" aria-hidden="true" tabindex="-1"></a><span class="in">    } else if(hs.type == 1) {</span></span>
<span id="cb24-970"><a href="#cb24-970" aria-hidden="true" tabindex="-1"></a><span class="in">        // Vertical hyperbolic reflection</span></span>
<span id="cb24-971"><a href="#cb24-971" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb24-972"><a href="#cb24-972" aria-hidden="true" tabindex="-1"></a><span class="in">        // Circular hyperbolic reflection</span></span>
<span id="cb24-973"><a href="#cb24-973" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb24-974"><a href="#cb24-974" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-975"><a href="#cb24-975" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-976"><a href="#cb24-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-977"><a href="#cb24-977" aria-hidden="true" tabindex="-1"></a>**Part 2: Triangle Struct**</span>
<span id="cb24-978"><a href="#cb24-978" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-979"><a href="#cb24-979" aria-hidden="true" tabindex="-1"></a>Once you have a unified <span class="in">`HalfSpace`</span>, create:</span>
<span id="cb24-980"><a href="#cb24-980" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb24-981"><a href="#cb24-981" aria-hidden="true" tabindex="-1"></a><span class="in">struct Triangle {</span></span>
<span id="cb24-982"><a href="#cb24-982" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace a, b, c;</span></span>
<span id="cb24-983"><a href="#cb24-983" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb24-984"><a href="#cb24-984" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-985"><a href="#cb24-985" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, Triangle T) {</span></span>
<span id="cb24-986"><a href="#cb24-986" aria-hidden="true" tabindex="-1"></a><span class="in">    p = reflectInto(p, T.a);</span></span>
<span id="cb24-987"><a href="#cb24-987" aria-hidden="true" tabindex="-1"></a><span class="in">    p = reflectInto(p, T.b);</span></span>
<span id="cb24-988"><a href="#cb24-988" aria-hidden="true" tabindex="-1"></a><span class="in">    p = reflectInto(p, T.c);</span></span>
<span id="cb24-989"><a href="#cb24-989" aria-hidden="true" tabindex="-1"></a><span class="in">    return p;</span></span>
<span id="cb24-990"><a href="#cb24-990" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb24-991"><a href="#cb24-991" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb24-992"><a href="#cb24-992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-993"><a href="#cb24-993" aria-hidden="true" tabindex="-1"></a>Now your folding loop is just <span class="in">`p = reflectInto(p, T)`</span> for ANY geometry—Euclidean or hyperbolic!</span>
<span id="cb24-994"><a href="#cb24-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-995"><a href="#cb24-995" aria-hidden="true" tabindex="-1"></a>**Goal**: This exercise teaches abstraction and code organization. You're building a single interface that works across multiple geometries, which is exactly how mathematical software should be structured.</span>
<span id="cb24-996"><a href="#cb24-996" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-997"><a href="#cb24-997" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-998"><a href="#cb24-998" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-999"><a href="#cb24-999" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional: Decorated Tiles</span></span>
<span id="cb24-1000"><a href="#cb24-1000" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1001"><a href="#cb24-1001" aria-hidden="true" tabindex="-1"></a>Add patterns within the fundamental domain (Escher-style):</span>
<span id="cb24-1002"><a href="#cb24-1002" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1003"><a href="#cb24-1003" aria-hidden="true" tabindex="-1"></a>**Ideas**:</span>
<span id="cb24-1004"><a href="#cb24-1004" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Draw curves using distance from edges</span>
<span id="cb24-1005"><a href="#cb24-1005" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Create radial patterns from vertices</span>
<span id="cb24-1006"><a href="#cb24-1006" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Use hyperbolic distance to create concentric patterns</span>
<span id="cb24-1007"><a href="#cb24-1007" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The pattern repeats automatically via reflections!</span>
<span id="cb24-1008"><a href="#cb24-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1009"><a href="#cb24-1009" aria-hidden="true" tabindex="-1"></a>**Challenge**: Create a tessellation that looks like Escher's *Circle Limit* prints—fish or angels that tile the hyperbolic plane!</span>
<span id="cb24-1010"><a href="#cb24-1010" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1011"><a href="#cb24-1011" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb24-1012"><a href="#cb24-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1013"><a href="#cb24-1013" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional: Pentagon Tilings</span></span>
<span id="cb24-1014"><a href="#cb24-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1015"><a href="#cb24-1015" aria-hidden="true" tabindex="-1"></a>Right-angled pentagons can tile hyperbolic space (impossible in Euclidean geometry!).</span>
<span id="cb24-1016"><a href="#cb24-1016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1017"><a href="#cb24-1017" aria-hidden="true" tabindex="-1"></a>**Setup**: Create five geodesics that all meet their neighbors at right angles and enclose a bounded region.</span>
<span id="cb24-1018"><a href="#cb24-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1019"><a href="#cb24-1019" aria-hidden="true" tabindex="-1"></a>**Challenge**: Computing geodesic positions given side lengths is complex. Start with a vertical line and a semicircle at right angles, then add three more geodesics using the constraint that adjacent geodesics meet orthogonally.</span>
<span id="cb24-1020"><a href="#cb24-1020" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-1021"><a href="#cb24-1021" aria-hidden="true" tabindex="-1"></a>**Reward**: Pentagons give very different aesthetic patterns than triangles!</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>