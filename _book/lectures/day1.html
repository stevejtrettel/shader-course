<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Day 1: Introduction to Shader Programming – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../lectures/day2.html" rel="next">
<link href="../outline.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e62aa0a8c28b52a0e19b1cebeabd7fd3.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-f0463eacbf7faa50df92658b97a72515.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e62aa0a8c28b52a0e19b1cebeabd7fd3.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-8dac8edbcb53bfd9d06979fcd2049297.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-12e35c1957ac53844ba804103a0e9c05.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-8dac8edbcb53bfd9d06979fcd2049297.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/day1.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/stevejtrettel/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day1.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day1-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 1</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day2-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 2</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day3-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">1.1</span> Overview</a></li>
  <li><a href="#what-is-a-shader" id="toc-what-is-a-shader" class="nav-link" data-scroll-target="#what-is-a-shader"><span class="header-section-number">1.2</span> What is a Shader?</a>
  <ul class="collapse">
  <li><a href="#mathematical-perspective" id="toc-mathematical-perspective" class="nav-link" data-scroll-target="#mathematical-perspective">Mathematical Perspective</a></li>
  <li><a href="#why-shadertoy" id="toc-why-shadertoy" class="nav-link" data-scroll-target="#why-shadertoy">Why Shadertoy?</a></li>
  </ul></li>
  <li><a href="#first-shader-solid-colors" id="toc-first-shader-solid-colors" class="nav-link" data-scroll-target="#first-shader-solid-colors"><span class="header-section-number">1.3</span> First Shader: Solid Colors</a>
  <ul class="collapse">
  <li><a href="#basic-structure" id="toc-basic-structure" class="nav-link" data-scroll-target="#basic-structure">Basic Structure</a></li>
  <li><a href="#example-red-screen" id="toc-example-red-screen" class="nav-link" data-scroll-target="#example-red-screen">Example: Red Screen</a></li>
  <li><a href="#glsl-syntax-basics" id="toc-glsl-syntax-basics" class="nav-link" data-scroll-target="#glsl-syntax-basics">GLSL Syntax Basics</a></li>
  <li><a href="#animating-with-time" id="toc-animating-with-time" class="nav-link" data-scroll-target="#animating-with-time">Animating with Time</a></li>
  </ul></li>
  <li><a href="#coordinate-systems" id="toc-coordinate-systems" class="nav-link" data-scroll-target="#coordinate-systems"><span class="header-section-number">1.4</span> Coordinate Systems</a>
  <ul class="collapse">
  <li><a href="#raw-coordinates" id="toc-raw-coordinates" class="nav-link" data-scroll-target="#raw-coordinates">Raw Coordinates</a></li>
  <li><a href="#centered-normalized-coordinates" id="toc-centered-normalized-coordinates" class="nav-link" data-scroll-target="#centered-normalized-coordinates">Centered, Normalized Coordinates</a></li>
  <li><a href="#visualizing-coordinates" id="toc-visualizing-coordinates" class="nav-link" data-scroll-target="#visualizing-coordinates">Visualizing Coordinates</a></li>
  </ul></li>
  <li><a href="#conditional-coloring-half-planes" id="toc-conditional-coloring-half-planes" class="nav-link" data-scroll-target="#conditional-coloring-half-planes"><span class="header-section-number">1.5</span> Conditional Coloring: Half-Planes</a>
  <ul class="collapse">
  <li><a href="#the-concept" id="toc-the-concept" class="nav-link" data-scroll-target="#the-concept">The Concept</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  <li><a href="#the-step-function" id="toc-the-step-function" class="nav-link" data-scroll-target="#the-step-function">The Step Function</a></li>
  <li><a href="#arbitrary-half-planes" id="toc-arbitrary-half-planes" class="nav-link" data-scroll-target="#arbitrary-half-planes">Arbitrary Half-Planes</a></li>
  </ul></li>
  <li><a href="#distance-fields-and-circles" id="toc-distance-fields-and-circles" class="nav-link" data-scroll-target="#distance-fields-and-circles"><span class="header-section-number">1.6</span> Distance Fields and Circles</a>
  <ul class="collapse">
  <li><a href="#distance-to-center" id="toc-distance-to-center" class="nav-link" data-scroll-target="#distance-to-center">Distance to Center</a></li>
  <li><a href="#filled-circle" id="toc-filled-circle" class="nav-link" data-scroll-target="#filled-circle">Filled Circle</a></li>
  <li><a href="#distance-based-coloring" id="toc-distance-based-coloring" class="nav-link" data-scroll-target="#distance-based-coloring">Distance-Based Coloring</a></li>
  <li><a href="#circle-outline" id="toc-circle-outline" class="nav-link" data-scroll-target="#circle-outline">Circle Outline</a></li>
  </ul></li>
  <li><a href="#grids-and-repetition" id="toc-grids-and-repetition" class="nav-link" data-scroll-target="#grids-and-repetition"><span class="header-section-number">1.7</span> Grids and Repetition</a>
  <ul class="collapse">
  <li><a href="#modular-arithmetic" id="toc-modular-arithmetic" class="nav-link" data-scroll-target="#modular-arithmetic">Modular Arithmetic</a></li>
  <li><a href="#creating-a-grid" id="toc-creating-a-grid" class="nav-link" data-scroll-target="#creating-a-grid">Creating a Grid</a></li>
  <li><a href="#alternating-pattern" id="toc-alternating-pattern" class="nav-link" data-scroll-target="#alternating-pattern">Alternating Pattern</a></li>
  <li><a href="#combining-with-circles" id="toc-combining-with-circles" class="nav-link" data-scroll-target="#combining-with-circles">Combining with Circles</a></li>
  </ul></li>
  <li><a href="#implicit-curves" id="toc-implicit-curves" class="nav-link" data-scroll-target="#implicit-curves"><span class="header-section-number">1.8</span> Implicit Curves</a>
  <ul class="collapse">
  <li><a href="#general-principle" id="toc-general-principle" class="nav-link" data-scroll-target="#general-principle">General Principle</a></li>
  <li><a href="#example-parabola" id="toc-example-parabola" class="nav-link" data-scroll-target="#example-parabola">Example: Parabola</a></li>
  <li><a href="#example-circle-implicit-form" id="toc-example-circle-implicit-form" class="nav-link" data-scroll-target="#example-circle-implicit-form">Example: Circle (Implicit Form)</a></li>
  <li><a href="#more-examples" id="toc-more-examples" class="nav-link" data-scroll-target="#more-examples">More Examples</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">1.9</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">1.10</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-parabola-graphing-calculator" id="toc-required-parabola-graphing-calculator" class="nav-link" data-scroll-target="#required-parabola-graphing-calculator">Required: Parabola Graphing Calculator</a></li>
  <li><a href="#optional-1-animated-curve-family" id="toc-optional-1-animated-curve-family" class="nav-link" data-scroll-target="#optional-1-animated-curve-family">Optional #1: Animated Curve Family</a></li>
  <li><a href="#optional-2-beautiful-tiling-pattern" id="toc-optional-2-beautiful-tiling-pattern" class="nav-link" data-scroll-target="#optional-2-beautiful-tiling-pattern">Optional #2: Beautiful Tiling Pattern</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">1.11</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">1.1</span> Overview</h2>
<p>Today we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.</p>
<p>By the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Roadmap for Today
</div>
</div>
<div class="callout-body-container callout-body">
<p>We’ll build up shader programming in layers:</p>
<ol type="1">
<li><strong>Core concept</strong>: Shaders as parallel functions (What is a Shader?)</li>
<li><strong>Setup</strong>: Coordinate systems and GLSL syntax (First Shader, Coordinate Systems)</li>
<li><strong>Basic techniques</strong>: Conditional coloring and distance fields (Half-Planes, Distance Fields)<br>
</li>
<li><strong>Repetition</strong>: Grids via modular arithmetic (Grids and Repetition)</li>
<li><strong>Application</strong>: Implicit curves (Implicit Curves)</li>
</ol>
<p>Each section builds on the previous, so if something feels unclear, it’s worth revisiting earlier material before moving forward.</p>
</div>
</div>
<hr>
</section>
<section id="what-is-a-shader" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="what-is-a-shader"><span class="header-section-number">1.2</span> What is a Shader?</h2>
<section id="mathematical-perspective" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-perspective">Mathematical Perspective</h3>
<p>A shader is fundamentally a function <span class="math display">\[f: \mathbb{R}^2 \times \mathbb{R} \times \cdots \to [0,1]^4\]</span> that maps pixel coordinates <span class="math inline">\((x,y)\)</span>, time <span class="math inline">\(t\)</span>, and potentially other parameters to RGBA color values. For today, we’ll focus on the spatial dependence—thinking of the shader as a function <span class="math inline">\(f: \mathbb{R}^2 \to [0,1]^4\)</span> that assigns a color to each point in the plane. The domain <span class="math inline">\([0,1]^4\)</span> represents the red, green, blue, and alpha (transparency) channels, each normalized to the unit interval.</p>
<p>Here’s the magic: modern GPUs can evaluate this function for <strong>all pixels simultaneously</strong>. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!</p>
<p>This is completely different from how you might write mathematical visualization code in, say, Python or MATLAB. There you’d have nested loops:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(width):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(height):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        color[x,y] <span class="op">=</span> f(x, y)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>With shaders, there are no loops. You write the function <span class="math inline">\(f\)</span>, and the GPU just <em>does it</em> everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.</p>
<p>The computational model is fundamentally different: in traditional CPU programming you have sequential control flow with explicit loops, while in shader programming you express computation as a pure mathematical function that gets evaluated independently at every pixel. The GPU architecture is specifically designed for this kind of massively parallel workload—it has thousands of small processors that can each evaluate your function simultaneously. This is why a relatively modest GPU can outperform even a powerful CPU on graphics tasks by orders of magnitude.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Why is this called a “shader”?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Historically, these programs were used for <em>shading</em> 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!</p>
</div>
</div>
</section>
<section id="why-shadertoy" class="level3">
<h3 class="anchored" data-anchor-id="why-shadertoy">Why Shadertoy?</h3>
<p>Shadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.</p>
<p>Shadertoy launched in 2013, created by Pol Jeremias-Vila and Íñigo Quílez (we’ll see more of Íñigo’s work throughout this week—he’s pioneered many shader techniques). Before platforms like Shadertoy, shader programming required managing the entire OpenGL or DirectX pipeline yourself—compiling shaders, linking programs, setting up vertex buffers, managing textures. It was the domain of graphics programmers, not mathematicians.</p>
<p>The genius of Shadertoy was recognizing that for many visualizations, you don’t need that complexity. Just give people a function to fill in, handle the boilerplate invisibly, and suddenly shaders become accessible to anyone. It’s democratized GPU programming in much the same way that Python notebooks democratized scientific computing—lower the barrier to entry, and a whole new community emerges.</p>
<p>The platform provides several built-in <strong>uniforms</strong> (read-only global variables that are the same for all pixels):</p>
<ul>
<li><code>iResolution</code>: screen resolution as a <code>vec3</code> (width, height, pixel aspect ratio)</li>
<li><code>iTime</code>: elapsed time in seconds since the shader started</li>
<li><code>iMouse</code>: mouse position and click state as a <code>vec4</code></li>
</ul>
<p>We’ll use these throughout the week to create animated, interactive mathematical visualizations.</p>
<hr>
</section>
</section>
<section id="first-shader-solid-colors" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="first-shader-solid-colors"><span class="header-section-number">1.3</span> First Shader: Solid Colors</h2>
<section id="basic-structure" class="level3">
<h3 class="anchored" data-anchor-id="basic-structure">Basic Structure</h3>
<p>Every Shadertoy shader has the same entry point:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Your code here</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fragCoord</code>: the pixel coordinate we’re currently computing, as a <code>vec2</code> giving the <span class="math inline">\((x, y)\)</span> position</li>
<li><code>fragColor</code>: the output color we need to set, as a <code>vec4</code> giving the <span class="math inline">\((r, g, b, a)\)</span> color</li>
</ul>
<p>Colors are represented in RGBA format with values in <span class="math inline">\([0, 1]\)</span>. So <code>vec4(1.0, 0.0, 0.0, 1.0)</code> represents opaque red, while <code>vec4(0.5, 0.5, 0.5, 1.0)</code> is middle gray.</p>
</section>
<section id="example-red-screen" class="level3">
<h3 class="anchored" data-anchor-id="example-red-screen">Example: Red Screen</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on <code>fragCoord</code>, every pixel gets the same value. Not very exciting—but it’s a start!</p>
</section>
<section id="glsl-syntax-basics" class="level3">
<h3 class="anchored" data-anchor-id="glsl-syntax-basics">GLSL Syntax Basics</h3>
<p>Before we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>GLSL Syntax Rules
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Semicolons are required.</strong> Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.</p>
<p><strong>Floating point literals:</strong> Write <code>1.0</code> not <code>1</code> for floating point values. GLSL is very picky about types—if you write <code>1</code>, it’s an integer, and mixing types causes errors. Get in the habit of always writing the <code>.0</code>.</p>
<p><strong>Vector types:</strong> GLSL has built-in types <code>vec2</code>, <code>vec3</code>, <code>vec4</code> for 2D, 3D, and 4D vectors. You can construct them with:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> w <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec4</span> color <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>v<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Can combine vectors and scalars</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Swizzling:</strong> You can access components by name: <code>v.x</code>, <code>v.y</code> or equivalently <code>v.r</code>, <code>v.g</code> (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: <code>v.yx</code> swaps the coordinates, <code>v.xxx</code> repeats the x-component three times. This is incredibly useful!</p>
</div>
</div>
</section>
<section id="animating-with-time" class="level3">
<h3 class="anchored" data-anchor-id="animating-with-time">Animating with Time</h3>
<p>Let’s make something that changes:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> red <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>red<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>iTime</code> grows continuously, <code>sin(iTime)</code> oscillates between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>, and we remap this to <span class="math inline">\([0, 1]\)</span> with the affine transformation <span class="math inline">\(t \mapsto \frac{1}{2}(1 + t)\)</span>. The screen now pulses between black and red!</p>
<p>This pattern—<code>0.5 + 0.5 * sin(...)</code>—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range <span class="math inline">\([0,1]\)</span>. You’ll use this so often it becomes second nature.</p>
<hr>
</section>
</section>
<section id="coordinate-systems" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="coordinate-systems"><span class="header-section-number">1.4</span> Coordinate Systems</h2>
<section id="raw-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="raw-coordinates">Raw Coordinates</h3>
<p>By default, <code>fragCoord</code> gives pixel coordinates with:</p>
<ul>
<li>Origin <span class="math inline">\((0, 0)\)</span> at the bottom-left</li>
<li><span class="math inline">\(x\)</span> increases rightward to <code>iResolution.x</code></li>
<li><span class="math inline">\(y\)</span> increases upward to <code>iResolution.y</code></li>
</ul>
<p>This is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!</p>
</section>
<section id="centered-normalized-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="centered-normalized-coordinates">Centered, Normalized Coordinates</h3>
<p>Here’s the standard transformation we’ll use in every shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Normalize to [0,1]</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Center at origin: [-0.5, 0.5]</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to account for aspect ratio</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now uv is centered and aspect-corrected</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to desired viewing window (e.g., [-2, 2] on x-axis)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span>  </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Let’s understand this transformation rigorously. We’re composing four maps. Let’s write <span class="math inline">\(w =\)</span> <code>iResolution.x</code> and <span class="math inline">\(h =\)</span> <code>iResolution.y</code> for the width and height in pixels.</p>
<p><strong>Step 1: Normalization</strong> <span class="math display">\[T_1: [0, w] \times [0, h] \to [0,1]^2, \quad T_1(x,y) = \left(\frac{x}{w}, \frac{y}{h}\right)\]</span></p>
<p>This makes our coordinates resolution-independent—the same shader code works whether your screen is 1920×1080 or 800×600. A point that’s halfway across the screen is <span class="math inline">\((0.5, v)\)</span> regardless of how many pixels wide the screen actually is.</p>
<p><strong>Step 2: Centering</strong> <span class="math display">\[T_2: [0,1]^2 \to [-\tfrac{1}{2}, \tfrac{1}{2}]^2, \quad T_2(u,v) = (u - \tfrac{1}{2}, v - \tfrac{1}{2})\]</span></p>
<p>Now the origin is at the center of the screen, which is much more natural for mathematical work. We can think about positive and negative coordinates, circles centered at the origin, and so on.</p>
<p><strong>Step 3: Aspect correction</strong> <span class="math display">\[T_3(u,v) = \left(\frac{w}{h} \cdot u, v\right)\]</span></p>
<p>This is crucial! Without it, circles would appear as ellipses on non-square screens. The aspect ratio <span class="math inline">\(w/h\)</span> stretches the <span class="math inline">\(x\)</span>-coordinate so that one unit in <span class="math inline">\(x\)</span> corresponds to the same screen distance as one unit in <span class="math inline">\(y\)</span>. On a typical 16:9 display (<span class="math inline">\(w/h \approx 1.78\)</span>), this means the <span class="math inline">\(x\)</span>-axis spans a wider range than the <span class="math inline">\(y\)</span>-axis—as it should to maintain equal scaling. A circle of radius <span class="math inline">\(r\)</span> will actually appear circular on screen, not squashed.</p>
<p><strong>Step 4: Scaling to viewing window</strong> <span class="math display">\[T_4(u,v) = s \cdot (u,v)\]</span></p>
<p>Finally, we scale by whatever factor gives us the mathematical viewing window we want. If we choose <span class="math inline">\(s = 4\)</span>, then on a 16:9 screen our coordinates range roughly from <span class="math inline">\([-3.56, 3.56]\)</span> in <span class="math inline">\(x\)</span> and <span class="math inline">\([-2, 2]\)</span> in <span class="math inline">\(y\)</span>—notice the <span class="math inline">\(x\)</span>-range is wider to match the screen aspect ratio.</p>
<p>The composition <span class="math inline">\(T_4 \circ T_3 \circ T_2 \circ T_1\)</span> is our complete coordinate transformation, taking us from raw pixel coordinates to a centered, aspect-corrected mathematical coordinate system.</p>
<p>From now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable <code>p</code> for “position.”</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>The coordinate transformation boilerplate
</div>
</div>
<div class="callout-body-container callout-body">
<p>You’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit and you can modify it when needed.</p>
</div>
</div>
</section>
<section id="visualizing-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-coordinates">Visualizing Coordinates</h3>
<p>Let’s verify our coordinate system is working by coloring pixels according to their position:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map x coordinate to red, y to green</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> color_rg <span class="op">=</span> p <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Remap to [0, 1]</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color_rg<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup! This is a good debugging technique—whenever you’re unsure about your coordinates, visualize them directly as colors.</p>
<hr>
</section>
</section>
<section id="conditional-coloring-half-planes" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="conditional-coloring-half-planes"><span class="header-section-number">1.5</span> Conditional Coloring: Half-Planes</h2>
<section id="the-concept" class="level3">
<h3 class="anchored" data-anchor-id="the-concept">The Concept</h3>
<p>Given a linear function <span class="math inline">\(L(x, y) = ax + by + c\)</span>, we want to color pixels differently depending on whether <span class="math inline">\(L(p) &lt; 0\)</span> or <span class="math inline">\(L(p) \geq 0\)</span>. This divides the plane into two half-planes—the regions where the function is negative versus positive.</p>
<p>The line itself is the zero set: <span class="math inline">\(\{(x,y) : L(x,y) = 0\}\)</span>. This is the boundary between the two regions.</p>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>GLSL provides a conditional operator (ternary operator) just like C:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> L <span class="op">=</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span>  <span class="co">// The function L(x,y) = x</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>L <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Left half-plane is red, right half-plane is blue. The syntax <code>(condition) ? value_if_true : value_if_false</code> should be familiar if you’ve programmed in C, Java, or JavaScript.</p>
</section>
<section id="the-step-function" class="level3">
<h3 class="anchored" data-anchor-id="the-step-function">The Step Function</h3>
<p>GLSL also provides <code>step(edge, x)</code> which returns <span class="math inline">\(0\)</span> if <span class="math inline">\(x &lt; \text{edge}\)</span> and <span class="math inline">\(1\)</span> otherwise. The name comes from its graph—a step function in the calculus sense, jumping discontinuously from 0 to 1 at the edge value. This is useful for writing cleaner code without explicit conditionals:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> s <span class="op">=</span> <span class="bu">step</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> p<span class="op">.</span><span class="fu">x</span><span class="op">);</span>  <span class="co">// 0 on left, 1 on right</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span> s<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>mix(a, b, t)</code> performs linear interpolation: <span class="math inline">\((1-t)a + tb\)</span>. So when <code>s = 0</code> we get pure red, when <code>s = 1</code> we get pure blue. The <code>mix</code> function is one of GLSL’s most useful tools—you’ll use it constantly for blending colors, smoothly transitioning between values, and implementing linear interpolation in all sorts of contexts.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Why use <code>step</code> instead of the ternary operator?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Both work fine! The ternary operator <code>?:</code> is more explicit and familiar if you know C-like languages. But <code>step</code> and <code>mix</code> are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation. For now, use whichever makes sense to you.</p>
</div>
</div>
</section>
<section id="arbitrary-half-planes" class="level3">
<h3 class="anchored" data-anchor-id="arbitrary-half-planes">Arbitrary Half-Planes</h3>
<p>For a general line <span class="math inline">\(ax + by + c = 0\)</span>, we just evaluate the corresponding linear function:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> b <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> c <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> L <span class="op">=</span> a <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> b <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>L <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Try different values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(c\)</span> to see different line orientations and positions. The line itself is where <span class="math inline">\(L = 0\)</span>, and we’re coloring the two sides differently. Notice that scaling <span class="math inline">\((a,b,c)\)</span> by a positive constant doesn’t change the geometry—it’s the zero set that matters, not the specific values of the function away from zero.</p>
<hr>
</section>
</section>
<section id="distance-fields-and-circles" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="distance-fields-and-circles"><span class="header-section-number">1.6</span> Distance Fields and Circles</h2>
<section id="distance-to-center" class="level3">
<h3 class="anchored" data-anchor-id="distance-to-center">Distance to Center</h3>
<p>The distance from a point <span class="math inline">\(p = (x, y)\)</span> to the origin is just the usual Euclidean distance: <span class="math display">\[d = \|p\| = \sqrt{x^2 + y^2}\]</span></p>
<p>In GLSL this is built-in:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>length()</code> function computes the Euclidean norm of a vector. It works for <code>vec2</code>, <code>vec3</code>, <code>vec4</code>—whatever you need. Under the hood it’s computing the square root of the dot product of the vector with itself, but there’s no need to write that out explicitly.</p>
</section>
<section id="filled-circle" class="level3">
<h3 class="anchored" data-anchor-id="filled-circle">Filled Circle</h3>
<p>A circle of radius <span class="math inline">\(r\)</span> centered at the origin is the set <span class="math inline">\(\{p : \|p\| &lt; r\}\)</span>—just points whose distance from the origin is less than <span class="math inline">\(r\)</span>. So to color the inside versus outside of a circle, we just compare distances:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>That’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle. Simple, elegant, and fast—millions of distance calculations per frame, all happening in parallel.</p>
</section>
<section id="distance-based-coloring" class="level3">
<h3 class="anchored" data-anchor-id="distance-based-coloring">Distance-Based Coloring</h3>
<p>But we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> intensity <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> d <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span>  <span class="co">// Fades from 1 at center to 0 at distance 2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>intensity <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span>intensity<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Keep it in [0, 1]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>intensity<span class="op">);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This creates a radial gradient—bright at the center, dark at the edges. The <code>clamp</code> function ensures we stay within <span class="math inline">\([0,1]\)</span> even if our formula would produce values outside that range. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!</p>
<p>Distance fields will become increasingly important as the week progresses. On Day 4, we’ll use them as the foundation for <strong>raymarching</strong>—a technique for rendering 3D geometry without any triangles or polygons, purely by iteratively evaluating distance functions. The <code>length(p)</code> function we used for circles today generalizes to arbitrary implicit surfaces: $d(p) = $ “distance to the surface defined by <span class="math inline">\(F(p) = 0\)</span>.” It’s a beautiful connection between analysis and computer graphics.</p>
</section>
<section id="circle-outline" class="level3">
<h3 class="anchored" data-anchor-id="circle-outline">Circle Outline</h3>
<p>What if we want to draw just the <em>boundary</em> of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is <em>approximately equal</em> to the radius. Mathematically, we’re coloring the set <span class="math inline">\(\{p : |d(p) - r| &lt; \epsilon\}\)</span> where <span class="math inline">\(\epsilon\)</span> is a small thickness parameter:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> circle_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>d <span class="op">-</span> r<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>circle_mask<span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This draws a thin white annulus around the circle. Play with the <code>thickness</code> parameter to see how it affects the line width!</p>
<p>For a smoother, anti-aliased edge, GLSL provides <code>smoothstep</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> circle_mask <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> <span class="bu">smoothstep</span><span class="op">(</span>r <span class="op">-</span> thickness<span class="op">,</span> r <span class="op">+</span> thickness<span class="op">,</span> d<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>smoothstep(a, b, x)</code> function performs smooth Hermite interpolation. For <span class="math inline">\(x \in [a,b]\)</span>, it returns <span class="math display">\[s(t) = 3t^2 - 2t^3 \quad \text{where } t = \frac{x-a}{b-a}\]</span></p>
<p>This is a cubic polynomial with <span class="math inline">\(s(0) = 0\)</span>, <span class="math inline">\(s(1) = 1\)</span>, and crucially <span class="math inline">\(s'(0) = s'(1) = 0\)</span>—the zero derivatives at the endpoints mean it transitions smoothly without visible “kinks.” For <span class="math inline">\(x &lt; a\)</span> it returns <span class="math inline">\(0\)</span>, for <span class="math inline">\(x &gt; b\)</span> it returns <span class="math inline">\(1\)</span>.</p>
<p>The result is anti-aliasing: instead of a hard transition at a single pixel, the edge is blurred over the interval <span class="math inline">\([a,b]\)</span>. For circle outlines, using <code>smoothstep(r - thickness, r + thickness, d)</code> creates a smooth transition zone of width <span class="math inline">\(2 \cdot \text{thickness}\)</span> around the target radius. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Anti-aliasing in shaders
</div>
</div>
<div class="callout-body-container callout-body">
<p>The harsh cutoffs from using <code>&lt;</code> or the ternary operator create jagged, pixelated edges—what computer graphics people call “aliasing” (the signal is being undersampled relative to its frequency content, creating artifacts). Functions like <code>smoothstep</code> give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with <code>smoothstep</code> for smoother results.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="grids-and-repetition" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="grids-and-repetition"><span class="header-section-number">1.7</span> Grids and Repetition</h2>
<section id="modular-arithmetic" class="level3">
<h3 class="anchored" data-anchor-id="modular-arithmetic">Modular Arithmetic</h3>
<p>The modulo operation creates periodic repetition. For a period <span class="math inline">\(T\)</span>, the function <span class="math inline">\(p \mapsto (p \bmod T) - T/2\)</span> maps <span class="math inline">\(\mathbb{R}\)</span> to <span class="math inline">\([-T/2, T/2]\)</span> repeatedly—it “folds” the entire real line into a finite interval over and over again.</p>
<p>More precisely, recall that <span class="math inline">\(x \bmod T\)</span> is the unique value in <span class="math inline">\([0, T)\)</span> satisfying <span class="math inline">\(x \equiv r \pmod{T}\)</span>—that is, <span class="math inline">\(x = nT + r\)</span> for some integer <span class="math inline">\(n\)</span>. Geometrically, this takes the real line and wraps it into the interval <span class="math inline">\([0,T)\)</span>. Subtracting <span class="math inline">\(T/2\)</span> recenters this to <span class="math inline">\([-T/2, T/2]\)</span>.</p>
<p>In GLSL, <code>mod(x, T)</code> computes <span class="math inline">\(x \bmod T\)</span>. This is one of the most powerful tools in shader programming!</p>
</section>
<section id="creating-a-grid" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-grid">Creating a Grid</h3>
<p>To create a grid of repeated cells, we apply <code>mod</code> to our coordinates:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> spacing <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>p <span class="op">+</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">,</span> spacing<span class="op">)</span> <span class="op">-</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now cell_p repeats every spacing units</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a circle in each cell</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>cell_p<span class="op">);</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This creates an infinite grid of yellow circles! The coordinate transformation <code>cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0</code> ensures that <code>cell_p</code> is always in the range <span class="math inline">\([-\text{spacing}/2, \text{spacing}/2]\)</span>, and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.</p>
<p>Think about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation.</p>
<p>Compare this to how you might approach this in Python or MATLAB: you’d probably set up a nested loop over grid cells, compute the center of each cell, then draw a circle there. That’s <span class="math inline">\(O(n^2)\)</span> work for an <span class="math inline">\(n \times n\)</span> grid. With shaders, it’s <span class="math inline">\(O(1)\)</span> in the grid size—the cost is entirely in the number of <em>pixels</em>, not the number of <em>circles</em>. This is why shaders can render infinitely complex patterns at the same framerate as simple ones.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>The power of <code>mod</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>This computational efficiency through coordinate transformations is a recurring theme in shader programming. You’ll see it again when we talk about domain repetition for fractals (Day 2), symmetry groups for hyperbolic tilings (Day 3), and space folding for raymarched scenes (Day 4). The key insight is always the same: instead of explicitly iterating over instances, transform the coordinate system so that all instances share the same local coordinates.</p>
</div>
</div>
</section>
<section id="alternating-pattern" class="level3">
<h3 class="anchored" data-anchor-id="alternating-pattern">Alternating Pattern</h3>
<p>We can create checkerboard-like patterns by using the <em>cell index</em> to vary colors. To get the cell index, we divide by the spacing and floor:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">/</span> spacing<span class="op">);</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> checker <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>cell_id<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> cell_id<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color_a <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color_b <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> bg_color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color_a<span class="op">,</span> color_b<span class="op">,</span> checker<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Here <code>floor(p / spacing)</code> gives us integer grid indices <span class="math inline">\((i, j)\)</span>, and we alternate colors based on the parity of <span class="math inline">\(i + j\)</span>. When <span class="math inline">\(i + j\)</span> is even, <code>checker = 0</code> (giving us <code>color_a</code>), when odd, <code>checker = 1</code> (giving us <code>color_b</code>).</p>
<p>Notice the elegant separation: <code>cell_id</code> tells us <em>which</em> cell we’re in, while <code>cell_p</code> tells us <em>where within</em> that cell. This separation of global position and local coordinates is fundamental to working with repeating patterns.</p>
</section>
<section id="combining-with-circles" class="level3">
<h3 class="anchored" data-anchor-id="combining-with-circles">Combining with Circles</h3>
<p>Let’s put it all together—a grid of circles on an alternating background:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> spacing <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">/</span> spacing<span class="op">);</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>p <span class="op">+</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">,</span> spacing<span class="op">)</span> <span class="op">-</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Checkerboard background</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> checker <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>cell_id<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> cell_id<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> bg_color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">),</span> checker<span class="op">);</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle in each cell</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>cell_p<span class="op">);</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> circle_color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> circle_color <span class="op">:</span> bg_color<span class="op">;</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Try varying the <code>spacing</code> and <code>r</code> parameters. What happens if you make the circles larger than the cells? (They overlap across cell boundaries!) What if you use different spacing values for <code>x</code> and <code>y</code>? (You get a rectangular rather than square lattice.) This simple framework is incredibly flexible.</p>
<hr>
</section>
</section>
<section id="implicit-curves" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="implicit-curves"><span class="header-section-number">1.8</span> Implicit Curves</h2>
<section id="general-principle" class="level3">
<h3 class="anchored" data-anchor-id="general-principle">General Principle</h3>
<p>An implicit curve is defined by an equation <span class="math inline">\(F(x, y) = 0\)</span>. Points on the curve satisfy the equation exactly, while points off the curve have <span class="math inline">\(F(x,y) \neq 0\)</span>. To render the curve, we compute <span class="math inline">\(F(p)\)</span> for each pixel and color based on proximity to zero:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="op">[</span>some function of p<span class="op">.</span><span class="fu">x</span> and p<span class="op">.</span><span class="fu">y</span><span class="op">];</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>background<span class="op">,</span> curve_color<span class="op">,</span> curve_mask<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, transcendental curves, whatever you want. If you can write down a formula <span class="math inline">\(F(x,y)\)</span>, you can visualize its zero set.</p>
</section>
<section id="example-parabola" class="level3">
<h3 class="anchored" data-anchor-id="example-parabola">Example: Parabola</h3>
<p>The parabola <span class="math inline">\(y = x^2\)</span> can be written implicitly as <span class="math inline">\(F(x, y) = y - x^2 = 0\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> curve_mask<span class="op">);</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a yellow parabola on a dark blue background. The curve appears wherever <span class="math inline">\(|F(x,y)| &lt; 0.1\)</span>—a thin band around the zero set of <span class="math inline">\(F\)</span>.</p>
<p>One thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker, while in the steep regions it appears thinner. Why does this happen?</p>
<p>We’re thresholding on the <em>value</em> of <span class="math inline">\(F\)</span>, not the <em>geometric distance</em> to the curve. Near the vertex at <span class="math inline">\((0,0)\)</span>, the parabola is nearly horizontal—small changes in <span class="math inline">\(y\)</span> correspond to small changes in <span class="math inline">\(x\)</span>, so the set <span class="math inline">\(\{p : |y - x^2| &lt; \epsilon\}\)</span> is a thick vertical band. But on the steep parts where <span class="math inline">\(|x|\)</span> is large, the parabola is nearly vertical—now the same change in <span class="math inline">\(y\)</span> corresponds to a large change in <span class="math inline">\(x\)</span>, so the band is thin.</p>
<p>To see this more precisely, consider the gradient: <span class="math inline">\(\nabla F = (-2x, 1)\)</span>. Near the vertex this has magnitude close to <span class="math inline">\(1\)</span>, but for large <span class="math inline">\(|x|\)</span> it has magnitude approximately <span class="math inline">\(2|x|\)</span>. The visual thickness is roughly inversely proportional to <span class="math inline">\(|\nabla F|\)</span>—where the gradient is small, the level sets are far apart, and where it’s large, they’re close together.</p>
<p>To get uniform thickness, we’d need the <em>signed distance function</em> to the curve: <span class="math display">\[d(p) = \inf\{\|p - q\| : F(q) = 0\}\]</span></p>
<p>Then thresholding on <span class="math inline">\(|d(p)| &lt; \epsilon\)</span> gives exactly thickness <span class="math inline">\(\epsilon\)</span> everywhere. Computing exact signed distance functions is nontrivial (we’ll see techniques for this on Day 4 when we discuss raymarching), but for many applications the naive thresholding on <span class="math inline">\(|F|\)</span> works fine—especially if you tune the thickness parameter appropriately or use different thickness values in different regions.</p>
</section>
<section id="example-circle-implicit-form" class="level3">
<h3 class="anchored" data-anchor-id="example-circle-implicit-form">Example: Circle (Implicit Form)</h3>
<p>We’ve been using <span class="math inline">\(\|p\| &lt; r\)</span> for filled circles, but we can also write the circle implicitly as <span class="math inline">\(x^2 + y^2 - r^2 = 0\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">)</span> <span class="op">-</span> r <span class="op">*</span> r<span class="op">;</span>  <span class="co">// dot(p,p) = x² + y²</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The <code>dot(p, p)</code> computes <span class="math inline">\(x^2 + y^2\)</span> as a single GPU operation—more efficient than <code>p.x * p.x + p.y * p.y</code> and certainly cleaner than writing it out! For circles, the signed distance function and the implicit function are particularly closely related: <span class="math inline">\(d(p) = |\|p\| - r|\)</span>, so the naive implicit approach actually works quite well.</p>
</section>
<section id="more-examples" class="level3">
<h3 class="anchored" data-anchor-id="more-examples">More Examples</h3>
<p>Let’s look at a few more interesting curves:</p>
<p><strong>Hyperbola</strong>: <span class="math inline">\(xy = 1\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Ellipse</strong>: <span class="math inline">\(\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">2.0</span><span class="op">,</span> b <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span>a <span class="op">*</span> a<span class="op">)</span> <span class="op">+</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span>b <span class="op">*</span> b<span class="op">)</span> <span class="op">-</span> <span class="fl">1.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Lemniscate of Bernoulli</strong>: <span class="math inline">\((x^2 + y^2)^2 = a^2(x^2 - y^2)\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> r2 <span class="op">*</span> r2 <span class="op">-</span> a <span class="op">*</span> a <span class="op">*</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Each of these creates beautiful curves! Try implementing them and experimenting with different parameters.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Implicit curves in your homework
</div>
</div>
<div class="callout-body-container callout-body">
<p>When you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation <span class="math inline">\(F(x,y) = y - (ax^2 + bx + c)\)</span> and thresholding on <span class="math inline">\(|F| &lt; \epsilon\)</span>. Make sure to test with various values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> to ensure your grapher is robust!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="summary" class="level2" data-number="1.9">
<h2 data-number="1.9" class="anchored" data-anchor-id="summary"><span class="header-section-number">1.9</span> Summary</h2>
<p>Today we’ve learned the fundamental tools of shader programming:</p>
<ol type="1">
<li><p><strong>Shaders as parallel functions</strong>: Every pixel evaluates <span class="math inline">\(f(x, y, t, \ldots) \to \text{color}\)</span> simultaneously—no loops required! The computational model is fundamentally different from sequential CPU programming.</p></li>
<li><p><strong>GLSL basics</strong>: Syntax rules (semicolons, <code>.0</code> for floats), vector types (<code>vec2</code>, <code>vec3</code>, <code>vec4</code>), and essential built-in functions like <code>length()</code>, <code>dot()</code>, <code>step()</code>, and <code>smoothstep()</code></p></li>
<li><p><strong>Coordinate systems</strong>: The four-step transformation (normalize, center, aspect-correct, scale) that takes us from pixel coordinates to a mathematical coordinate system suitable for visualization</p></li>
<li><p><strong>Conditional coloring</strong>: Using boolean expressions, the ternary operator, and <code>step()</code> combined with <code>mix()</code> to create discrete color regions based on mathematical predicates</p></li>
<li><p><strong>Distance fields</strong>: Using <code>length()</code> to create circles and radial patterns—the foundation for much more complex techniques we’ll explore on Day 4 with raymarching</p></li>
<li><p><strong>Modular arithmetic</strong>: Creating grids and repeating patterns with <code>mod()</code>—achieving infinite complexity with finite computation through coordinate transformations rather than explicit iteration</p></li>
<li><p><strong>Implicit curves</strong>: Rendering curves defined by <span class="math inline">\(F(x, y) = 0\)</span> by thresholding on <span class="math inline">\(|F|\)</span>—a general technique that works for any curve we can express as an equation, though we must be aware of the non-uniform thickness issue</p></li>
</ol>
<p>With these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today.</p>
<hr>
</section>
<section id="homework" class="level2" data-number="1.10">
<h2 data-number="1.10" class="anchored" data-anchor-id="homework"><span class="header-section-number">1.10</span> Homework</h2>
<section id="required-parabola-graphing-calculator" class="level3">
<h3 class="anchored" data-anchor-id="required-parabola-graphing-calculator">Required: Parabola Graphing Calculator</h3>
<p>Create a shader that draws a customizable parabola <span class="math inline">\(y = ax^2 + bx + c\)</span> along with coordinate axes.</p>
<p><strong>Requirements:</strong></p>
<ul>
<li>Define variables <code>a</code>, <code>b</code>, <code>c</code> at the top of your shader (hardcoded values are fine—we’re not building a GUI yet)</li>
<li>Draw the <span class="math inline">\(x\)</span>-axis and <span class="math inline">\(y\)</span>-axis as thin lines using the implicit line technique: <span class="math inline">\(|y| &lt; \epsilon\)</span> for the <span class="math inline">\(x\)</span>-axis, <span class="math inline">\(|x| &lt; \epsilon\)</span> for the <span class="math inline">\(y\)</span>-axis</li>
<li>Plot the parabola <span class="math inline">\(y = ax^2 + bx + c\)</span> as a thicker curve</li>
<li>Use distinct colors for axes (suggest a neutral gray) and parabola (suggest something bright)</li>
<li>The visualization should work for any reasonable values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>—make sure to test edge cases!</li>
</ul>
<p><strong>What it should look like:</strong> A coordinate plane with thin gray axes, and a colored curve tracing out your parabola. The entire parabola should be visible in your viewing window (you may need to adjust your scaling factor depending on your parameters).</p>
<p><strong>Test cases to verify:</strong> - <span class="math inline">\(a=1, b=0, c=0\)</span> (standard parabola opening upward) - <span class="math inline">\(a=-1, b=0, c=1\)</span> (downward-opening parabola shifted up) - <span class="math inline">\(a=0.5, b=1, c=-0.5\)</span> (general case with all parameters nonzero) - <span class="math inline">\(a=0, b=1, c=0\)</span> (degenerate case—just a line! Your code should handle this gracefully)</p>
<p><strong>Suggested approach:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define parameters</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> b <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> c <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Background</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">);</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Axes</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> axis_thickness <span class="op">=</span> <span class="fl">0.02</span><span class="op">;</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> x_axis_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">&lt;</span> axis_thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> y_axis_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">)</span> <span class="op">&lt;</span> axis_thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> axis_color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Parabola: F(x,y) = y - (ax² + bx + c) = 0</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> <span class="op">(</span>a <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> b <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> c<span class="op">);</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> curve_thickness <span class="op">=</span> <span class="fl">0.08</span><span class="op">;</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parabola_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> curve_thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> parabola_color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Combine (axes behind parabola)</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> axis_color<span class="op">,</span> <span class="bu">max</span><span class="op">(</span>x_axis_mask<span class="op">,</span> y_axis_mask<span class="op">));</span></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> parabola_color<span class="op">,</span> parabola_mask<span class="op">);</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Try different values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> and verify your grapher works correctly! What happens with negative <span class="math inline">\(a\)</span>? What about <span class="math inline">\(b \neq 0\)</span>? Make sure the axes and parabola remain visible for all parameter values you try. If the parabola goes off-screen, you may need to adjust your coordinate scaling in the setup.</p>
</section>
<section id="optional-1-animated-curve-family" class="level3">
<h3 class="anchored" data-anchor-id="optional-1-animated-curve-family">Optional #1: Animated Curve Family</h3>
<p>Create a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build geometric intuition!</p>
<p><strong>Easier options:</strong></p>
<ul>
<li><p><strong>Circle family</strong>: Draw circles of varying radii: <span class="math inline">\(x^2 + y^2 = r^2\)</span> where <span class="math inline">\(r = 1 + 0.5\sin(\text{iTime})\)</span>. Simple but mesmerizing!</p></li>
<li><p><strong>Rotating ellipse</strong>: <span class="math inline">\((x\cos\theta + y\sin\theta)^2/a^2 + (-x\sin\theta + y\cos\theta)^2/b^2 = 1\)</span> with <span class="math inline">\(\theta = \text{iTime}\)</span>. Watch an ellipse rotate continuously.</p></li>
</ul>
<p><strong>More challenging options:</strong></p>
<ul>
<li><p><strong>Lissajous curves</strong>: Use parametric equations <span class="math inline">\(x = A\sin(at + \delta)\)</span>, <span class="math inline">\(y = B\sin(bt)\)</span> and animate <span class="math inline">\(\delta\)</span> with <code>iTime</code>. To render a parametric curve implicitly, you’ll need to be clever—one approach is to sample many points along the curve and draw circles at each point (we’ll learn better techniques for this later).</p></li>
<li><p><strong>Cassini ovals</strong>: <span class="math inline">\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\)</span>. Fix <span class="math inline">\(c = 1\)</span> and vary <span class="math inline">\(a\)</span> with <code>iTime</code>. Watch the curve transition from two separate loops to a single figure-eight-like shape as <span class="math inline">\(a\)</span> passes through the critical value <span class="math inline">\(a = c\)</span>!</p></li>
<li><p><strong>Cubic curves</strong>: Take <span class="math inline">\(y^2 = x^3 + ax + b\)</span> and vary one parameter with <code>iTime</code>. The topology of the curve changes dramatically as you pass through singular values—this is the beginning of the theory of elliptic curves!</p></li>
</ul>
<p>Use <code>iTime</code> creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes (these are the singularities of the family)!</p>
</section>
<section id="optional-2-beautiful-tiling-pattern" class="level3">
<h3 class="anchored" data-anchor-id="optional-2-beautiful-tiling-pattern">Optional #2: Beautiful Tiling Pattern</h3>
<p>Design an aesthetically pleasing tiling pattern using the <code>mod()</code> technique. This is your chance to be creative and make something visually striking!</p>
<p><strong>Requirements:</strong></p>
<ul>
<li>Create a non-trivial pattern within a fundamental domain (a single tile)</li>
<li>Use <code>mod()</code> to repeat it across the plane</li>
<li>The pattern should tile seamlessly—edges must match up so there are no visible discontinuities at tile boundaries</li>
</ul>
<p><strong>Ideas to get you started:</strong></p>
<ul>
<li><strong>Geometric patterns</strong>: Nested circles, polygons approximated by implicit curves, star shapes using angular coordinates</li>
<li><strong>Color gradients</strong>: Use <code>cell_id</code> to vary colors smoothly across tiles, creating large-scale gradient effects superimposed on the local pattern</li>
<li><strong>Multiple implicit curves</strong>: Combine several curves within each tile using boolean operations (intersection, union, etc.)</li>
<li><strong>Symmetry</strong>: Use <code>abs()</code> to create reflections within tiles—this is a simple way to get complex patterns with built-in symmetry</li>
<li><strong>Distance-based effects</strong>: Make features pulse or fade based on <code>iTime</code> and their position in the grid—create waves propagating across the tiling</li>
</ul>
<p><strong>Advanced challenge</strong>: Can you create a pattern that has different symmetries in different tiles? For example, alternate between rotational and reflectional symmetry using the checkerboard <code>cell_id</code> technique. Or create a pattern where the colors vary smoothly across the entire infinite tiling, creating a large-scale gradient effect that’s independent of the tile boundaries?</p>
<p>Think about Islamic geometric patterns, Escher tilings, or quasiperiodic tilings (though true quasiperiodicity requires techniques beyond simple <code>mod</code>—we’ll see that on Day 3!). The goal is to create something mathematically interesting and visually beautiful.</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="1.11">
<h2 data-number="1.11" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">1.11</span> Looking Ahead</h2>
<p>Tomorrow we’ll use these techniques to explore <strong>complex dynamics</strong> and <strong>geometric transformations</strong>:</p>
<ul>
<li><strong>Mandelbrot and Julia sets</strong>: Using the implicit curve technique to visualize the boundary of escape sets for complex iteration</li>
<li><strong>Circle inversions</strong>: A geometric transformation that takes lines and circles to lines and circles, creating beautiful fractal-like patterns</li>
<li><strong>Apollonian gasket</strong>: An infinite packing of circles constructed via repeated inversions—a stunning example of how simple geometric rules create intricate structures</li>
</ul>
<p>The coordinate systems, distance fields, and implicit curve techniques you’ve learned today will be the foundation for everything to come. Make sure you’re comfortable with:</p>
<ul>
<li>Setting up coordinates (the standard four-step transformation from <code>fragCoord</code> to centered, aspect-corrected <code>p</code>)</li>
<li>Computing distances with <code>length()</code> and dot products</li>
<li>Using <code>mod()</code> for repetition and understanding the separation of global <code>cell_id</code> and local <code>cell_p</code></li>
<li>Conditionally coloring based on mathematical expressions, using both explicit conditionals and smooth interpolation with <code>smoothstep</code></li>
</ul>
<p>If any of these feel shaky, now is the time to practice! Work through the homework problems, experiment with variations, and make sure you understand not just <em>how</em> the code works but <em>why</em> the mathematics gives the visual results you see. Everything this week builds on this foundation.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../outline.html" class="pagination-link" aria-label="Outline">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Outline</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../lectures/day2.html" class="pagination-link" aria-label="Day 2: Complex Dynamics and Iterated Inversions">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>