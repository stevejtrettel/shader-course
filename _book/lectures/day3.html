<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Day 3: Geometric Tilings in Euclidean and Hyperbolic Space – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../lectures/day4.html" rel="next">
<link href="../lectures/day2.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e62aa0a8c28b52a0e19b1cebeabd7fd3.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-f0463eacbf7faa50df92658b97a72515.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e62aa0a8c28b52a0e19b1cebeabd7fd3.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-fdefc9cf9f9c0931e25703ad3762f0b0.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-62a97c0d1547f795681c2ac33a20a5a5.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../site_libs/bootstrap/bootstrap-fdefc9cf9f9c0931e25703ad3762f0b0.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/day3.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/stevejtrettel/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day1-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 1</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day2-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 2</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day3-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">3.1</span> Overview</a></li>
  <li><a href="#part-1-reflection-and-tilings-in-euclidean-geometry" id="toc-part-1-reflection-and-tilings-in-euclidean-geometry" class="nav-link" data-scroll-target="#part-1-reflection-and-tilings-in-euclidean-geometry"><span class="header-section-number">3.2</span> Part 1: Reflection and Tilings in Euclidean Geometry</a>
  <ul class="collapse">
  <li><a href="#starting-simple-the-folding-algorithm" id="toc-starting-simple-the-folding-algorithm" class="nav-link" data-scroll-target="#starting-simple-the-folding-algorithm">Starting Simple: The Folding Algorithm</a></li>
  <li><a href="#abstracting-half-spaces" id="toc-abstracting-half-spaces" class="nav-link" data-scroll-target="#abstracting-half-spaces">Abstracting: Half-Spaces</a></li>
  <li><a href="#square-tiling-with-half-spaces" id="toc-square-tiling-with-half-spaces" class="nav-link" data-scroll-target="#square-tiling-with-half-spaces">Square Tiling with Half-Spaces</a></li>
  <li><a href="#triangle-tiling" id="toc-triangle-tiling" class="nav-link" data-scroll-target="#triangle-tiling">Triangle Tiling</a></li>
  <li><a href="#why-does-this-algorithm-work-reflection-groups" id="toc-why-does-this-algorithm-work-reflection-groups" class="nav-link" data-scroll-target="#why-does-this-algorithm-work-reflection-groups">Why Does This Algorithm Work? Reflection Groups</a></li>
  </ul></li>
  <li><a href="#part-2-hyperbolic-geometry" id="toc-part-2-hyperbolic-geometry" class="nav-link" data-scroll-target="#part-2-hyperbolic-geometry"><span class="header-section-number">3.3</span> Part 2: Hyperbolic Geometry</a>
  <ul class="collapse">
  <li><a href="#introduction-to-hyperbolic-geometry" id="toc-introduction-to-hyperbolic-geometry" class="nav-link" data-scroll-target="#introduction-to-hyperbolic-geometry">Introduction to Hyperbolic Geometry</a></li>
  <li><a href="#the-upper-half-plane-model" id="toc-the-upper-half-plane-model" class="nav-link" data-scroll-target="#the-upper-half-plane-model">The Upper Half-Plane Model</a></li>
  <li><a href="#the-boundary-at-infinity" id="toc-the-boundary-at-infinity" class="nav-link" data-scroll-target="#the-boundary-at-infinity">The Boundary at Infinity</a></li>
  <li><a href="#geodesics-and-reflections" id="toc-geodesics-and-reflections" class="nav-link" data-scroll-target="#geodesics-and-reflections">Geodesics and Reflections</a></li>
  <li><a href="#the-23-triangle" id="toc-the-23-triangle" class="nav-link" data-scroll-target="#the-23-triangle">The (2,3,∞) Triangle</a></li>
  <li><a href="#multiple-models-of-hyperbolic-space" id="toc-multiple-models-of-hyperbolic-space" class="nav-link" data-scroll-target="#multiple-models-of-hyperbolic-space">Multiple Models of Hyperbolic Space</a></li>
  <li><a href="#other-triangle-groups" id="toc-other-triangle-groups" class="nav-link" data-scroll-target="#other-triangle-groups">Other Triangle Groups</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">3.4</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">3.5</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-0-understanding-hyperbolic-distance" id="toc-required-0-understanding-hyperbolic-distance" class="nav-link" data-scroll-target="#required-0-understanding-hyperbolic-distance">Required #0: Understanding Hyperbolic Distance</a></li>
  <li><a href="#required-1-euclidean-triangle-tiling-with-edges-and-vertices" id="toc-required-1-euclidean-triangle-tiling-with-edges-and-vertices" class="nav-link" data-scroll-target="#required-1-euclidean-triangle-tiling-with-edges-and-vertices">Required #1: Euclidean Triangle Tiling with Edges and Vertices</a></li>
  <li><a href="#required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" id="toc-required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" class="nav-link" data-scroll-target="#required-2-hyperbolic-triangle-tiling-with-edges-and-vertices">Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</a></li>
  <li><a href="#required-3-model-conversions" id="toc-required-3-model-conversions" class="nav-link" data-scroll-target="#required-3-model-conversions">Required #3: Model Conversions</a></li>
  <li><a href="#required-4-different-triangle-groups-challenge" id="toc-required-4-different-triangle-groups-challenge" class="nav-link" data-scroll-target="#required-4-different-triangle-groups-challenge">Required #4: Different Triangle Groups (Challenge!)</a></li>
  <li><a href="#optional-exercises" id="toc-optional-exercises" class="nav-link" data-scroll-target="#optional-exercises">Optional Exercises</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">3.6</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">3.1</span> Overview</h2>
<p>Today we explore geometric tilings through reflection operations. We’ll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.</p>
<p>The key insight: <strong>the algorithm stays the same across geometries—only the reflection operations change.</strong> This mirrors what we saw on Day 2 with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region. But today we’ll understand <em>why</em> this works through the lens of group theory.</p>
<p>By the end of today, you’ll understand: - How to construct reflections using linear algebra - <strong>Why the folding algorithm works</strong> (reflection groups and fundamental domains) - The structure of hyperbolic geometry in the upper half-plane model - How to implement hyperbolic triangle tilings using the same algorithmic pattern - How to convert between different models of hyperbolic space - The connection between circle inversion (Day 2) and hyperbolic isometries</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Roadmap for Today
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Part 1: Euclidean Geometry</strong> - Simple tilings (strip, square) - Half-space abstraction - Triangle tilings - <strong>Why this works</strong>: Reflection groups</p>
<p><strong>Part 2: Hyperbolic Geometry</strong> - The upper half-plane model and metric - Geodesics and reflections (connection to Day 2!) - Triangle tilings in <span class="math inline">\(\mathbb{H}^2\)</span> - Multiple models (Poincaré disk, Klein) - Historical context and applications</p>
<p>The unifying theme is <strong>geometric transformations and their groups</strong>—the same mathematical structure underlies fractals, tilings, and symmetry across all geometries.</p>
</div>
</div>
<hr>
</section>
<section id="part-1-reflection-and-tilings-in-euclidean-geometry" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="part-1-reflection-and-tilings-in-euclidean-geometry"><span class="header-section-number">3.2</span> Part 1: Reflection and Tilings in Euclidean Geometry</h2>
<section id="starting-simple-the-folding-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="starting-simple-the-folding-algorithm">Starting Simple: The Folding Algorithm</h3>
<p>Before we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.</p>
<section id="tiling-a-strip" class="level4">
<h4 class="anchored" data-anchor-id="tiling-a-strip">Tiling a Strip</h4>
<p>Imagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip <span class="math inline">\(0 &lt; x &lt; 1\)</span>—and reflect any point outside this strip back inside.</p>
<p>The algorithm is remarkably simple: - If <span class="math inline">\(x &lt; 0\)</span>, reflect across <span class="math inline">\(x = 0\)</span> - If <span class="math inline">\(x &gt; 1\)</span>, reflect across <span class="math inline">\(x = 1\)</span><br>
- Repeat until the point stops moving</p>
<p>For a vertical line at <span class="math inline">\(x = c\)</span>, reflection just flips the <span class="math inline">\(x\)</span>-coordinate: <span class="math inline">\((x, y) \mapsto (2c - x, y)\)</span>.</p>
<p>Here’s a complete shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Standard coordinate setup</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the strip [0, 1]</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Dark background</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A circle in the strip</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">));</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Yellow circle</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.</p>
<p><strong>What’s happening geometrically?</strong> Every point on the screen gets mapped back to the fundamental domain <span class="math inline">\([0,1]\)</span>. Points that were in reflected copies of the domain get folded back through a sequence of reflections. Since we draw the same pattern in the fundamental domain, all the reflected copies show the same pattern.</p>
<hr>
</section>
<section id="square-tiling" class="level4">
<h4 class="anchored" data-anchor-id="square-tiling">Square Tiling</h4>
<p>Let’s extend to two dimensions. Now we have four boundaries: <span class="math inline">\(x = 0\)</span>, <span class="math inline">\(x = 1\)</span>, <span class="math inline">\(y = 0\)</span>, and <span class="math inline">\(y = 1\)</span>. Same algorithm, just more boundaries to check:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square [0,1] × [0,1]</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle at center</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Perfect! A full 2D tiling.</p>
<hr>
</section>
<section id="square-tiling-with-fold-count" class="level4">
<h4 class="anchored" data-anchor-id="square-tiling-with-fold-count">Square Tiling with Fold Count</h4>
<p>Let’s track how many reflections were needed. This helps us understand the geometry and creates beautiful visualizations:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square [0,1] × [0,1]</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're done</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">8.0</span><span class="op">;</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> t <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">)));</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">,</span> d<span class="op">));</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Beautiful! The color gradient shows how many reflections were needed—points near the fundamental domain require few iterations, while points far away need many.</p>
<p>Notice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain and we can stop.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Computational Efficiency: Iteration Count
</div>
</div>
<div class="callout-body-container callout-body">
<p>Why does this converge so quickly? Each reflection moves the point strictly closer to the fundamental domain (in the sense of reducing the number of boundary crossings). For a viewport of size <span class="math inline">\(4 \times 4\)</span> and fundamental domain of size <span class="math inline">\(1 \times 1\)</span>, we need at most <span class="math inline">\(\lceil \log_2(4) \rceil = 2\)</span> reflections per axis, so 4 reflections total in the worst case.</p>
<p>The 20-iteration limit is very conservative—most pixels converge in under 5 iterations. We could dynamically adjust this based on the coordinate scale, but for real-time rendering, a fixed conservative bound works well.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="abstracting-half-spaces" class="level3">
<h3 class="anchored" data-anchor-id="abstracting-half-spaces">Abstracting: Half-Spaces</h3>
<p>Looking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.</p>
<section id="what-is-a-half-space" class="level4">
<h4 class="anchored" data-anchor-id="what-is-a-half-space">What is a Half-Space?</h4>
<p>A <strong>half-space</strong> is one side of a line. Any line <span class="math inline">\(ax + by = c\)</span> divides the plane into two regions: - Points where <span class="math inline">\(ax + by &lt; c\)</span> - Points where <span class="math inline">\(ax + by &gt; c\)</span></p>
<p>We’ll encode a half-space by storing the line parameters and which side we want:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span>  <span class="co">// Line parameters: ax + by = c</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span>     <span class="co">// +1 or -1 for which side</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>side</code> parameter determines which inequality we want: - <code>side = -1.0</code> means we want <span class="math inline">\(ax + by &gt; c\)</span> (equivalently, <span class="math inline">\((ax + by - c) \cdot (-1) &lt; 0\)</span>) - <code>side = 1.0</code> means we want <span class="math inline">\(ax + by &lt; c\)</span> (equivalently, <span class="math inline">\((ax + by - c) \cdot (1) &lt; 0\)</span>)</p>
<p>This might seem redundant—we could always use <span class="math inline">\(ax + by &lt; c\)</span> and just flip the signs of <span class="math inline">\(a, b, c\)</span> to get the other side. But having an explicit <code>side</code> parameter makes the code clearer and will be essential in hyperbolic geometry where sign-flipping doesn’t work as cleanly.</p>
</section>
<section id="visualizing-half-spaces" class="level4">
<h4 class="anchored" data-anchor-id="visualizing-half-spaces">Visualizing Half-Spaces</h4>
<p>Before we implement reflections, let’s visualize what a half-space is. Here’s a shader that colors one side of a line:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">inside</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define a half-space: x &lt; 1 (left side of vertical line at x=1)</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on whether we're inside</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.7</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see the left side of the line colored blue, the right side dark. Try changing the half-space parameters to see how it affects the coloring!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Drawing the Boundary Line
</div>
</div>
<div class="callout-body-container callout-body">
<p>Want to see where the line is? Add this distance function:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">distToHalfSpace</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">abs</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> <span class="bu">length</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">));</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Then draw the line:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs<span class="op">);</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White boundary</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This computes the perpendicular distance from the point to the line, then colors points near the line white. See Appendix E4b for the complete implementation!</p>
</div>
</div>
</section>
<section id="intersecting-half-spaces-making-a-square" class="level4">
<h4 class="anchored" data-anchor-id="intersecting-half-spaces-making-a-square">Intersecting Half-Spaces: Making a Square</h4>
<p>Now let’s intersect four half-spaces to create a square region. We’ll use <strong>additive coloring</strong>—each half-space we’re inside adds to the color, so the interior (inside all four) will be brightest:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">inside</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define the four half-spaces for [0,1] × [0,1]</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    HalfSpace left   <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// x &gt; 0</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    HalfSpace right  <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// x &lt; 1</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    HalfSpace bottom <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// y &gt; 0</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    HalfSpace top    <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// y &lt; 1</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Additive coloring - each half-space adds brightness</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> left<span class="op">))</span>   color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> right<span class="op">))</span>  color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> bottom<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> top<span class="op">))</span>    color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see the square region brightest (inside all four half-spaces), with regions inside fewer half-spaces progressively darker. This additive approach makes it easy to see how the regions overlap!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Improved Visualization
</div>
</div>
<div class="callout-body-container callout-body">
<p>For a cleaner look, you might want to:</p>
<ol type="1">
<li><strong>Binary coloring</strong> (inside domain or not):</li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> in_square <span class="op">=</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> left<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> right<span class="op">)</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> bottom<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> top<span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> in_square <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.4</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol start="2" type="1">
<li><p><strong>Draw boundaries</strong> using the distance function from earlier</p></li>
<li><p><strong>Create an <code>insideDomain()</code> function</strong>:</p></li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">insideDomain</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs1<span class="op">,</span> HalfSpace hs2<span class="op">,</span> </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                  HalfSpace hs3<span class="op">,</span> HalfSpace hs4<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">)</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>           <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs4<span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>See Appendix E5b for complete enhanced versions!</p>
</div>
</div>
</section>
<section id="three-half-spaces-make-a-triangle" class="level4">
<h4 class="anchored" data-anchor-id="three-half-spaces-make-a-triangle">Three Half-Spaces Make a Triangle</h4>
<p>Let’s visualize three half-spaces defining a triangle:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">inside</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define three half-spaces for equilateral triangle</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs1 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs2 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.732</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs3 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(-</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Additive coloring</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">);</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">);</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">);</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a triangle region where all three half-spaces overlap! The additive coloring helps visualize the structure.</p>
<hr>
</section>
<section id="the-reflection-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-reflection-formula">The Reflection Formula</h4>
<p>Now we’re ready to implement reflection. To reflect a point <span class="math inline">\(\mathbf{p} = (x, y)\)</span> across the line <span class="math inline">\(ax + by = c\)</span>, we use linear algebra. The normal vector to the line is <span class="math inline">\(\mathbf{n} = (a, b)\)</span>. After normalizing to <span class="math inline">\(\hat{\mathbf{n}} = \mathbf{n}/|\mathbf{n}|\)</span>, the reflection formula is:</p>
<p><span class="math display">\[\mathbf{p}' = \mathbf{p} - 2d\hat{\mathbf{n}}\]</span></p>
<p>where <span class="math inline">\(d\)</span> is the signed distance from <span class="math inline">\(\mathbf{p}\)</span> to the line:</p>
<p><span class="math display">\[d = \frac{ax + by - c}{\sqrt{a^2 + b^2}}\]</span></p>
<p>This is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.</p>
<p>Our <code>reflectInto</code> function checks if we’re on the correct side and only reflects if necessary—it <strong>extends</strong> our <code>inside()</code> test by conditionally reflecting:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute which side of the line we're on</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're already on the correct side (this is our inside() test!)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span>  <span class="co">// Already inside, nothing to do</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We're on the wrong side - reflect across the boundary line</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This function encapsulates the entire pattern: check if we’re on the correct side (the <code>inside()</code> test), and only reflect if we’re not. So <code>reflectInto()</code> extends and renames our visualization function to also perform the reflection!</p>
<hr>
</section>
</section>
<section id="square-tiling-with-half-spaces" class="level3">
<h3 class="anchored" data-anchor-id="square-tiling-with-half-spaces">Square Tiling with Half-Spaces</h3>
<p>Let’s rewrite our square tiling using this abstraction. For the square <span class="math inline">\([0, 1] \times [0, 1]\)</span>, we need four half-spaces:</p>
<ul>
<li><strong>Left edge</strong> (<span class="math inline">\(x = 0\)</span>): We want <span class="math inline">\(x &gt; 0\)</span> → <code>HalfSpace(1.0, 0.0, 0.0, -1.0)</code></li>
<li><strong>Right edge</strong> (<span class="math inline">\(x = 1\)</span>): We want <span class="math inline">\(x &lt; 1\)</span> → <code>HalfSpace(1.0, 0.0, 1.0, 1.0)</code></li>
<li><strong>Bottom and top</strong>: Similarly for <span class="math inline">\(y\)</span></li>
</ul>
<p>Complete shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define the four half-spaces for [0,1]×[0,1]</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    HalfSpace left   <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    HalfSpace right  <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    HalfSpace bottom <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    HalfSpace top    <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> left<span class="op">);</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> bottom<span class="op">);</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> top<span class="op">);</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">8.0</span><span class="op">;</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> t <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">)));</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in fundamental domain</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">,</span> d<span class="op">));</span></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This looks identical to our earlier version, but now our code is flexible. The beauty: <strong>changing from a square to a triangle only requires changing the half-space definitions!</strong></p>
<hr>
</section>
<section id="triangle-tiling" class="level3">
<h3 class="anchored" data-anchor-id="triangle-tiling">Triangle Tiling</h3>
<p>Now we’re ready for triangles. We’ll use an equilateral triangle with vertices at:</p>
<p><span class="math display">\[v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)\]</span></p>
<p>This triangle is centered at the origin with one vertex pointing up.</p>
<section id="computing-half-spaces-from-edges" class="level4">
<h4 class="anchored" data-anchor-id="computing-half-spaces-from-edges">Computing Half-Spaces from Edges</h4>
<p>For each edge, we need to compute the line parameters <span class="math inline">\((a, b, c)\)</span> and determine the correct side. The process:</p>
<ol type="1">
<li>Take two vertices defining an edge: <span class="math inline">\(\mathbf{v}_i\)</span> and <span class="math inline">\(\mathbf{v}_j\)</span></li>
<li>Compute edge direction: <span class="math inline">\(\mathbf{d} = \mathbf{v}_j - \mathbf{v}_i\)</span></li>
<li>Compute perpendicular (rotate 90° counterclockwise): <span class="math inline">\(\mathbf{n} = (-d_y, d_x)\)</span></li>
<li>Line equation: <span class="math inline">\(n_x \cdot x + n_y \cdot y = c\)</span> where <span class="math inline">\(c = \mathbf{n} \cdot \mathbf{v}_i\)</span></li>
<li>Test origin: if <span class="math inline">\((n_x \cdot 0 + n_y \cdot 0 - c) &lt; 0\)</span>, then <code>side = -1.0</code>, else <code>side = 1.0</code></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Derivation of Triangle Half-Space Parameters
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Edge from <span class="math inline">\(v_0 = (0, 1)\)</span> to <span class="math inline">\(v_1 = (-\sqrt{3}/2, -1/2)\)</span>:</strong></p>
<ul>
<li>Edge direction: <span class="math inline">\(\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\)</span></li>
<li>Perpendicular (90° CCW): <span class="math inline">\(\mathbf{n} = (1.5, -0.866)\)</span></li>
<li>Line: <span class="math inline">\(1.5x - 0.866y = c\)</span> where <span class="math inline">\(c = \mathbf{n} \cdot v_0 = (1.5)(0) + (-0.866)(1) = -0.866\)</span></li>
<li>For origin (inside): <span class="math inline">\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\)</span></li>
<li>We want inside when <span class="math inline">\((ax + by - c) &lt; 0\)</span>, so we need <code>side = -1.0</code></li>
</ul>
<p><strong>Result:</strong> <code>HalfSpace(1.5, -0.866, -0.866, -1.0)</code></p>
<p>Similar calculations give: - <strong>Edge <span class="math inline">\(v_1\)</span> to <span class="math inline">\(v_2\)</span>:</strong> <code>HalfSpace(0.0, 1.732, -0.866, -1.0)</code> - <strong>Edge <span class="math inline">\(v_2\)</span> to <span class="math inline">\(v_0\)</span>:</strong> <code>HalfSpace(-1.5, -0.866, -0.866, -1.0)</code></p>
</div>
</div>
</div>
<p>The computed parameters are:</p>
<ul>
<li><strong>Edge <span class="math inline">\(v_0\)</span> to <span class="math inline">\(v_1\)</span>:</strong> <code>HalfSpace(1.5, -0.866, -0.866, -1.0)</code></li>
<li><strong>Edge <span class="math inline">\(v_1\)</span> to <span class="math inline">\(v_2\)</span>:</strong> <code>HalfSpace(0.0, 1.732, -0.866, -1.0)</code><br>
</li>
<li><strong>Edge <span class="math inline">\(v_2\)</span> to <span class="math inline">\(v_0\)</span>:</strong> <code>HalfSpace(-1.5, -0.866, -0.866, -1.0)</code></li>
</ul>
<p>We already verified these work with our visualization shader above!</p>
</section>
<section id="triangle-tiling-shader" class="level4">
<h4 class="anchored" data-anchor-id="triangle-tiling-shader">Triangle Tiling Shader</h4>
<p>Now we can implement the tiling by copying our reflection shader and just changing the half-spaces:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define the three half-spaces for equilateral triangle</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs1 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs2 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.732</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs3 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(-</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the triangle</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by fold count parity</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parity <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span><span class="dt">float</span><span class="op">(</span>foldCount<span class="op">),</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>parity <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.9</span><span class="op">);</span>  <span class="co">// Light blue</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Darker blue</span></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Beautiful! You should see an infinite triangle tiling. The alternating colors show which triangles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Visualizing Triangle Structure
</div>
</div>
<div class="callout-body-container callout-body">
<p>Want to see the edges and vertices of your triangles? This requires computing distances to half-spaces and vertices.</p>
<p><strong>For edges</strong> (drawing the boundaries):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">distToHalfSpace</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">abs</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> <span class="bu">length</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">));</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">// In main rendering:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d1 <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d2 <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d3 <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> border <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>d2<span class="op">,</span> d3<span class="op">));</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>border <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White edges</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For vertices</strong> (marking the corners):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define vertices</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v0 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v1 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v2 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Check distance after folding</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dv0 <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> v0<span class="op">);</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dv1 <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> v1<span class="op">);</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dv2 <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> v2<span class="op">);</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> vertex_dist <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>dv0<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>dv1<span class="op">,</span> dv2<span class="op">));</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>vertex_dist <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// Red vertices</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>See Appendix E9 for the complete enhanced version!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="why-does-this-algorithm-work-reflection-groups" class="level3">
<h3 class="anchored" data-anchor-id="why-does-this-algorithm-work-reflection-groups">Why Does This Algorithm Work? Reflection Groups</h3>
<p>We’ve implemented the folding algorithm, but <em>why</em> does it work? Why does iteratively reflecting guarantee we reach the fundamental domain? The answer lies in <strong>group theory</strong>.</p>
<section id="reflections-generate-a-group" class="level4">
<h4 class="anchored" data-anchor-id="reflections-generate-a-group">Reflections Generate a Group</h4>
<p>Each reflection <span class="math inline">\(r_i\)</span> across a half-space boundary is an <strong>isometry</strong> of the Euclidean plane—it preserves distances and angles. Composing reflections gives us more isometries. The set of all compositions of our reflections forms a <strong>group</strong> under composition:</p>
<ul>
<li><strong>Identity</strong>: Reflecting twice across the same line returns to the original point (<span class="math inline">\(r_i \circ r_i = \text{id}\)</span>)</li>
<li><strong>Closure</strong>: Composing reflections gives another isometry (which might be a reflection, rotation, or glide reflection)</li>
<li><strong>Inverses</strong>: Every isometry has an inverse (just reflect again)</li>
<li><strong>Associativity</strong>: Composition is associative</li>
</ul>
<p>This group, generated by reflections across the boundaries of our fundamental domain, is called a <strong>reflection group</strong> or <strong>Coxeter group</strong>.</p>
</section>
<section id="the-fundamental-domain-and-orbit" class="level4">
<h4 class="anchored" data-anchor-id="the-fundamental-domain-and-orbit">The Fundamental Domain and Orbit</h4>
<p>Our fundamental domain <span class="math inline">\(F\)</span> (the square <span class="math inline">\([0,1]^2\)</span> or triangle) is a <strong>fundamental domain</strong> for the group action. This means:</p>
<ol type="1">
<li>Every point in the plane is equivalent to exactly one point in <span class="math inline">\(F\)</span> (modulo boundary points)</li>
<li>The <strong>orbit</strong> of <span class="math inline">\(F\)</span> under the group (all images <span class="math inline">\(g(F)\)</span> for <span class="math inline">\(g\)</span> in the group) tiles the entire plane</li>
<li>Different tiles <span class="math inline">\(g(F)\)</span> and <span class="math inline">\(h(F)\)</span> only overlap on their boundaries</li>
</ol>
<p>When we start with a point <span class="math inline">\(p\)</span> outside <span class="math inline">\(F\)</span>, there exists a sequence of group elements (reflections) that maps <span class="math inline">\(p\)</span> into <span class="math inline">\(F\)</span>. Our algorithm finds this sequence!</p>
</section>
<section id="why-the-algorithm-terminates" class="level4">
<h4 class="anchored" data-anchor-id="why-the-algorithm-terminates">Why the Algorithm Terminates</h4>
<p>Here’s the key insight: each reflection across a boundary of <span class="math inline">\(F\)</span> either: - Keeps the point inside <span class="math inline">\(F\)</span> (if it’s already on the correct side) - Moves the point strictly closer to <span class="math inline">\(F\)</span> (if it’s on the wrong side)</p>
<p>“Closer” here means we reduce some discrete measure—like the number of boundaries we’re on the wrong side of. Since this number is finite and decreases with each reflection, the algorithm must terminate.</p>
<p>Formally, we can define a <strong>height function</strong> <span class="math inline">\(h(p)\)</span> that counts how many half-space boundaries <span class="math inline">\(p\)</span> violates. Initially <span class="math inline">\(h(p) \geq 0\)</span>. Each reflection that actually moves the point decreases <span class="math inline">\(h(p)\)</span> by at least 1. When <span class="math inline">\(h(p) = 0\)</span>, the point is inside <span class="math inline">\(F\)</span> and the algorithm stops.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>The Pattern Across Days
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is the same fundamental principle we’ve seen throughout:</p>
<p><strong>Day 2 (Apollonian gasket):</strong> - Group: Iterated circle inversions - Fundamental domain: The gaps between circles - Algorithm: Invert until inside the domain</p>
<p><strong>Day 3 (Euclidean tilings):</strong> - Group: Reflections across boundaries - Fundamental domain: The square/triangle - Algorithm: Reflect until inside the domain</p>
<p><strong>Day 3 (Hyperbolic, coming soon):</strong> - Group: Hyperbolic reflections (same structure!) - Fundamental domain: Hyperbolic triangle - Algorithm: Reflect until inside the domain (identical code!)</p>
<p>The unifying theme is <strong>group actions and fundamental domains</strong>. We’re always finding the unique representative of an orbit that lies in the fundamental domain.</p>
</div>
</div>
</section>
<section id="computational-implications" class="level4">
<h4 class="anchored" data-anchor-id="computational-implications">Computational Implications</h4>
<p>Understanding the group theory gives us insight into the computation:</p>
<p><strong>Convergence rate</strong>: For a viewport of size <span class="math inline">\(V\)</span> and fundamental domain of size <span class="math inline">\(F\)</span>, we need at most <span class="math inline">\(O(\log(V/F))\)</span> reflections per coordinate axis. This is why small iteration limits (20-30) work well.</p>
<p><strong>Parallelism</strong>: Each pixel’s orbit is independent—perfect for GPU parallelism. Millions of pixels computing orbits simultaneously with no communication needed.</p>
<p><strong>Threshold choice</strong>: The <code>0.0001</code> threshold for detecting convergence balances precision and performance. Smaller thresholds catch more subtle movements but risk floating-point noise; larger thresholds might terminate early but rarely matter for visualization.</p>
<p><strong>Why it’s efficient</strong>: Most tiles are “nearby” in the group—they’re reached by short sequences of reflections. Only tiles far from the origin require many reflections, and these appear very small on screen (contributing few pixels).</p>
<p>This completes our Euclidean foundation. We now understand: 1. The folding algorithm in concrete examples 2. The half-space abstraction that makes it general 3. <strong>Why it works</strong>: reflection groups and fundamental domains 4. Computational properties: convergence, parallelism, efficiency</p>
<p>Next, we’ll take this exact algorithmic structure into hyperbolic geometry!</p>
<hr>
</section>
</section>
</section>
<section id="part-2-hyperbolic-geometry" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="part-2-hyperbolic-geometry"><span class="header-section-number">3.3</span> Part 2: Hyperbolic Geometry</h2>
<section id="introduction-to-hyperbolic-geometry" class="level3">
<h3 class="anchored" data-anchor-id="introduction-to-hyperbolic-geometry">Introduction to Hyperbolic Geometry</h3>
<p>Hyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant <strong>negative curvature</strong>. For over two millennia, mathematicians believed Euclidean geometry was the only logically consistent geometry—Euclid’s parallel postulate seemed necessary. The discovery of hyperbolic geometry in the early 19th century revolutionized mathematics.</p>
<section id="historical-context-the-discovery" class="level4">
<h4 class="anchored" data-anchor-id="historical-context-the-discovery">Historical Context: The Discovery</h4>
<p>The story of hyperbolic geometry is one of the great dramas in mathematical history. For centuries, mathematicians tried to prove Euclid’s fifth postulate (the parallel postulate) from the other four axioms. What if you could have multiple parallel lines through a point?</p>
<p>Three mathematicians independently discovered that this “impossible” geometry was actually perfectly consistent:</p>
<p><strong>János Bolyai</strong> (1802-1860), a Hungarian mathematician, developed hyperbolic geometry in the 1820s. His father, a mathematician himself, warned him: “For God’s sake, I beseech you, give it up. Fear it no less than sensual passions because it too may take all your time and deprive you of your health, peace of mind and happiness in life.” But János persisted, publishing his work in 1832 as an appendix to his father’s book.</p>
<p><strong>Nikolai Lobachevsky</strong> (1792-1856), a Russian mathematician, published the first account of hyperbolic geometry in 1829. He called it “imaginary geometry” and faced considerable resistance from the mathematical establishment. His work was largely ignored during his lifetime.</p>
<p><strong>Carl Friedrich Gauss</strong> (1777-1855), the “Prince of Mathematicians,” had discovered hyperbolic geometry even earlier but never published it. In his private correspondence, he revealed he’d been working on non-Euclidean geometry since the 1790s but feared the “clamor of the Boeotians” (his term for mathematical philistines). When he read Bolyai’s work in 1832, he wrote that he could not praise it “because to praise it would be to praise myself”—he’d discovered the same results years earlier but kept them private.</p>
<p>The discovery had profound implications: geometry was not a single truth about space but a family of possible consistent systems. This philosophical shift influenced everything from Einstein’s general relativity (which uses non-Euclidean geometry for curved spacetime) to modern physics and mathematics.</p>
</section>
<section id="modern-applications" class="level4">
<h4 class="anchored" data-anchor-id="modern-applications">Modern Applications</h4>
<p>Hyperbolic geometry appears throughout modern mathematics and physics:</p>
<ul>
<li><strong>Complex analysis</strong>: The upper half-plane model is fundamental to the theory of modular forms, elliptic curves, and the Riemann mapping theorem</li>
<li><strong>Number theory</strong>: The action of <span class="math inline">\(SL(2,\mathbb{Z})\)</span> on <span class="math inline">\(\mathbb{H}^2\)</span> produces modular forms—functions crucial to the proof of Fermat’s Last Theorem</li>
<li><strong>Topology</strong>: The study of 3-manifolds and knot theory often requires understanding hyperbolic structures</li>
<li><strong>Teichmüller theory</strong>: Moduli spaces of Riemann surfaces have natural hyperbolic metrics</li>
<li><strong>Kleinian groups</strong>: Discrete subgroups of hyperbolic isometries produce fractal limit sets (like we saw with the Apollonian gasket!)</li>
<li><strong>General relativity</strong>: Anti-de Sitter space has constant negative curvature—hyperbolic geometry in spacetime</li>
<li><strong>Machine learning</strong>: Recent work uses hyperbolic embeddings to represent hierarchical data efficiently</li>
</ul>
</section>
<section id="key-properties" class="level4">
<h4 class="anchored" data-anchor-id="key-properties">Key Properties</h4>
<p>What makes hyperbolic geometry different from Euclidean geometry?</p>
<p><strong>Parallel lines</strong>: Given a line and a point not on it, there are <strong>infinitely many</strong> lines through the point that don’t intersect the given line (all parallel to it). This is the defining feature that distinguishes hyperbolic geometry.</p>
<p><strong>Triangle angles</strong>: The sum of angles in a triangle is <strong>less than</strong> <span class="math inline">\(\pi\)</span>. In fact, the <strong>area</strong> of a hyperbolic triangle with angles <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span> is exactly: <span class="math display">\[\text{Area} = \pi - (\alpha + \beta + \gamma)\]</span> This is the <strong>Gauss-Bonnet theorem</strong> for hyperbolic triangles—a beautiful connection between geometry (angles) and topology (area).</p>
<p><strong>Exponential growth</strong>: In Euclidean geometry, the circumference of a circle grows linearly with radius (<span class="math inline">\(C = 2\pi r\)</span>). In hyperbolic geometry, it grows <strong>exponentially</strong>: <span class="math inline">\(C \sim e^r\)</span> for large <span class="math inline">\(r\)</span>. This means hyperbolic space has “more room” than Euclidean space—there’s exponentially more area at distance <span class="math inline">\(r\)</span> from a point.</p>
<p><strong>No similarity</strong>: In Euclidean geometry, you can scale any shape—a small triangle and a large triangle with the same angles are similar. In hyperbolic geometry, there’s an absolute unit of length built into the curvature. All triangles with angles <span class="math inline">\((\pi/2, \pi/3, \pi/7)\)</span> are congruent—there’s no “scaled version.” This makes hyperbolic geometry richer but more rigid.</p>
<p>These properties create the “extra room” that allows much richer tiling structures than Euclidean geometry.</p>
<hr>
</section>
</section>
<section id="the-upper-half-plane-model" class="level3">
<h3 class="anchored" data-anchor-id="the-upper-half-plane-model">The Upper Half-Plane Model</h3>
<p>We’ll work in the <strong>upper half-plane model</strong> of hyperbolic geometry, denoted <span class="math inline">\(\mathbb{H}^2\)</span>:</p>
<p><span class="math display">\[\mathbb{H}^2 = \{z = x + iy \in \mathbb{C} : y &gt; 0\}\]</span></p>
<p>This is just complex numbers with positive imaginary part—the upper half of the complex plane. The <strong>real axis</strong> <span class="math inline">\(\{y = 0\}\)</span> forms the boundary “at infinity”—it’s not actually part of <span class="math inline">\(\mathbb{H}^2\)</span>, but represents points infinitely far away in hyperbolic distance.</p>
<section id="the-hyperbolic-metric" class="level4">
<h4 class="anchored" data-anchor-id="the-hyperbolic-metric">The Hyperbolic Metric</h4>
<p>The <strong>hyperbolic metric</strong> is what makes <span class="math inline">\(\mathbb{H}^2\)</span> a hyperbolic space:</p>
<p><span class="math display">\[ds^2 = \frac{dx^2 + dy^2}{y^2}\]</span></p>
<p>This gives <span class="math inline">\(\mathbb{H}^2\)</span> the structure of a complete Riemannian manifold with constant curvature <span class="math inline">\(-1\)</span>.</p>
<p><strong>What does this mean?</strong> The factor <span class="math inline">\(1/y^2\)</span> is a <strong>conformal factor</strong> that scales the Euclidean metric. As <span class="math inline">\(y \to 0\)</span> (approaching the boundary), this scaling factor blows up—distances that look small Euclidean-wise are enormous hyperbolically. As <span class="math inline">\(y \to \infty\)</span> (going “up” in the upper half-plane), the scaling factor goes to zero—large Euclidean distances are actually finite hyperbolically.</p>
<p>The metric is <strong>conformal</strong> to the Euclidean metric—it preserves angles but not lengths. If two curves meet at angle <span class="math inline">\(\theta\)</span> in the Euclidean sense, they also meet at angle <span class="math inline">\(\theta\)</span> in the hyperbolic sense! This is why you can trust your eyes when looking at pictures—angles are what they appear to be.</p>
</section>
<section id="the-distance-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-distance-formula">The Distance Formula</h4>
<p>Integrating the metric along paths gives the <strong>hyperbolic distance</strong> between two points <span class="math inline">\(z_1 = x_1 + iy_1\)</span> and <span class="math inline">\(z_2 = x_2 + iy_2\)</span>:</p>
<p><span class="math display">\[d_{\mathbb{H}^2}(z_1, z_2) = \text{arcosh}\left(1 + \frac{|z_1 - z_2|^2}{2y_1 y_2}\right)\]</span></p>
<p>where <span class="math inline">\(|z_1 - z_2| = \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\)</span> is the usual Euclidean distance.</p>
<p>Notice the <span class="math inline">\(1/y_1 y_2\)</span> factor—points near the boundary (<span class="math inline">\(y\)</span> small) are very far apart hyperbolically even if they’re close Euclidean-wise.</p>
<p><strong>Derivation sketch</strong>: For a vertical line from <span class="math inline">\(z_1 = x + iy_1\)</span> to <span class="math inline">\(z_2 = x + iy_2\)</span>, the hyperbolic length is: <span class="math display">\[\int_{y_1}^{y_2} \frac{dy}{y} = \log(y_2) - \log(y_1) = \log(y_2/y_1)\]</span></p>
<p>For a general path, you need to integrate along the geodesic connecting the points (which might not be a straight Euclidean line), giving the arcosh formula above.</p>
</section>
<section id="visualizing-hyperbolic-distance" class="level4">
<h4 class="anchored" data-anchor-id="visualizing-hyperbolic-distance">Visualizing Hyperbolic Distance</h4>
<p>Let’s make this concrete with an interactive shader. We’ll start with Euclidean distance, then switch to hyperbolic to see the difference.</p>
<p><strong>Euclidean distance circles:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span>  <span class="co">// Shift up so we're in y &gt; 0</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mouse position as center (or default)</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> mouse <span class="op">=</span> iMouse<span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>iMouse<span class="op">.</span><span class="fu">z</span> <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> mouse <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.7</span><span class="op">);</span>  <span class="co">// Default if no click</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    mouse <span class="op">=</span> <span class="op">(</span>mouse <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    mouse<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> center <span class="op">=</span> mouse <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Euclidean distance</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> center<span class="op">);</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a disk of radius 0.5 using two circles</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span>  <span class="co">// Background</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outer circle (slightly larger)</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">+</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Yellow ring</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inner circle (slightly smaller) - "cuts out" interior</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">-</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.4</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Blue interior</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw center point</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> center<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Darken outside upper half-plane</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>        color <span class="op">*=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Click and drag around—the circle stays the same size everywhere. This is Euclidean distance: uniform across the plane. Notice how we draw the boundary: we draw a filled circle at radius <span class="math inline">\(r + \epsilon\)</span> (outer edge), then draw another filled circle at radius <span class="math inline">\(r - \epsilon\)</span> (inner edge) in a different color. The ring between them is our boundary!</p>
<p><strong>Hyperbolic distance circles:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span><span class="dt">vec2</span> z1<span class="op">,</span> <span class="dt">vec2</span> z2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> diff <span class="op">=</span> z1 <span class="op">-</span> z2<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> diff2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>diff<span class="op">,</span> diff<span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> z1<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> z2<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> arg <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> diff2 <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">log</span><span class="op">(</span>arg <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span>arg <span class="op">*</span> arg <span class="op">-</span> <span class="fl">1.0</span><span class="op">));</span>  <span class="co">// arccosh(arg)</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mouse position as center</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> mouse <span class="op">=</span> iMouse<span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>iMouse<span class="op">.</span><span class="fu">z</span> <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> mouse <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.7</span><span class="op">);</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    mouse <span class="op">=</span> <span class="op">(</span>mouse <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    mouse<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> center <span class="op">=</span> mouse <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Hyperbolic distance</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist <span class="op">=</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span>p<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a hyperbolic disk using two "circles"</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span>  <span class="co">// Background</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outer boundary</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">+</span> <span class="fl">0.05</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Yellow ring</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inner region</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">-</span> <span class="fl">0.05</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.4</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Blue interior</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw center</span></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">hyperbolicDistance</span><span class="op">(</span>p<span class="op">,</span> center<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Darken outside upper half-plane</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>        color <span class="op">*=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Now drag the center around! Notice how the “circle” changes shape as you move it. Near the bottom (<span class="math inline">\(y \to 0\)</span>), the circle appears huge Euclidean-wise—that’s because we’re near the boundary where hyperbolic distances blow up. Higher up (<span class="math inline">\(y\)</span> large), the circle appears smaller.</p>
<p>This visualization makes the <span class="math inline">\(1/y^2\)</span> conformal factor visceral: <strong>hyperbolic space is compressed near the boundary</strong>.</p>
<hr>
</section>
</section>
<section id="the-boundary-at-infinity" class="level3">
<h3 class="anchored" data-anchor-id="the-boundary-at-infinity">The Boundary at Infinity</h3>
<p>The real axis <span class="math inline">\(\{y = 0\}\)</span> is not part of <span class="math inline">\(\mathbb{H}^2\)</span>, but we can think of it as the <strong>boundary at infinity</strong>—points infinitely far away in hyperbolic distance.</p>
<p><strong>Ideal points as equivalence classes</strong>: An <strong>ideal point</strong> on the boundary can be defined as an equivalence class of geodesics that asymptotically approach each other. Two geodesics are equivalent if the hyperbolic distance between them goes to zero as you go to infinity along them.</p>
<p>For example, the vertical line <span class="math inline">\(\{x = 0\}\)</span> and the vertical line <span class="math inline">\(\{x = \epsilon\}\)</span> (for small <span class="math inline">\(\epsilon\)</span>) both approach the point <span class="math inline">\(0\)</span> on the real axis. As you go up (<span class="math inline">\(y \to \infty\)</span>), the hyperbolic distance between corresponding points goes to zero—they’re asymptotically parallel.</p>
<p><strong>Geometric intuition</strong>: In the Poincaré disk model (which we’ll see soon), the boundary at infinity is literally the unit circle <span class="math inline">\(|z| = 1\)</span>. Points on this circle are infinitely far away from any interior point, but they still have geometric meaning—they represent directions or “points at infinity.”</p>
<p><strong>Why this matters</strong>: When we define hyperbolic triangles, we can have vertices “at infinity” on the boundary. These are called <strong>ideal vertices</strong> or <strong>ideal triangles</strong>. For instance, our <span class="math inline">\((2,3,\infty)\)</span> triangle has one vertex at the point <span class="math inline">\(\infty\)</span> in the upper half-plane (straight up the imaginary axis). The angle at an ideal vertex is zero—the sides become asymptotically parallel as they approach the boundary.</p>
<p>The Gauss-Bonnet theorem still works: for a triangle with angles <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span>, the area is <span class="math inline">\(\pi - (\alpha + \beta + \gamma)\)</span>. If one angle is zero (ideal vertex), the area is <span class="math inline">\(\pi - \alpha - \beta &gt; 0\)</span>—ideal triangles have finite area!</p>
<hr>
</section>
<section id="geodesics-and-reflections" class="level3">
<h3 class="anchored" data-anchor-id="geodesics-and-reflections">Geodesics and Reflections</h3>
<section id="geodesics-in-the-upper-half-plane" class="level4">
<h4 class="anchored" data-anchor-id="geodesics-in-the-upper-half-plane">Geodesics in the Upper Half-Plane</h4>
<p><strong>Geodesics</strong> (the “straight lines” of hyperbolic geometry—curves that locally minimize distance) in <span class="math inline">\(\mathbb{H}^2\)</span> have exactly two forms:</p>
<ol type="1">
<li><strong>Vertical lines</strong>: <span class="math inline">\(\{x = c\}\)</span> for any constant <span class="math inline">\(c \in \mathbb{R}\)</span></li>
<li><strong>Semicircles</strong>: Centered on the real axis, perpendicular to it</li>
</ol>
<p>These curves meet the boundary at right angles—this is the characterizing property of geodesics in this model.</p>
<p><strong>Why these are geodesics</strong>: Reflections across these curves are isometries (they preserve the hyperbolic metric <span class="math inline">\(ds^2 = \frac{dx^2+dy^2}{y^2}\)</span>). An isometry’s fixed point set is always a geodesic! So we just need to verify that reflection across vertical lines and semicircles preserves the metric.</p>
<p>For <strong>vertical lines</strong>, this is obvious: reflecting across <span class="math inline">\(x = c\)</span> sends <span class="math inline">\((x,y) \mapsto (2c-x, y)\)</span>, which preserves both the Euclidean distance <span class="math inline">\(dx^2 + dy^2\)</span> and the <span class="math inline">\(y\)</span>-coordinate, hence preserves <span class="math inline">\(\frac{dx^2+dy^2}{y^2}\)</span>.</p>
<p>For <strong>semicircles</strong>, we use circle inversion from Day 2! A semicircle centered at <span class="math inline">\((c, 0)\)</span> with radius <span class="math inline">\(R\)</span> is preserved by the inversion: <span class="math display">\[z \mapsto c + R^2 \frac{z - c}{|z - c|^2}\]</span></p>
<p>Circle inversion is conformal (preserves angles) and scales distances by exactly <span class="math inline">\(1/y^2\)</span> near the boundary—precisely the conformal factor in the hyperbolic metric! So inversions through semicircles are hyperbolic isometries. Their fixed point sets (the semicircles themselves) are therefore geodesics.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Connection to Day 2: Circle Inversion is a Hyperbolic Isometry!
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is a profound connection: the circle inversions we used on Day 2 for the Apollonian gasket were actually <strong>hyperbolic isometries</strong> all along! The Apollonian gasket lives in hyperbolic space—the gaps between circles are hyperbolic regions, and the inversions are reflections across hyperbolic geodesics (semicircles).</p>
<p>When we iterated inversions on Day 2, we were doing exactly what we’re doing today—finding the fundamental domain of a group action! The Apollonian gasket is a hyperbolic object, just like our triangle tilings. The same group-theoretic principles apply.</p>
<p>This is why the techniques work across days: we’re always working with group actions, whether we realize it or not. The mathematics unifies everything.</p>
</div>
</div>
</section>
<section id="implementing-reflections" class="level4">
<h4 class="anchored" data-anchor-id="implementing-reflections">Implementing Reflections</h4>
<p>For <strong>vertical lines</strong> (like <span class="math inline">\(x = c\)</span>), reflection is simple—flip the <span class="math inline">\(x\)</span>-coordinate:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> x_pos<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're on the correct side</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> x_pos<span class="op">)</span> <span class="op">*</span> side <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> z<span class="op">;</span>  <span class="co">// Already on correct side</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reflect: (x,y) ↦ (2c - x, y)</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x_pos <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For <strong>semicircles</strong> (geodesics from point <span class="math inline">\(p\)</span> to point <span class="math inline">\(q\)</span> on the real axis), we use circle inversion. The semicircle has center <span class="math inline">\((c, 0)\)</span> where <span class="math inline">\(c = (p+q)/2\)</span> and radius <span class="math inline">\(R = |p-q|/2\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> rel <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>rel<span class="op">,</span> rel<span class="op">);</span>  <span class="co">// Squared distance from center</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're on the correct side</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>dist2 <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> side <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> z<span class="op">;</span>  <span class="co">// Already on correct side</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle inversion (from Day 2!)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> inverted <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span>radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> rel <span class="op">/</span> dist2<span class="op">;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> inverted<span class="op">;</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Note: We’re inverting through a circle in the Euclidean sense (using Euclidean distance <code>dist2</code>), but this operation is actually a hyperbolic isometry! The magic is that circle inversion’s conformal properties exactly match the hyperbolic metric’s requirements.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Why Two Types of Reflections?
</div>
</div>
<div class="callout-body-container callout-body">
<p>In Euclidean geometry, all reflections across lines look the same—just the orientation changes. Why do we need two different functions in hyperbolic geometry?</p>
<p>The answer is that we’re working in a <strong>model</strong> of hyperbolic geometry (the upper half-plane). The vertical lines and semicircles are the images of geodesics in this model. In the intrinsic hyperbolic geometry, all reflections across geodesics are the same—there’s only one type of reflection.</p>
<p>But when we represent hyperbolic geometry in the Euclidean upper half-plane, geodesics appear as two different types of curves (vertical lines and semicircles), so we need two different formulas. This is an artifact of the model, not the geometry itself.</p>
<p>In the Poincaré disk model (coming soon), ALL geodesics are circular arcs perpendicular to the boundary circle, so we’d only need one reflection function there!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="the-23-triangle" class="level3">
<h3 class="anchored" data-anchor-id="the-23-triangle">The (2,3,∞) Triangle</h3>
<p>Let’s build our first hyperbolic triangle tiling. The notation <span class="math inline">\((p, q, r)\)</span> means the triangle has angles <span class="math inline">\(\pi/p\)</span>, <span class="math inline">\(\pi/q\)</span>, and <span class="math inline">\(\pi/r\)</span> at its three vertices. So <span class="math inline">\((2,3,\infty)\)</span> means angles <span class="math inline">\(\pi/2\)</span>, <span class="math inline">\(\pi/3\)</span>, and <span class="math inline">\(0\)</span> (an ideal vertex at infinity).</p>
<p><strong>Why this triangle exists in hyperbolic geometry</strong>: The Gauss-Bonnet theorem tells us the area of a hyperbolic triangle with angles <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span> is: <span class="math display">\[\text{Area} = \pi - (\alpha + \beta + \gamma)\]</span></p>
<p>For a <span class="math inline">\((2,3,\infty)\)</span> triangle: <span class="math display">\[\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + 0\right) = \pi - \frac{5\pi}{6} = \frac{\pi}{6} &gt; 0\]</span></p>
<p>So this triangle has finite positive area and can tile the hyperbolic plane. In Euclidean geometry, <span class="math inline">\(\pi/2 + \pi/3 = 5\pi/6 &lt; \pi\)</span>, but that’s not enough—we’d need the sum to equal <em>exactly</em> <span class="math inline">\(\pi\)</span> to get zero curvature. Since <span class="math inline">\(5\pi/6 &lt; \pi\)</span>, there’s negative curvature left over, making this a hyperbolic triangle.</p>
<p><strong>Configuration</strong>: We’ll use a particularly nice setup in the upper half-plane: - <strong>Left boundary</strong>: Vertical line at <span class="math inline">\(x = -1\)</span> - <strong>Right boundary</strong>: Vertical line at <span class="math inline">\(x = 1\)</span><br>
- <strong>Bottom boundary</strong>: Unit semicircle from <span class="math inline">\(-1\)</span> to <span class="math inline">\(1\)</span> (centered at origin, radius <span class="math inline">\(1\)</span>)</p>
<p>This creates a triangle with: - Two finite vertices at approximately <span class="math inline">\((-1, 0)\)</span> and <span class="math inline">\((1, 0)\)</span> (technically infinitesimally above the real axis) - One ideal vertex at <span class="math inline">\(\infty\)</span> (straight up the imaginary axis) - Angles of <span class="math inline">\(\pi/2\)</span> at the bottom two vertices (vertical line meets semicircle at right angles) - Angle of <span class="math inline">\(\pi/3\)</span> between the two vertical lines when measured hyperbolically - Angle of <span class="math inline">\(0\)</span> at the ideal vertex <span class="math inline">\(\infty\)</span></p>
<section id="implementation" class="level4">
<h4 class="anchored" data-anchor-id="implementation">Implementation</h4>
<p>Here’s the complete shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> x_pos<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> x_pos<span class="op">)</span> <span class="op">*</span> side <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x_pos <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> rel <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>rel<span class="op">,</span> rel<span class="op">);</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>dist2 <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> side <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span>radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> rel <span class="op">/</span> dist2<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Shift to upper half-plane (need y &gt; 0)</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the (2,3,∞) triangle</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">50</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> z_old <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across left vertical line (x = -1, want x &gt; -1)</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across right vertical line (x = 1, want x &lt; 1)</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across semicircle (from -1 to 1, want outside/above)</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're inside</span></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>z <span class="op">-</span> z_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by fold count parity</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parity <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span><span class="dt">float</span><span class="op">(</span>foldCount<span class="op">),</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>parity <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.9</span><span class="op">);</span>  <span class="co">// Light blue</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Darker blue</span></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Darken if below the real axis (outside hyperbolic space)</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>z<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>        color <span class="op">*=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis <span class="math inline">\(y = 0\)</span>)—they’re all the same hyperbolic size, but Euclidean distances compress due to the <span class="math inline">\(1/y^2\)</span> metric.</p>
<p>The alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Compare to Euclidean
</div>
</div>
<div class="callout-body-container callout-body">
<p>Look at the structure of this shader compared to the Euclidean triangle tiling:</p>
<p><strong>Euclidean:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Hyperbolic:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Computational Analysis
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>GPU Parallelism</strong>: Just like Days 1 and 2, this algorithm is embarrassingly parallel. Each pixel computes independently—no communication, no shared state, perfect for GPU architecture.</p>
<p><strong>Convergence</strong>: The folding algorithm works for the same group-theoretic reasons as the Euclidean case. The three reflections generate a discrete group of hyperbolic isometries, and our fundamental triangle is a fundamental domain for this group’s action on <span class="math inline">\(\mathbb{H}^2\)</span>.</p>
<p><strong>Precision issues</strong>: Near <span class="math inline">\(y \to 0\)</span>, floating-point precision degrades. The large conformal factor <span class="math inline">\(1/y^2\)</span> amplifies small errors in distance calculations. This is why we darken the region <span class="math inline">\(y &lt; 0\)</span>—technically it’s not part of the hyperbolic plane, but also our numerics become unreliable there.</p>
<p><strong>Threshold <span class="math inline">\(0.0001\)</span></strong>: This convergence threshold balances precision and performance. Smaller thresholds catch more subtle movements but risk getting stuck in floating-point noise; larger thresholds might terminate early. For visualization purposes, <span class="math inline">\(0.0001\)</span> is a good sweet spot.</p>
<p><strong>Memory efficiency</strong>: Each pixel only needs to store its current position <code>z</code> (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures—just stateless iteration. This is as memory-efficient as you can get!</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Visualizing Hyperbolic Triangle Structure
</div>
</div>
<div class="callout-body-container callout-body">
<p>Want to see the edges and vertices of your hyperbolic triangles? This requires computing hyperbolic distances.</p>
<p><strong>For hyperbolic distance:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span><span class="dt">vec2</span> z1<span class="op">,</span> <span class="dt">vec2</span> z2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> diff <span class="op">=</span> z1 <span class="op">-</span> z2<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> diff2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>diff<span class="op">,</span> diff<span class="op">);</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> z1<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> z2<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> arg <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> diff2 <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">log</span><span class="op">(</span>arg <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span>arg <span class="op">*</span> arg <span class="op">-</span> <span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For drawing edges</strong> (vertical lines):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Distance to vertical line x = c</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> distToVertical <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> c<span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>distToVertical <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For drawing edges</strong> (semicircular geodesics):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Distance to semicircle from p to q</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> distToCircle <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">))</span> <span class="op">-</span> radius<span class="op">);</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Only draw if above real axis</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>z<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">0.0</span> <span class="op">&amp;&amp;</span> distToCircle <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For vertices</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Check hyperbolic distance to vertices after folding</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v1 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.01</span><span class="op">);</span>  <span class="co">// Left vertex (slightly above axis)</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v2 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.01</span><span class="op">);</span>   <span class="co">// Right vertex</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span><span class="fu">hyperbolicDistance</span><span class="op">(</span>z<span class="op">,</span> v1<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.1</span> <span class="op">||</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span>z<span class="op">,</span> v2<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// Red vertices</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>See Appendix H5 for the complete enhanced implementation!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="multiple-models-of-hyperbolic-space" class="level3">
<h3 class="anchored" data-anchor-id="multiple-models-of-hyperbolic-space">Multiple Models of Hyperbolic Space</h3>
<p>The upper half-plane is just one way to represent hyperbolic geometry. There are several other models, each with advantages:</p>
<section id="the-poincaré-disk-model" class="level4">
<h4 class="anchored" data-anchor-id="the-poincaré-disk-model">The Poincaré Disk Model</h4>
<p>The <strong>Poincaré disk model</strong> represents all of <span class="math inline">\(\mathbb{H}^2\)</span> as the interior of the unit disk <span class="math inline">\(\{z \in \mathbb{C} : |z| &lt; 1\}\)</span>. The boundary circle <span class="math inline">\(|z| = 1\)</span> represents points at infinity.</p>
<p><strong>Geodesics</strong> in this model are: - Diameters of the disk (straight lines through the origin) - Circular arcs perpendicular to the boundary circle</p>
<p>The conformal factor here is <span class="math inline">\(\frac{4}{(1-|z|^2)^2}\)</span>, which blows up as <span class="math inline">\(|z| \to 1\)</span> (approaching the boundary).</p>
<p><strong>Advantages</strong>: - The entire hyperbolic plane fits in a bounded region (the disk) - All geodesics look similar (circular arcs)—no distinction between vertical and circular - Visually intuitive for understanding the full structure at once</p>
<p><strong>Disadvantages</strong>: - Harder to compute distances - More complex reflection formulas</p>
</section>
<section id="converting-between-models-the-cayley-transform" class="level4">
<h4 class="anchored" data-anchor-id="converting-between-models-the-cayley-transform">Converting Between Models: The Cayley Transform</h4>
<p>We can convert between the upper half-plane and Poincaré disk using the <strong>Cayley transform</strong> (also called the Möbius transformation):</p>
<p><span class="math display">\[w = \frac{z - i}{z + i}\]</span></p>
<p>This maps: - Upper half-plane <span class="math inline">\(\{z : \operatorname{Im}(z) &gt; 0\}\)</span> → Poincaré disk <span class="math inline">\(\{w : |w| &lt; 1\}\)</span> - Real axis <span class="math inline">\(\{z : \operatorname{Im}(z) = 0\}\)</span> → Unit circle <span class="math inline">\(\{w : |w| = 1\}\)</span> - Point <span class="math inline">\(i\)</span> in the upper half-plane → origin <span class="math inline">\(0\)</span> in the disk</p>
<p>The inverse transform is: <span class="math display">\[z = i\frac{1 + w}{1 - w}\]</span></p>
<p>Here’s the implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">,</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cdiv</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>b<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">,</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">uhpToDisk</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// w = (z - i) / (z + i)</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> i <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>z <span class="op">-</span> i<span class="op">,</span> z <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">diskToUhp</span><span class="op">(</span><span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// z = i(1 + w) / (1 - w)</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> i <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> one <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cmul</span><span class="op">(</span>i<span class="op">,</span> <span class="fu">cdiv</span><span class="op">(</span>one <span class="op">+</span> w<span class="op">,</span> one <span class="op">-</span> w<span class="op">));</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>To display your tiling in the Poincaré disk:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup for disk</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2.5</span><span class="op">;</span>  <span class="co">// Fit disk in viewport</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert disk coordinates to upper half-plane</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> <span class="fu">diskToUhp</span><span class="op">(</span>uv<span class="op">);</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Run your tiling algorithm in UHP</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... (fold into (2,3,∞) triangle as before)</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color and render</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="the-klein-model" class="level4">
<h4 class="anchored" data-anchor-id="the-klein-model">The Klein Model</h4>
<p>The <strong>Klein model</strong> (also called the <strong>Beltrami-Klein model</strong> or <strong>projective disk model</strong>) is another disk representation. Its defining feature: <strong>geodesics are Euclidean straight lines</strong>! This makes some geometric properties clearer but sacrifices the conformal property—angles are distorted.</p>
<p>Converting from Poincaré disk to Klein disk:</p>
<p><span class="math display">\[\text{Klein}(w) = \frac{2w}{1 + |w|^2}\]</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">poincareToKlein</span><span class="op">(</span><span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> <span class="bu">dot</span><span class="op">(</span>w<span class="op">,</span> w<span class="op">);</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fl">2.0</span> <span class="op">*</span> w <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The inverse:</p>
<p><span class="math display">\[w = \frac{\text{Klein}(w)}{1 + \sqrt{1 - |\text{Klein}(w)|^2}}\]</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">kleinToPoincare</span><span class="op">(</span><span class="dt">vec2</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> k2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>k<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span><span class="fl">1.0</span> <span class="op">-</span> k2<span class="op">);</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> k <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Advantages of Klein</strong>: - Geodesics are straight lines (simplest to compute) - Great for understanding incidence relationships</p>
<p><strong>Disadvantages</strong>: - Not conformal—angles are distorted - Harder to see hyperbolic distances</p>
<hr>
</section>
</section>
<section id="other-triangle-groups" class="level3">
<h3 class="anchored" data-anchor-id="other-triangle-groups">Other Triangle Groups</h3>
<p>The <span class="math inline">\((2,3,\infty)\)</span> triangle is just the beginning. Many other hyperbolic triangles can tile the plane! The most famous is the <span class="math inline">\((2,3,7)\)</span> triangle.</p>
<section id="the-237-triangle" class="level4">
<h4 class="anchored" data-anchor-id="the-237-triangle">The <span class="math inline">\((2,3,7)\)</span> Triangle</h4>
<p>This triangle has angles <span class="math inline">\(\pi/2\)</span>, <span class="math inline">\(\pi/3\)</span>, and <span class="math inline">\(\pi/7\)</span>. Its area is: <span class="math display">\[\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + \frac{\pi}{7}\right) = \frac{\pi}{42}\]</span></p>
<p>This is one of the smallest compact hyperbolic triangles! It produces incredibly dense tilings—the <span class="math inline">\((2,3,7)\)</span> tiling has a 7-fold symmetry that creates intricate patterns reminiscent of M.C. Escher’s work.</p>
<p>In fact, Escher’s famous <em>Circle Limit</em> prints (especially Circle Limit III with the fish) are based on tilings by <span class="math inline">\((2,3,7)\)</span> and related triangle groups. The hyperbolic geometry creates the exponential compression toward the boundary that gives these prints their distinctive character.</p>
<p><strong>Classification of hyperbolic triangles</strong>: Not every combination <span class="math inline">\((p,q,r)\)</span> gives a hyperbolic triangle. The Gauss-Bonnet formula tells us we need: <span class="math display">\[\frac{1}{p} + \frac{1}{q} + \frac{1}{r} &lt; 1\]</span></p>
<p>for a hyperbolic triangle (negative curvature). If the sum equals exactly <span class="math inline">\(1\)</span>, we get a Euclidean triangle. If the sum is greater than <span class="math inline">\(1\)</span>, we get a spherical triangle (positive curvature).</p>
<p><strong>Examples</strong>: - <span class="math inline">\((2,3,7)\)</span>: <span class="math inline">\(\frac{1}{2} + \frac{1}{3} + \frac{1}{7} = \frac{41}{42} &lt; 1\)</span> ✓ Hyperbolic - <span class="math inline">\((2,3,\infty)\)</span>: <span class="math inline">\(\frac{1}{2} + \frac{1}{3} + 0 = \frac{5}{6} &lt; 1\)</span> ✓ Hyperbolic - <span class="math inline">\((3,3,3)\)</span>: <span class="math inline">\(\frac{1}{3} + \frac{1}{3} + \frac{1}{3} = 1\)</span> ✓ Euclidean (equilateral triangle) - <span class="math inline">\((2,3,5)\)</span>: <span class="math inline">\(\frac{1}{2} + \frac{1}{3} + \frac{1}{5} = \frac{31}{30} &gt; 1\)</span> ✓ Spherical (icosahedron face)</p>
<p>Implementing other triangle groups requires computing where the third geodesic should be, given the angle constraints. This is non-trivial and involves hyperbolic trigonometry—we leave this as an advanced homework exercise!</p>
<hr>
</section>
</section>
</section>
<section id="summary" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="summary"><span class="header-section-number">3.4</span> Summary</h2>
<p>Today we learned:</p>
<ol type="1">
<li><p><strong>The folding algorithm</strong>: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry</p></li>
<li><p><strong>Half-space structure</strong>: Boundary + side gives a unified way to encode regions in Euclidean geometry</p></li>
<li><p><strong>Why it works</strong>: <strong>Reflection groups</strong> and fundamental domains—the group-theoretic perspective that unifies all our iterative algorithms across Days 2 and 3</p></li>
<li><p><strong>Hyperbolic geometry</strong>: Negative curvature space with two types of geodesics (vertical lines and semicircles in the UHP model)</p></li>
<li><p><strong>Connection to Day 2</strong>: Circle inversion is a hyperbolic isometry! The Apollonian gasket is actually a hyperbolic object</p></li>
<li><p><strong>Two reflection functions</strong>: <code>reflectIntoVertical</code> and <code>reflectIntoCircular</code> parallel the Euclidean <code>reflectInto</code></p></li>
<li><p><strong>Multiple models</strong>: Converting between upper half-plane and Poincaré disk using the Cayley transform</p></li>
<li><p><strong>Historical context</strong>: The dramatic discovery of hyperbolic geometry by Gauss, Bolyai, and Lobachevsky in the 19th century</p></li>
<li><p><strong>Computational perspective</strong>: GPU parallelism, convergence rates, precision issues, iteration count tuning</p></li>
</ol>
<p><strong>Key insight</strong>: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!</p>
<p><strong>The universal pattern</strong>: - <strong>Day 1</strong>: Distance fields and implicit curves—visualizing mathematics on the GPU - <strong>Day 2</strong>: Iterating circle inversions to create the Apollonian gasket—first group action - <strong>Day 3 (Euclidean)</strong>: Iterating reflections to create tilings—reflection groups make it work - <strong>Day 3 (Hyperbolic)</strong>: Same algorithm, different geometry—circle inversion reappears as hyperbolic isometry!</p>
<p>The through-line is <strong>geometric transformations and their groups</strong>. When we iterate a group action to reach a fundamental domain, we create tilings, fractals, and beautiful mathematical art.</p>
<hr>
</section>
<section id="homework" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="homework"><span class="header-section-number">3.5</span> Homework</h2>
<section id="required-0-understanding-hyperbolic-distance" class="level3">
<h3 class="anchored" data-anchor-id="required-0-understanding-hyperbolic-distance">Required #0: Understanding Hyperbolic Distance</h3>
<p><strong>Goal</strong>: Build geometric intuition for how hyperbolic distance works before implementing tilings.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p><strong>Euclidean distance visualization</strong>: Implement the shader showing Euclidean distance circles (provided in lecture). Drag the center around and observe that circles stay the same size everywhere.</p></li>
<li><p><strong>Hyperbolic distance visualization</strong>: Implement the hyperbolic version (provided in lecture). Drag the center and observe how the “circle” changes shape—growing huge near <span class="math inline">\(y \to 0\)</span> and shrinking as <span class="math inline">\(y\)</span> increases.</p></li>
<li><p><strong>Observations</strong>: Write 2-3 sentences describing what you observe about how hyperbolic “circles” behave compared to Euclidean ones. Why does the shape change as you drag the center?</p></li>
</ol>
<p><strong>Expected output</strong>: Two working shaders demonstrating the difference between Euclidean and hyperbolic distance.</p>
<hr>
</section>
<section id="required-1-euclidean-triangle-tiling-with-edges-and-vertices" class="level3">
<h3 class="anchored" data-anchor-id="required-1-euclidean-triangle-tiling-with-edges-and-vertices">Required #1: Euclidean Triangle Tiling with Edges and Vertices</h3>
<p><strong>Goal</strong>: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p>Start with the basic triangle tiling from lecture</p></li>
<li><p><strong>Add edge visualization</strong> using distance to half-spaces</p></li>
<li><p><strong>Add vertex markers</strong> at the three triangle vertices</p></li>
<li><p><strong>Create an attractive color scheme</strong></p></li>
</ol>
<p><strong>Expected output</strong>: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.</p>
<p>See Appendix E9 for reference implementation.</p>
<p><strong>Bonus</strong>: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.</p>
<hr>
</section>
<section id="required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" class="level3">
<h3 class="anchored" data-anchor-id="required-2-hyperbolic-triangle-tiling-with-edges-and-vertices">Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</h3>
<p><strong>Goal</strong>: Create a beautiful hyperbolic triangle tiling with visible structure.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p>Start with the basic <span class="math inline">\((2,3,\infty)\)</span> tiling from lecture</p></li>
<li><p><strong>Implement hyperbolic distance functions</strong> (see hints in lecture)</p></li>
<li><p><strong>Draw geodesic edges</strong> using hyperbolic distance to geodesics</p></li>
<li><p><strong>Draw vertices</strong> using hyperbolic distance to vertex points</p></li>
<li><p><strong>Create an attractive color scheme</strong></p></li>
</ol>
<p><strong>Expected output</strong>: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.</p>
<p>See Appendix H5 for complete reference implementation.</p>
<p><strong>Bonus</strong>: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.</p>
<hr>
</section>
<section id="required-3-model-conversions" class="level3">
<h3 class="anchored" data-anchor-id="required-3-model-conversions">Required #3: Model Conversions</h3>
<p><strong>Goal</strong>: See the same tiling in different representations of hyperbolic space.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p><strong>Poincaré Disk</strong> (already provided in lecture): Verify it works with your tiling code</p></li>
<li><p><strong>Klein Model</strong>: Implement the transformation from Poincaré disk to Klein disk (see lecture for formula)</p>
<p>In the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.</p></li>
<li><p><strong>Comparison</strong>: Show your <span class="math inline">\((2,3,\infty)\)</span> tiling in both the Poincaré disk and Klein model side-by-side. Write a few sentences about what you observe.</p></li>
</ol>
<p><strong>Deliverable</strong>: Screenshots of your tiling in at least two models, with brief observations.</p>
<p>See Appendix H7 for Klein model reference.</p>
<hr>
</section>
<section id="required-4-different-triangle-groups-challenge" class="level3">
<h3 class="anchored" data-anchor-id="required-4-different-triangle-groups-challenge">Required #4: Different Triangle Groups (Challenge!)</h3>
<p><strong>Goal</strong>: Explore other hyperbolic tilings by implementing different triangle groups.</p>
<p><strong>The Challenge</strong>: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.</p>
<p><strong>Suggested triangles to try</strong>: - <strong>(2, 3, 7)</strong>: Creates Escher-like tilings with 7-fold symmetry - <strong>(2, 4, 6)</strong>: Different symmetry pattern - <strong>(3, 3, 3)</strong>: Equilateral hyperbolic triangle</p>
<p><strong>Approach</strong>: Use the hyperbolic law of cosines (see lecture for formula) to compute geodesic positions.</p>
<p><strong>Deliverable</strong>: Working tiling for at least one triangle group other than <span class="math inline">\((2,3,\infty)\)</span>. Include screenshots and document your approach.</p>
<hr>
</section>
<section id="optional-exercises" class="level3">
<h3 class="anchored" data-anchor-id="optional-exercises">Optional Exercises</h3>
<p><strong>Optional #1: Unified Abstractions</strong> - Create structs that work for both Euclidean and hyperbolic geometry</p>
<p><strong>Optional #2: Decorated Tiles</strong> - Add Escher-style patterns within fundamental domains</p>
<p><strong>Optional #3: Pentagon Tilings</strong> - Right-angled pentagons can tile hyperbolic space!</p>
<p>See lecture for details on these optional exercises.</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">3.6</span> Looking Ahead</h2>
<p>We’ve now seen three days of geometric iteration: - <strong>Day 1</strong>: Distance fields and implicit functions - <strong>Day 2</strong>: Circle inversion and the Apollonian gasket - <strong>Day 3</strong>: Reflection groups in Euclidean and hyperbolic geometry</p>
<p>The common thread: <strong>group actions on geometric spaces</strong>. Iteratively applying transformations to reach a desired region, whether it’s the fundamental domain of a tiling or the gap structure of a fractal.</p>
<p>The techniques you’ve learned—GPU parallelism, iterative algorithms, group theory, geometric transformations—apply across a huge landscape of mathematical visualization!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../lectures/day2.html" class="pagination-link" aria-label="Day 2: Complex Dynamics and Iterated Inversions">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../lectures/day4.html" class="pagination-link" aria-label="Day 4: Introduction to 3D Rendering">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>