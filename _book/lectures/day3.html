<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Day 3: Geometric Tilings in Euclidean and Hyperbolic Space – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../lectures/day4.html" rel="next">
<link href="../lectures/day2.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-b758ccaa5987ceb1b75504551e579abf.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9e2e301c0fdd450bb15139cdeddb1e82.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-78490966b4b15172cdd2cc194ce59f52.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-9e2e301c0fdd450bb15139cdeddb1e82.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/day3.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/stevejtrettel/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="../GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day1-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 1</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day2-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 2</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/day3-shaders.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Appendix: Complete Shader Code for Day 3</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../appendices/glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">3.1</span> Overview</a></li>
  <li><a href="#part-1-reflection-and-tilings-in-euclidean-geometry" id="toc-part-1-reflection-and-tilings-in-euclidean-geometry" class="nav-link" data-scroll-target="#part-1-reflection-and-tilings-in-euclidean-geometry"><span class="header-section-number">3.2</span> Part 1: Reflection and Tilings in Euclidean Geometry</a>
  <ul class="collapse">
  <li><a href="#starting-simple-the-folding-algorithm" id="toc-starting-simple-the-folding-algorithm" class="nav-link" data-scroll-target="#starting-simple-the-folding-algorithm">Starting Simple: The Folding Algorithm</a></li>
  <li><a href="#abstracting-half-spaces" id="toc-abstracting-half-spaces" class="nav-link" data-scroll-target="#abstracting-half-spaces">Abstracting: Half-Spaces</a></li>
  <li><a href="#square-tiling-with-half-spaces" id="toc-square-tiling-with-half-spaces" class="nav-link" data-scroll-target="#square-tiling-with-half-spaces">Square Tiling with Half-Spaces</a></li>
  <li><a href="#triangle-tiling" id="toc-triangle-tiling" class="nav-link" data-scroll-target="#triangle-tiling">Triangle Tiling</a></li>
  <li><a href="#why-does-this-algorithm-work-reflection-groups" id="toc-why-does-this-algorithm-work-reflection-groups" class="nav-link" data-scroll-target="#why-does-this-algorithm-work-reflection-groups">Why Does This Algorithm Work? Reflection Groups</a></li>
  </ul></li>
  <li><a href="#part-2-hyperbolic-geometry" id="toc-part-2-hyperbolic-geometry" class="nav-link" data-scroll-target="#part-2-hyperbolic-geometry"><span class="header-section-number">3.3</span> Part 2: Hyperbolic Geometry</a>
  <ul class="collapse">
  <li><a href="#introduction-to-hyperbolic-geometry" id="toc-introduction-to-hyperbolic-geometry" class="nav-link" data-scroll-target="#introduction-to-hyperbolic-geometry">Introduction to Hyperbolic Geometry</a></li>
  <li><a href="#the-upper-half-plane-model" id="toc-the-upper-half-plane-model" class="nav-link" data-scroll-target="#the-upper-half-plane-model">The Upper Half-Plane Model</a></li>
  <li><a href="#the-boundary-at-infinity" id="toc-the-boundary-at-infinity" class="nav-link" data-scroll-target="#the-boundary-at-infinity">The Boundary at Infinity</a></li>
  <li><a href="#geodesics-and-reflections" id="toc-geodesics-and-reflections" class="nav-link" data-scroll-target="#geodesics-and-reflections">Geodesics and Reflections</a></li>
  <li><a href="#the-23-triangle" id="toc-the-23-triangle" class="nav-link" data-scroll-target="#the-23-triangle">The (2,3,∞) Triangle</a></li>
  <li><a href="#multiple-models-of-hyperbolic-space" id="toc-multiple-models-of-hyperbolic-space" class="nav-link" data-scroll-target="#multiple-models-of-hyperbolic-space">Multiple Models of Hyperbolic Space</a></li>
  <li><a href="#other-triangle-groups" id="toc-other-triangle-groups" class="nav-link" data-scroll-target="#other-triangle-groups">Other Triangle Groups</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">3.4</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">3.5</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-0-understanding-hyperbolic-distance" id="toc-required-0-understanding-hyperbolic-distance" class="nav-link" data-scroll-target="#required-0-understanding-hyperbolic-distance">Required #0: Understanding Hyperbolic Distance</a></li>
  <li><a href="#required-1-euclidean-triangle-tiling-with-edges-and-vertices" id="toc-required-1-euclidean-triangle-tiling-with-edges-and-vertices" class="nav-link" data-scroll-target="#required-1-euclidean-triangle-tiling-with-edges-and-vertices">Required #1: Euclidean Triangle Tiling with Edges and Vertices</a></li>
  <li><a href="#required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" id="toc-required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" class="nav-link" data-scroll-target="#required-2-hyperbolic-triangle-tiling-with-edges-and-vertices">Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</a></li>
  <li><a href="#required-3-model-conversions" id="toc-required-3-model-conversions" class="nav-link" data-scroll-target="#required-3-model-conversions">Required #3: Model Conversions</a></li>
  <li><a href="#required-4-different-triangle-groups-challenge" id="toc-required-4-different-triangle-groups-challenge" class="nav-link" data-scroll-target="#required-4-different-triangle-groups-challenge">Required #4: Different Triangle Groups (Challenge!)</a></li>
  <li><a href="#optional-exercises" id="toc-optional-exercises" class="nav-link" data-scroll-target="#optional-exercises">Optional Exercises</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">3.6</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">3.1</span> Overview</h2>
<p>Today we explore geometric tilings through reflection operations. We’ll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.</p>
<p>The key insight: <strong>the algorithm stays the same across geometries—only the reflection operations change.</strong> This mirrors what we saw on Day 2 with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region. But today we’ll understand <em>why</em> this works through the lens of group theory.</p>
<p>By the end of today, you’ll understand: - How to construct reflections using linear algebra - <strong>Why the folding algorithm works</strong> (reflection groups and fundamental domains) - The structure of hyperbolic geometry in the upper half-plane model - How to implement hyperbolic triangle tilings using the same algorithmic pattern - How to convert between different models of hyperbolic space - The connection between circle inversion (Day 2) and hyperbolic isometries</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Roadmap for Today
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Part 1: Euclidean Geometry</strong> - Simple tilings (strip, square) - Half-space abstraction - Triangle tilings - <strong>Why this works</strong>: Reflection groups</p>
<p><strong>Part 2: Hyperbolic Geometry</strong> - The upper half-plane model and metric - Geodesics and reflections (connection to Day 2!) - Triangle tilings in <span class="math inline">\(\mathbb{H}^2\)</span> - Multiple models (Poincaré disk, Klein) - Historical context and applications</p>
<p>The unifying theme is <strong>geometric transformations and their groups</strong>—the same mathematical structure underlies fractals, tilings, and symmetry across all geometries.</p>
</div>
</div>
<hr>
</section>
<section id="part-1-reflection-and-tilings-in-euclidean-geometry" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="part-1-reflection-and-tilings-in-euclidean-geometry"><span class="header-section-number">3.2</span> Part 1: Reflection and Tilings in Euclidean Geometry</h2>
<section id="starting-simple-the-folding-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="starting-simple-the-folding-algorithm">Starting Simple: The Folding Algorithm</h3>
<p>Before we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.</p>
<section id="tiling-a-strip" class="level4">
<h4 class="anchored" data-anchor-id="tiling-a-strip">Tiling a Strip</h4>
<p>Imagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip <span class="math inline">\(0 &lt; x &lt; 1\)</span>—and reflect any point outside this strip back inside.</p>
<p>The algorithm is remarkably simple: - If <span class="math inline">\(x &lt; 0\)</span>, reflect across <span class="math inline">\(x = 0\)</span> - If <span class="math inline">\(x &gt; 1\)</span>, reflect across <span class="math inline">\(x = 1\)</span><br>
- Repeat until the point stops moving</p>
<p>For a vertical line at <span class="math inline">\(x = c\)</span>, reflection just flips the <span class="math inline">\(x\)</span>-coordinate: <span class="math inline">\((x, y) \mapsto (2c - x, y)\)</span>.</p>
<p>Here’s a complete shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Standard coordinate setup</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the strip [0, 1]</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Dark background</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A circle in the strip</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">));</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Yellow circle</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.</p>
<p><strong>What’s happening geometrically?</strong> Every point on the screen gets mapped back to the fundamental domain <span class="math inline">\([0,1]\)</span>. Points that were in reflected copies of the domain get folded back through a sequence of reflections. Since we draw the same pattern in the fundamental domain, all the reflected copies show the same pattern.</p>
<hr>
</section>
<section id="square-tiling" class="level4">
<h4 class="anchored" data-anchor-id="square-tiling">Square Tiling</h4>
<p>Let’s extend to two dimensions. Now we have four boundaries: <span class="math inline">\(x = 0\)</span>, <span class="math inline">\(x = 1\)</span>, <span class="math inline">\(y = 0\)</span>, and <span class="math inline">\(y = 1\)</span>. Same algorithm, just more boundaries to check:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square [0,1] × [0,1]</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle at center</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Perfect! A full 2D tiling.</p>
<hr>
</section>
<section id="square-tiling-with-fold-count" class="level4">
<h4 class="anchored" data-anchor-id="square-tiling-with-fold-count">Square Tiling with Fold Count</h4>
<p>Let’s track how many reflections were needed. This helps us understand the geometry and creates beautiful visualizations:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square [0,1] × [0,1]</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="op">-</span>p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">1.0</span><span class="op">)</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're done</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">8.0</span><span class="op">;</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> t <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">)));</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in the fundamental domain</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">,</span> d<span class="op">));</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Beautiful! The color gradient shows how many reflections were needed—points near the fundamental domain require few iterations, while points far away need many.</p>
<p>Notice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain and we can stop.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Computational Efficiency: Iteration Count
</div>
</div>
<div class="callout-body-container callout-body">
<p>Why does this converge so quickly? Each reflection moves the point strictly closer to the fundamental domain (in the sense of reducing the number of boundary crossings). For a viewport of size <span class="math inline">\(4 \times 4\)</span> and fundamental domain of size <span class="math inline">\(1 \times 1\)</span>, we need at most <span class="math inline">\(\lceil \log_2(4) \rceil = 2\)</span> reflections per axis, so 4 reflections total in the worst case.</p>
<p>The 20-iteration limit is very conservative—most pixels converge in under 5 iterations. We could dynamically adjust this based on the coordinate scale, but for real-time rendering, a fixed conservative bound works well.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="abstracting-half-spaces" class="level3">
<h3 class="anchored" data-anchor-id="abstracting-half-spaces">Abstracting: Half-Spaces</h3>
<p>Looking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.</p>
<section id="what-is-a-half-space" class="level4">
<h4 class="anchored" data-anchor-id="what-is-a-half-space">What is a Half-Space?</h4>
<p>A <strong>half-space</strong> is one side of a line. Any line <span class="math inline">\(ax + by = c\)</span> divides the plane into two regions: - Points where <span class="math inline">\(ax + by &lt; c\)</span> - Points where <span class="math inline">\(ax + by &gt; c\)</span></p>
<p>We’ll encode a half-space by storing the line parameters and which side we want:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span>  <span class="co">// Line parameters: ax + by = c</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span>     <span class="co">// +1 or -1 for which side</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The <code>side</code> parameter determines which inequality we want: - <code>side = -1.0</code> means we want <span class="math inline">\(ax + by &gt; c\)</span> (equivalently, <span class="math inline">\((ax + by - c) \cdot (-1) &lt; 0\)</span>) - <code>side = 1.0</code> means we want <span class="math inline">\(ax + by &lt; c\)</span> (equivalently, <span class="math inline">\((ax + by - c) \cdot (1) &lt; 0\)</span>)</p>
<p>This might seem redundant—we could always use <span class="math inline">\(ax + by &lt; c\)</span> and just flip the signs of <span class="math inline">\(a, b, c\)</span> to get the other side. But having an explicit <code>side</code> parameter makes the code clearer and will be essential in hyperbolic geometry where sign-flipping doesn’t work as cleanly.</p>
</section>
<section id="visualizing-half-spaces" class="level4">
<h4 class="anchored" data-anchor-id="visualizing-half-spaces">Visualizing Half-Spaces</h4>
<p>Before we implement reflections, let’s visualize what a half-space is. Here’s a shader that colors one side of a line:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">inside</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define a half-space: x &lt; 1 (left side of vertical line at x=1)</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on whether we're inside</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.7</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see the left side of the line colored blue, the right side dark. Try changing the half-space parameters to see how it affects the coloring!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Drawing the Boundary Line
</div>
</div>
<div class="callout-body-container callout-body">
<p>Want to see where the line is? Add this distance function:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">distToHalfSpace</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">abs</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> <span class="bu">length</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">));</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Then draw the line:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs<span class="op">);</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White boundary</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This computes the perpendicular distance from the point to the line, then colors points near the line white. See Appendix E4b for the complete implementation!</p>
</div>
</div>
</section>
<section id="intersecting-half-spaces-making-a-square" class="level4">
<h4 class="anchored" data-anchor-id="intersecting-half-spaces-making-a-square">Intersecting Half-Spaces: Making a Square</h4>
<p>Now let’s intersect four half-spaces to create a square region. We’ll use <strong>additive coloring</strong>—each half-space we’re inside adds to the color, so the interior (inside all four) will be brightest:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">inside</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define the four half-spaces for [0,1] × [0,1]</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    HalfSpace left   <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// x &gt; 0</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    HalfSpace right  <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// x &lt; 1</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    HalfSpace bottom <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// y &gt; 0</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    HalfSpace top    <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// y &lt; 1</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Additive coloring - each half-space adds brightness</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> left<span class="op">))</span>   color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> right<span class="op">))</span>  color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> bottom<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> top<span class="op">))</span>    color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see the square region brightest (inside all four half-spaces), with regions inside fewer half-spaces progressively darker. This additive approach makes it easy to see how the regions overlap!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Improved Visualization
</div>
</div>
<div class="callout-body-container callout-body">
<p>For a cleaner look, you might want to:</p>
<ol type="1">
<li><strong>Binary coloring</strong> (inside domain or not):</li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> in_square <span class="op">=</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> left<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> right<span class="op">)</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> bottom<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> top<span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> in_square <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.4</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol start="2" type="1">
<li><p><strong>Draw boundaries</strong> using the distance function from earlier</p></li>
<li><p><strong>Create an <code>insideDomain()</code> function</strong>:</p></li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">insideDomain</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs1<span class="op">,</span> HalfSpace hs2<span class="op">,</span> </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                  HalfSpace hs3<span class="op">,</span> HalfSpace hs4<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">)</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>           <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs4<span class="op">);</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>See Appendix E5b for complete enhanced versions!</p>
</div>
</div>
</section>
<section id="three-half-spaces-make-a-triangle" class="level4">
<h4 class="anchored" data-anchor-id="three-half-spaces-make-a-triangle">Three Half-Spaces Make a Triangle</h4>
<p>Let’s visualize three half-spaces defining a triangle:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="fu">inside</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define three half-spaces for equilateral triangle</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs1 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs2 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.732</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs3 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(-</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Additive coloring</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">);</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">);</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">inside</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">))</span> color <span class="op">+=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">);</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a triangle region where all three half-spaces overlap! The additive coloring helps visualize the structure.</p>
<hr>
</section>
<section id="the-reflection-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-reflection-formula">The Reflection Formula</h4>
<p>Now we’re ready to implement reflection. To reflect a point <span class="math inline">\(\mathbf{p} = (x, y)\)</span> across the line <span class="math inline">\(ax + by = c\)</span>, we use linear algebra. The normal vector to the line is <span class="math inline">\(\mathbf{n} = (a, b)\)</span>. After normalizing to <span class="math inline">\(\hat{\mathbf{n}} = \mathbf{n}/|\mathbf{n}|\)</span>, the reflection formula is:</p>
<p><span class="math display">\[\mathbf{p}' = \mathbf{p} - 2d\hat{\mathbf{n}}\]</span></p>
<p>where <span class="math inline">\(d\)</span> is the signed distance from <span class="math inline">\(\mathbf{p}\)</span> to the line:</p>
<p><span class="math display">\[d = \frac{ax + by - c}{\sqrt{a^2 + b^2}}\]</span></p>
<p>This is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.</p>
<p>Our <code>reflectInto</code> function checks if we’re on the correct side and only reflects if necessary—it <strong>extends</strong> our <code>inside()</code> test by conditionally reflecting:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute which side of the line we're on</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're already on the correct side (this is our inside() test!)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span>  <span class="co">// Already inside, nothing to do</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We're on the wrong side - reflect across the boundary line</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This function encapsulates the entire pattern: check if we’re on the correct side (the <code>inside()</code> test), and only reflect if we’re not. So <code>reflectInto()</code> extends and renames our visualization function to also perform the reflection!</p>
<hr>
</section>
</section>
<section id="square-tiling-with-half-spaces" class="level3">
<h3 class="anchored" data-anchor-id="square-tiling-with-half-spaces">Square Tiling with Half-Spaces</h3>
<p>Let’s rewrite our square tiling using this abstraction. For the square <span class="math inline">\([0, 1] \times [0, 1]\)</span>, we need four half-spaces:</p>
<ul>
<li><strong>Left edge</strong> (<span class="math inline">\(x = 0\)</span>): We want <span class="math inline">\(x &gt; 0\)</span> → <code>HalfSpace(1.0, 0.0, 0.0, -1.0)</code></li>
<li><strong>Right edge</strong> (<span class="math inline">\(x = 1\)</span>): We want <span class="math inline">\(x &lt; 1\)</span> → <code>HalfSpace(1.0, 0.0, 1.0, 1.0)</code></li>
<li><strong>Bottom and top</strong>: Similarly for <span class="math inline">\(y\)</span></li>
</ul>
<p>Complete shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define the four half-spaces for [0,1]×[0,1]</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>    HalfSpace left   <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    HalfSpace right  <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>    HalfSpace bottom <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>    HalfSpace top    <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span>  <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the square</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> left<span class="op">);</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> bottom<span class="op">);</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> top<span class="op">);</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color based on fold count</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> t <span class="op">=</span> <span class="dt">float</span><span class="op">(</span>foldCount<span class="op">)</span> <span class="op">/</span> <span class="fl">8.0</span><span class="op">;</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">cos</span><span class="op">(</span><span class="fl">6.28318</span> <span class="op">*</span> <span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">)</span> <span class="op">*</span> t <span class="op">+</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.33</span><span class="op">,</span> <span class="fl">0.67</span><span class="op">)));</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw something in fundamental domain</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>d <span class="op">&lt;</span> <span class="fl">0.3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="bu">smoothstep</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.25</span><span class="op">,</span> d<span class="op">));</span></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>This looks identical to our earlier version, but now our code is flexible. The beauty: <strong>changing from a square to a triangle only requires changing the half-space definitions!</strong></p>
<hr>
</section>
<section id="triangle-tiling" class="level3">
<h3 class="anchored" data-anchor-id="triangle-tiling">Triangle Tiling</h3>
<p>Now we’re ready for triangles. We’ll use an equilateral triangle with vertices at:</p>
<p><span class="math display">\[v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)\]</span></p>
<p>This triangle is centered at the origin with one vertex pointing up.</p>
<section id="computing-half-spaces-from-edges" class="level4">
<h4 class="anchored" data-anchor-id="computing-half-spaces-from-edges">Computing Half-Spaces from Edges</h4>
<p>For each edge, we need to compute the line parameters <span class="math inline">\((a, b, c)\)</span> and determine the correct side. The process:</p>
<ol type="1">
<li>Take two vertices defining an edge: <span class="math inline">\(\mathbf{v}_i\)</span> and <span class="math inline">\(\mathbf{v}_j\)</span></li>
<li>Compute edge direction: <span class="math inline">\(\mathbf{d} = \mathbf{v}_j - \mathbf{v}_i\)</span></li>
<li>Compute perpendicular (rotate 90° counterclockwise): <span class="math inline">\(\mathbf{n} = (-d_y, d_x)\)</span></li>
<li>Line equation: <span class="math inline">\(n_x \cdot x + n_y \cdot y = c\)</span> where <span class="math inline">\(c = \mathbf{n} \cdot \mathbf{v}_i\)</span></li>
<li>Test origin: if <span class="math inline">\((n_x \cdot 0 + n_y \cdot 0 - c) &lt; 0\)</span>, then <code>side = -1.0</code>, else <code>side = 1.0</code></li>
</ol>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Derivation of Triangle Half-Space Parameters
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Edge from <span class="math inline">\(v_0 = (0, 1)\)</span> to <span class="math inline">\(v_1 = (-\sqrt{3}/2, -1/2)\)</span>:</strong></p>
<ul>
<li>Edge direction: <span class="math inline">\(\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\)</span></li>
<li>Perpendicular (90° CCW): <span class="math inline">\(\mathbf{n} = (1.5, -0.866)\)</span></li>
<li>Line: <span class="math inline">\(1.5x - 0.866y = c\)</span> where <span class="math inline">\(c = \mathbf{n} \cdot v_0 = (1.5)(0) + (-0.866)(1) = -0.866\)</span></li>
<li>For origin (inside): <span class="math inline">\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\)</span></li>
<li>We want inside when <span class="math inline">\((ax + by - c) &lt; 0\)</span>, so we need <code>side = -1.0</code></li>
</ul>
<p><strong>Result:</strong> <code>HalfSpace(1.5, -0.866, -0.866, -1.0)</code></p>
<p>Similar calculations give: - <strong>Edge <span class="math inline">\(v_1\)</span> to <span class="math inline">\(v_2\)</span>:</strong> <code>HalfSpace(0.0, 1.732, -0.866, -1.0)</code> - <strong>Edge <span class="math inline">\(v_2\)</span> to <span class="math inline">\(v_0\)</span>:</strong> <code>HalfSpace(-1.5, -0.866, -0.866, -1.0)</code></p>
</div>
</div>
</div>
<p>The computed parameters are:</p>
<ul>
<li><strong>Edge <span class="math inline">\(v_0\)</span> to <span class="math inline">\(v_1\)</span>:</strong> <code>HalfSpace(1.5, -0.866, -0.866, -1.0)</code></li>
<li><strong>Edge <span class="math inline">\(v_1\)</span> to <span class="math inline">\(v_2\)</span>:</strong> <code>HalfSpace(0.0, 1.732, -0.866, -1.0)</code><br>
</li>
<li><strong>Edge <span class="math inline">\(v_2\)</span> to <span class="math inline">\(v_0\)</span>:</strong> <code>HalfSpace(-1.5, -0.866, -0.866, -1.0)</code></li>
</ul>
<p>We already verified these work with our visualization shader above!</p>
</section>
<section id="triangle-tiling-shader" class="level4">
<h4 class="anchored" data-anchor-id="triangle-tiling-shader">Triangle Tiling Shader</h4>
<p>Now we can implement the tiling by copying our reflection shader and just changing the half-spaces:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> HalfSpace <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> side<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectInto</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> value <span class="op">=</span> hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">*</span> hs<span class="op">.</span><span class="fu">side</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> normal <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">);</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> norm <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>normal<span class="op">);</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    normal <span class="op">=</span> normal <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> signedDist <span class="op">=</span> <span class="op">(</span>value <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> norm<span class="op">;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> p <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> signedDist <span class="op">*</span> normal<span class="op">;</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv<span class="op">;</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Define the three half-spaces for equilateral triangle</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs1 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs2 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.732</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    HalfSpace hs3 <span class="op">=</span> <span class="fu">HalfSpace</span><span class="op">(-</span><span class="fl">1.5</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the triangle</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">20</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> p_old <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> p_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by fold count parity</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parity <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span><span class="dt">float</span><span class="op">(</span>foldCount<span class="op">),</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>parity <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.9</span><span class="op">);</span>  <span class="co">// Light blue</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Darker blue</span></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Beautiful! You should see an infinite triangle tiling. The alternating colors show which triangles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Visualizing Triangle Structure
</div>
</div>
<div class="callout-body-container callout-body">
<p>Want to see the edges and vertices of your triangles? This requires computing distances to half-spaces and vertices.</p>
<p><strong>For edges</strong> (drawing the boundaries):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">distToHalfSpace</span><span class="op">(</span><span class="dt">vec2</span> p<span class="op">,</span> HalfSpace hs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">abs</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> hs<span class="op">.</span><span class="fu">b</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> hs<span class="op">.</span><span class="fu">c</span><span class="op">)</span> <span class="op">/</span> <span class="bu">length</span><span class="op">(</span><span class="dt">vec2</span><span class="op">(</span>hs<span class="op">.</span><span class="fu">a</span><span class="op">,</span> hs<span class="op">.</span><span class="fu">b</span><span class="op">));</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">// In main rendering:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d1 <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d2 <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d3 <span class="op">=</span> <span class="fu">distToHalfSpace</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> border <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>d1<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>d2<span class="op">,</span> d3<span class="op">));</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>border <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span>  <span class="co">// White edges</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For vertices</strong> (marking the corners):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define vertices</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v0 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v1 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v2 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.866</span><span class="op">,</span> <span class="op">-</span><span class="fl">0.5</span><span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Check distance after folding</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dv0 <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> v0<span class="op">);</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dv1 <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> v1<span class="op">);</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> dv2 <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> v2<span class="op">);</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> vertex_dist <span class="op">=</span> <span class="bu">min</span><span class="op">(</span>dv0<span class="op">,</span> <span class="bu">min</span><span class="op">(</span>dv1<span class="op">,</span> dv2<span class="op">));</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>vertex_dist <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// Red vertices</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>See Appendix E9 for the complete enhanced version!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="why-does-this-algorithm-work-reflection-groups" class="level3">
<h3 class="anchored" data-anchor-id="why-does-this-algorithm-work-reflection-groups">Why Does This Algorithm Work? Reflection Groups</h3>
<p>We’ve implemented the folding algorithm, but <em>why</em> does it work? Why does iteratively reflecting guarantee we reach the fundamental domain? The answer lies in <strong>group theory</strong>.</p>
<section id="reflections-generate-a-group" class="level4">
<h4 class="anchored" data-anchor-id="reflections-generate-a-group">Reflections Generate a Group</h4>
<p>Each reflection <span class="math inline">\(r_i\)</span> across a half-space boundary is an <strong>isometry</strong> of the Euclidean plane—it preserves distances and angles. Composing reflections gives us more isometries. The set of all compositions of our reflections forms a <strong>group</strong> under composition:</p>
<ul>
<li><strong>Identity</strong>: Reflecting twice across the same line returns to the original point (<span class="math inline">\(r_i \circ r_i = \text{id}\)</span>)</li>
<li><strong>Closure</strong>: Composing reflections gives another isometry (which might be a reflection, rotation, or glide reflection)</li>
<li><strong>Inverses</strong>: Every isometry has an inverse (just reflect again)</li>
<li><strong>Associativity</strong>: Composition is associative</li>
</ul>
<p>This group, generated by reflections across the boundaries of our fundamental domain, is called a <strong>reflection group</strong> or <strong>Coxeter group</strong>.</p>
</section>
<section id="the-fundamental-domain-and-orbit" class="level4">
<h4 class="anchored" data-anchor-id="the-fundamental-domain-and-orbit">The Fundamental Domain and Orbit</h4>
<p>Our fundamental domain <span class="math inline">\(F\)</span> (the square <span class="math inline">\([0,1]^2\)</span> or triangle) is a <strong>fundamental domain</strong> for the group action. This means:</p>
<ol type="1">
<li>Every point in the plane is equivalent to exactly one point in <span class="math inline">\(F\)</span> (modulo boundary points)</li>
<li>The <strong>orbit</strong> of <span class="math inline">\(F\)</span> under the group (all images <span class="math inline">\(g(F)\)</span> for <span class="math inline">\(g\)</span> in the group) tiles the entire plane</li>
<li>Different tiles <span class="math inline">\(g(F)\)</span> and <span class="math inline">\(h(F)\)</span> only overlap on their boundaries</li>
</ol>
<p>When we start with a point <span class="math inline">\(p\)</span> outside <span class="math inline">\(F\)</span>, there exists a sequence of group elements (reflections) that maps <span class="math inline">\(p\)</span> into <span class="math inline">\(F\)</span>. Our algorithm finds this sequence!</p>
</section>
<section id="why-the-algorithm-terminates" class="level4">
<h4 class="anchored" data-anchor-id="why-the-algorithm-terminates">Why the Algorithm Terminates</h4>
<p>Here’s the key insight: each reflection across a boundary of <span class="math inline">\(F\)</span> either: - Keeps the point inside <span class="math inline">\(F\)</span> (if it’s already on the correct side) - Moves the point strictly closer to <span class="math inline">\(F\)</span> (if it’s on the wrong side)</p>
<p>“Closer” here means we reduce some discrete measure—like the number of boundaries we’re on the wrong side of. Since this number is finite and decreases with each reflection, the algorithm must terminate.</p>
<p>Formally, we can define a <strong>height function</strong> <span class="math inline">\(h(p)\)</span> that counts how many half-space boundaries <span class="math inline">\(p\)</span> violates. Initially <span class="math inline">\(h(p) \geq 0\)</span>. Each reflection that actually moves the point decreases <span class="math inline">\(h(p)\)</span> by at least 1. When <span class="math inline">\(h(p) = 0\)</span>, the point is inside <span class="math inline">\(F\)</span> and the algorithm stops.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>The Pattern Across Days
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is the same fundamental principle we’ve seen throughout:</p>
<p><strong>Day 2 (Apollonian gasket):</strong> - Group: Iterated circle inversions - Fundamental domain: The gaps between circles - Algorithm: Invert until inside the domain</p>
<p><strong>Day 3 (Euclidean tilings):</strong> - Group: Reflections across boundaries - Fundamental domain: The square/triangle - Algorithm: Reflect until inside the domain</p>
<p><strong>Day 3 (Hyperbolic, coming soon):</strong> - Group: Hyperbolic reflections (same structure!) - Fundamental domain: Hyperbolic triangle - Algorithm: Reflect until inside the domain (identical code!)</p>
<p>The unifying theme is <strong>group actions and fundamental domains</strong>. We’re always finding the unique representative of an orbit that lies in the fundamental domain.</p>
</div>
</div>
</section>
<section id="computational-implications" class="level4">
<h4 class="anchored" data-anchor-id="computational-implications">Computational Implications</h4>
<p>Understanding the group theory gives us insight into the computation:</p>
<p><strong>Convergence rate</strong>: For a viewport of size <span class="math inline">\(V\)</span> and fundamental domain of size <span class="math inline">\(F\)</span>, we need at most <span class="math inline">\(O(\log(V/F))\)</span> reflections per coordinate axis. This is why small iteration limits (20-30) work well.</p>
<p><strong>Parallelism</strong>: Each pixel’s orbit is independent—perfect for GPU parallelism. Millions of pixels computing orbits simultaneously with no communication needed.</p>
<p><strong>Threshold choice</strong>: The <code>0.0001</code> threshold for detecting convergence balances precision and performance. Smaller thresholds catch more subtle movements but risk floating-point noise; larger thresholds might terminate early but rarely matter for visualization.</p>
<p><strong>Why it’s efficient</strong>: Most tiles are “nearby” in the group—they’re reached by short sequences of reflections. Only tiles far from the origin require many reflections, and these appear very small on screen (contributing few pixels).</p>
<p>This completes our Euclidean foundation. We now understand: 1. The folding algorithm in concrete examples 2. The half-space abstraction that makes it general 3. <strong>Why it works</strong>: reflection groups and fundamental domains 4. Computational properties: convergence, parallelism, efficiency</p>
<p>Next, we’ll take this exact algorithmic structure into hyperbolic geometry!</p>
<hr>
</section>
</section>
</section>
<section id="part-2-hyperbolic-geometry" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="part-2-hyperbolic-geometry"><span class="header-section-number">3.3</span> Part 2: Hyperbolic Geometry</h2>
<section id="introduction-to-hyperbolic-geometry" class="level3">
<h3 class="anchored" data-anchor-id="introduction-to-hyperbolic-geometry">Introduction to Hyperbolic Geometry</h3>
<p>Hyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant <strong>negative curvature</strong>. For over two millennia, mathematicians believed Euclidean geometry was the only logically consistent geometry—Euclid’s parallel postulate seemed necessary. The discovery of hyperbolic geometry in the early 19th century revolutionized mathematics.</p>
<section id="historical-context-the-discovery" class="level4">
<h4 class="anchored" data-anchor-id="historical-context-the-discovery">Historical Context: The Discovery</h4>
<p>The story of hyperbolic geometry is one of the great dramas in mathematical history. For centuries, mathematicians tried to prove Euclid’s fifth postulate (the parallel postulate) from the other four axioms. What if you could have multiple parallel lines through a point?</p>
<p>Three mathematicians independently discovered that this “impossible” geometry was actually perfectly consistent:</p>
<p><strong>János Bolyai</strong> (1802-1860), a Hungarian mathematician, developed hyperbolic geometry in the 1820s. His father, a mathematician himself, warned him: “For God’s sake, I beseech you, give it up. Fear it no less than sensual passions because it too may take all your time and deprive you of your health, peace of mind and happiness in life.” But János persisted, publishing his work in 1832 as an appendix to his father’s book.</p>
<p><strong>Nikolai Lobachevsky</strong> (1792-1856), a Russian mathematician, published the first account of hyperbolic geometry in 1829. He called it “imaginary geometry” and faced considerable resistance from the mathematical establishment. His work was largely ignored during his lifetime.</p>
<p><strong>Carl Friedrich Gauss</strong> (1777-1855), the “Prince of Mathematicians,” had discovered hyperbolic geometry even earlier but never published it. In his private correspondence, he revealed he’d been working on non-Euclidean geometry since the 1790s but feared the “clamor of the Boeotians” (his term for mathematical philistines). When he read Bolyai’s work in 1832, he wrote that he could not praise it “because to praise it would be to praise myself”—he’d discovered the same results years earlier but kept them private.</p>
<p>The discovery had profound implications: geometry was not a single truth about space but a family of possible consistent systems. This philosophical shift influenced everything from Einstein’s general relativity (which uses non-Euclidean geometry for curved spacetime) to modern physics and mathematics.</p>
</section>
<section id="modern-applications" class="level4">
<h4 class="anchored" data-anchor-id="modern-applications">Modern Applications</h4>
<p>Hyperbolic geometry appears throughout modern mathematics and physics:</p>
<ul>
<li><strong>Complex analysis</strong>: The upper half-plane model is fundamental to the theory of modular forms, elliptic curves, and the Riemann mapping theorem</li>
<li><strong>Number theory</strong>: The action of <span class="math inline">\(SL(2,\mathbb{Z})\)</span> on <span class="math inline">\(\mathbb{H}^2\)</span> produces modular forms—functions crucial to the proof of Fermat’s Last Theorem</li>
<li><strong>Topology</strong>: The study of 3-manifolds and knot theory often requires understanding hyperbolic structures</li>
<li><strong>Teichmüller theory</strong>: Moduli spaces of Riemann surfaces have natural hyperbolic metrics</li>
<li><strong>Kleinian groups</strong>: Discrete subgroups of hyperbolic isometries produce fractal limit sets (like we saw with the Apollonian gasket!)</li>
<li><strong>General relativity</strong>: Anti-de Sitter space has constant negative curvature—hyperbolic geometry in spacetime</li>
<li><strong>Machine learning</strong>: Recent work uses hyperbolic embeddings to represent hierarchical data efficiently</li>
</ul>
</section>
<section id="key-properties" class="level4">
<h4 class="anchored" data-anchor-id="key-properties">Key Properties</h4>
<p>What makes hyperbolic geometry different from Euclidean geometry?</p>
<p><strong>Parallel lines</strong>: Given a line and a point not on it, there are <strong>infinitely many</strong> lines through the point that don’t intersect the given line (all parallel to it). This is the defining feature that distinguishes hyperbolic geometry.</p>
<p><strong>Triangle angles</strong>: The sum of angles in a triangle is <strong>less than</strong> <span class="math inline">\(\pi\)</span>. In fact, the <strong>area</strong> of a hyperbolic triangle with angles <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span> is exactly: <span class="math display">\[\text{Area} = \pi - (\alpha + \beta + \gamma)\]</span> This is the <strong>Gauss-Bonnet theorem</strong> for hyperbolic triangles—a beautiful connection between geometry (angles) and topology (area).</p>
<p><strong>Exponential growth</strong>: In Euclidean geometry, the circumference of a circle grows linearly with radius (<span class="math inline">\(C = 2\pi r\)</span>). In hyperbolic geometry, it grows <strong>exponentially</strong>: <span class="math inline">\(C \sim e^r\)</span> for large <span class="math inline">\(r\)</span>. This means hyperbolic space has “more room” than Euclidean space—there’s exponentially more area at distance <span class="math inline">\(r\)</span> from a point.</p>
<p><strong>No similarity</strong>: In Euclidean geometry, you can scale any shape—a small triangle and a large triangle with the same angles are similar. In hyperbolic geometry, there’s an absolute unit of length built into the curvature. All triangles with angles <span class="math inline">\((\pi/2, \pi/3, \pi/7)\)</span> are congruent—there’s no “scaled version.” This makes hyperbolic geometry richer but more rigid.</p>
<p>These properties create the “extra room” that allows much richer tiling structures than Euclidean geometry.</p>
<hr>
</section>
</section>
<section id="the-upper-half-plane-model" class="level3">
<h3 class="anchored" data-anchor-id="the-upper-half-plane-model">The Upper Half-Plane Model</h3>
<p>We’ll work in the <strong>upper half-plane model</strong> of hyperbolic geometry, denoted <span class="math inline">\(\mathbb{H}^2\)</span>:</p>
<p><span class="math display">\[\mathbb{H}^2 = \{z = x + iy \in \mathbb{C} : y &gt; 0\}\]</span></p>
<p>This is just complex numbers with positive imaginary part—the upper half of the complex plane. The <strong>real axis</strong> <span class="math inline">\(\{y = 0\}\)</span> forms the boundary “at infinity”—it’s not actually part of <span class="math inline">\(\mathbb{H}^2\)</span>, but represents points infinitely far away in hyperbolic distance.</p>
<section id="the-hyperbolic-metric" class="level4">
<h4 class="anchored" data-anchor-id="the-hyperbolic-metric">The Hyperbolic Metric</h4>
<p>The <strong>hyperbolic metric</strong> is what makes <span class="math inline">\(\mathbb{H}^2\)</span> a hyperbolic space:</p>
<p><span class="math display">\[ds^2 = \frac{dx^2 + dy^2}{y^2}\]</span></p>
<p>This gives <span class="math inline">\(\mathbb{H}^2\)</span> the structure of a complete Riemannian manifold with constant curvature <span class="math inline">\(-1\)</span>.</p>
<p><strong>What does this mean?</strong> The factor <span class="math inline">\(1/y^2\)</span> is a <strong>conformal factor</strong> that scales the Euclidean metric. As <span class="math inline">\(y \to 0\)</span> (approaching the boundary), this scaling factor blows up—distances that look small Euclidean-wise are enormous hyperbolically. As <span class="math inline">\(y \to \infty\)</span> (going “up” in the upper half-plane), the scaling factor goes to zero—large Euclidean distances are actually finite hyperbolically.</p>
<p>The metric is <strong>conformal</strong> to the Euclidean metric—it preserves angles but not lengths. If two curves meet at angle <span class="math inline">\(\theta\)</span> in the Euclidean sense, they also meet at angle <span class="math inline">\(\theta\)</span> in the hyperbolic sense! This is why you can trust your eyes when looking at pictures—angles are what they appear to be.</p>
</section>
<section id="the-distance-formula" class="level4">
<h4 class="anchored" data-anchor-id="the-distance-formula">The Distance Formula</h4>
<p>Integrating the metric along paths gives the <strong>hyperbolic distance</strong> between two points <span class="math inline">\(z_1 = x_1 + iy_1\)</span> and <span class="math inline">\(z_2 = x_2 + iy_2\)</span>:</p>
<p><span class="math display">\[d_{\mathbb{H}^2}(z_1, z_2) = \text{arcosh}\left(1 + \frac{|z_1 - z_2|^2}{2y_1 y_2}\right)\]</span></p>
<p>where <span class="math inline">\(|z_1 - z_2| = \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\)</span> is the usual Euclidean distance.</p>
<p>Notice the <span class="math inline">\(1/y_1 y_2\)</span> factor—points near the boundary (<span class="math inline">\(y\)</span> small) are very far apart hyperbolically even if they’re close Euclidean-wise.</p>
<p><strong>Derivation sketch</strong>: For a vertical line from <span class="math inline">\(z_1 = x + iy_1\)</span> to <span class="math inline">\(z_2 = x + iy_2\)</span>, the hyperbolic length is: <span class="math display">\[\int_{y_1}^{y_2} \frac{dy}{y} = \log(y_2) - \log(y_1) = \log(y_2/y_1)\]</span></p>
<p>For a general path, you need to integrate along the geodesic connecting the points (which might not be a straight Euclidean line), giving the arcosh formula above.</p>
</section>
<section id="visualizing-hyperbolic-distance" class="level4">
<h4 class="anchored" data-anchor-id="visualizing-hyperbolic-distance">Visualizing Hyperbolic Distance</h4>
<p>Let’s make this concrete with an interactive shader. We’ll start with Euclidean distance, then switch to hyperbolic to see the difference.</p>
<p><strong>Euclidean distance circles:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span>  <span class="co">// Shift up so we're in y &gt; 0</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mouse position as center (or default)</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> mouse <span class="op">=</span> iMouse<span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>iMouse<span class="op">.</span><span class="fu">z</span> <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> mouse <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.7</span><span class="op">);</span>  <span class="co">// Default if no click</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    mouse <span class="op">=</span> <span class="op">(</span>mouse <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    mouse<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> center <span class="op">=</span> mouse <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Euclidean distance</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> center<span class="op">);</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a disk of radius 0.5 using two circles</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span>  <span class="co">// Background</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outer circle (slightly larger)</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">+</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Yellow ring</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inner circle (slightly smaller) - "cuts out" interior</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">-</span> <span class="fl">0.02</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.4</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Blue interior</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw center point</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>p <span class="op">-</span> center<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.05</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Darken outside upper half-plane</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>        color <span class="op">*=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Click and drag around—the circle stays the same size everywhere. This is Euclidean distance: uniform across the plane. Notice how we draw the boundary: we draw a filled circle at radius <span class="math inline">\(r + \epsilon\)</span> (outer edge), then draw another filled circle at radius <span class="math inline">\(r - \epsilon\)</span> (inner edge) in a different color. The ring between them is our boundary!</p>
<p><strong>Hyperbolic distance circles:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span><span class="dt">vec2</span> z1<span class="op">,</span> <span class="dt">vec2</span> z2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> diff <span class="op">=</span> z1 <span class="op">-</span> z2<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> diff2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>diff<span class="op">,</span> diff<span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> z1<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> z2<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> arg <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> diff2 <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">log</span><span class="op">(</span>arg <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span>arg <span class="op">*</span> arg <span class="op">-</span> <span class="fl">1.0</span><span class="op">));</span>  <span class="co">// arccosh(arg)</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mouse position as center</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> mouse <span class="op">=</span> iMouse<span class="op">.</span><span class="fu">xy</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>iMouse<span class="op">.</span><span class="fu">z</span> <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> mouse <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.7</span><span class="op">);</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    mouse <span class="op">=</span> <span class="op">(</span>mouse <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    mouse<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> center <span class="op">=</span> mouse <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Hyperbolic distance</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist <span class="op">=</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span>p<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a hyperbolic disk using two "circles"</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">);</span>  <span class="co">// Background</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Outer boundary</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">+</span> <span class="fl">0.05</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span>  <span class="co">// Yellow ring</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inner region</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>dist <span class="op">&lt;</span> radius <span class="op">-</span> <span class="fl">0.05</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.4</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Blue interior</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw center</span></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span><span class="fu">hyperbolicDistance</span><span class="op">(</span>p<span class="op">,</span> center<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Darken outside upper half-plane</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a>        color <span class="op">*=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Now drag the center around! Notice how the “circle” changes shape as you move it. Near the bottom (<span class="math inline">\(y \to 0\)</span>), the circle appears huge Euclidean-wise—that’s because we’re near the boundary where hyperbolic distances blow up. Higher up (<span class="math inline">\(y\)</span> large), the circle appears smaller.</p>
<p>This visualization makes the <span class="math inline">\(1/y^2\)</span> conformal factor visceral: <strong>hyperbolic space is compressed near the boundary</strong>.</p>
<hr>
</section>
</section>
<section id="the-boundary-at-infinity" class="level3">
<h3 class="anchored" data-anchor-id="the-boundary-at-infinity">The Boundary at Infinity</h3>
<p>The real axis <span class="math inline">\(\{y = 0\}\)</span> is not part of <span class="math inline">\(\mathbb{H}^2\)</span>, but we can think of it as the <strong>boundary at infinity</strong>—points infinitely far away in hyperbolic distance.</p>
<p><strong>Ideal points as equivalence classes</strong>: An <strong>ideal point</strong> on the boundary can be defined as an equivalence class of geodesics that asymptotically approach each other. Two geodesics are equivalent if the hyperbolic distance between them goes to zero as you go to infinity along them.</p>
<p>For example, the vertical line <span class="math inline">\(\{x = 0\}\)</span> and the vertical line <span class="math inline">\(\{x = \epsilon\}\)</span> (for small <span class="math inline">\(\epsilon\)</span>) both approach the point <span class="math inline">\(0\)</span> on the real axis. As you go up (<span class="math inline">\(y \to \infty\)</span>), the hyperbolic distance between corresponding points goes to zero—they’re asymptotically parallel.</p>
<p><strong>Geometric intuition</strong>: In the Poincaré disk model (which we’ll see soon), the boundary at infinity is literally the unit circle <span class="math inline">\(|z| = 1\)</span>. Points on this circle are infinitely far away from any interior point, but they still have geometric meaning—they represent directions or “points at infinity.”</p>
<p><strong>Why this matters</strong>: When we define hyperbolic triangles, we can have vertices “at infinity” on the boundary. These are called <strong>ideal vertices</strong> or <strong>ideal triangles</strong>. For instance, our <span class="math inline">\((2,3,\infty)\)</span> triangle has one vertex at the point <span class="math inline">\(\infty\)</span> in the upper half-plane (straight up the imaginary axis). The angle at an ideal vertex is zero—the sides become asymptotically parallel as they approach the boundary.</p>
<p>The Gauss-Bonnet theorem still works: for a triangle with angles <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span>, the area is <span class="math inline">\(\pi - (\alpha + \beta + \gamma)\)</span>. If one angle is zero (ideal vertex), the area is <span class="math inline">\(\pi - \alpha - \beta &gt; 0\)</span>—ideal triangles have finite area!</p>
<hr>
</section>
<section id="geodesics-and-reflections" class="level3">
<h3 class="anchored" data-anchor-id="geodesics-and-reflections">Geodesics and Reflections</h3>
<section id="geodesics-in-the-upper-half-plane" class="level4">
<h4 class="anchored" data-anchor-id="geodesics-in-the-upper-half-plane">Geodesics in the Upper Half-Plane</h4>
<p><strong>Geodesics</strong> (the “straight lines” of hyperbolic geometry—curves that locally minimize distance) in <span class="math inline">\(\mathbb{H}^2\)</span> have exactly two forms:</p>
<ol type="1">
<li><strong>Vertical lines</strong>: <span class="math inline">\(\{x = c\}\)</span> for any constant <span class="math inline">\(c \in \mathbb{R}\)</span></li>
<li><strong>Semicircles</strong>: Centered on the real axis, perpendicular to it</li>
</ol>
<p>These curves meet the boundary at right angles—this is the characterizing property of geodesics in this model.</p>
<p><strong>Why these are geodesics</strong>: Reflections across these curves are isometries (they preserve the hyperbolic metric <span class="math inline">\(ds^2 = \frac{dx^2+dy^2}{y^2}\)</span>). An isometry’s fixed point set is always a geodesic! So we just need to verify that reflection across vertical lines and semicircles preserves the metric.</p>
<p>For <strong>vertical lines</strong>, this is obvious: reflecting across <span class="math inline">\(x = c\)</span> sends <span class="math inline">\((x,y) \mapsto (2c-x, y)\)</span>, which preserves both the Euclidean distance <span class="math inline">\(dx^2 + dy^2\)</span> and the <span class="math inline">\(y\)</span>-coordinate, hence preserves <span class="math inline">\(\frac{dx^2+dy^2}{y^2}\)</span>.</p>
<p>For <strong>semicircles</strong>, we use circle inversion from Day 2! A semicircle centered at <span class="math inline">\((c, 0)\)</span> with radius <span class="math inline">\(R\)</span> is preserved by the inversion: <span class="math display">\[z \mapsto c + R^2 \frac{z - c}{|z - c|^2}\]</span></p>
<p>Circle inversion is conformal (preserves angles) and scales distances by exactly <span class="math inline">\(1/y^2\)</span> near the boundary—precisely the conformal factor in the hyperbolic metric! So inversions through semicircles are hyperbolic isometries. Their fixed point sets (the semicircles themselves) are therefore geodesics.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Connection to Day 2: Circle Inversion is a Hyperbolic Isometry!
</div>
</div>
<div class="callout-body-container callout-body">
<p>This is a profound connection: the circle inversions we used on Day 2 for the Apollonian gasket were actually <strong>hyperbolic isometries</strong> all along! The Apollonian gasket lives in hyperbolic space—the gaps between circles are hyperbolic regions, and the inversions are reflections across hyperbolic geodesics (semicircles).</p>
<p>When we iterated inversions on Day 2, we were doing exactly what we’re doing today—finding the fundamental domain of a group action! The Apollonian gasket is a hyperbolic object, just like our triangle tilings. The same group-theoretic principles apply.</p>
<p>This is why the techniques work across days: we’re always working with group actions, whether we realize it or not. The mathematics unifies everything.</p>
</div>
</div>
</section>
<section id="implementing-reflections" class="level4">
<h4 class="anchored" data-anchor-id="implementing-reflections">Implementing Reflections</h4>
<p>For <strong>vertical lines</strong> (like <span class="math inline">\(x = c\)</span>), reflection is simple—flip the <span class="math inline">\(x\)</span>-coordinate:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> x_pos<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're on the correct side</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> x_pos<span class="op">)</span> <span class="op">*</span> side <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> z<span class="op">;</span>  <span class="co">// Already on correct side</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reflect: (x,y) ↦ (2c - x, y)</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x_pos <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>For <strong>semicircles</strong> (geodesics from point <span class="math inline">\(p\)</span> to point <span class="math inline">\(q\)</span> on the real axis), we use circle inversion. The semicircle has center <span class="math inline">\((c, 0)\)</span> where <span class="math inline">\(c = (p+q)/2\)</span> and radius <span class="math inline">\(R = |p-q|/2\)</span>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> rel <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>rel<span class="op">,</span> rel<span class="op">);</span>  <span class="co">// Squared distance from center</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we're on the correct side</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>dist2 <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> side <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> z<span class="op">;</span>  <span class="co">// Already on correct side</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle inversion (from Day 2!)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> inverted <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span>radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> rel <span class="op">/</span> dist2<span class="op">;</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> inverted<span class="op">;</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Note: We’re inverting through a circle in the Euclidean sense (using Euclidean distance <code>dist2</code>), but this operation is actually a hyperbolic isometry! The magic is that circle inversion’s conformal properties exactly match the hyperbolic metric’s requirements.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Why Two Types of Reflections?
</div>
</div>
<div class="callout-body-container callout-body">
<p>In Euclidean geometry, all reflections across lines look the same—just the orientation changes. Why do we need two different functions in hyperbolic geometry?</p>
<p>The answer is that we’re working in a <strong>model</strong> of hyperbolic geometry (the upper half-plane). The vertical lines and semicircles are the images of geodesics in this model. In the intrinsic hyperbolic geometry, all reflections across geodesics are the same—there’s only one type of reflection.</p>
<p>But when we represent hyperbolic geometry in the Euclidean upper half-plane, geodesics appear as two different types of curves (vertical lines and semicircles), so we need two different formulas. This is an artifact of the model, not the geometry itself.</p>
<p>In the Poincaré disk model (coming soon), ALL geodesics are circular arcs perpendicular to the boundary circle, so we’d only need one reflection function there!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="the-23-triangle" class="level3">
<h3 class="anchored" data-anchor-id="the-23-triangle">The (2,3,∞) Triangle</h3>
<p>Let’s build our first hyperbolic triangle tiling. The notation <span class="math inline">\((p, q, r)\)</span> means the triangle has angles <span class="math inline">\(\pi/p\)</span>, <span class="math inline">\(\pi/q\)</span>, and <span class="math inline">\(\pi/r\)</span> at its three vertices. So <span class="math inline">\((2,3,\infty)\)</span> means angles <span class="math inline">\(\pi/2\)</span>, <span class="math inline">\(\pi/3\)</span>, and <span class="math inline">\(0\)</span> (an ideal vertex at infinity).</p>
<p><strong>Why this triangle exists in hyperbolic geometry</strong>: The Gauss-Bonnet theorem tells us the area of a hyperbolic triangle with angles <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\gamma\)</span> is: <span class="math display">\[\text{Area} = \pi - (\alpha + \beta + \gamma)\]</span></p>
<p>For a <span class="math inline">\((2,3,\infty)\)</span> triangle: <span class="math display">\[\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + 0\right) = \pi - \frac{5\pi}{6} = \frac{\pi}{6} &gt; 0\]</span></p>
<p>So this triangle has finite positive area and can tile the hyperbolic plane. In Euclidean geometry, <span class="math inline">\(\pi/2 + \pi/3 = 5\pi/6 &lt; \pi\)</span>, but that’s not enough—we’d need the sum to equal <em>exactly</em> <span class="math inline">\(\pi\)</span> to get zero curvature. Since <span class="math inline">\(5\pi/6 &lt; \pi\)</span>, there’s negative curvature left over, making this a hyperbolic triangle.</p>
<p><strong>Configuration</strong>: We’ll use a particularly nice setup in the upper half-plane: - <strong>Left boundary</strong>: Vertical line at <span class="math inline">\(x = -1\)</span> - <strong>Right boundary</strong>: Vertical line at <span class="math inline">\(x = 1\)</span><br>
- <strong>Bottom boundary</strong>: Unit semicircle from <span class="math inline">\(-1\)</span> to <span class="math inline">\(1\)</span> (centered at origin, radius <span class="math inline">\(1\)</span>)</p>
<p>This creates a triangle with: - Two finite vertices at approximately <span class="math inline">\((-1, 0)\)</span> and <span class="math inline">\((1, 0)\)</span> (technically infinitesimally above the real axis) - One ideal vertex at <span class="math inline">\(\infty\)</span> (straight up the imaginary axis) - Angles of <span class="math inline">\(\pi/2\)</span> at the bottom two vertices (vertical line meets semicircle at right angles) - Angle of <span class="math inline">\(\pi/3\)</span> between the two vertical lines when measured hyperbolically - Angle of <span class="math inline">\(0\)</span> at the ideal vertex <span class="math inline">\(\infty\)</span></p>
<section id="implementation" class="level4">
<h4 class="anchored" data-anchor-id="implementation">Implementation</h4>
<p>Here’s the complete shader:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> x_pos<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> x_pos<span class="op">)</span> <span class="op">*</span> side <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    z<span class="op">.</span><span class="fu">x</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x_pos <span class="op">-</span> z<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">,</span> <span class="dt">float</span> p<span class="op">,</span> <span class="dt">float</span> q<span class="op">,</span> <span class="dt">float</span> side<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> rel <span class="op">=</span> z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> dist2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>rel<span class="op">,</span> rel<span class="op">);</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">((</span>dist2 <span class="op">-</span> radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> side <span class="op">&gt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="kw">return</span> z<span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span>radius <span class="op">*</span> radius<span class="op">)</span> <span class="op">*</span> rel <span class="op">/</span> dist2<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Shift to upper half-plane (need y &gt; 0)</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> uv <span class="op">+</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.5</span><span class="op">);</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fold into the (2,3,∞) triangle</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> foldCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">50</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">vec2</span> z_old <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across left vertical line (x = -1, want x &gt; -1)</span></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across right vertical line (x = 1, want x &lt; 1)</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reflect across semicircle (from -1 to 1, want outside/above)</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>        z <span class="op">=</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If point didn't move, we're inside</span></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>z <span class="op">-</span> z_old<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.0001</span><span class="op">)</span> <span class="kw">break</span><span class="op">;</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>        foldCount<span class="op">++;</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color by fold count parity</span></span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> parity <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span><span class="dt">float</span><span class="op">(</span>foldCount<span class="op">),</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color<span class="op">;</span></span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>parity <span class="op">&lt;</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.7</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">,</span> <span class="fl">0.9</span><span class="op">);</span>  <span class="co">// Light blue</span></span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.5</span><span class="op">,</span> <span class="fl">0.6</span><span class="op">,</span> <span class="fl">0.8</span><span class="op">);</span>  <span class="co">// Darker blue</span></span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Darken if below the real axis (outside hyperbolic space)</span></span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span><span class="op">(</span>z<span class="op">.</span><span class="fu">y</span> <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>        color <span class="op">*=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>You should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis <span class="math inline">\(y = 0\)</span>)—they’re all the same hyperbolic size, but Euclidean distances compress due to the <span class="math inline">\(1/y^2\)</span> metric.</p>
<p>The alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Compare to Euclidean
</div>
</div>
<div class="callout-body-container callout-body">
<p>Look at the structure of this shader compared to the Euclidean triangle tiling:</p>
<p><strong>Euclidean:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs1<span class="op">);</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs2<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="fu">reflectInto</span><span class="op">(</span>p<span class="op">,</span> hs3<span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Hyperbolic:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb23"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoVertical</span><span class="op">(</span>z<span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> <span class="fu">reflectIntoCircular</span><span class="op">(</span>z<span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Computational Analysis
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>GPU Parallelism</strong>: Just like Days 1 and 2, this algorithm is embarrassingly parallel. Each pixel computes independently—no communication, no shared state, perfect for GPU architecture.</p>
<p><strong>Convergence</strong>: The folding algorithm works for the same group-theoretic reasons as the Euclidean case. The three reflections generate a discrete group of hyperbolic isometries, and our fundamental triangle is a fundamental domain for this group’s action on <span class="math inline">\(\mathbb{H}^2\)</span>.</p>
<p><strong>Precision issues</strong>: Near <span class="math inline">\(y \to 0\)</span>, floating-point precision degrades. The large conformal factor <span class="math inline">\(1/y^2\)</span> amplifies small errors in distance calculations. This is why we darken the region <span class="math inline">\(y &lt; 0\)</span>—technically it’s not part of the hyperbolic plane, but also our numerics become unreliable there.</p>
<p><strong>Threshold <span class="math inline">\(0.0001\)</span></strong>: This convergence threshold balances precision and performance. Smaller thresholds catch more subtle movements but risk getting stuck in floating-point noise; larger thresholds might terminate early. For visualization purposes, <span class="math inline">\(0.0001\)</span> is a good sweet spot.</p>
<p><strong>Memory efficiency</strong>: Each pixel only needs to store its current position <code>z</code> (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures—just stateless iteration. This is as memory-efficient as you can get!</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Exercise: Visualizing Hyperbolic Triangle Structure
</div>
</div>
<div class="callout-body-container callout-body">
<p>Want to see the edges and vertices of your hyperbolic triangles? This requires computing hyperbolic distances.</p>
<p><strong>For hyperbolic distance:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span><span class="dt">vec2</span> z1<span class="op">,</span> <span class="dt">vec2</span> z2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> diff <span class="op">=</span> z1 <span class="op">-</span> z2<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> diff2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>diff<span class="op">,</span> diff<span class="op">);</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> z1<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> z2<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> arg <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> diff2 <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="bu">log</span><span class="op">(</span>arg <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span>arg <span class="op">*</span> arg <span class="op">-</span> <span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For drawing edges</strong> (vertical lines):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb25"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Distance to vertical line x = c</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> distToVertical <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>z<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> c<span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>distToVertical <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For drawing edges</strong> (semicircular geodesics):</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Distance to semicircle from p to q</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> center <span class="op">=</span> <span class="op">(</span>p <span class="op">+</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> radius <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p <span class="op">-</span> q<span class="op">)</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> distToCircle <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span><span class="bu">length</span><span class="op">(</span>z <span class="op">-</span> <span class="dt">vec2</span><span class="op">(</span>center<span class="op">,</span> <span class="fl">0.0</span><span class="op">))</span> <span class="op">-</span> radius<span class="op">);</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Only draw if above real axis</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span>z<span class="op">.</span><span class="fu">y</span> <span class="op">&gt;</span> <span class="fl">0.0</span> <span class="op">&amp;&amp;</span> distToCircle <span class="op">&lt;</span> <span class="fl">0.02</span><span class="op">)</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">);</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>For vertices</strong>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Check hyperbolic distance to vertices after folding</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v1 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.01</span><span class="op">);</span>  <span class="co">// Left vertex (slightly above axis)</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v2 <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.01</span><span class="op">);</span>   <span class="co">// Right vertex</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span><span class="op">(</span><span class="fu">hyperbolicDistance</span><span class="op">(</span>z<span class="op">,</span> v1<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.1</span> <span class="op">||</span> <span class="fu">hyperbolicDistance</span><span class="op">(</span>z<span class="op">,</span> v2<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span>  <span class="co">// Red vertices</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>See Appendix H5 for the complete enhanced implementation!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="multiple-models-of-hyperbolic-space" class="level3">
<h3 class="anchored" data-anchor-id="multiple-models-of-hyperbolic-space">Multiple Models of Hyperbolic Space</h3>
<p>The upper half-plane is just one way to represent hyperbolic geometry. There are several other models, each with advantages:</p>
<section id="the-poincaré-disk-model" class="level4">
<h4 class="anchored" data-anchor-id="the-poincaré-disk-model">The Poincaré Disk Model</h4>
<p>The <strong>Poincaré disk model</strong> represents all of <span class="math inline">\(\mathbb{H}^2\)</span> as the interior of the unit disk <span class="math inline">\(\{z \in \mathbb{C} : |z| &lt; 1\}\)</span>. The boundary circle <span class="math inline">\(|z| = 1\)</span> represents points at infinity.</p>
<p><strong>Geodesics</strong> in this model are: - Diameters of the disk (straight lines through the origin) - Circular arcs perpendicular to the boundary circle</p>
<p>The conformal factor here is <span class="math inline">\(\frac{4}{(1-|z|^2)^2}\)</span>, which blows up as <span class="math inline">\(|z| \to 1\)</span> (approaching the boundary).</p>
<p><strong>Advantages</strong>: - The entire hyperbolic plane fits in a bounded region (the disk) - All geodesics look similar (circular arcs)—no distinction between vertical and circular - Visually intuitive for understanding the full structure at once</p>
<p><strong>Disadvantages</strong>: - Harder to compute distances - More complex reflection formulas</p>
</section>
<section id="converting-between-models-the-cayley-transform" class="level4">
<h4 class="anchored" data-anchor-id="converting-between-models-the-cayley-transform">Converting Between Models: The Cayley Transform</h4>
<p>We can convert between the upper half-plane and Poincaré disk using the <strong>Cayley transform</strong> (also called the Möbius transformation):</p>
<p><span class="math display">\[w = \frac{z - i}{z + i}\]</span></p>
<p>This maps: - Upper half-plane <span class="math inline">\(\{z : \operatorname{Im}(z) &gt; 0\}\)</span> → Poincaré disk <span class="math inline">\(\{w : |w| &lt; 1\}\)</span> - Real axis <span class="math inline">\(\{z : \operatorname{Im}(z) = 0\}\)</span> → Unit circle <span class="math inline">\(\{w : |w| = 1\}\)</span> - Point <span class="math inline">\(i\)</span> in the upper half-plane → origin <span class="math inline">\(0\)</span> in the disk</p>
<p>The inverse transform is: <span class="math display">\[z = i\frac{1 + w}{1 - w}\]</span></p>
<p>Here’s the implementation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb28"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cmul</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">,</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span> <span class="op">+</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span><span class="op">);</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">cdiv</span><span class="op">(</span><span class="dt">vec2</span> a<span class="op">,</span> <span class="dt">vec2</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>b<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">vec2</span><span class="op">(</span>a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">,</span> a<span class="op">.</span><span class="fu">y</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">x</span> <span class="op">-</span> a<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> b<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">uhpToDisk</span><span class="op">(</span><span class="dt">vec2</span> z<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// w = (z - i) / (z + i)</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> i <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cdiv</span><span class="op">(</span>z <span class="op">-</span> i<span class="op">,</span> z <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">diskToUhp</span><span class="op">(</span><span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// z = i(1 + w) / (1 - w)</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> i <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> one <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fu">cmul</span><span class="op">(</span>i<span class="op">,</span> <span class="fu">cdiv</span><span class="op">(</span>one <span class="op">+</span> w<span class="op">,</span> one <span class="op">-</span> w<span class="op">));</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>To display your tiling in the Poincaré disk:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Coordinate setup for disk</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> <span class="op">(</span>uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span> <span class="op">*</span> <span class="fl">2.5</span><span class="op">;</span>  <span class="co">// Fit disk in viewport</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert disk coordinates to upper half-plane</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> z <span class="op">=</span> <span class="fu">diskToUhp</span><span class="op">(</span>uv<span class="op">);</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Run your tiling algorithm in UHP</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... (fold into (2,3,∞) triangle as before)</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color and render</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="the-klein-model" class="level4">
<h4 class="anchored" data-anchor-id="the-klein-model">The Klein Model</h4>
<p>The <strong>Klein model</strong> (also called the <strong>Beltrami-Klein model</strong> or <strong>projective disk model</strong>) is another disk representation. Its defining feature: <strong>geodesics are Euclidean straight lines</strong>! This makes some geometric properties clearer but sacrifices the conformal property—angles are distorted.</p>
<p>Converting from Poincaré disk to Klein disk:</p>
<p><span class="math display">\[\text{Klein}(w) = \frac{2w}{1 + |w|^2}\]</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">poincareToKlein</span><span class="op">(</span><span class="dt">vec2</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> <span class="bu">dot</span><span class="op">(</span>w<span class="op">,</span> w<span class="op">);</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="fl">2.0</span> <span class="op">*</span> w <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>The inverse:</p>
<p><span class="math display">\[w = \frac{\text{Klein}(w)}{1 + \sqrt{1 - |\text{Klein}(w)|^2}}\]</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb31"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> <span class="fu">kleinToPoincare</span><span class="op">(</span><span class="dt">vec2</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> k2 <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>k<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> denom <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> <span class="bu">sqrt</span><span class="op">(</span><span class="fl">1.0</span> <span class="op">-</span> k2<span class="op">);</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> k <span class="op">/</span> denom<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>Advantages of Klein</strong>: - Geodesics are straight lines (simplest to compute) - Great for understanding incidence relationships</p>
<p><strong>Disadvantages</strong>: - Not conformal—angles are distorted - Harder to see hyperbolic distances</p>
<hr>
</section>
</section>
<section id="other-triangle-groups" class="level3">
<h3 class="anchored" data-anchor-id="other-triangle-groups">Other Triangle Groups</h3>
<p>The <span class="math inline">\((2,3,\infty)\)</span> triangle is just the beginning. Many other hyperbolic triangles can tile the plane! The most famous is the <span class="math inline">\((2,3,7)\)</span> triangle.</p>
<section id="the-237-triangle" class="level4">
<h4 class="anchored" data-anchor-id="the-237-triangle">The <span class="math inline">\((2,3,7)\)</span> Triangle</h4>
<p>This triangle has angles <span class="math inline">\(\pi/2\)</span>, <span class="math inline">\(\pi/3\)</span>, and <span class="math inline">\(\pi/7\)</span>. Its area is: <span class="math display">\[\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + \frac{\pi}{7}\right) = \frac{\pi}{42}\]</span></p>
<p>This is one of the smallest compact hyperbolic triangles! It produces incredibly dense tilings—the <span class="math inline">\((2,3,7)\)</span> tiling has a 7-fold symmetry that creates intricate patterns reminiscent of M.C. Escher’s work.</p>
<p>In fact, Escher’s famous <em>Circle Limit</em> prints (especially Circle Limit III with the fish) are based on tilings by <span class="math inline">\((2,3,7)\)</span> and related triangle groups. The hyperbolic geometry creates the exponential compression toward the boundary that gives these prints their distinctive character.</p>
<p><strong>Classification of hyperbolic triangles</strong>: Not every combination <span class="math inline">\((p,q,r)\)</span> gives a hyperbolic triangle. The Gauss-Bonnet formula tells us we need: <span class="math display">\[\frac{1}{p} + \frac{1}{q} + \frac{1}{r} &lt; 1\]</span></p>
<p>for a hyperbolic triangle (negative curvature). If the sum equals exactly <span class="math inline">\(1\)</span>, we get a Euclidean triangle. If the sum is greater than <span class="math inline">\(1\)</span>, we get a spherical triangle (positive curvature).</p>
<p><strong>Examples</strong>: - <span class="math inline">\((2,3,7)\)</span>: <span class="math inline">\(\frac{1}{2} + \frac{1}{3} + \frac{1}{7} = \frac{41}{42} &lt; 1\)</span> ✓ Hyperbolic - <span class="math inline">\((2,3,\infty)\)</span>: <span class="math inline">\(\frac{1}{2} + \frac{1}{3} + 0 = \frac{5}{6} &lt; 1\)</span> ✓ Hyperbolic - <span class="math inline">\((3,3,3)\)</span>: <span class="math inline">\(\frac{1}{3} + \frac{1}{3} + \frac{1}{3} = 1\)</span> ✓ Euclidean (equilateral triangle) - <span class="math inline">\((2,3,5)\)</span>: <span class="math inline">\(\frac{1}{2} + \frac{1}{3} + \frac{1}{5} = \frac{31}{30} &gt; 1\)</span> ✓ Spherical (icosahedron face)</p>
<p>Implementing other triangle groups requires computing where the third geodesic should be, given the angle constraints. This is non-trivial and involves hyperbolic trigonometry—we leave this as an advanced homework exercise!</p>
<hr>
</section>
</section>
</section>
<section id="summary" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="summary"><span class="header-section-number">3.4</span> Summary</h2>
<p>Today we learned:</p>
<ol type="1">
<li><p><strong>The folding algorithm</strong>: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry</p></li>
<li><p><strong>Half-space structure</strong>: Boundary + side gives a unified way to encode regions in Euclidean geometry</p></li>
<li><p><strong>Why it works</strong>: <strong>Reflection groups</strong> and fundamental domains—the group-theoretic perspective that unifies all our iterative algorithms across Days 2 and 3</p></li>
<li><p><strong>Hyperbolic geometry</strong>: Negative curvature space with two types of geodesics (vertical lines and semicircles in the UHP model)</p></li>
<li><p><strong>Connection to Day 2</strong>: Circle inversion is a hyperbolic isometry! The Apollonian gasket is actually a hyperbolic object</p></li>
<li><p><strong>Two reflection functions</strong>: <code>reflectIntoVertical</code> and <code>reflectIntoCircular</code> parallel the Euclidean <code>reflectInto</code></p></li>
<li><p><strong>Multiple models</strong>: Converting between upper half-plane and Poincaré disk using the Cayley transform</p></li>
<li><p><strong>Historical context</strong>: The dramatic discovery of hyperbolic geometry by Gauss, Bolyai, and Lobachevsky in the 19th century</p></li>
<li><p><strong>Computational perspective</strong>: GPU parallelism, convergence rates, precision issues, iteration count tuning</p></li>
</ol>
<p><strong>Key insight</strong>: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!</p>
<p><strong>The universal pattern</strong>: - <strong>Day 1</strong>: Distance fields and implicit curves—visualizing mathematics on the GPU - <strong>Day 2</strong>: Iterating circle inversions to create the Apollonian gasket—first group action - <strong>Day 3 (Euclidean)</strong>: Iterating reflections to create tilings—reflection groups make it work - <strong>Day 3 (Hyperbolic)</strong>: Same algorithm, different geometry—circle inversion reappears as hyperbolic isometry!</p>
<p>The through-line is <strong>geometric transformations and their groups</strong>. When we iterate a group action to reach a fundamental domain, we create tilings, fractals, and beautiful mathematical art.</p>
<hr>
</section>
<section id="homework" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="homework"><span class="header-section-number">3.5</span> Homework</h2>
<section id="required-0-understanding-hyperbolic-distance" class="level3">
<h3 class="anchored" data-anchor-id="required-0-understanding-hyperbolic-distance">Required #0: Understanding Hyperbolic Distance</h3>
<p><strong>Goal</strong>: Build geometric intuition for how hyperbolic distance works before implementing tilings.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p><strong>Euclidean distance visualization</strong>: Implement the shader showing Euclidean distance circles (provided in lecture). Drag the center around and observe that circles stay the same size everywhere.</p></li>
<li><p><strong>Hyperbolic distance visualization</strong>: Implement the hyperbolic version (provided in lecture). Drag the center and observe how the “circle” changes shape—growing huge near <span class="math inline">\(y \to 0\)</span> and shrinking as <span class="math inline">\(y\)</span> increases.</p></li>
<li><p><strong>Observations</strong>: Write 2-3 sentences describing what you observe about how hyperbolic “circles” behave compared to Euclidean ones. Why does the shape change as you drag the center?</p></li>
</ol>
<p><strong>Expected output</strong>: Two working shaders demonstrating the difference between Euclidean and hyperbolic distance.</p>
<hr>
</section>
<section id="required-1-euclidean-triangle-tiling-with-edges-and-vertices" class="level3">
<h3 class="anchored" data-anchor-id="required-1-euclidean-triangle-tiling-with-edges-and-vertices">Required #1: Euclidean Triangle Tiling with Edges and Vertices</h3>
<p><strong>Goal</strong>: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p>Start with the basic triangle tiling from lecture</p></li>
<li><p><strong>Add edge visualization</strong> using distance to half-spaces</p></li>
<li><p><strong>Add vertex markers</strong> at the three triangle vertices</p></li>
<li><p><strong>Create an attractive color scheme</strong></p></li>
</ol>
<p><strong>Expected output</strong>: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.</p>
<p>See Appendix E9 for reference implementation.</p>
<p><strong>Bonus</strong>: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.</p>
<hr>
</section>
<section id="required-2-hyperbolic-triangle-tiling-with-edges-and-vertices" class="level3">
<h3 class="anchored" data-anchor-id="required-2-hyperbolic-triangle-tiling-with-edges-and-vertices">Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</h3>
<p><strong>Goal</strong>: Create a beautiful hyperbolic triangle tiling with visible structure.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p>Start with the basic <span class="math inline">\((2,3,\infty)\)</span> tiling from lecture</p></li>
<li><p><strong>Implement hyperbolic distance functions</strong> (see hints in lecture)</p></li>
<li><p><strong>Draw geodesic edges</strong> using hyperbolic distance to geodesics</p></li>
<li><p><strong>Draw vertices</strong> using hyperbolic distance to vertex points</p></li>
<li><p><strong>Create an attractive color scheme</strong></p></li>
</ol>
<p><strong>Expected output</strong>: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.</p>
<p>See Appendix H5 for complete reference implementation.</p>
<p><strong>Bonus</strong>: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.</p>
<hr>
</section>
<section id="required-3-model-conversions" class="level3">
<h3 class="anchored" data-anchor-id="required-3-model-conversions">Required #3: Model Conversions</h3>
<p><strong>Goal</strong>: See the same tiling in different representations of hyperbolic space.</p>
<p><strong>Tasks</strong>:</p>
<ol type="1">
<li><p><strong>Poincaré Disk</strong> (already provided in lecture): Verify it works with your tiling code</p></li>
<li><p><strong>Klein Model</strong>: Implement the transformation from Poincaré disk to Klein disk (see lecture for formula)</p>
<p>In the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.</p></li>
<li><p><strong>Comparison</strong>: Show your <span class="math inline">\((2,3,\infty)\)</span> tiling in both the Poincaré disk and Klein model side-by-side. Write a few sentences about what you observe.</p></li>
</ol>
<p><strong>Deliverable</strong>: Screenshots of your tiling in at least two models, with brief observations.</p>
<p>See Appendix H7 for Klein model reference.</p>
<hr>
</section>
<section id="required-4-different-triangle-groups-challenge" class="level3">
<h3 class="anchored" data-anchor-id="required-4-different-triangle-groups-challenge">Required #4: Different Triangle Groups (Challenge!)</h3>
<p><strong>Goal</strong>: Explore other hyperbolic tilings by implementing different triangle groups.</p>
<p><strong>The Challenge</strong>: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.</p>
<p><strong>Suggested triangles to try</strong>: - <strong>(2, 3, 7)</strong>: Creates Escher-like tilings with 7-fold symmetry - <strong>(2, 4, 6)</strong>: Different symmetry pattern - <strong>(3, 3, 3)</strong>: Equilateral hyperbolic triangle</p>
<p><strong>Approach</strong>: Use the hyperbolic law of cosines (see lecture for formula) to compute geodesic positions.</p>
<p><strong>Deliverable</strong>: Working tiling for at least one triangle group other than <span class="math inline">\((2,3,\infty)\)</span>. Include screenshots and document your approach.</p>
<hr>
</section>
<section id="optional-exercises" class="level3">
<h3 class="anchored" data-anchor-id="optional-exercises">Optional Exercises</h3>
<p><strong>Optional #1: Unified Abstractions</strong> - Create structs that work for both Euclidean and hyperbolic geometry</p>
<p><strong>Optional #2: Decorated Tiles</strong> - Add Escher-style patterns within fundamental domains</p>
<p><strong>Optional #3: Pentagon Tilings</strong> - Right-angled pentagons can tile hyperbolic space!</p>
<p>See lecture for details on these optional exercises.</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">3.6</span> Looking Ahead</h2>
<p>We’ve now seen three days of geometric iteration: - <strong>Day 1</strong>: Distance fields and implicit functions - <strong>Day 2</strong>: Circle inversion and the Apollonian gasket - <strong>Day 3</strong>: Reflection groups in Euclidean and hyperbolic geometry</p>
<p>The common thread: <strong>group actions on geometric spaces</strong>. Iteratively applying transformations to reach a desired region, whether it’s the fundamental domain of a tiling or the gap structure of a fractal.</p>
<p>The techniques you’ve learned—GPU parallelism, iterative algorithms, group theory, geometric transformations—apply across a huge landscape of mathematical visualization!</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../lectures/day2.html" class="pagination-link" aria-label="Day 2: Complex Dynamics and Iterated Inversions">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../lectures/day4.html" class="pagination-link" aria-label="Day 4: Introduction to 3D Rendering">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>Today we explore geometric tilings through reflection operations. We'll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>The key insight: **the algorithm stays the same across geometries—only the reflection operations change.** This mirrors what we saw on Day 2 with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region. But today we'll understand *why* this works through the lens of group theory.</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll understand:</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to construct reflections using linear algebra</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Why the folding algorithm works** (reflection groups and fundamental domains)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The structure of hyperbolic geometry in the upper half-plane model</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to implement hyperbolic triangle tilings using the same algorithmic pattern</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>How to convert between different models of hyperbolic space</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The connection between circle inversion (Day 2) and hyperbolic isometries</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="fu">## Roadmap for Today</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>**Part 1: Euclidean Geometry**</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Simple tilings (strip, square)</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Half-space abstraction</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Triangle tilings</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Why this works**: Reflection groups</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>**Part 2: Hyperbolic Geometry**</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The upper half-plane model and metric</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Geodesics and reflections (connection to Day 2!)</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Triangle tilings in $\mathbb{H}^2$</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Multiple models (Poincaré disk, Klein)</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Historical context and applications</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>The unifying theme is **geometric transformations and their groups**—the same mathematical structure underlies fractals, tilings, and symmetry across all geometries.</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 1: Reflection and Tilings in Euclidean Geometry</span></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a><span class="fu">### Starting Simple: The Folding Algorithm</span></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>Before we dive into general theory, let's build intuition with the simplest possible example: creating a repeating strip pattern.</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Tiling a Strip</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>Imagine we want to tile the plane horizontally. We'll define a fundamental domain—the strip $0 &lt; x &lt; 1$—and reflect any point outside this strip back inside.</span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>The algorithm is remarkably simple:</span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $x &lt; 0$, reflect across $x = 0$</span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $x &gt; 1$, reflect across $x = 1$  </span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Repeat until the point stops moving</span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>For a vertical line at $x = c$, reflection just flips the $x$-coordinate: $(x, y) \mapsto (2c - x, y)$.</span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a>Here's a complete shader:</span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-57"><a href="#cb32-57" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-58"><a href="#cb32-58" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-59"><a href="#cb32-59" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-60"><a href="#cb32-60" aria-hidden="true" tabindex="-1"></a><span class="in">    // Standard coordinate setup</span></span>
<span id="cb32-61"><a href="#cb32-61" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-62"><a href="#cb32-62" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-63"><a href="#cb32-63" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-64"><a href="#cb32-64" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-65"><a href="#cb32-65" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-66"><a href="#cb32-66" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the strip [0, 1]</span></span>
<span id="cb32-67"><a href="#cb32-67" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb32-68"><a href="#cb32-68" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &lt; 0.0) p.x = -p.x;</span></span>
<span id="cb32-69"><a href="#cb32-69" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &gt; 1.0) p.x = 2.0 - p.x;</span></span>
<span id="cb32-70"><a href="#cb32-70" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-71"><a href="#cb32-71" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-72"><a href="#cb32-72" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw something in the fundamental domain</span></span>
<span id="cb32-73"><a href="#cb32-73" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background</span></span>
<span id="cb32-74"><a href="#cb32-74" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-75"><a href="#cb32-75" aria-hidden="true" tabindex="-1"></a><span class="in">    // A circle in the strip</span></span>
<span id="cb32-76"><a href="#cb32-76" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p - vec2(0.5, 0.0));</span></span>
<span id="cb32-77"><a href="#cb32-77" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.3) {</span></span>
<span id="cb32-78"><a href="#cb32-78" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 0.8, 0.3);  // Yellow circle</span></span>
<span id="cb32-79"><a href="#cb32-79" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-80"><a href="#cb32-80" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-81"><a href="#cb32-81" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-82"><a href="#cb32-82" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-83"><a href="#cb32-83" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-84"><a href="#cb32-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-85"><a href="#cb32-85" aria-hidden="true" tabindex="-1"></a>You should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.</span>
<span id="cb32-86"><a href="#cb32-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-87"><a href="#cb32-87" aria-hidden="true" tabindex="-1"></a>**What's happening geometrically?** Every point on the screen gets mapped back to the fundamental domain $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. Points that were in reflected copies of the domain get folded back through a sequence of reflections. Since we draw the same pattern in the fundamental domain, all the reflected copies show the same pattern.</span>
<span id="cb32-88"><a href="#cb32-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-89"><a href="#cb32-89" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-90"><a href="#cb32-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-91"><a href="#cb32-91" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Square Tiling</span></span>
<span id="cb32-92"><a href="#cb32-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-93"><a href="#cb32-93" aria-hidden="true" tabindex="-1"></a>Let's extend to two dimensions. Now we have four boundaries: $x = 0$, $x = 1$, $y = 0$, and $y = 1$. Same algorithm, just more boundaries to check:</span>
<span id="cb32-94"><a href="#cb32-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-95"><a href="#cb32-95" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-96"><a href="#cb32-96" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-97"><a href="#cb32-97" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-98"><a href="#cb32-98" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-99"><a href="#cb32-99" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-100"><a href="#cb32-100" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-101"><a href="#cb32-101" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-102"><a href="#cb32-102" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-103"><a href="#cb32-103" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-104"><a href="#cb32-104" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the square [0,1] × [0,1]</span></span>
<span id="cb32-105"><a href="#cb32-105" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb32-106"><a href="#cb32-106" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &lt; 0.0) p.x = -p.x;</span></span>
<span id="cb32-107"><a href="#cb32-107" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &gt; 1.0) p.x = 2.0 - p.x;</span></span>
<span id="cb32-108"><a href="#cb32-108" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.y &lt; 0.0) p.y = -p.y;</span></span>
<span id="cb32-109"><a href="#cb32-109" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.y &gt; 1.0) p.y = 2.0 - p.y;</span></span>
<span id="cb32-110"><a href="#cb32-110" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-111"><a href="#cb32-111" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-112"><a href="#cb32-112" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw something in the fundamental domain</span></span>
<span id="cb32-113"><a href="#cb32-113" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.2, 0.2, 0.3);</span></span>
<span id="cb32-114"><a href="#cb32-114" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-115"><a href="#cb32-115" aria-hidden="true" tabindex="-1"></a><span class="in">    // Circle at center</span></span>
<span id="cb32-116"><a href="#cb32-116" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p - vec2(0.5, 0.5));</span></span>
<span id="cb32-117"><a href="#cb32-117" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.3) {</span></span>
<span id="cb32-118"><a href="#cb32-118" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 0.8, 0.3);</span></span>
<span id="cb32-119"><a href="#cb32-119" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-120"><a href="#cb32-120" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-121"><a href="#cb32-121" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-122"><a href="#cb32-122" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-123"><a href="#cb32-123" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-124"><a href="#cb32-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-125"><a href="#cb32-125" aria-hidden="true" tabindex="-1"></a>Perfect! A full 2D tiling.</span>
<span id="cb32-126"><a href="#cb32-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-127"><a href="#cb32-127" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-128"><a href="#cb32-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-129"><a href="#cb32-129" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Square Tiling with Fold Count</span></span>
<span id="cb32-130"><a href="#cb32-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-131"><a href="#cb32-131" aria-hidden="true" tabindex="-1"></a>Let's track how many reflections were needed. This helps us understand the geometry and creates beautiful visualizations:</span>
<span id="cb32-132"><a href="#cb32-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-133"><a href="#cb32-133" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-134"><a href="#cb32-134" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-135"><a href="#cb32-135" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-136"><a href="#cb32-136" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-137"><a href="#cb32-137" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-138"><a href="#cb32-138" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-139"><a href="#cb32-139" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-140"><a href="#cb32-140" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-141"><a href="#cb32-141" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-142"><a href="#cb32-142" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the square [0,1] × [0,1]</span></span>
<span id="cb32-143"><a href="#cb32-143" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb32-144"><a href="#cb32-144" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb32-145"><a href="#cb32-145" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 p_old = p;</span></span>
<span id="cb32-146"><a href="#cb32-146" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-147"><a href="#cb32-147" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &lt; 0.0) p.x = -p.x;</span></span>
<span id="cb32-148"><a href="#cb32-148" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.x &gt; 1.0) p.x = 2.0 - p.x;</span></span>
<span id="cb32-149"><a href="#cb32-149" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.y &lt; 0.0) p.y = -p.y;</span></span>
<span id="cb32-150"><a href="#cb32-150" aria-hidden="true" tabindex="-1"></a><span class="in">        if(p.y &gt; 1.0) p.y = 2.0 - p.y;</span></span>
<span id="cb32-151"><a href="#cb32-151" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-152"><a href="#cb32-152" aria-hidden="true" tabindex="-1"></a><span class="in">        // If point didn't move, we're done</span></span>
<span id="cb32-153"><a href="#cb32-153" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - p_old) &lt; 0.0001) break;</span></span>
<span id="cb32-154"><a href="#cb32-154" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb32-155"><a href="#cb32-155" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-156"><a href="#cb32-156" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-157"><a href="#cb32-157" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb32-158"><a href="#cb32-158" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 8.0;</span></span>
<span id="cb32-159"><a href="#cb32-159" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));</span></span>
<span id="cb32-160"><a href="#cb32-160" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-161"><a href="#cb32-161" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw something in the fundamental domain</span></span>
<span id="cb32-162"><a href="#cb32-162" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p - vec2(0.5, 0.5));</span></span>
<span id="cb32-163"><a href="#cb32-163" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.3) {</span></span>
<span id="cb32-164"><a href="#cb32-164" aria-hidden="true" tabindex="-1"></a><span class="in">        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));</span></span>
<span id="cb32-165"><a href="#cb32-165" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-166"><a href="#cb32-166" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-167"><a href="#cb32-167" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-168"><a href="#cb32-168" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-169"><a href="#cb32-169" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-170"><a href="#cb32-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-171"><a href="#cb32-171" aria-hidden="true" tabindex="-1"></a>Beautiful! The color gradient shows how many reflections were needed—points near the fundamental domain require few iterations, while points far away need many.</span>
<span id="cb32-172"><a href="#cb32-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-173"><a href="#cb32-173" aria-hidden="true" tabindex="-1"></a>Notice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain and we can stop.</span>
<span id="cb32-174"><a href="#cb32-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-175"><a href="#cb32-175" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb32-176"><a href="#cb32-176" aria-hidden="true" tabindex="-1"></a><span class="fu">## Computational Efficiency: Iteration Count</span></span>
<span id="cb32-177"><a href="#cb32-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-178"><a href="#cb32-178" aria-hidden="true" tabindex="-1"></a>Why does this converge so quickly? Each reflection moves the point strictly closer to the fundamental domain (in the sense of reducing the number of boundary crossings). For a viewport of size $4 \times 4$ and fundamental domain of size $1 \times 1$, we need at most $\lceil \log_2(4) \rceil = 2$ reflections per axis, so 4 reflections total in the worst case.</span>
<span id="cb32-179"><a href="#cb32-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-180"><a href="#cb32-180" aria-hidden="true" tabindex="-1"></a>The 20-iteration limit is very conservative—most pixels converge in under 5 iterations. We could dynamically adjust this based on the coordinate scale, but for real-time rendering, a fixed conservative bound works well.</span>
<span id="cb32-181"><a href="#cb32-181" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-182"><a href="#cb32-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-183"><a href="#cb32-183" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-184"><a href="#cb32-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-185"><a href="#cb32-185" aria-hidden="true" tabindex="-1"></a><span class="fu">### Abstracting: Half-Spaces</span></span>
<span id="cb32-186"><a href="#cb32-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-187"><a href="#cb32-187" aria-hidden="true" tabindex="-1"></a>Looking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let's abstract this pattern so we can handle arbitrary shapes.</span>
<span id="cb32-188"><a href="#cb32-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-189"><a href="#cb32-189" aria-hidden="true" tabindex="-1"></a><span class="fu">#### What is a Half-Space?</span></span>
<span id="cb32-190"><a href="#cb32-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-191"><a href="#cb32-191" aria-hidden="true" tabindex="-1"></a>A **half-space** is one side of a line. Any line $ax + by = c$ divides the plane into two regions:</span>
<span id="cb32-192"><a href="#cb32-192" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points where $ax + by &lt; c$</span>
<span id="cb32-193"><a href="#cb32-193" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Points where $ax + by &gt; c$</span>
<span id="cb32-194"><a href="#cb32-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-195"><a href="#cb32-195" aria-hidden="true" tabindex="-1"></a>We'll encode a half-space by storing the line parameters and which side we want:</span>
<span id="cb32-196"><a href="#cb32-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-197"><a href="#cb32-197" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-198"><a href="#cb32-198" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb32-199"><a href="#cb32-199" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;  // Line parameters: ax + by = c</span></span>
<span id="cb32-200"><a href="#cb32-200" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;     // +1 or -1 for which side</span></span>
<span id="cb32-201"><a href="#cb32-201" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb32-202"><a href="#cb32-202" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-203"><a href="#cb32-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-204"><a href="#cb32-204" aria-hidden="true" tabindex="-1"></a>The <span class="in">`side`</span> parameter determines which inequality we want:</span>
<span id="cb32-205"><a href="#cb32-205" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`side = -1.0`</span> means we want $ax + by &gt; c$ (equivalently, $(ax + by - c) \cdot (-1) &lt; 0$)</span>
<span id="cb32-206"><a href="#cb32-206" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`side = 1.0`</span> means we want $ax + by &lt; c$ (equivalently, $(ax + by - c) \cdot (1) &lt; 0$)</span>
<span id="cb32-207"><a href="#cb32-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-208"><a href="#cb32-208" aria-hidden="true" tabindex="-1"></a>This might seem redundant—we could always use $ax + by &lt; c$ and just flip the signs of $a, b, c$ to get the other side. But having an explicit <span class="in">`side`</span> parameter makes the code clearer and will be essential in hyperbolic geometry where sign-flipping doesn't work as cleanly.</span>
<span id="cb32-209"><a href="#cb32-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-210"><a href="#cb32-210" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Visualizing Half-Spaces</span></span>
<span id="cb32-211"><a href="#cb32-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-212"><a href="#cb32-212" aria-hidden="true" tabindex="-1"></a>Before we implement reflections, let's visualize what a half-space is. Here's a shader that colors one side of a line:</span>
<span id="cb32-213"><a href="#cb32-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-214"><a href="#cb32-214" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-215"><a href="#cb32-215" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb32-216"><a href="#cb32-216" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;</span></span>
<span id="cb32-217"><a href="#cb32-217" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;</span></span>
<span id="cb32-218"><a href="#cb32-218" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb32-219"><a href="#cb32-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-220"><a href="#cb32-220" aria-hidden="true" tabindex="-1"></a><span class="in">bool inside(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-221"><a href="#cb32-221" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb32-222"><a href="#cb32-222" aria-hidden="true" tabindex="-1"></a><span class="in">    return (value - hs.c) * hs.side &lt; 0.0;</span></span>
<span id="cb32-223"><a href="#cb32-223" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-224"><a href="#cb32-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-225"><a href="#cb32-225" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-226"><a href="#cb32-226" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-227"><a href="#cb32-227" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-228"><a href="#cb32-228" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-229"><a href="#cb32-229" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-230"><a href="#cb32-230" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-231"><a href="#cb32-231" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-232"><a href="#cb32-232" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-233"><a href="#cb32-233" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define a half-space: x &lt; 1 (left side of vertical line at x=1)</span></span>
<span id="cb32-234"><a href="#cb32-234" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);</span></span>
<span id="cb32-235"><a href="#cb32-235" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-236"><a href="#cb32-236" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on whether we're inside</span></span>
<span id="cb32-237"><a href="#cb32-237" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);</span></span>
<span id="cb32-238"><a href="#cb32-238" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-239"><a href="#cb32-239" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-240"><a href="#cb32-240" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-241"><a href="#cb32-241" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-242"><a href="#cb32-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-243"><a href="#cb32-243" aria-hidden="true" tabindex="-1"></a>You should see the left side of the line colored blue, the right side dark. Try changing the half-space parameters to see how it affects the coloring!</span>
<span id="cb32-244"><a href="#cb32-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-245"><a href="#cb32-245" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb32-246"><a href="#cb32-246" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercise: Drawing the Boundary Line</span></span>
<span id="cb32-247"><a href="#cb32-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-248"><a href="#cb32-248" aria-hidden="true" tabindex="-1"></a>Want to see where the line is? Add this distance function:</span>
<span id="cb32-249"><a href="#cb32-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-250"><a href="#cb32-250" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-251"><a href="#cb32-251" aria-hidden="true" tabindex="-1"></a><span class="in">float distToHalfSpace(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-252"><a href="#cb32-252" aria-hidden="true" tabindex="-1"></a><span class="in">    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));</span></span>
<span id="cb32-253"><a href="#cb32-253" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-254"><a href="#cb32-254" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-255"><a href="#cb32-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-256"><a href="#cb32-256" aria-hidden="true" tabindex="-1"></a>Then draw the line:</span>
<span id="cb32-257"><a href="#cb32-257" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-258"><a href="#cb32-258" aria-hidden="true" tabindex="-1"></a><span class="in">float d = distToHalfSpace(p, hs);</span></span>
<span id="cb32-259"><a href="#cb32-259" aria-hidden="true" tabindex="-1"></a><span class="in">if(d &lt; 0.02) color = vec3(1.0);  // White boundary</span></span>
<span id="cb32-260"><a href="#cb32-260" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-261"><a href="#cb32-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-262"><a href="#cb32-262" aria-hidden="true" tabindex="-1"></a>This computes the perpendicular distance from the point to the line, then colors points near the line white. See Appendix E4b for the complete implementation!</span>
<span id="cb32-263"><a href="#cb32-263" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-264"><a href="#cb32-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-265"><a href="#cb32-265" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Intersecting Half-Spaces: Making a Square</span></span>
<span id="cb32-266"><a href="#cb32-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-267"><a href="#cb32-267" aria-hidden="true" tabindex="-1"></a>Now let's intersect four half-spaces to create a square region. We'll use **additive coloring**—each half-space we're inside adds to the color, so the interior (inside all four) will be brightest:</span>
<span id="cb32-268"><a href="#cb32-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-269"><a href="#cb32-269" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-270"><a href="#cb32-270" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb32-271"><a href="#cb32-271" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;</span></span>
<span id="cb32-272"><a href="#cb32-272" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;</span></span>
<span id="cb32-273"><a href="#cb32-273" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb32-274"><a href="#cb32-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-275"><a href="#cb32-275" aria-hidden="true" tabindex="-1"></a><span class="in">bool inside(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-276"><a href="#cb32-276" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb32-277"><a href="#cb32-277" aria-hidden="true" tabindex="-1"></a><span class="in">    return (value - hs.c) * hs.side &lt; 0.0;</span></span>
<span id="cb32-278"><a href="#cb32-278" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-279"><a href="#cb32-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-280"><a href="#cb32-280" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-281"><a href="#cb32-281" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-282"><a href="#cb32-282" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-283"><a href="#cb32-283" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-284"><a href="#cb32-284" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-285"><a href="#cb32-285" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-286"><a href="#cb32-286" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-287"><a href="#cb32-287" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-288"><a href="#cb32-288" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define the four half-spaces for [0,1] × [0,1]</span></span>
<span id="cb32-289"><a href="#cb32-289" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0</span></span>
<span id="cb32-290"><a href="#cb32-290" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1</span></span>
<span id="cb32-291"><a href="#cb32-291" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0</span></span>
<span id="cb32-292"><a href="#cb32-292" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1</span></span>
<span id="cb32-293"><a href="#cb32-293" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-294"><a href="#cb32-294" aria-hidden="true" tabindex="-1"></a><span class="in">    // Additive coloring - each half-space adds brightness</span></span>
<span id="cb32-295"><a href="#cb32-295" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.0);</span></span>
<span id="cb32-296"><a href="#cb32-296" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-297"><a href="#cb32-297" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inside(p, left))   color += vec3(0.1, 0.15, 0.2);</span></span>
<span id="cb32-298"><a href="#cb32-298" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inside(p, right))  color += vec3(0.1, 0.15, 0.2);</span></span>
<span id="cb32-299"><a href="#cb32-299" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inside(p, bottom)) color += vec3(0.1, 0.15, 0.2);</span></span>
<span id="cb32-300"><a href="#cb32-300" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inside(p, top))    color += vec3(0.1, 0.15, 0.2);</span></span>
<span id="cb32-301"><a href="#cb32-301" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-302"><a href="#cb32-302" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-303"><a href="#cb32-303" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-304"><a href="#cb32-304" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-305"><a href="#cb32-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-306"><a href="#cb32-306" aria-hidden="true" tabindex="-1"></a>You should see the square region brightest (inside all four half-spaces), with regions inside fewer half-spaces progressively darker. This additive approach makes it easy to see how the regions overlap!</span>
<span id="cb32-307"><a href="#cb32-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-308"><a href="#cb32-308" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb32-309"><a href="#cb32-309" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercise: Improved Visualization</span></span>
<span id="cb32-310"><a href="#cb32-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-311"><a href="#cb32-311" aria-hidden="true" tabindex="-1"></a>For a cleaner look, you might want to:</span>
<span id="cb32-312"><a href="#cb32-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-313"><a href="#cb32-313" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Binary coloring** (inside domain or not):</span>
<span id="cb32-314"><a href="#cb32-314" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-315"><a href="#cb32-315" aria-hidden="true" tabindex="-1"></a><span class="in">bool in_square = inside(p, left) &amp;&amp; inside(p, right) &amp;&amp; </span></span>
<span id="cb32-316"><a href="#cb32-316" aria-hidden="true" tabindex="-1"></a><span class="in">                 inside(p, bottom) &amp;&amp; inside(p, top);</span></span>
<span id="cb32-317"><a href="#cb32-317" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = in_square ? vec3(0.4, 0.6, 0.8) : vec3(0.1, 0.1, 0.2);</span></span>
<span id="cb32-318"><a href="#cb32-318" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-319"><a href="#cb32-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-320"><a href="#cb32-320" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Draw boundaries** using the distance function from earlier</span>
<span id="cb32-321"><a href="#cb32-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-322"><a href="#cb32-322" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Create an `insideDomain()` function**:</span>
<span id="cb32-323"><a href="#cb32-323" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-324"><a href="#cb32-324" aria-hidden="true" tabindex="-1"></a><span class="in">bool insideDomain(vec2 p, HalfSpace hs1, HalfSpace hs2, </span></span>
<span id="cb32-325"><a href="#cb32-325" aria-hidden="true" tabindex="-1"></a><span class="in">                  HalfSpace hs3, HalfSpace hs4) {</span></span>
<span id="cb32-326"><a href="#cb32-326" aria-hidden="true" tabindex="-1"></a><span class="in">    return inside(p, hs1) &amp;&amp; inside(p, hs2) &amp;&amp; </span></span>
<span id="cb32-327"><a href="#cb32-327" aria-hidden="true" tabindex="-1"></a><span class="in">           inside(p, hs3) &amp;&amp; inside(p, hs4);</span></span>
<span id="cb32-328"><a href="#cb32-328" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-329"><a href="#cb32-329" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-330"><a href="#cb32-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-331"><a href="#cb32-331" aria-hidden="true" tabindex="-1"></a>See Appendix E5b for complete enhanced versions!</span>
<span id="cb32-332"><a href="#cb32-332" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-333"><a href="#cb32-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-334"><a href="#cb32-334" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Three Half-Spaces Make a Triangle</span></span>
<span id="cb32-335"><a href="#cb32-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-336"><a href="#cb32-336" aria-hidden="true" tabindex="-1"></a>Let's visualize three half-spaces defining a triangle:</span>
<span id="cb32-337"><a href="#cb32-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-338"><a href="#cb32-338" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-339"><a href="#cb32-339" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb32-340"><a href="#cb32-340" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;</span></span>
<span id="cb32-341"><a href="#cb32-341" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;</span></span>
<span id="cb32-342"><a href="#cb32-342" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb32-343"><a href="#cb32-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-344"><a href="#cb32-344" aria-hidden="true" tabindex="-1"></a><span class="in">bool inside(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-345"><a href="#cb32-345" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb32-346"><a href="#cb32-346" aria-hidden="true" tabindex="-1"></a><span class="in">    return (value - hs.c) * hs.side &lt; 0.0;</span></span>
<span id="cb32-347"><a href="#cb32-347" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-348"><a href="#cb32-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-349"><a href="#cb32-349" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-350"><a href="#cb32-350" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-351"><a href="#cb32-351" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-352"><a href="#cb32-352" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-353"><a href="#cb32-353" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-354"><a href="#cb32-354" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-355"><a href="#cb32-355" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-356"><a href="#cb32-356" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-357"><a href="#cb32-357" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define three half-spaces for equilateral triangle</span></span>
<span id="cb32-358"><a href="#cb32-358" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);</span></span>
<span id="cb32-359"><a href="#cb32-359" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);</span></span>
<span id="cb32-360"><a href="#cb32-360" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);</span></span>
<span id="cb32-361"><a href="#cb32-361" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-362"><a href="#cb32-362" aria-hidden="true" tabindex="-1"></a><span class="in">    // Additive coloring</span></span>
<span id="cb32-363"><a href="#cb32-363" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.0);</span></span>
<span id="cb32-364"><a href="#cb32-364" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-365"><a href="#cb32-365" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inside(p, hs1)) color += vec3(0.15, 0.2, 0.25);</span></span>
<span id="cb32-366"><a href="#cb32-366" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inside(p, hs2)) color += vec3(0.15, 0.2, 0.25);</span></span>
<span id="cb32-367"><a href="#cb32-367" aria-hidden="true" tabindex="-1"></a><span class="in">    if(inside(p, hs3)) color += vec3(0.15, 0.2, 0.25);</span></span>
<span id="cb32-368"><a href="#cb32-368" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-369"><a href="#cb32-369" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-370"><a href="#cb32-370" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-371"><a href="#cb32-371" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-372"><a href="#cb32-372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-373"><a href="#cb32-373" aria-hidden="true" tabindex="-1"></a>You should see a triangle region where all three half-spaces overlap! The additive coloring helps visualize the structure.</span>
<span id="cb32-374"><a href="#cb32-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-375"><a href="#cb32-375" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-376"><a href="#cb32-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-377"><a href="#cb32-377" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Reflection Formula</span></span>
<span id="cb32-378"><a href="#cb32-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-379"><a href="#cb32-379" aria-hidden="true" tabindex="-1"></a>Now we're ready to implement reflection. To reflect a point $\mathbf{p} = (x, y)$ across the line $ax + by = c$, we use linear algebra. The normal vector to the line is $\mathbf{n} = (a, b)$. After normalizing to $\hat{\mathbf{n}} = \mathbf{n}/|\mathbf{n}|$, the reflection formula is:</span>
<span id="cb32-380"><a href="#cb32-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-381"><a href="#cb32-381" aria-hidden="true" tabindex="-1"></a>$$\mathbf{p}' = \mathbf{p} - 2d\hat{\mathbf{n}}$$</span>
<span id="cb32-382"><a href="#cb32-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-383"><a href="#cb32-383" aria-hidden="true" tabindex="-1"></a>where $d$ is the signed distance from $\mathbf{p}$ to the line:</span>
<span id="cb32-384"><a href="#cb32-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-385"><a href="#cb32-385" aria-hidden="true" tabindex="-1"></a>$$d = \frac{ax + by - c}{\sqrt{a^2 + b^2}}$$</span>
<span id="cb32-386"><a href="#cb32-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-387"><a href="#cb32-387" aria-hidden="true" tabindex="-1"></a>This is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.</span>
<span id="cb32-388"><a href="#cb32-388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-389"><a href="#cb32-389" aria-hidden="true" tabindex="-1"></a>Our <span class="in">`reflectInto`</span> function checks if we're on the correct side and only reflects if necessary—it **extends** our <span class="in">`inside()`</span> test by conditionally reflecting:</span>
<span id="cb32-390"><a href="#cb32-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-391"><a href="#cb32-391" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-392"><a href="#cb32-392" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-393"><a href="#cb32-393" aria-hidden="true" tabindex="-1"></a><span class="in">    // Compute which side of the line we're on</span></span>
<span id="cb32-394"><a href="#cb32-394" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb32-395"><a href="#cb32-395" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-396"><a href="#cb32-396" aria-hidden="true" tabindex="-1"></a><span class="in">    // Check if we're already on the correct side (this is our inside() test!)</span></span>
<span id="cb32-397"><a href="#cb32-397" aria-hidden="true" tabindex="-1"></a><span class="in">    if((value - hs.c) * hs.side &lt; 0.0) {</span></span>
<span id="cb32-398"><a href="#cb32-398" aria-hidden="true" tabindex="-1"></a><span class="in">        return p;  // Already inside, nothing to do</span></span>
<span id="cb32-399"><a href="#cb32-399" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-400"><a href="#cb32-400" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-401"><a href="#cb32-401" aria-hidden="true" tabindex="-1"></a><span class="in">    // We're on the wrong side - reflect across the boundary line</span></span>
<span id="cb32-402"><a href="#cb32-402" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 normal = vec2(hs.a, hs.b);</span></span>
<span id="cb32-403"><a href="#cb32-403" aria-hidden="true" tabindex="-1"></a><span class="in">    float norm = length(normal);</span></span>
<span id="cb32-404"><a href="#cb32-404" aria-hidden="true" tabindex="-1"></a><span class="in">    normal = normal / norm;</span></span>
<span id="cb32-405"><a href="#cb32-405" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-406"><a href="#cb32-406" aria-hidden="true" tabindex="-1"></a><span class="in">    float signedDist = (value - hs.c) / norm;</span></span>
<span id="cb32-407"><a href="#cb32-407" aria-hidden="true" tabindex="-1"></a><span class="in">    return p - 2.0 * signedDist * normal;</span></span>
<span id="cb32-408"><a href="#cb32-408" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-409"><a href="#cb32-409" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-410"><a href="#cb32-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-411"><a href="#cb32-411" aria-hidden="true" tabindex="-1"></a>This function encapsulates the entire pattern: check if we're on the correct side (the <span class="in">`inside()`</span> test), and only reflect if we're not. So <span class="in">`reflectInto()`</span> extends and renames our visualization function to also perform the reflection!</span>
<span id="cb32-412"><a href="#cb32-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-413"><a href="#cb32-413" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-414"><a href="#cb32-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-415"><a href="#cb32-415" aria-hidden="true" tabindex="-1"></a><span class="fu">### Square Tiling with Half-Spaces</span></span>
<span id="cb32-416"><a href="#cb32-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-417"><a href="#cb32-417" aria-hidden="true" tabindex="-1"></a>Let's rewrite our square tiling using this abstraction. For the square $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$, we need four half-spaces:</span>
<span id="cb32-418"><a href="#cb32-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-419"><a href="#cb32-419" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Left edge** ($x = 0$): We want $x &gt; 0$ → <span class="in">`HalfSpace(1.0, 0.0, 0.0, -1.0)`</span></span>
<span id="cb32-420"><a href="#cb32-420" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Right edge** ($x = 1$): We want $x &lt; 1$ → <span class="in">`HalfSpace(1.0, 0.0, 1.0, 1.0)`</span></span>
<span id="cb32-421"><a href="#cb32-421" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Bottom and top**: Similarly for $y$</span>
<span id="cb32-422"><a href="#cb32-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-423"><a href="#cb32-423" aria-hidden="true" tabindex="-1"></a>Complete shader:</span>
<span id="cb32-424"><a href="#cb32-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-425"><a href="#cb32-425" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-426"><a href="#cb32-426" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb32-427"><a href="#cb32-427" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;</span></span>
<span id="cb32-428"><a href="#cb32-428" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;</span></span>
<span id="cb32-429"><a href="#cb32-429" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb32-430"><a href="#cb32-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-431"><a href="#cb32-431" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-432"><a href="#cb32-432" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb32-433"><a href="#cb32-433" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-434"><a href="#cb32-434" aria-hidden="true" tabindex="-1"></a><span class="in">    if((value - hs.c) * hs.side &lt; 0.0) {</span></span>
<span id="cb32-435"><a href="#cb32-435" aria-hidden="true" tabindex="-1"></a><span class="in">        return p;</span></span>
<span id="cb32-436"><a href="#cb32-436" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-437"><a href="#cb32-437" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-438"><a href="#cb32-438" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 normal = vec2(hs.a, hs.b);</span></span>
<span id="cb32-439"><a href="#cb32-439" aria-hidden="true" tabindex="-1"></a><span class="in">    float norm = length(normal);</span></span>
<span id="cb32-440"><a href="#cb32-440" aria-hidden="true" tabindex="-1"></a><span class="in">    normal = normal / norm;</span></span>
<span id="cb32-441"><a href="#cb32-441" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-442"><a href="#cb32-442" aria-hidden="true" tabindex="-1"></a><span class="in">    float signedDist = (value - hs.c) / norm;</span></span>
<span id="cb32-443"><a href="#cb32-443" aria-hidden="true" tabindex="-1"></a><span class="in">    return p - 2.0 * signedDist * normal;</span></span>
<span id="cb32-444"><a href="#cb32-444" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-445"><a href="#cb32-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-446"><a href="#cb32-446" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-447"><a href="#cb32-447" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-448"><a href="#cb32-448" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-449"><a href="#cb32-449" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-450"><a href="#cb32-450" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-451"><a href="#cb32-451" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-452"><a href="#cb32-452" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-453"><a href="#cb32-453" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-454"><a href="#cb32-454" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define the four half-spaces for [0,1]×[0,1]</span></span>
<span id="cb32-455"><a href="#cb32-455" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);</span></span>
<span id="cb32-456"><a href="#cb32-456" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);</span></span>
<span id="cb32-457"><a href="#cb32-457" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);</span></span>
<span id="cb32-458"><a href="#cb32-458" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);</span></span>
<span id="cb32-459"><a href="#cb32-459" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-460"><a href="#cb32-460" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the square</span></span>
<span id="cb32-461"><a href="#cb32-461" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb32-462"><a href="#cb32-462" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb32-463"><a href="#cb32-463" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 p_old = p;</span></span>
<span id="cb32-464"><a href="#cb32-464" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-465"><a href="#cb32-465" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, left);</span></span>
<span id="cb32-466"><a href="#cb32-466" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, right);</span></span>
<span id="cb32-467"><a href="#cb32-467" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, bottom);</span></span>
<span id="cb32-468"><a href="#cb32-468" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, top);</span></span>
<span id="cb32-469"><a href="#cb32-469" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-470"><a href="#cb32-470" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - p_old) &lt; 0.0001) break;</span></span>
<span id="cb32-471"><a href="#cb32-471" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb32-472"><a href="#cb32-472" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-473"><a href="#cb32-473" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-474"><a href="#cb32-474" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color based on fold count</span></span>
<span id="cb32-475"><a href="#cb32-475" aria-hidden="true" tabindex="-1"></a><span class="in">    float t = float(foldCount) / 8.0;</span></span>
<span id="cb32-476"><a href="#cb32-476" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));</span></span>
<span id="cb32-477"><a href="#cb32-477" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-478"><a href="#cb32-478" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw something in fundamental domain</span></span>
<span id="cb32-479"><a href="#cb32-479" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p - vec2(0.5, 0.5));</span></span>
<span id="cb32-480"><a href="#cb32-480" aria-hidden="true" tabindex="-1"></a><span class="in">    if(d &lt; 0.3) {</span></span>
<span id="cb32-481"><a href="#cb32-481" aria-hidden="true" tabindex="-1"></a><span class="in">        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));</span></span>
<span id="cb32-482"><a href="#cb32-482" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-483"><a href="#cb32-483" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-484"><a href="#cb32-484" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-485"><a href="#cb32-485" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-486"><a href="#cb32-486" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-487"><a href="#cb32-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-488"><a href="#cb32-488" aria-hidden="true" tabindex="-1"></a>This looks identical to our earlier version, but now our code is flexible. The beauty: **changing from a square to a triangle only requires changing the half-space definitions!**</span>
<span id="cb32-489"><a href="#cb32-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-490"><a href="#cb32-490" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-491"><a href="#cb32-491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-492"><a href="#cb32-492" aria-hidden="true" tabindex="-1"></a><span class="fu">### Triangle Tiling</span></span>
<span id="cb32-493"><a href="#cb32-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-494"><a href="#cb32-494" aria-hidden="true" tabindex="-1"></a>Now we're ready for triangles. We'll use an equilateral triangle with vertices at:</span>
<span id="cb32-495"><a href="#cb32-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-496"><a href="#cb32-496" aria-hidden="true" tabindex="-1"></a>$$v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)$$</span>
<span id="cb32-497"><a href="#cb32-497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-498"><a href="#cb32-498" aria-hidden="true" tabindex="-1"></a>This triangle is centered at the origin with one vertex pointing up.</span>
<span id="cb32-499"><a href="#cb32-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-500"><a href="#cb32-500" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Computing Half-Spaces from Edges</span></span>
<span id="cb32-501"><a href="#cb32-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-502"><a href="#cb32-502" aria-hidden="true" tabindex="-1"></a>For each edge, we need to compute the line parameters $(a, b, c)$ and determine the correct side. The process:</span>
<span id="cb32-503"><a href="#cb32-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-504"><a href="#cb32-504" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Take two vertices defining an edge: $\mathbf{v}_i$ and $\mathbf{v}_j$</span>
<span id="cb32-505"><a href="#cb32-505" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Compute edge direction: $\mathbf{d} = \mathbf{v}_j - \mathbf{v}_i$</span>
<span id="cb32-506"><a href="#cb32-506" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Compute perpendicular (rotate 90° counterclockwise): $\mathbf{n} = (-d_y, d_x)$</span>
<span id="cb32-507"><a href="#cb32-507" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Line equation: $n_x \cdot x + n_y \cdot y = c$ where $c = \mathbf{n} \cdot \mathbf{v}_i$</span>
<span id="cb32-508"><a href="#cb32-508" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Test origin: if $(n_x \cdot 0 + n_y \cdot 0 - c) &lt; 0$, then <span class="in">`side = -1.0`</span>, else <span class="in">`side = 1.0`</span></span>
<span id="cb32-509"><a href="#cb32-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-510"><a href="#cb32-510" aria-hidden="true" tabindex="-1"></a>::: {.callout-note collapse="true"}</span>
<span id="cb32-511"><a href="#cb32-511" aria-hidden="true" tabindex="-1"></a><span class="fu">## Derivation of Triangle Half-Space Parameters</span></span>
<span id="cb32-512"><a href="#cb32-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-513"><a href="#cb32-513" aria-hidden="true" tabindex="-1"></a>**Edge from $v_0 = (0, 1)$ to $v_1 = (-\sqrt{3}/2, -1/2)$:**</span>
<span id="cb32-514"><a href="#cb32-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-515"><a href="#cb32-515" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Edge direction: $\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)$</span>
<span id="cb32-516"><a href="#cb32-516" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Perpendicular (90° CCW): $\mathbf{n} = (1.5, -0.866)$</span>
<span id="cb32-517"><a href="#cb32-517" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Line: $1.5x - 0.866y = c$ where $c = \mathbf{n} \cdot v_0 = (1.5)(0) + (-0.866)(1) = -0.866$</span>
<span id="cb32-518"><a href="#cb32-518" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>For origin (inside): $1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0$</span>
<span id="cb32-519"><a href="#cb32-519" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>We want inside when $(ax + by - c) &lt; 0$, so we need <span class="in">`side = -1.0`</span></span>
<span id="cb32-520"><a href="#cb32-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-521"><a href="#cb32-521" aria-hidden="true" tabindex="-1"></a>**Result:** <span class="in">`HalfSpace(1.5, -0.866, -0.866, -1.0)`</span></span>
<span id="cb32-522"><a href="#cb32-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-523"><a href="#cb32-523" aria-hidden="true" tabindex="-1"></a>Similar calculations give:</span>
<span id="cb32-524"><a href="#cb32-524" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Edge $v_1$ to $v_2$:** <span class="in">`HalfSpace(0.0, 1.732, -0.866, -1.0)`</span></span>
<span id="cb32-525"><a href="#cb32-525" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Edge $v_2$ to $v_0$:** <span class="in">`HalfSpace(-1.5, -0.866, -0.866, -1.0)`</span></span>
<span id="cb32-526"><a href="#cb32-526" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-527"><a href="#cb32-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-528"><a href="#cb32-528" aria-hidden="true" tabindex="-1"></a>The computed parameters are:</span>
<span id="cb32-529"><a href="#cb32-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-530"><a href="#cb32-530" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Edge $v_0$ to $v_1$:** <span class="in">`HalfSpace(1.5, -0.866, -0.866, -1.0)`</span></span>
<span id="cb32-531"><a href="#cb32-531" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Edge $v_1$ to $v_2$:** <span class="in">`HalfSpace(0.0, 1.732, -0.866, -1.0)`</span>  </span>
<span id="cb32-532"><a href="#cb32-532" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Edge $v_2$ to $v_0$:** <span class="in">`HalfSpace(-1.5, -0.866, -0.866, -1.0)`</span></span>
<span id="cb32-533"><a href="#cb32-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-534"><a href="#cb32-534" aria-hidden="true" tabindex="-1"></a>We already verified these work with our visualization shader above!</span>
<span id="cb32-535"><a href="#cb32-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-536"><a href="#cb32-536" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Triangle Tiling Shader</span></span>
<span id="cb32-537"><a href="#cb32-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-538"><a href="#cb32-538" aria-hidden="true" tabindex="-1"></a>Now we can implement the tiling by copying our reflection shader and just changing the half-spaces:</span>
<span id="cb32-539"><a href="#cb32-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-540"><a href="#cb32-540" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-541"><a href="#cb32-541" aria-hidden="true" tabindex="-1"></a><span class="in">struct HalfSpace {</span></span>
<span id="cb32-542"><a href="#cb32-542" aria-hidden="true" tabindex="-1"></a><span class="in">    float a, b, c;</span></span>
<span id="cb32-543"><a href="#cb32-543" aria-hidden="true" tabindex="-1"></a><span class="in">    float side;</span></span>
<span id="cb32-544"><a href="#cb32-544" aria-hidden="true" tabindex="-1"></a><span class="in">};</span></span>
<span id="cb32-545"><a href="#cb32-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-546"><a href="#cb32-546" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectInto(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-547"><a href="#cb32-547" aria-hidden="true" tabindex="-1"></a><span class="in">    float value = hs.a * p.x + hs.b * p.y;</span></span>
<span id="cb32-548"><a href="#cb32-548" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-549"><a href="#cb32-549" aria-hidden="true" tabindex="-1"></a><span class="in">    if((value - hs.c) * hs.side &lt; 0.0) {</span></span>
<span id="cb32-550"><a href="#cb32-550" aria-hidden="true" tabindex="-1"></a><span class="in">        return p;</span></span>
<span id="cb32-551"><a href="#cb32-551" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-552"><a href="#cb32-552" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-553"><a href="#cb32-553" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 normal = vec2(hs.a, hs.b);</span></span>
<span id="cb32-554"><a href="#cb32-554" aria-hidden="true" tabindex="-1"></a><span class="in">    float norm = length(normal);</span></span>
<span id="cb32-555"><a href="#cb32-555" aria-hidden="true" tabindex="-1"></a><span class="in">    normal = normal / norm;</span></span>
<span id="cb32-556"><a href="#cb32-556" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-557"><a href="#cb32-557" aria-hidden="true" tabindex="-1"></a><span class="in">    float signedDist = (value - hs.c) / norm;</span></span>
<span id="cb32-558"><a href="#cb32-558" aria-hidden="true" tabindex="-1"></a><span class="in">    return p - 2.0 * signedDist * normal;</span></span>
<span id="cb32-559"><a href="#cb32-559" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-560"><a href="#cb32-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-561"><a href="#cb32-561" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-562"><a href="#cb32-562" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-563"><a href="#cb32-563" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-564"><a href="#cb32-564" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-565"><a href="#cb32-565" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-566"><a href="#cb32-566" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-567"><a href="#cb32-567" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv;</span></span>
<span id="cb32-568"><a href="#cb32-568" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-569"><a href="#cb32-569" aria-hidden="true" tabindex="-1"></a><span class="in">    // Define the three half-spaces for equilateral triangle</span></span>
<span id="cb32-570"><a href="#cb32-570" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);</span></span>
<span id="cb32-571"><a href="#cb32-571" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);</span></span>
<span id="cb32-572"><a href="#cb32-572" aria-hidden="true" tabindex="-1"></a><span class="in">    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);</span></span>
<span id="cb32-573"><a href="#cb32-573" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-574"><a href="#cb32-574" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the triangle</span></span>
<span id="cb32-575"><a href="#cb32-575" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb32-576"><a href="#cb32-576" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 20; i++) {</span></span>
<span id="cb32-577"><a href="#cb32-577" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 p_old = p;</span></span>
<span id="cb32-578"><a href="#cb32-578" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-579"><a href="#cb32-579" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, hs1);</span></span>
<span id="cb32-580"><a href="#cb32-580" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, hs2);</span></span>
<span id="cb32-581"><a href="#cb32-581" aria-hidden="true" tabindex="-1"></a><span class="in">        p = reflectInto(p, hs3);</span></span>
<span id="cb32-582"><a href="#cb32-582" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-583"><a href="#cb32-583" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(p - p_old) &lt; 0.0001) break;</span></span>
<span id="cb32-584"><a href="#cb32-584" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb32-585"><a href="#cb32-585" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-586"><a href="#cb32-586" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-587"><a href="#cb32-587" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color by fold count parity</span></span>
<span id="cb32-588"><a href="#cb32-588" aria-hidden="true" tabindex="-1"></a><span class="in">    float parity = mod(float(foldCount), 2.0);</span></span>
<span id="cb32-589"><a href="#cb32-589" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color;</span></span>
<span id="cb32-590"><a href="#cb32-590" aria-hidden="true" tabindex="-1"></a><span class="in">    if(parity &lt; 0.5) {</span></span>
<span id="cb32-591"><a href="#cb32-591" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.7, 0.8, 0.9);  // Light blue</span></span>
<span id="cb32-592"><a href="#cb32-592" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb32-593"><a href="#cb32-593" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.5, 0.6, 0.8);  // Darker blue</span></span>
<span id="cb32-594"><a href="#cb32-594" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-595"><a href="#cb32-595" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-596"><a href="#cb32-596" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-597"><a href="#cb32-597" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-598"><a href="#cb32-598" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-599"><a href="#cb32-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-600"><a href="#cb32-600" aria-hidden="true" tabindex="-1"></a>Beautiful! You should see an infinite triangle tiling. The alternating colors show which triangles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</span>
<span id="cb32-601"><a href="#cb32-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-602"><a href="#cb32-602" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb32-603"><a href="#cb32-603" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercise: Visualizing Triangle Structure</span></span>
<span id="cb32-604"><a href="#cb32-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-605"><a href="#cb32-605" aria-hidden="true" tabindex="-1"></a>Want to see the edges and vertices of your triangles? This requires computing distances to half-spaces and vertices.</span>
<span id="cb32-606"><a href="#cb32-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-607"><a href="#cb32-607" aria-hidden="true" tabindex="-1"></a>**For edges** (drawing the boundaries):</span>
<span id="cb32-608"><a href="#cb32-608" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-609"><a href="#cb32-609" aria-hidden="true" tabindex="-1"></a><span class="in">float distToHalfSpace(vec2 p, HalfSpace hs) {</span></span>
<span id="cb32-610"><a href="#cb32-610" aria-hidden="true" tabindex="-1"></a><span class="in">    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));</span></span>
<span id="cb32-611"><a href="#cb32-611" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-612"><a href="#cb32-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-613"><a href="#cb32-613" aria-hidden="true" tabindex="-1"></a><span class="in">// In main rendering:</span></span>
<span id="cb32-614"><a href="#cb32-614" aria-hidden="true" tabindex="-1"></a><span class="in">float d1 = distToHalfSpace(p, hs1);</span></span>
<span id="cb32-615"><a href="#cb32-615" aria-hidden="true" tabindex="-1"></a><span class="in">float d2 = distToHalfSpace(p, hs2);</span></span>
<span id="cb32-616"><a href="#cb32-616" aria-hidden="true" tabindex="-1"></a><span class="in">float d3 = distToHalfSpace(p, hs3);</span></span>
<span id="cb32-617"><a href="#cb32-617" aria-hidden="true" tabindex="-1"></a><span class="in">float border = min(d1, min(d2, d3));</span></span>
<span id="cb32-618"><a href="#cb32-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-619"><a href="#cb32-619" aria-hidden="true" tabindex="-1"></a><span class="in">if(border &lt; 0.02) color = vec3(1.0);  // White edges</span></span>
<span id="cb32-620"><a href="#cb32-620" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-621"><a href="#cb32-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-622"><a href="#cb32-622" aria-hidden="true" tabindex="-1"></a>**For vertices** (marking the corners):</span>
<span id="cb32-623"><a href="#cb32-623" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-624"><a href="#cb32-624" aria-hidden="true" tabindex="-1"></a><span class="in">// Define vertices</span></span>
<span id="cb32-625"><a href="#cb32-625" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v0 = vec2(0.0, 1.0);</span></span>
<span id="cb32-626"><a href="#cb32-626" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v1 = vec2(-0.866, -0.5);</span></span>
<span id="cb32-627"><a href="#cb32-627" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v2 = vec2(0.866, -0.5);</span></span>
<span id="cb32-628"><a href="#cb32-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-629"><a href="#cb32-629" aria-hidden="true" tabindex="-1"></a><span class="in">// Check distance after folding</span></span>
<span id="cb32-630"><a href="#cb32-630" aria-hidden="true" tabindex="-1"></a><span class="in">float dv0 = length(p - v0);</span></span>
<span id="cb32-631"><a href="#cb32-631" aria-hidden="true" tabindex="-1"></a><span class="in">float dv1 = length(p - v1);</span></span>
<span id="cb32-632"><a href="#cb32-632" aria-hidden="true" tabindex="-1"></a><span class="in">float dv2 = length(p - v2);</span></span>
<span id="cb32-633"><a href="#cb32-633" aria-hidden="true" tabindex="-1"></a><span class="in">float vertex_dist = min(dv0, min(dv1, dv2));</span></span>
<span id="cb32-634"><a href="#cb32-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-635"><a href="#cb32-635" aria-hidden="true" tabindex="-1"></a><span class="in">if(vertex_dist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);  // Red vertices</span></span>
<span id="cb32-636"><a href="#cb32-636" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-637"><a href="#cb32-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-638"><a href="#cb32-638" aria-hidden="true" tabindex="-1"></a>See Appendix E9 for the complete enhanced version!</span>
<span id="cb32-639"><a href="#cb32-639" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-640"><a href="#cb32-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-641"><a href="#cb32-641" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-642"><a href="#cb32-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-643"><a href="#cb32-643" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why Does This Algorithm Work? Reflection Groups</span></span>
<span id="cb32-644"><a href="#cb32-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-645"><a href="#cb32-645" aria-hidden="true" tabindex="-1"></a>We've implemented the folding algorithm, but *why* does it work? Why does iteratively reflecting guarantee we reach the fundamental domain? The answer lies in **group theory**.</span>
<span id="cb32-646"><a href="#cb32-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-647"><a href="#cb32-647" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Reflections Generate a Group</span></span>
<span id="cb32-648"><a href="#cb32-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-649"><a href="#cb32-649" aria-hidden="true" tabindex="-1"></a>Each reflection $r_i$ across a half-space boundary is an **isometry** of the Euclidean plane—it preserves distances and angles. Composing reflections gives us more isometries. The set of all compositions of our reflections forms a **group** under composition:</span>
<span id="cb32-650"><a href="#cb32-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-651"><a href="#cb32-651" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Identity**: Reflecting twice across the same line returns to the original point ($r_i \circ r_i = \text{id}$)</span>
<span id="cb32-652"><a href="#cb32-652" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Closure**: Composing reflections gives another isometry (which might be a reflection, rotation, or glide reflection)</span>
<span id="cb32-653"><a href="#cb32-653" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Inverses**: Every isometry has an inverse (just reflect again)</span>
<span id="cb32-654"><a href="#cb32-654" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Associativity**: Composition is associative</span>
<span id="cb32-655"><a href="#cb32-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-656"><a href="#cb32-656" aria-hidden="true" tabindex="-1"></a>This group, generated by reflections across the boundaries of our fundamental domain, is called a **reflection group** or **Coxeter group**.</span>
<span id="cb32-657"><a href="#cb32-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-658"><a href="#cb32-658" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Fundamental Domain and Orbit</span></span>
<span id="cb32-659"><a href="#cb32-659" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-660"><a href="#cb32-660" aria-hidden="true" tabindex="-1"></a>Our fundamental domain $F$ (the square $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>^2$ or triangle) is a **fundamental domain** for the group action. This means:</span>
<span id="cb32-661"><a href="#cb32-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-662"><a href="#cb32-662" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Every point in the plane is equivalent to exactly one point in $F$ (modulo boundary points)</span>
<span id="cb32-663"><a href="#cb32-663" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The **orbit** of $F$ under the group (all images $g(F)$ for $g$ in the group) tiles the entire plane</span>
<span id="cb32-664"><a href="#cb32-664" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Different tiles $g(F)$ and $h(F)$ only overlap on their boundaries</span>
<span id="cb32-665"><a href="#cb32-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-666"><a href="#cb32-666" aria-hidden="true" tabindex="-1"></a>When we start with a point $p$ outside $F$, there exists a sequence of group elements (reflections) that maps $p$ into $F$. Our algorithm finds this sequence!</span>
<span id="cb32-667"><a href="#cb32-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-668"><a href="#cb32-668" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Why the Algorithm Terminates</span></span>
<span id="cb32-669"><a href="#cb32-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-670"><a href="#cb32-670" aria-hidden="true" tabindex="-1"></a>Here's the key insight: each reflection across a boundary of $F$ either:</span>
<span id="cb32-671"><a href="#cb32-671" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Keeps the point inside $F$ (if it's already on the correct side)</span>
<span id="cb32-672"><a href="#cb32-672" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Moves the point strictly closer to $F$ (if it's on the wrong side)</span>
<span id="cb32-673"><a href="#cb32-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-674"><a href="#cb32-674" aria-hidden="true" tabindex="-1"></a>"Closer" here means we reduce some discrete measure—like the number of boundaries we're on the wrong side of. Since this number is finite and decreases with each reflection, the algorithm must terminate.</span>
<span id="cb32-675"><a href="#cb32-675" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-676"><a href="#cb32-676" aria-hidden="true" tabindex="-1"></a>Formally, we can define a **height function** $h(p)$ that counts how many half-space boundaries $p$ violates. Initially $h(p) \geq 0$. Each reflection that actually moves the point decreases $h(p)$ by at least 1. When $h(p) = 0$, the point is inside $F$ and the algorithm stops.</span>
<span id="cb32-677"><a href="#cb32-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-678"><a href="#cb32-678" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb32-679"><a href="#cb32-679" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Pattern Across Days</span></span>
<span id="cb32-680"><a href="#cb32-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-681"><a href="#cb32-681" aria-hidden="true" tabindex="-1"></a>This is the same fundamental principle we've seen throughout:</span>
<span id="cb32-682"><a href="#cb32-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-683"><a href="#cb32-683" aria-hidden="true" tabindex="-1"></a>**Day 2 (Apollonian gasket):**</span>
<span id="cb32-684"><a href="#cb32-684" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Group: Iterated circle inversions</span>
<span id="cb32-685"><a href="#cb32-685" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Fundamental domain: The gaps between circles</span>
<span id="cb32-686"><a href="#cb32-686" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Algorithm: Invert until inside the domain</span>
<span id="cb32-687"><a href="#cb32-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-688"><a href="#cb32-688" aria-hidden="true" tabindex="-1"></a>**Day 3 (Euclidean tilings):**</span>
<span id="cb32-689"><a href="#cb32-689" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Group: Reflections across boundaries</span>
<span id="cb32-690"><a href="#cb32-690" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Fundamental domain: The square/triangle</span>
<span id="cb32-691"><a href="#cb32-691" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Algorithm: Reflect until inside the domain</span>
<span id="cb32-692"><a href="#cb32-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-693"><a href="#cb32-693" aria-hidden="true" tabindex="-1"></a>**Day 3 (Hyperbolic, coming soon):**</span>
<span id="cb32-694"><a href="#cb32-694" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Group: Hyperbolic reflections (same structure!)</span>
<span id="cb32-695"><a href="#cb32-695" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Fundamental domain: Hyperbolic triangle</span>
<span id="cb32-696"><a href="#cb32-696" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Algorithm: Reflect until inside the domain (identical code!)</span>
<span id="cb32-697"><a href="#cb32-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-698"><a href="#cb32-698" aria-hidden="true" tabindex="-1"></a>The unifying theme is **group actions and fundamental domains**. We're always finding the unique representative of an orbit that lies in the fundamental domain.</span>
<span id="cb32-699"><a href="#cb32-699" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-700"><a href="#cb32-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-701"><a href="#cb32-701" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Computational Implications</span></span>
<span id="cb32-702"><a href="#cb32-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-703"><a href="#cb32-703" aria-hidden="true" tabindex="-1"></a>Understanding the group theory gives us insight into the computation:</span>
<span id="cb32-704"><a href="#cb32-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-705"><a href="#cb32-705" aria-hidden="true" tabindex="-1"></a>**Convergence rate**: For a viewport of size $V$ and fundamental domain of size $F$, we need at most $O(\log(V/F))$ reflections per coordinate axis. This is why small iteration limits (20-30) work well.</span>
<span id="cb32-706"><a href="#cb32-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-707"><a href="#cb32-707" aria-hidden="true" tabindex="-1"></a>**Parallelism**: Each pixel's orbit is independent—perfect for GPU parallelism. Millions of pixels computing orbits simultaneously with no communication needed.</span>
<span id="cb32-708"><a href="#cb32-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-709"><a href="#cb32-709" aria-hidden="true" tabindex="-1"></a>**Threshold choice**: The <span class="in">`0.0001`</span> threshold for detecting convergence balances precision and performance. Smaller thresholds catch more subtle movements but risk floating-point noise; larger thresholds might terminate early but rarely matter for visualization.</span>
<span id="cb32-710"><a href="#cb32-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-711"><a href="#cb32-711" aria-hidden="true" tabindex="-1"></a>**Why it's efficient**: Most tiles are "nearby" in the group—they're reached by short sequences of reflections. Only tiles far from the origin require many reflections, and these appear very small on screen (contributing few pixels).</span>
<span id="cb32-712"><a href="#cb32-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-713"><a href="#cb32-713" aria-hidden="true" tabindex="-1"></a>This completes our Euclidean foundation. We now understand:</span>
<span id="cb32-714"><a href="#cb32-714" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>The folding algorithm in concrete examples</span>
<span id="cb32-715"><a href="#cb32-715" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>The half-space abstraction that makes it general</span>
<span id="cb32-716"><a href="#cb32-716" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Why it works**: reflection groups and fundamental domains</span>
<span id="cb32-717"><a href="#cb32-717" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Computational properties: convergence, parallelism, efficiency</span>
<span id="cb32-718"><a href="#cb32-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-719"><a href="#cb32-719" aria-hidden="true" tabindex="-1"></a>Next, we'll take this exact algorithmic structure into hyperbolic geometry!</span>
<span id="cb32-720"><a href="#cb32-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-721"><a href="#cb32-721" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-722"><a href="#cb32-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-723"><a href="#cb32-723" aria-hidden="true" tabindex="-1"></a><span class="fu">## Part 2: Hyperbolic Geometry</span></span>
<span id="cb32-724"><a href="#cb32-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-725"><a href="#cb32-725" aria-hidden="true" tabindex="-1"></a><span class="fu">### Introduction to Hyperbolic Geometry</span></span>
<span id="cb32-726"><a href="#cb32-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-727"><a href="#cb32-727" aria-hidden="true" tabindex="-1"></a>Hyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant **negative curvature**. For over two millennia, mathematicians believed Euclidean geometry was the only logically consistent geometry—Euclid's parallel postulate seemed necessary. The discovery of hyperbolic geometry in the early 19th century revolutionized mathematics.</span>
<span id="cb32-728"><a href="#cb32-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-729"><a href="#cb32-729" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Historical Context: The Discovery</span></span>
<span id="cb32-730"><a href="#cb32-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-731"><a href="#cb32-731" aria-hidden="true" tabindex="-1"></a>The story of hyperbolic geometry is one of the great dramas in mathematical history. For centuries, mathematicians tried to prove Euclid's fifth postulate (the parallel postulate) from the other four axioms. What if you could have multiple parallel lines through a point?</span>
<span id="cb32-732"><a href="#cb32-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-733"><a href="#cb32-733" aria-hidden="true" tabindex="-1"></a>Three mathematicians independently discovered that this "impossible" geometry was actually perfectly consistent:</span>
<span id="cb32-734"><a href="#cb32-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-735"><a href="#cb32-735" aria-hidden="true" tabindex="-1"></a>**János Bolyai** (1802-1860), a Hungarian mathematician, developed hyperbolic geometry in the 1820s. His father, a mathematician himself, warned him: "For God's sake, I beseech you, give it up. Fear it no less than sensual passions because it too may take all your time and deprive you of your health, peace of mind and happiness in life." But János persisted, publishing his work in 1832 as an appendix to his father's book.</span>
<span id="cb32-736"><a href="#cb32-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-737"><a href="#cb32-737" aria-hidden="true" tabindex="-1"></a>**Nikolai Lobachevsky** (1792-1856), a Russian mathematician, published the first account of hyperbolic geometry in 1829. He called it "imaginary geometry" and faced considerable resistance from the mathematical establishment. His work was largely ignored during his lifetime.</span>
<span id="cb32-738"><a href="#cb32-738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-739"><a href="#cb32-739" aria-hidden="true" tabindex="-1"></a>**Carl Friedrich Gauss** (1777-1855), the "Prince of Mathematicians," had discovered hyperbolic geometry even earlier but never published it. In his private correspondence, he revealed he'd been working on non-Euclidean geometry since the 1790s but feared the "clamor of the Boeotians" (his term for mathematical philistines). When he read Bolyai's work in 1832, he wrote that he could not praise it "because to praise it would be to praise myself"—he'd discovered the same results years earlier but kept them private.</span>
<span id="cb32-740"><a href="#cb32-740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-741"><a href="#cb32-741" aria-hidden="true" tabindex="-1"></a>The discovery had profound implications: geometry was not a single truth about space but a family of possible consistent systems. This philosophical shift influenced everything from Einstein's general relativity (which uses non-Euclidean geometry for curved spacetime) to modern physics and mathematics.</span>
<span id="cb32-742"><a href="#cb32-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-743"><a href="#cb32-743" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Modern Applications</span></span>
<span id="cb32-744"><a href="#cb32-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-745"><a href="#cb32-745" aria-hidden="true" tabindex="-1"></a>Hyperbolic geometry appears throughout modern mathematics and physics:</span>
<span id="cb32-746"><a href="#cb32-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-747"><a href="#cb32-747" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Complex analysis**: The upper half-plane model is fundamental to the theory of modular forms, elliptic curves, and the Riemann mapping theorem</span>
<span id="cb32-748"><a href="#cb32-748" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Number theory**: The action of $SL(2,\mathbb{Z})$ on $\mathbb{H}^2$ produces modular forms—functions crucial to the proof of Fermat's Last Theorem</span>
<span id="cb32-749"><a href="#cb32-749" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Topology**: The study of 3-manifolds and knot theory often requires understanding hyperbolic structures</span>
<span id="cb32-750"><a href="#cb32-750" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Teichmüller theory**: Moduli spaces of Riemann surfaces have natural hyperbolic metrics</span>
<span id="cb32-751"><a href="#cb32-751" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Kleinian groups**: Discrete subgroups of hyperbolic isometries produce fractal limit sets (like we saw with the Apollonian gasket!)</span>
<span id="cb32-752"><a href="#cb32-752" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**General relativity**: Anti-de Sitter space has constant negative curvature—hyperbolic geometry in spacetime</span>
<span id="cb32-753"><a href="#cb32-753" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Machine learning**: Recent work uses hyperbolic embeddings to represent hierarchical data efficiently</span>
<span id="cb32-754"><a href="#cb32-754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-755"><a href="#cb32-755" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Key Properties</span></span>
<span id="cb32-756"><a href="#cb32-756" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-757"><a href="#cb32-757" aria-hidden="true" tabindex="-1"></a>What makes hyperbolic geometry different from Euclidean geometry?</span>
<span id="cb32-758"><a href="#cb32-758" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-759"><a href="#cb32-759" aria-hidden="true" tabindex="-1"></a>**Parallel lines**: Given a line and a point not on it, there are **infinitely many** lines through the point that don't intersect the given line (all parallel to it). This is the defining feature that distinguishes hyperbolic geometry.</span>
<span id="cb32-760"><a href="#cb32-760" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-761"><a href="#cb32-761" aria-hidden="true" tabindex="-1"></a>**Triangle angles**: The sum of angles in a triangle is **less than** $\pi$. In fact, the **area** of a hyperbolic triangle with angles $\alpha$, $\beta$, $\gamma$ is exactly:</span>
<span id="cb32-762"><a href="#cb32-762" aria-hidden="true" tabindex="-1"></a>$$\text{Area} = \pi - (\alpha + \beta + \gamma)$$</span>
<span id="cb32-763"><a href="#cb32-763" aria-hidden="true" tabindex="-1"></a>This is the **Gauss-Bonnet theorem** for hyperbolic triangles—a beautiful connection between geometry (angles) and topology (area).</span>
<span id="cb32-764"><a href="#cb32-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-765"><a href="#cb32-765" aria-hidden="true" tabindex="-1"></a>**Exponential growth**: In Euclidean geometry, the circumference of a circle grows linearly with radius ($C = 2\pi r$). In hyperbolic geometry, it grows **exponentially**: $C \sim e^r$ for large $r$. This means hyperbolic space has "more room" than Euclidean space—there's exponentially more area at distance $r$ from a point.</span>
<span id="cb32-766"><a href="#cb32-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-767"><a href="#cb32-767" aria-hidden="true" tabindex="-1"></a>**No similarity**: In Euclidean geometry, you can scale any shape—a small triangle and a large triangle with the same angles are similar. In hyperbolic geometry, there's an absolute unit of length built into the curvature. All triangles with angles $(\pi/2, \pi/3, \pi/7)$ are congruent—there's no "scaled version." This makes hyperbolic geometry richer but more rigid.</span>
<span id="cb32-768"><a href="#cb32-768" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-769"><a href="#cb32-769" aria-hidden="true" tabindex="-1"></a>These properties create the "extra room" that allows much richer tiling structures than Euclidean geometry.</span>
<span id="cb32-770"><a href="#cb32-770" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-771"><a href="#cb32-771" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-772"><a href="#cb32-772" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-773"><a href="#cb32-773" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Upper Half-Plane Model</span></span>
<span id="cb32-774"><a href="#cb32-774" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-775"><a href="#cb32-775" aria-hidden="true" tabindex="-1"></a>We'll work in the **upper half-plane model** of hyperbolic geometry, denoted $\mathbb{H}^2$:</span>
<span id="cb32-776"><a href="#cb32-776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-777"><a href="#cb32-777" aria-hidden="true" tabindex="-1"></a>$$\mathbb{H}^2 = <span class="sc">\{</span>z = x + iy \in \mathbb{C} : y &gt; 0<span class="sc">\}</span>$$</span>
<span id="cb32-778"><a href="#cb32-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-779"><a href="#cb32-779" aria-hidden="true" tabindex="-1"></a>This is just complex numbers with positive imaginary part—the upper half of the complex plane. The **real axis** $<span class="sc">\{</span>y = 0<span class="sc">\}</span>$ forms the boundary "at infinity"—it's not actually part of $\mathbb{H}^2$, but represents points infinitely far away in hyperbolic distance.</span>
<span id="cb32-780"><a href="#cb32-780" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-781"><a href="#cb32-781" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Hyperbolic Metric</span></span>
<span id="cb32-782"><a href="#cb32-782" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-783"><a href="#cb32-783" aria-hidden="true" tabindex="-1"></a>The **hyperbolic metric** is what makes $\mathbb{H}^2$ a hyperbolic space:</span>
<span id="cb32-784"><a href="#cb32-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-785"><a href="#cb32-785" aria-hidden="true" tabindex="-1"></a>$$ds^2 = \frac{dx^2 + dy^2}{y^2}$$</span>
<span id="cb32-786"><a href="#cb32-786" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-787"><a href="#cb32-787" aria-hidden="true" tabindex="-1"></a>This gives $\mathbb{H}^2$ the structure of a complete Riemannian manifold with constant curvature $-1$.</span>
<span id="cb32-788"><a href="#cb32-788" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-789"><a href="#cb32-789" aria-hidden="true" tabindex="-1"></a>**What does this mean?** The factor $1/y^2$ is a **conformal factor** that scales the Euclidean metric. As $y \to 0$ (approaching the boundary), this scaling factor blows up—distances that look small Euclidean-wise are enormous hyperbolically. As $y \to \infty$ (going "up" in the upper half-plane), the scaling factor goes to zero—large Euclidean distances are actually finite hyperbolically.</span>
<span id="cb32-790"><a href="#cb32-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-791"><a href="#cb32-791" aria-hidden="true" tabindex="-1"></a>The metric is **conformal** to the Euclidean metric—it preserves angles but not lengths. If two curves meet at angle $\theta$ in the Euclidean sense, they also meet at angle $\theta$ in the hyperbolic sense! This is why you can trust your eyes when looking at pictures—angles are what they appear to be.</span>
<span id="cb32-792"><a href="#cb32-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-793"><a href="#cb32-793" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Distance Formula</span></span>
<span id="cb32-794"><a href="#cb32-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-795"><a href="#cb32-795" aria-hidden="true" tabindex="-1"></a>Integrating the metric along paths gives the **hyperbolic distance** between two points $z_1 = x_1 + iy_1$ and $z_2 = x_2 + iy_2$:</span>
<span id="cb32-796"><a href="#cb32-796" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-797"><a href="#cb32-797" aria-hidden="true" tabindex="-1"></a>$$d_{\mathbb{H}^2}(z_1, z_2) = \text{arcosh}\left(1 + \frac{|z_1 - z_2|^2}{2y_1 y_2}\right)$$</span>
<span id="cb32-798"><a href="#cb32-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-799"><a href="#cb32-799" aria-hidden="true" tabindex="-1"></a>where $|z_1 - z_2| = \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$ is the usual Euclidean distance.</span>
<span id="cb32-800"><a href="#cb32-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-801"><a href="#cb32-801" aria-hidden="true" tabindex="-1"></a>Notice the $1/y_1 y_2$ factor—points near the boundary ($y$ small) are very far apart hyperbolically even if they're close Euclidean-wise.</span>
<span id="cb32-802"><a href="#cb32-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-803"><a href="#cb32-803" aria-hidden="true" tabindex="-1"></a>**Derivation sketch**: For a vertical line from $z_1 = x + iy_1$ to $z_2 = x + iy_2$, the hyperbolic length is:</span>
<span id="cb32-804"><a href="#cb32-804" aria-hidden="true" tabindex="-1"></a>$$\int_{y_1}^{y_2} \frac{dy}{y} = \log(y_2) - \log(y_1) = \log(y_2/y_1)$$</span>
<span id="cb32-805"><a href="#cb32-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-806"><a href="#cb32-806" aria-hidden="true" tabindex="-1"></a>For a general path, you need to integrate along the geodesic connecting the points (which might not be a straight Euclidean line), giving the arcosh formula above.</span>
<span id="cb32-807"><a href="#cb32-807" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-808"><a href="#cb32-808" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Visualizing Hyperbolic Distance</span></span>
<span id="cb32-809"><a href="#cb32-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-810"><a href="#cb32-810" aria-hidden="true" tabindex="-1"></a>Let's make this concrete with an interactive shader. We'll start with Euclidean distance, then switch to hyperbolic to see the difference.</span>
<span id="cb32-811"><a href="#cb32-811" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-812"><a href="#cb32-812" aria-hidden="true" tabindex="-1"></a>**Euclidean distance circles:**</span>
<span id="cb32-813"><a href="#cb32-813" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-814"><a href="#cb32-814" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-815"><a href="#cb32-815" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-816"><a href="#cb32-816" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-817"><a href="#cb32-817" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-818"><a href="#cb32-818" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-819"><a href="#cb32-819" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-820"><a href="#cb32-820" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-821"><a href="#cb32-821" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv + vec2(0.0, 1.5);  // Shift up so we're in y &gt; 0</span></span>
<span id="cb32-822"><a href="#cb32-822" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-823"><a href="#cb32-823" aria-hidden="true" tabindex="-1"></a><span class="in">    // Mouse position as center (or default)</span></span>
<span id="cb32-824"><a href="#cb32-824" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 mouse = iMouse.xy / iResolution.xy;</span></span>
<span id="cb32-825"><a href="#cb32-825" aria-hidden="true" tabindex="-1"></a><span class="in">    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);  // Default if no click</span></span>
<span id="cb32-826"><a href="#cb32-826" aria-hidden="true" tabindex="-1"></a><span class="in">    mouse = (mouse - 0.5) * 4.0;</span></span>
<span id="cb32-827"><a href="#cb32-827" aria-hidden="true" tabindex="-1"></a><span class="in">    mouse.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-828"><a href="#cb32-828" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 center = mouse + vec2(0.0, 1.5);</span></span>
<span id="cb32-829"><a href="#cb32-829" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-830"><a href="#cb32-830" aria-hidden="true" tabindex="-1"></a><span class="in">    // Euclidean distance</span></span>
<span id="cb32-831"><a href="#cb32-831" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist = length(p - center);</span></span>
<span id="cb32-832"><a href="#cb32-832" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-833"><a href="#cb32-833" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw a disk of radius 0.5 using two circles</span></span>
<span id="cb32-834"><a href="#cb32-834" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius = 0.5;</span></span>
<span id="cb32-835"><a href="#cb32-835" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.1, 0.1, 0.2);  // Background</span></span>
<span id="cb32-836"><a href="#cb32-836" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-837"><a href="#cb32-837" aria-hidden="true" tabindex="-1"></a><span class="in">    // Outer circle (slightly larger)</span></span>
<span id="cb32-838"><a href="#cb32-838" aria-hidden="true" tabindex="-1"></a><span class="in">    if(dist &lt; radius + 0.02) {</span></span>
<span id="cb32-839"><a href="#cb32-839" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 1.0, 0.3);  // Yellow ring</span></span>
<span id="cb32-840"><a href="#cb32-840" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-841"><a href="#cb32-841" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-842"><a href="#cb32-842" aria-hidden="true" tabindex="-1"></a><span class="in">    // Inner circle (slightly smaller) - "cuts out" interior</span></span>
<span id="cb32-843"><a href="#cb32-843" aria-hidden="true" tabindex="-1"></a><span class="in">    if(dist &lt; radius - 0.02) {</span></span>
<span id="cb32-844"><a href="#cb32-844" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.4, 0.6, 0.8);  // Blue interior</span></span>
<span id="cb32-845"><a href="#cb32-845" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-846"><a href="#cb32-846" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-847"><a href="#cb32-847" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw center point</span></span>
<span id="cb32-848"><a href="#cb32-848" aria-hidden="true" tabindex="-1"></a><span class="in">    if(length(p - center) &lt; 0.05) {</span></span>
<span id="cb32-849"><a href="#cb32-849" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 0.0, 0.0);</span></span>
<span id="cb32-850"><a href="#cb32-850" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-851"><a href="#cb32-851" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-852"><a href="#cb32-852" aria-hidden="true" tabindex="-1"></a><span class="in">    // Darken outside upper half-plane</span></span>
<span id="cb32-853"><a href="#cb32-853" aria-hidden="true" tabindex="-1"></a><span class="in">    if(p.y &lt; 0.0) {</span></span>
<span id="cb32-854"><a href="#cb32-854" aria-hidden="true" tabindex="-1"></a><span class="in">        color *= 0.3;</span></span>
<span id="cb32-855"><a href="#cb32-855" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-856"><a href="#cb32-856" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-857"><a href="#cb32-857" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-858"><a href="#cb32-858" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-859"><a href="#cb32-859" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-860"><a href="#cb32-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-861"><a href="#cb32-861" aria-hidden="true" tabindex="-1"></a>Click and drag around—the circle stays the same size everywhere. This is Euclidean distance: uniform across the plane. Notice how we draw the boundary: we draw a filled circle at radius $r + \epsilon$ (outer edge), then draw another filled circle at radius $r - \epsilon$ (inner edge) in a different color. The ring between them is our boundary!</span>
<span id="cb32-862"><a href="#cb32-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-863"><a href="#cb32-863" aria-hidden="true" tabindex="-1"></a>**Hyperbolic distance circles:**</span>
<span id="cb32-864"><a href="#cb32-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-865"><a href="#cb32-865" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-866"><a href="#cb32-866" aria-hidden="true" tabindex="-1"></a><span class="in">float hyperbolicDistance(vec2 z1, vec2 z2) {</span></span>
<span id="cb32-867"><a href="#cb32-867" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 diff = z1 - z2;</span></span>
<span id="cb32-868"><a href="#cb32-868" aria-hidden="true" tabindex="-1"></a><span class="in">    float diff2 = dot(diff, diff);</span></span>
<span id="cb32-869"><a href="#cb32-869" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = 2.0 * z1.y * z2.y;</span></span>
<span id="cb32-870"><a href="#cb32-870" aria-hidden="true" tabindex="-1"></a><span class="in">    float arg = 1.0 + diff2 / denom;</span></span>
<span id="cb32-871"><a href="#cb32-871" aria-hidden="true" tabindex="-1"></a><span class="in">    return log(arg + sqrt(arg * arg - 1.0));  // arccosh(arg)</span></span>
<span id="cb32-872"><a href="#cb32-872" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-873"><a href="#cb32-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-874"><a href="#cb32-874" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-875"><a href="#cb32-875" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-876"><a href="#cb32-876" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-877"><a href="#cb32-877" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-878"><a href="#cb32-878" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-879"><a href="#cb32-879" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-880"><a href="#cb32-880" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv + vec2(0.0, 1.5);</span></span>
<span id="cb32-881"><a href="#cb32-881" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-882"><a href="#cb32-882" aria-hidden="true" tabindex="-1"></a><span class="in">    // Mouse position as center</span></span>
<span id="cb32-883"><a href="#cb32-883" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 mouse = iMouse.xy / iResolution.xy;</span></span>
<span id="cb32-884"><a href="#cb32-884" aria-hidden="true" tabindex="-1"></a><span class="in">    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);</span></span>
<span id="cb32-885"><a href="#cb32-885" aria-hidden="true" tabindex="-1"></a><span class="in">    mouse = (mouse - 0.5) * 4.0;</span></span>
<span id="cb32-886"><a href="#cb32-886" aria-hidden="true" tabindex="-1"></a><span class="in">    mouse.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-887"><a href="#cb32-887" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 center = mouse + vec2(0.0, 1.5);</span></span>
<span id="cb32-888"><a href="#cb32-888" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-889"><a href="#cb32-889" aria-hidden="true" tabindex="-1"></a><span class="in">    // Hyperbolic distance</span></span>
<span id="cb32-890"><a href="#cb32-890" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist = hyperbolicDistance(p, center);</span></span>
<span id="cb32-891"><a href="#cb32-891" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-892"><a href="#cb32-892" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw a hyperbolic disk using two "circles"</span></span>
<span id="cb32-893"><a href="#cb32-893" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius = 0.5;</span></span>
<span id="cb32-894"><a href="#cb32-894" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = vec3(0.1, 0.1, 0.2);  // Background</span></span>
<span id="cb32-895"><a href="#cb32-895" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-896"><a href="#cb32-896" aria-hidden="true" tabindex="-1"></a><span class="in">    // Outer boundary</span></span>
<span id="cb32-897"><a href="#cb32-897" aria-hidden="true" tabindex="-1"></a><span class="in">    if(dist &lt; radius + 0.05) {</span></span>
<span id="cb32-898"><a href="#cb32-898" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 1.0, 0.3);  // Yellow ring</span></span>
<span id="cb32-899"><a href="#cb32-899" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-900"><a href="#cb32-900" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-901"><a href="#cb32-901" aria-hidden="true" tabindex="-1"></a><span class="in">    // Inner region</span></span>
<span id="cb32-902"><a href="#cb32-902" aria-hidden="true" tabindex="-1"></a><span class="in">    if(dist &lt; radius - 0.05) {</span></span>
<span id="cb32-903"><a href="#cb32-903" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.4, 0.6, 0.8);  // Blue interior</span></span>
<span id="cb32-904"><a href="#cb32-904" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-905"><a href="#cb32-905" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-906"><a href="#cb32-906" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw center</span></span>
<span id="cb32-907"><a href="#cb32-907" aria-hidden="true" tabindex="-1"></a><span class="in">    if(hyperbolicDistance(p, center) &lt; 0.1) {</span></span>
<span id="cb32-908"><a href="#cb32-908" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(1.0, 0.0, 0.0);</span></span>
<span id="cb32-909"><a href="#cb32-909" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-910"><a href="#cb32-910" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-911"><a href="#cb32-911" aria-hidden="true" tabindex="-1"></a><span class="in">    // Darken outside upper half-plane</span></span>
<span id="cb32-912"><a href="#cb32-912" aria-hidden="true" tabindex="-1"></a><span class="in">    if(p.y &lt; 0.0) {</span></span>
<span id="cb32-913"><a href="#cb32-913" aria-hidden="true" tabindex="-1"></a><span class="in">        color *= 0.3;</span></span>
<span id="cb32-914"><a href="#cb32-914" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-915"><a href="#cb32-915" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-916"><a href="#cb32-916" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-917"><a href="#cb32-917" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-918"><a href="#cb32-918" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-919"><a href="#cb32-919" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-920"><a href="#cb32-920" aria-hidden="true" tabindex="-1"></a>Now drag the center around! Notice how the "circle" changes shape as you move it. Near the bottom ($y \to 0$), the circle appears huge Euclidean-wise—that's because we're near the boundary where hyperbolic distances blow up. Higher up ($y$ large), the circle appears smaller.</span>
<span id="cb32-921"><a href="#cb32-921" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-922"><a href="#cb32-922" aria-hidden="true" tabindex="-1"></a>This visualization makes the $1/y^2$ conformal factor visceral: **hyperbolic space is compressed near the boundary**.</span>
<span id="cb32-923"><a href="#cb32-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-924"><a href="#cb32-924" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-925"><a href="#cb32-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-926"><a href="#cb32-926" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Boundary at Infinity</span></span>
<span id="cb32-927"><a href="#cb32-927" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-928"><a href="#cb32-928" aria-hidden="true" tabindex="-1"></a>The real axis $<span class="sc">\{</span>y = 0<span class="sc">\}</span>$ is not part of $\mathbb{H}^2$, but we can think of it as the **boundary at infinity**—points infinitely far away in hyperbolic distance.</span>
<span id="cb32-929"><a href="#cb32-929" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-930"><a href="#cb32-930" aria-hidden="true" tabindex="-1"></a>**Ideal points as equivalence classes**: An **ideal point** on the boundary can be defined as an equivalence class of geodesics that asymptotically approach each other. Two geodesics are equivalent if the hyperbolic distance between them goes to zero as you go to infinity along them.</span>
<span id="cb32-931"><a href="#cb32-931" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-932"><a href="#cb32-932" aria-hidden="true" tabindex="-1"></a>For example, the vertical line $<span class="sc">\{</span>x = 0<span class="sc">\}</span>$ and the vertical line $<span class="sc">\{</span>x = \epsilon<span class="sc">\}</span>$ (for small $\epsilon$) both approach the point $0$ on the real axis. As you go up ($y \to \infty$), the hyperbolic distance between corresponding points goes to zero—they're asymptotically parallel.</span>
<span id="cb32-933"><a href="#cb32-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-934"><a href="#cb32-934" aria-hidden="true" tabindex="-1"></a>**Geometric intuition**: In the Poincaré disk model (which we'll see soon), the boundary at infinity is literally the unit circle $|z| = 1$. Points on this circle are infinitely far away from any interior point, but they still have geometric meaning—they represent directions or "points at infinity."</span>
<span id="cb32-935"><a href="#cb32-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-936"><a href="#cb32-936" aria-hidden="true" tabindex="-1"></a>**Why this matters**: When we define hyperbolic triangles, we can have vertices "at infinity" on the boundary. These are called **ideal vertices** or **ideal triangles**. For instance, our $(2,3,\infty)$ triangle has one vertex at the point $\infty$ in the upper half-plane (straight up the imaginary axis). The angle at an ideal vertex is zero—the sides become asymptotically parallel as they approach the boundary.</span>
<span id="cb32-937"><a href="#cb32-937" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-938"><a href="#cb32-938" aria-hidden="true" tabindex="-1"></a>The Gauss-Bonnet theorem still works: for a triangle with angles $\alpha$, $\beta$, $\gamma$, the area is $\pi - (\alpha + \beta + \gamma)$. If one angle is zero (ideal vertex), the area is $\pi - \alpha - \beta &gt; 0$—ideal triangles have finite area!</span>
<span id="cb32-939"><a href="#cb32-939" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-940"><a href="#cb32-940" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-941"><a href="#cb32-941" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-942"><a href="#cb32-942" aria-hidden="true" tabindex="-1"></a><span class="fu">### Geodesics and Reflections</span></span>
<span id="cb32-943"><a href="#cb32-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-944"><a href="#cb32-944" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Geodesics in the Upper Half-Plane</span></span>
<span id="cb32-945"><a href="#cb32-945" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-946"><a href="#cb32-946" aria-hidden="true" tabindex="-1"></a>**Geodesics** (the "straight lines" of hyperbolic geometry—curves that locally minimize distance) in $\mathbb{H}^2$ have exactly two forms:</span>
<span id="cb32-947"><a href="#cb32-947" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-948"><a href="#cb32-948" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Vertical lines**: $<span class="sc">\{</span>x = c<span class="sc">\}</span>$ for any constant $c \in \mathbb{R}$</span>
<span id="cb32-949"><a href="#cb32-949" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Semicircles**: Centered on the real axis, perpendicular to it</span>
<span id="cb32-950"><a href="#cb32-950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-951"><a href="#cb32-951" aria-hidden="true" tabindex="-1"></a>These curves meet the boundary at right angles—this is the characterizing property of geodesics in this model.</span>
<span id="cb32-952"><a href="#cb32-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-953"><a href="#cb32-953" aria-hidden="true" tabindex="-1"></a>**Why these are geodesics**: Reflections across these curves are isometries (they preserve the hyperbolic metric $ds^2 = \frac{dx^2+dy^2}{y^2}$). An isometry's fixed point set is always a geodesic! So we just need to verify that reflection across vertical lines and semicircles preserves the metric.</span>
<span id="cb32-954"><a href="#cb32-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-955"><a href="#cb32-955" aria-hidden="true" tabindex="-1"></a>For **vertical lines**, this is obvious: reflecting across $x = c$ sends $(x,y) \mapsto (2c-x, y)$, which preserves both the Euclidean distance $dx^2 + dy^2$ and the $y$-coordinate, hence preserves $\frac{dx^2+dy^2}{y^2}$.</span>
<span id="cb32-956"><a href="#cb32-956" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-957"><a href="#cb32-957" aria-hidden="true" tabindex="-1"></a>For **semicircles**, we use circle inversion from Day 2! A semicircle centered at $(c, 0)$ with radius $R$ is preserved by the inversion:</span>
<span id="cb32-958"><a href="#cb32-958" aria-hidden="true" tabindex="-1"></a>$$z \mapsto c + R^2 \frac{z - c}{|z - c|^2}$$</span>
<span id="cb32-959"><a href="#cb32-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-960"><a href="#cb32-960" aria-hidden="true" tabindex="-1"></a>Circle inversion is conformal (preserves angles) and scales distances by exactly $1/y^2$ near the boundary—precisely the conformal factor in the hyperbolic metric! So inversions through semicircles are hyperbolic isometries. Their fixed point sets (the semicircles themselves) are therefore geodesics.</span>
<span id="cb32-961"><a href="#cb32-961" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-962"><a href="#cb32-962" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb32-963"><a href="#cb32-963" aria-hidden="true" tabindex="-1"></a><span class="fu">## Connection to Day 2: Circle Inversion is a Hyperbolic Isometry!</span></span>
<span id="cb32-964"><a href="#cb32-964" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-965"><a href="#cb32-965" aria-hidden="true" tabindex="-1"></a>This is a profound connection: the circle inversions we used on Day 2 for the Apollonian gasket were actually **hyperbolic isometries** all along! The Apollonian gasket lives in hyperbolic space—the gaps between circles are hyperbolic regions, and the inversions are reflections across hyperbolic geodesics (semicircles).</span>
<span id="cb32-966"><a href="#cb32-966" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-967"><a href="#cb32-967" aria-hidden="true" tabindex="-1"></a>When we iterated inversions on Day 2, we were doing exactly what we're doing today—finding the fundamental domain of a group action! The Apollonian gasket is a hyperbolic object, just like our triangle tilings. The same group-theoretic principles apply.</span>
<span id="cb32-968"><a href="#cb32-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-969"><a href="#cb32-969" aria-hidden="true" tabindex="-1"></a>This is why the techniques work across days: we're always working with group actions, whether we realize it or not. The mathematics unifies everything.</span>
<span id="cb32-970"><a href="#cb32-970" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-971"><a href="#cb32-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-972"><a href="#cb32-972" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Implementing Reflections</span></span>
<span id="cb32-973"><a href="#cb32-973" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-974"><a href="#cb32-974" aria-hidden="true" tabindex="-1"></a>For **vertical lines** (like $x = c$), reflection is simple—flip the $x$-coordinate:</span>
<span id="cb32-975"><a href="#cb32-975" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-976"><a href="#cb32-976" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-977"><a href="#cb32-977" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoVertical(vec2 z, float x_pos, float side) {</span></span>
<span id="cb32-978"><a href="#cb32-978" aria-hidden="true" tabindex="-1"></a><span class="in">    // Check if we're on the correct side</span></span>
<span id="cb32-979"><a href="#cb32-979" aria-hidden="true" tabindex="-1"></a><span class="in">    if((z.x - x_pos) * side &lt; 0.0) {</span></span>
<span id="cb32-980"><a href="#cb32-980" aria-hidden="true" tabindex="-1"></a><span class="in">        return z;  // Already on correct side</span></span>
<span id="cb32-981"><a href="#cb32-981" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-982"><a href="#cb32-982" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-983"><a href="#cb32-983" aria-hidden="true" tabindex="-1"></a><span class="in">    // Reflect: (x,y) ↦ (2c - x, y)</span></span>
<span id="cb32-984"><a href="#cb32-984" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x = 2.0 * x_pos - z.x;</span></span>
<span id="cb32-985"><a href="#cb32-985" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb32-986"><a href="#cb32-986" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-987"><a href="#cb32-987" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-988"><a href="#cb32-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-989"><a href="#cb32-989" aria-hidden="true" tabindex="-1"></a>For **semicircles** (geodesics from point $p$ to point $q$ on the real axis), we use circle inversion. The semicircle has center $(c, 0)$ where $c = (p+q)/2$ and radius $R = |p-q|/2$:</span>
<span id="cb32-990"><a href="#cb32-990" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-991"><a href="#cb32-991" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-992"><a href="#cb32-992" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoCircular(vec2 z, float p, float q, float side) {</span></span>
<span id="cb32-993"><a href="#cb32-993" aria-hidden="true" tabindex="-1"></a><span class="in">    float center = (p + q) / 2.0;</span></span>
<span id="cb32-994"><a href="#cb32-994" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius = abs(p - q) / 2.0;</span></span>
<span id="cb32-995"><a href="#cb32-995" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-996"><a href="#cb32-996" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 rel = z - vec2(center, 0.0);</span></span>
<span id="cb32-997"><a href="#cb32-997" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist2 = dot(rel, rel);  // Squared distance from center</span></span>
<span id="cb32-998"><a href="#cb32-998" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-999"><a href="#cb32-999" aria-hidden="true" tabindex="-1"></a><span class="in">    // Check if we're on the correct side</span></span>
<span id="cb32-1000"><a href="#cb32-1000" aria-hidden="true" tabindex="-1"></a><span class="in">    if((dist2 - radius * radius) * side &gt; 0.0) {</span></span>
<span id="cb32-1001"><a href="#cb32-1001" aria-hidden="true" tabindex="-1"></a><span class="in">        return z;  // Already on correct side</span></span>
<span id="cb32-1002"><a href="#cb32-1002" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-1003"><a href="#cb32-1003" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1004"><a href="#cb32-1004" aria-hidden="true" tabindex="-1"></a><span class="in">    // Circle inversion (from Day 2!)</span></span>
<span id="cb32-1005"><a href="#cb32-1005" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 inverted = vec2(center, 0.0) + (radius * radius) * rel / dist2;</span></span>
<span id="cb32-1006"><a href="#cb32-1006" aria-hidden="true" tabindex="-1"></a><span class="in">    return inverted;</span></span>
<span id="cb32-1007"><a href="#cb32-1007" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1008"><a href="#cb32-1008" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1009"><a href="#cb32-1009" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1010"><a href="#cb32-1010" aria-hidden="true" tabindex="-1"></a>Note: We're inverting through a circle in the Euclidean sense (using Euclidean distance <span class="in">`dist2`</span>), but this operation is actually a hyperbolic isometry! The magic is that circle inversion's conformal properties exactly match the hyperbolic metric's requirements.</span>
<span id="cb32-1011"><a href="#cb32-1011" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1012"><a href="#cb32-1012" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb32-1013"><a href="#cb32-1013" aria-hidden="true" tabindex="-1"></a><span class="fu">## Why Two Types of Reflections?</span></span>
<span id="cb32-1014"><a href="#cb32-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1015"><a href="#cb32-1015" aria-hidden="true" tabindex="-1"></a>In Euclidean geometry, all reflections across lines look the same—just the orientation changes. Why do we need two different functions in hyperbolic geometry?</span>
<span id="cb32-1016"><a href="#cb32-1016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1017"><a href="#cb32-1017" aria-hidden="true" tabindex="-1"></a>The answer is that we're working in a **model** of hyperbolic geometry (the upper half-plane). The vertical lines and semicircles are the images of geodesics in this model. In the intrinsic hyperbolic geometry, all reflections across geodesics are the same—there's only one type of reflection.</span>
<span id="cb32-1018"><a href="#cb32-1018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1019"><a href="#cb32-1019" aria-hidden="true" tabindex="-1"></a>But when we represent hyperbolic geometry in the Euclidean upper half-plane, geodesics appear as two different types of curves (vertical lines and semicircles), so we need two different formulas. This is an artifact of the model, not the geometry itself.</span>
<span id="cb32-1020"><a href="#cb32-1020" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1021"><a href="#cb32-1021" aria-hidden="true" tabindex="-1"></a>In the Poincaré disk model (coming soon), ALL geodesics are circular arcs perpendicular to the boundary circle, so we'd only need one reflection function there!</span>
<span id="cb32-1022"><a href="#cb32-1022" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-1023"><a href="#cb32-1023" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1024"><a href="#cb32-1024" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1025"><a href="#cb32-1025" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1026"><a href="#cb32-1026" aria-hidden="true" tabindex="-1"></a><span class="fu">### The (2,3,∞) Triangle</span></span>
<span id="cb32-1027"><a href="#cb32-1027" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1028"><a href="#cb32-1028" aria-hidden="true" tabindex="-1"></a>Let's build our first hyperbolic triangle tiling. The notation $(p, q, r)$ means the triangle has angles $\pi/p$, $\pi/q$, and $\pi/r$ at its three vertices. So $(2,3,\infty)$ means angles $\pi/2$, $\pi/3$, and $0$ (an ideal vertex at infinity).</span>
<span id="cb32-1029"><a href="#cb32-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1030"><a href="#cb32-1030" aria-hidden="true" tabindex="-1"></a>**Why this triangle exists in hyperbolic geometry**: The Gauss-Bonnet theorem tells us the area of a hyperbolic triangle with angles $\alpha$, $\beta$, $\gamma$ is:</span>
<span id="cb32-1031"><a href="#cb32-1031" aria-hidden="true" tabindex="-1"></a>$$\text{Area} = \pi - (\alpha + \beta + \gamma)$$</span>
<span id="cb32-1032"><a href="#cb32-1032" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1033"><a href="#cb32-1033" aria-hidden="true" tabindex="-1"></a>For a $(2,3,\infty)$ triangle:</span>
<span id="cb32-1034"><a href="#cb32-1034" aria-hidden="true" tabindex="-1"></a>$$\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + 0\right) = \pi - \frac{5\pi}{6} = \frac{\pi}{6} &gt; 0$$</span>
<span id="cb32-1035"><a href="#cb32-1035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1036"><a href="#cb32-1036" aria-hidden="true" tabindex="-1"></a>So this triangle has finite positive area and can tile the hyperbolic plane. In Euclidean geometry, $\pi/2 + \pi/3 = 5\pi/6 &lt; \pi$, but that's not enough—we'd need the sum to equal *exactly* $\pi$ to get zero curvature. Since $5\pi/6 &lt; \pi$, there's negative curvature left over, making this a hyperbolic triangle.</span>
<span id="cb32-1037"><a href="#cb32-1037" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1038"><a href="#cb32-1038" aria-hidden="true" tabindex="-1"></a>**Configuration**: We'll use a particularly nice setup in the upper half-plane:</span>
<span id="cb32-1039"><a href="#cb32-1039" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Left boundary**: Vertical line at $x = -1$</span>
<span id="cb32-1040"><a href="#cb32-1040" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Right boundary**: Vertical line at $x = 1$  </span>
<span id="cb32-1041"><a href="#cb32-1041" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Bottom boundary**: Unit semicircle from $-1$ to $1$ (centered at origin, radius $1$)</span>
<span id="cb32-1042"><a href="#cb32-1042" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1043"><a href="#cb32-1043" aria-hidden="true" tabindex="-1"></a>This creates a triangle with:</span>
<span id="cb32-1044"><a href="#cb32-1044" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Two finite vertices at approximately $(-1, 0)$ and $(1, 0)$ (technically infinitesimally above the real axis)</span>
<span id="cb32-1045"><a href="#cb32-1045" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>One ideal vertex at $\infty$ (straight up the imaginary axis)</span>
<span id="cb32-1046"><a href="#cb32-1046" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Angles of $\pi/2$ at the bottom two vertices (vertical line meets semicircle at right angles)</span>
<span id="cb32-1047"><a href="#cb32-1047" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Angle of $\pi/3$ between the two vertical lines when measured hyperbolically</span>
<span id="cb32-1048"><a href="#cb32-1048" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Angle of $0$ at the ideal vertex $\infty$</span>
<span id="cb32-1049"><a href="#cb32-1049" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1050"><a href="#cb32-1050" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Implementation</span></span>
<span id="cb32-1051"><a href="#cb32-1051" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1052"><a href="#cb32-1052" aria-hidden="true" tabindex="-1"></a>Here's the complete shader:</span>
<span id="cb32-1053"><a href="#cb32-1053" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1054"><a href="#cb32-1054" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1055"><a href="#cb32-1055" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoVertical(vec2 z, float x_pos, float side) {</span></span>
<span id="cb32-1056"><a href="#cb32-1056" aria-hidden="true" tabindex="-1"></a><span class="in">    if((z.x - x_pos) * side &lt; 0.0) return z;</span></span>
<span id="cb32-1057"><a href="#cb32-1057" aria-hidden="true" tabindex="-1"></a><span class="in">    z.x = 2.0 * x_pos - z.x;</span></span>
<span id="cb32-1058"><a href="#cb32-1058" aria-hidden="true" tabindex="-1"></a><span class="in">    return z;</span></span>
<span id="cb32-1059"><a href="#cb32-1059" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1060"><a href="#cb32-1060" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1061"><a href="#cb32-1061" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 reflectIntoCircular(vec2 z, float p, float q, float side) {</span></span>
<span id="cb32-1062"><a href="#cb32-1062" aria-hidden="true" tabindex="-1"></a><span class="in">    float center = (p + q) / 2.0;</span></span>
<span id="cb32-1063"><a href="#cb32-1063" aria-hidden="true" tabindex="-1"></a><span class="in">    float radius = abs(p - q) / 2.0;</span></span>
<span id="cb32-1064"><a href="#cb32-1064" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 rel = z - vec2(center, 0.0);</span></span>
<span id="cb32-1065"><a href="#cb32-1065" aria-hidden="true" tabindex="-1"></a><span class="in">    float dist2 = dot(rel, rel);</span></span>
<span id="cb32-1066"><a href="#cb32-1066" aria-hidden="true" tabindex="-1"></a><span class="in">    if((dist2 - radius * radius) * side &gt; 0.0) return z;</span></span>
<span id="cb32-1067"><a href="#cb32-1067" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1068"><a href="#cb32-1068" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(center, 0.0) + (radius * radius) * rel / dist2;</span></span>
<span id="cb32-1069"><a href="#cb32-1069" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1070"><a href="#cb32-1070" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1071"><a href="#cb32-1071" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-1072"><a href="#cb32-1072" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-1073"><a href="#cb32-1073" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup</span></span>
<span id="cb32-1074"><a href="#cb32-1074" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-1075"><a href="#cb32-1075" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 4.0;</span></span>
<span id="cb32-1076"><a href="#cb32-1076" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-1077"><a href="#cb32-1077" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1078"><a href="#cb32-1078" aria-hidden="true" tabindex="-1"></a><span class="in">    // Shift to upper half-plane (need y &gt; 0)</span></span>
<span id="cb32-1079"><a href="#cb32-1079" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = uv + vec2(0.0, 1.5);</span></span>
<span id="cb32-1080"><a href="#cb32-1080" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1081"><a href="#cb32-1081" aria-hidden="true" tabindex="-1"></a><span class="in">    // Fold into the (2,3,∞) triangle</span></span>
<span id="cb32-1082"><a href="#cb32-1082" aria-hidden="true" tabindex="-1"></a><span class="in">    int foldCount = 0;</span></span>
<span id="cb32-1083"><a href="#cb32-1083" aria-hidden="true" tabindex="-1"></a><span class="in">    for(int i = 0; i &lt; 50; i++) {</span></span>
<span id="cb32-1084"><a href="#cb32-1084" aria-hidden="true" tabindex="-1"></a><span class="in">        vec2 z_old = z;</span></span>
<span id="cb32-1085"><a href="#cb32-1085" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-1086"><a href="#cb32-1086" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across left vertical line (x = -1, want x &gt; -1)</span></span>
<span id="cb32-1087"><a href="#cb32-1087" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoVertical(z, -1.0, -1.0);</span></span>
<span id="cb32-1088"><a href="#cb32-1088" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-1089"><a href="#cb32-1089" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across right vertical line (x = 1, want x &lt; 1)</span></span>
<span id="cb32-1090"><a href="#cb32-1090" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoVertical(z, 1.0, 1.0);</span></span>
<span id="cb32-1091"><a href="#cb32-1091" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-1092"><a href="#cb32-1092" aria-hidden="true" tabindex="-1"></a><span class="in">        // Reflect across semicircle (from -1 to 1, want outside/above)</span></span>
<span id="cb32-1093"><a href="#cb32-1093" aria-hidden="true" tabindex="-1"></a><span class="in">        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);</span></span>
<span id="cb32-1094"><a href="#cb32-1094" aria-hidden="true" tabindex="-1"></a><span class="in">        </span></span>
<span id="cb32-1095"><a href="#cb32-1095" aria-hidden="true" tabindex="-1"></a><span class="in">        // If point didn't move, we're inside</span></span>
<span id="cb32-1096"><a href="#cb32-1096" aria-hidden="true" tabindex="-1"></a><span class="in">        if(length(z - z_old) &lt; 0.0001) break;</span></span>
<span id="cb32-1097"><a href="#cb32-1097" aria-hidden="true" tabindex="-1"></a><span class="in">        foldCount++;</span></span>
<span id="cb32-1098"><a href="#cb32-1098" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-1099"><a href="#cb32-1099" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1100"><a href="#cb32-1100" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color by fold count parity</span></span>
<span id="cb32-1101"><a href="#cb32-1101" aria-hidden="true" tabindex="-1"></a><span class="in">    float parity = mod(float(foldCount), 2.0);</span></span>
<span id="cb32-1102"><a href="#cb32-1102" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color;</span></span>
<span id="cb32-1103"><a href="#cb32-1103" aria-hidden="true" tabindex="-1"></a><span class="in">    if(parity &lt; 0.5) {</span></span>
<span id="cb32-1104"><a href="#cb32-1104" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.7, 0.8, 0.9);  // Light blue</span></span>
<span id="cb32-1105"><a href="#cb32-1105" aria-hidden="true" tabindex="-1"></a><span class="in">    } else {</span></span>
<span id="cb32-1106"><a href="#cb32-1106" aria-hidden="true" tabindex="-1"></a><span class="in">        color = vec3(0.5, 0.6, 0.8);  // Darker blue</span></span>
<span id="cb32-1107"><a href="#cb32-1107" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-1108"><a href="#cb32-1108" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1109"><a href="#cb32-1109" aria-hidden="true" tabindex="-1"></a><span class="in">    // Darken if below the real axis (outside hyperbolic space)</span></span>
<span id="cb32-1110"><a href="#cb32-1110" aria-hidden="true" tabindex="-1"></a><span class="in">    if(z.y &lt; 0.0) {</span></span>
<span id="cb32-1111"><a href="#cb32-1111" aria-hidden="true" tabindex="-1"></a><span class="in">        color *= 0.3;</span></span>
<span id="cb32-1112"><a href="#cb32-1112" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb32-1113"><a href="#cb32-1113" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1114"><a href="#cb32-1114" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-1115"><a href="#cb32-1115" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1116"><a href="#cb32-1116" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1117"><a href="#cb32-1117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1118"><a href="#cb32-1118" aria-hidden="true" tabindex="-1"></a>You should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis $y = 0$)—they're all the same hyperbolic size, but Euclidean distances compress due to the $1/y^2$ metric.</span>
<span id="cb32-1119"><a href="#cb32-1119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1120"><a href="#cb32-1120" aria-hidden="true" tabindex="-1"></a>The alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.</span>
<span id="cb32-1121"><a href="#cb32-1121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1122"><a href="#cb32-1122" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb32-1123"><a href="#cb32-1123" aria-hidden="true" tabindex="-1"></a><span class="fu">## Compare to Euclidean</span></span>
<span id="cb32-1124"><a href="#cb32-1124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1125"><a href="#cb32-1125" aria-hidden="true" tabindex="-1"></a>Look at the structure of this shader compared to the Euclidean triangle tiling:</span>
<span id="cb32-1126"><a href="#cb32-1126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1127"><a href="#cb32-1127" aria-hidden="true" tabindex="-1"></a>**Euclidean:**</span>
<span id="cb32-1128"><a href="#cb32-1128" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1129"><a href="#cb32-1129" aria-hidden="true" tabindex="-1"></a><span class="in">p = reflectInto(p, hs1);</span></span>
<span id="cb32-1130"><a href="#cb32-1130" aria-hidden="true" tabindex="-1"></a><span class="in">p = reflectInto(p, hs2);</span></span>
<span id="cb32-1131"><a href="#cb32-1131" aria-hidden="true" tabindex="-1"></a><span class="in">p = reflectInto(p, hs3);</span></span>
<span id="cb32-1132"><a href="#cb32-1132" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1133"><a href="#cb32-1133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1134"><a href="#cb32-1134" aria-hidden="true" tabindex="-1"></a>**Hyperbolic:**</span>
<span id="cb32-1135"><a href="#cb32-1135" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1136"><a href="#cb32-1136" aria-hidden="true" tabindex="-1"></a><span class="in">z = reflectIntoVertical(z, -1.0, -1.0);</span></span>
<span id="cb32-1137"><a href="#cb32-1137" aria-hidden="true" tabindex="-1"></a><span class="in">z = reflectIntoVertical(z, 1.0, 1.0);</span></span>
<span id="cb32-1138"><a href="#cb32-1138" aria-hidden="true" tabindex="-1"></a><span class="in">z = reflectIntoCircular(z, -1.0, 1.0, 1.0);</span></span>
<span id="cb32-1139"><a href="#cb32-1139" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1140"><a href="#cb32-1140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1141"><a href="#cb32-1141" aria-hidden="true" tabindex="-1"></a>The algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.</span>
<span id="cb32-1142"><a href="#cb32-1142" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-1143"><a href="#cb32-1143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1144"><a href="#cb32-1144" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb32-1145"><a href="#cb32-1145" aria-hidden="true" tabindex="-1"></a><span class="fu">## Computational Analysis</span></span>
<span id="cb32-1146"><a href="#cb32-1146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1147"><a href="#cb32-1147" aria-hidden="true" tabindex="-1"></a>**GPU Parallelism**: Just like Days 1 and 2, this algorithm is embarrassingly parallel. Each pixel computes independently—no communication, no shared state, perfect for GPU architecture.</span>
<span id="cb32-1148"><a href="#cb32-1148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1149"><a href="#cb32-1149" aria-hidden="true" tabindex="-1"></a>**Convergence**: The folding algorithm works for the same group-theoretic reasons as the Euclidean case. The three reflections generate a discrete group of hyperbolic isometries, and our fundamental triangle is a fundamental domain for this group's action on $\mathbb{H}^2$.</span>
<span id="cb32-1150"><a href="#cb32-1150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1151"><a href="#cb32-1151" aria-hidden="true" tabindex="-1"></a>**Precision issues**: Near $y \to 0$, floating-point precision degrades. The large conformal factor $1/y^2$ amplifies small errors in distance calculations. This is why we darken the region $y &lt; 0$—technically it's not part of the hyperbolic plane, but also our numerics become unreliable there.</span>
<span id="cb32-1152"><a href="#cb32-1152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1153"><a href="#cb32-1153" aria-hidden="true" tabindex="-1"></a>**Threshold $0.0001$**: This convergence threshold balances precision and performance. Smaller thresholds catch more subtle movements but risk getting stuck in floating-point noise; larger thresholds might terminate early. For visualization purposes, $0.0001$ is a good sweet spot.</span>
<span id="cb32-1154"><a href="#cb32-1154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1155"><a href="#cb32-1155" aria-hidden="true" tabindex="-1"></a>**Memory efficiency**: Each pixel only needs to store its current position <span class="in">`z`</span> (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures—just stateless iteration. This is as memory-efficient as you can get!</span>
<span id="cb32-1156"><a href="#cb32-1156" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-1157"><a href="#cb32-1157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1158"><a href="#cb32-1158" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb32-1159"><a href="#cb32-1159" aria-hidden="true" tabindex="-1"></a><span class="fu">## Exercise: Visualizing Hyperbolic Triangle Structure</span></span>
<span id="cb32-1160"><a href="#cb32-1160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1161"><a href="#cb32-1161" aria-hidden="true" tabindex="-1"></a>Want to see the edges and vertices of your hyperbolic triangles? This requires computing hyperbolic distances.</span>
<span id="cb32-1162"><a href="#cb32-1162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1163"><a href="#cb32-1163" aria-hidden="true" tabindex="-1"></a>**For hyperbolic distance:**</span>
<span id="cb32-1164"><a href="#cb32-1164" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1165"><a href="#cb32-1165" aria-hidden="true" tabindex="-1"></a><span class="in">float hyperbolicDistance(vec2 z1, vec2 z2) {</span></span>
<span id="cb32-1166"><a href="#cb32-1166" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 diff = z1 - z2;</span></span>
<span id="cb32-1167"><a href="#cb32-1167" aria-hidden="true" tabindex="-1"></a><span class="in">    float diff2 = dot(diff, diff);</span></span>
<span id="cb32-1168"><a href="#cb32-1168" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = 2.0 * z1.y * z2.y;</span></span>
<span id="cb32-1169"><a href="#cb32-1169" aria-hidden="true" tabindex="-1"></a><span class="in">    float arg = 1.0 + diff2 / denom;</span></span>
<span id="cb32-1170"><a href="#cb32-1170" aria-hidden="true" tabindex="-1"></a><span class="in">    return log(arg + sqrt(arg * arg - 1.0));</span></span>
<span id="cb32-1171"><a href="#cb32-1171" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1172"><a href="#cb32-1172" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1173"><a href="#cb32-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1174"><a href="#cb32-1174" aria-hidden="true" tabindex="-1"></a>**For drawing edges** (vertical lines):</span>
<span id="cb32-1175"><a href="#cb32-1175" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1176"><a href="#cb32-1176" aria-hidden="true" tabindex="-1"></a><span class="in">// Distance to vertical line x = c</span></span>
<span id="cb32-1177"><a href="#cb32-1177" aria-hidden="true" tabindex="-1"></a><span class="in">float distToVertical = abs(z.x - c);</span></span>
<span id="cb32-1178"><a href="#cb32-1178" aria-hidden="true" tabindex="-1"></a><span class="in">if(distToVertical &lt; 0.02) color = vec3(1.0);</span></span>
<span id="cb32-1179"><a href="#cb32-1179" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1180"><a href="#cb32-1180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1181"><a href="#cb32-1181" aria-hidden="true" tabindex="-1"></a>**For drawing edges** (semicircular geodesics):</span>
<span id="cb32-1182"><a href="#cb32-1182" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1183"><a href="#cb32-1183" aria-hidden="true" tabindex="-1"></a><span class="in">// Distance to semicircle from p to q</span></span>
<span id="cb32-1184"><a href="#cb32-1184" aria-hidden="true" tabindex="-1"></a><span class="in">float center = (p + q) / 2.0;</span></span>
<span id="cb32-1185"><a href="#cb32-1185" aria-hidden="true" tabindex="-1"></a><span class="in">float radius = abs(p - q) / 2.0;</span></span>
<span id="cb32-1186"><a href="#cb32-1186" aria-hidden="true" tabindex="-1"></a><span class="in">float distToCircle = abs(length(z - vec2(center, 0.0)) - radius);</span></span>
<span id="cb32-1187"><a href="#cb32-1187" aria-hidden="true" tabindex="-1"></a><span class="in">// Only draw if above real axis</span></span>
<span id="cb32-1188"><a href="#cb32-1188" aria-hidden="true" tabindex="-1"></a><span class="in">if(z.y &gt; 0.0 &amp;&amp; distToCircle &lt; 0.02) color = vec3(1.0);</span></span>
<span id="cb32-1189"><a href="#cb32-1189" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1190"><a href="#cb32-1190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1191"><a href="#cb32-1191" aria-hidden="true" tabindex="-1"></a>**For vertices**:</span>
<span id="cb32-1192"><a href="#cb32-1192" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1193"><a href="#cb32-1193" aria-hidden="true" tabindex="-1"></a><span class="in">// Check hyperbolic distance to vertices after folding</span></span>
<span id="cb32-1194"><a href="#cb32-1194" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v1 = vec2(-1.0, 0.01);  // Left vertex (slightly above axis)</span></span>
<span id="cb32-1195"><a href="#cb32-1195" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v2 = vec2(1.0, 0.01);   // Right vertex</span></span>
<span id="cb32-1196"><a href="#cb32-1196" aria-hidden="true" tabindex="-1"></a><span class="in">if(hyperbolicDistance(z, v1) &lt; 0.1 || hyperbolicDistance(z, v2) &lt; 0.1) {</span></span>
<span id="cb32-1197"><a href="#cb32-1197" aria-hidden="true" tabindex="-1"></a><span class="in">    color = vec3(1.0, 0.0, 0.0);  // Red vertices</span></span>
<span id="cb32-1198"><a href="#cb32-1198" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1199"><a href="#cb32-1199" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1200"><a href="#cb32-1200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1201"><a href="#cb32-1201" aria-hidden="true" tabindex="-1"></a>See Appendix H5 for the complete enhanced implementation!</span>
<span id="cb32-1202"><a href="#cb32-1202" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb32-1203"><a href="#cb32-1203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1204"><a href="#cb32-1204" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1205"><a href="#cb32-1205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1206"><a href="#cb32-1206" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multiple Models of Hyperbolic Space</span></span>
<span id="cb32-1207"><a href="#cb32-1207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1208"><a href="#cb32-1208" aria-hidden="true" tabindex="-1"></a>The upper half-plane is just one way to represent hyperbolic geometry. There are several other models, each with advantages:</span>
<span id="cb32-1209"><a href="#cb32-1209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1210"><a href="#cb32-1210" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Poincaré Disk Model</span></span>
<span id="cb32-1211"><a href="#cb32-1211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1212"><a href="#cb32-1212" aria-hidden="true" tabindex="-1"></a>The **Poincaré disk model** represents all of $\mathbb{H}^2$ as the interior of the unit disk $<span class="sc">\{</span>z \in \mathbb{C} : |z| &lt; 1<span class="sc">\}</span>$. The boundary circle $|z| = 1$ represents points at infinity.</span>
<span id="cb32-1213"><a href="#cb32-1213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1214"><a href="#cb32-1214" aria-hidden="true" tabindex="-1"></a>**Geodesics** in this model are:</span>
<span id="cb32-1215"><a href="#cb32-1215" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Diameters of the disk (straight lines through the origin)</span>
<span id="cb32-1216"><a href="#cb32-1216" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Circular arcs perpendicular to the boundary circle</span>
<span id="cb32-1217"><a href="#cb32-1217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1218"><a href="#cb32-1218" aria-hidden="true" tabindex="-1"></a>The conformal factor here is $\frac{4}{(1-|z|^2)^2}$, which blows up as $|z| \to 1$ (approaching the boundary).</span>
<span id="cb32-1219"><a href="#cb32-1219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1220"><a href="#cb32-1220" aria-hidden="true" tabindex="-1"></a>**Advantages**: </span>
<span id="cb32-1221"><a href="#cb32-1221" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The entire hyperbolic plane fits in a bounded region (the disk)</span>
<span id="cb32-1222"><a href="#cb32-1222" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>All geodesics look similar (circular arcs)—no distinction between vertical and circular</span>
<span id="cb32-1223"><a href="#cb32-1223" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Visually intuitive for understanding the full structure at once</span>
<span id="cb32-1224"><a href="#cb32-1224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1225"><a href="#cb32-1225" aria-hidden="true" tabindex="-1"></a>**Disadvantages**:</span>
<span id="cb32-1226"><a href="#cb32-1226" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Harder to compute distances</span>
<span id="cb32-1227"><a href="#cb32-1227" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>More complex reflection formulas</span>
<span id="cb32-1228"><a href="#cb32-1228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1229"><a href="#cb32-1229" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Converting Between Models: The Cayley Transform</span></span>
<span id="cb32-1230"><a href="#cb32-1230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1231"><a href="#cb32-1231" aria-hidden="true" tabindex="-1"></a>We can convert between the upper half-plane and Poincaré disk using the **Cayley transform** (also called the Möbius transformation):</span>
<span id="cb32-1232"><a href="#cb32-1232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1233"><a href="#cb32-1233" aria-hidden="true" tabindex="-1"></a>$$w = \frac{z - i}{z + i}$$</span>
<span id="cb32-1234"><a href="#cb32-1234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1235"><a href="#cb32-1235" aria-hidden="true" tabindex="-1"></a>This maps:</span>
<span id="cb32-1236"><a href="#cb32-1236" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Upper half-plane $<span class="sc">\{</span>z : \operatorname{Im}(z) &gt; 0<span class="sc">\}</span>$ → Poincaré disk $<span class="sc">\{</span>w : |w| &lt; 1<span class="sc">\}</span>$</span>
<span id="cb32-1237"><a href="#cb32-1237" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Real axis $<span class="sc">\{</span>z : \operatorname{Im}(z) = 0<span class="sc">\}</span>$ → Unit circle $<span class="sc">\{</span>w : |w| = 1<span class="sc">\}</span>$</span>
<span id="cb32-1238"><a href="#cb32-1238" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Point $i$ in the upper half-plane → origin $0$ in the disk</span>
<span id="cb32-1239"><a href="#cb32-1239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1240"><a href="#cb32-1240" aria-hidden="true" tabindex="-1"></a>The inverse transform is:</span>
<span id="cb32-1241"><a href="#cb32-1241" aria-hidden="true" tabindex="-1"></a>$$z = i\frac{1 + w}{1 - w}$$</span>
<span id="cb32-1242"><a href="#cb32-1242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1243"><a href="#cb32-1243" aria-hidden="true" tabindex="-1"></a>Here's the implementation:</span>
<span id="cb32-1244"><a href="#cb32-1244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1245"><a href="#cb32-1245" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1246"><a href="#cb32-1246" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cmul(vec2 a, vec2 b) {</span></span>
<span id="cb32-1247"><a href="#cb32-1247" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);</span></span>
<span id="cb32-1248"><a href="#cb32-1248" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1249"><a href="#cb32-1249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1250"><a href="#cb32-1250" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cdiv(vec2 a, vec2 b) {</span></span>
<span id="cb32-1251"><a href="#cb32-1251" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = dot(b, b);</span></span>
<span id="cb32-1252"><a href="#cb32-1252" aria-hidden="true" tabindex="-1"></a><span class="in">    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;</span></span>
<span id="cb32-1253"><a href="#cb32-1253" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1254"><a href="#cb32-1254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1255"><a href="#cb32-1255" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 uhpToDisk(vec2 z) {</span></span>
<span id="cb32-1256"><a href="#cb32-1256" aria-hidden="true" tabindex="-1"></a><span class="in">    // w = (z - i) / (z + i)</span></span>
<span id="cb32-1257"><a href="#cb32-1257" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 i = vec2(0.0, 1.0);</span></span>
<span id="cb32-1258"><a href="#cb32-1258" aria-hidden="true" tabindex="-1"></a><span class="in">    return cdiv(z - i, z + i);</span></span>
<span id="cb32-1259"><a href="#cb32-1259" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1260"><a href="#cb32-1260" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1261"><a href="#cb32-1261" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 diskToUhp(vec2 w) {</span></span>
<span id="cb32-1262"><a href="#cb32-1262" aria-hidden="true" tabindex="-1"></a><span class="in">    // z = i(1 + w) / (1 - w)</span></span>
<span id="cb32-1263"><a href="#cb32-1263" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 i = vec2(0.0, 1.0);</span></span>
<span id="cb32-1264"><a href="#cb32-1264" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 one = vec2(1.0, 0.0);</span></span>
<span id="cb32-1265"><a href="#cb32-1265" aria-hidden="true" tabindex="-1"></a><span class="in">    return cmul(i, cdiv(one + w, one - w));</span></span>
<span id="cb32-1266"><a href="#cb32-1266" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1267"><a href="#cb32-1267" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1268"><a href="#cb32-1268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1269"><a href="#cb32-1269" aria-hidden="true" tabindex="-1"></a>To display your tiling in the Poincaré disk:</span>
<span id="cb32-1270"><a href="#cb32-1270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1271"><a href="#cb32-1271" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1272"><a href="#cb32-1272" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb32-1273"><a href="#cb32-1273" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb32-1274"><a href="#cb32-1274" aria-hidden="true" tabindex="-1"></a><span class="in">    // Coordinate setup for disk</span></span>
<span id="cb32-1275"><a href="#cb32-1275" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb32-1276"><a href="#cb32-1276" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = (uv - 0.5) * 2.5;  // Fit disk in viewport</span></span>
<span id="cb32-1277"><a href="#cb32-1277" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb32-1278"><a href="#cb32-1278" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1279"><a href="#cb32-1279" aria-hidden="true" tabindex="-1"></a><span class="in">    // Convert disk coordinates to upper half-plane</span></span>
<span id="cb32-1280"><a href="#cb32-1280" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 z = diskToUhp(uv);</span></span>
<span id="cb32-1281"><a href="#cb32-1281" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1282"><a href="#cb32-1282" aria-hidden="true" tabindex="-1"></a><span class="in">    // Run your tiling algorithm in UHP</span></span>
<span id="cb32-1283"><a href="#cb32-1283" aria-hidden="true" tabindex="-1"></a><span class="in">    // ... (fold into (2,3,∞) triangle as before)</span></span>
<span id="cb32-1284"><a href="#cb32-1284" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb32-1285"><a href="#cb32-1285" aria-hidden="true" tabindex="-1"></a><span class="in">    // Color and render</span></span>
<span id="cb32-1286"><a href="#cb32-1286" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb32-1287"><a href="#cb32-1287" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1288"><a href="#cb32-1288" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1289"><a href="#cb32-1289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1290"><a href="#cb32-1290" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The Klein Model</span></span>
<span id="cb32-1291"><a href="#cb32-1291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1292"><a href="#cb32-1292" aria-hidden="true" tabindex="-1"></a>The **Klein model** (also called the **Beltrami-Klein model** or **projective disk model**) is another disk representation. Its defining feature: **geodesics are Euclidean straight lines**! This makes some geometric properties clearer but sacrifices the conformal property—angles are distorted.</span>
<span id="cb32-1293"><a href="#cb32-1293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1294"><a href="#cb32-1294" aria-hidden="true" tabindex="-1"></a>Converting from Poincaré disk to Klein disk:</span>
<span id="cb32-1295"><a href="#cb32-1295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1296"><a href="#cb32-1296" aria-hidden="true" tabindex="-1"></a>$$\text{Klein}(w) = \frac{2w}{1 + |w|^2}$$</span>
<span id="cb32-1297"><a href="#cb32-1297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1298"><a href="#cb32-1298" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1299"><a href="#cb32-1299" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 poincareToKlein(vec2 w) {</span></span>
<span id="cb32-1300"><a href="#cb32-1300" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = 1.0 + dot(w, w);</span></span>
<span id="cb32-1301"><a href="#cb32-1301" aria-hidden="true" tabindex="-1"></a><span class="in">    return 2.0 * w / denom;</span></span>
<span id="cb32-1302"><a href="#cb32-1302" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1303"><a href="#cb32-1303" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1304"><a href="#cb32-1304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1305"><a href="#cb32-1305" aria-hidden="true" tabindex="-1"></a>The inverse:</span>
<span id="cb32-1306"><a href="#cb32-1306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1307"><a href="#cb32-1307" aria-hidden="true" tabindex="-1"></a>$$w = \frac{\text{Klein}(w)}{1 + \sqrt{1 - |\text{Klein}(w)|^2}}$$</span>
<span id="cb32-1308"><a href="#cb32-1308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1309"><a href="#cb32-1309" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb32-1310"><a href="#cb32-1310" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 kleinToPoincare(vec2 k) {</span></span>
<span id="cb32-1311"><a href="#cb32-1311" aria-hidden="true" tabindex="-1"></a><span class="in">    float k2 = dot(k, k);</span></span>
<span id="cb32-1312"><a href="#cb32-1312" aria-hidden="true" tabindex="-1"></a><span class="in">    float denom = 1.0 + sqrt(1.0 - k2);</span></span>
<span id="cb32-1313"><a href="#cb32-1313" aria-hidden="true" tabindex="-1"></a><span class="in">    return k / denom;</span></span>
<span id="cb32-1314"><a href="#cb32-1314" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb32-1315"><a href="#cb32-1315" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb32-1316"><a href="#cb32-1316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1317"><a href="#cb32-1317" aria-hidden="true" tabindex="-1"></a>**Advantages of Klein**:</span>
<span id="cb32-1318"><a href="#cb32-1318" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Geodesics are straight lines (simplest to compute)</span>
<span id="cb32-1319"><a href="#cb32-1319" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Great for understanding incidence relationships</span>
<span id="cb32-1320"><a href="#cb32-1320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1321"><a href="#cb32-1321" aria-hidden="true" tabindex="-1"></a>**Disadvantages**:</span>
<span id="cb32-1322"><a href="#cb32-1322" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Not conformal—angles are distorted</span>
<span id="cb32-1323"><a href="#cb32-1323" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Harder to see hyperbolic distances</span>
<span id="cb32-1324"><a href="#cb32-1324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1325"><a href="#cb32-1325" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1326"><a href="#cb32-1326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1327"><a href="#cb32-1327" aria-hidden="true" tabindex="-1"></a><span class="fu">### Other Triangle Groups</span></span>
<span id="cb32-1328"><a href="#cb32-1328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1329"><a href="#cb32-1329" aria-hidden="true" tabindex="-1"></a>The $(2,3,\infty)$ triangle is just the beginning. Many other hyperbolic triangles can tile the plane! The most famous is the $(2,3,7)$ triangle.</span>
<span id="cb32-1330"><a href="#cb32-1330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1331"><a href="#cb32-1331" aria-hidden="true" tabindex="-1"></a><span class="fu">#### The $(2,3,7)$ Triangle</span></span>
<span id="cb32-1332"><a href="#cb32-1332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1333"><a href="#cb32-1333" aria-hidden="true" tabindex="-1"></a>This triangle has angles $\pi/2$, $\pi/3$, and $\pi/7$. Its area is:</span>
<span id="cb32-1334"><a href="#cb32-1334" aria-hidden="true" tabindex="-1"></a>$$\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + \frac{\pi}{7}\right) = \frac{\pi}{42}$$</span>
<span id="cb32-1335"><a href="#cb32-1335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1336"><a href="#cb32-1336" aria-hidden="true" tabindex="-1"></a>This is one of the smallest compact hyperbolic triangles! It produces incredibly dense tilings—the $(2,3,7)$ tiling has a 7-fold symmetry that creates intricate patterns reminiscent of M.C. Escher's work.</span>
<span id="cb32-1337"><a href="#cb32-1337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1338"><a href="#cb32-1338" aria-hidden="true" tabindex="-1"></a>In fact, Escher's famous *Circle Limit* prints (especially Circle Limit III with the fish) are based on tilings by $(2,3,7)$ and related triangle groups. The hyperbolic geometry creates the exponential compression toward the boundary that gives these prints their distinctive character.</span>
<span id="cb32-1339"><a href="#cb32-1339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1340"><a href="#cb32-1340" aria-hidden="true" tabindex="-1"></a>**Classification of hyperbolic triangles**: Not every combination $(p,q,r)$ gives a hyperbolic triangle. The Gauss-Bonnet formula tells us we need:</span>
<span id="cb32-1341"><a href="#cb32-1341" aria-hidden="true" tabindex="-1"></a>$$\frac{1}{p} + \frac{1}{q} + \frac{1}{r} &lt; 1$$</span>
<span id="cb32-1342"><a href="#cb32-1342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1343"><a href="#cb32-1343" aria-hidden="true" tabindex="-1"></a>for a hyperbolic triangle (negative curvature). If the sum equals exactly $1$, we get a Euclidean triangle. If the sum is greater than $1$, we get a spherical triangle (positive curvature).</span>
<span id="cb32-1344"><a href="#cb32-1344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1345"><a href="#cb32-1345" aria-hidden="true" tabindex="-1"></a>**Examples**:</span>
<span id="cb32-1346"><a href="#cb32-1346" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(2,3,7)$: $\frac{1}{2} + \frac{1}{3} + \frac{1}{7} = \frac{41}{42} &lt; 1$ ✓ Hyperbolic</span>
<span id="cb32-1347"><a href="#cb32-1347" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(2,3,\infty)$: $\frac{1}{2} + \frac{1}{3} + 0 = \frac{5}{6} &lt; 1$ ✓ Hyperbolic</span>
<span id="cb32-1348"><a href="#cb32-1348" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(3,3,3)$: $\frac{1}{3} + \frac{1}{3} + \frac{1}{3} = 1$ ✓ Euclidean (equilateral triangle)</span>
<span id="cb32-1349"><a href="#cb32-1349" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(2,3,5)$: $\frac{1}{2} + \frac{1}{3} + \frac{1}{5} = \frac{31}{30} &gt; 1$ ✓ Spherical (icosahedron face)</span>
<span id="cb32-1350"><a href="#cb32-1350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1351"><a href="#cb32-1351" aria-hidden="true" tabindex="-1"></a>Implementing other triangle groups requires computing where the third geodesic should be, given the angle constraints. This is non-trivial and involves hyperbolic trigonometry—we leave this as an advanced homework exercise!</span>
<span id="cb32-1352"><a href="#cb32-1352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1353"><a href="#cb32-1353" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1354"><a href="#cb32-1354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1355"><a href="#cb32-1355" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb32-1356"><a href="#cb32-1356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1357"><a href="#cb32-1357" aria-hidden="true" tabindex="-1"></a>Today we learned:</span>
<span id="cb32-1358"><a href="#cb32-1358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1359"><a href="#cb32-1359" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**The folding algorithm**: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry</span>
<span id="cb32-1360"><a href="#cb32-1360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1361"><a href="#cb32-1361" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Half-space structure**: Boundary + side gives a unified way to encode regions in Euclidean geometry</span>
<span id="cb32-1362"><a href="#cb32-1362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1363"><a href="#cb32-1363" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Why it works**: **Reflection groups** and fundamental domains—the group-theoretic perspective that unifies all our iterative algorithms across Days 2 and 3</span>
<span id="cb32-1364"><a href="#cb32-1364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1365"><a href="#cb32-1365" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Hyperbolic geometry**: Negative curvature space with two types of geodesics (vertical lines and semicircles in the UHP model)</span>
<span id="cb32-1366"><a href="#cb32-1366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1367"><a href="#cb32-1367" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Connection to Day 2**: Circle inversion is a hyperbolic isometry! The Apollonian gasket is actually a hyperbolic object</span>
<span id="cb32-1368"><a href="#cb32-1368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1369"><a href="#cb32-1369" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**Two reflection functions**: <span class="in">`reflectIntoVertical`</span> and <span class="in">`reflectIntoCircular`</span> parallel the Euclidean <span class="in">`reflectInto`</span></span>
<span id="cb32-1370"><a href="#cb32-1370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1371"><a href="#cb32-1371" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**Multiple models**: Converting between upper half-plane and Poincaré disk using the Cayley transform</span>
<span id="cb32-1372"><a href="#cb32-1372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1373"><a href="#cb32-1373" aria-hidden="true" tabindex="-1"></a><span class="ss">8. </span>**Historical context**: The dramatic discovery of hyperbolic geometry by Gauss, Bolyai, and Lobachevsky in the 19th century</span>
<span id="cb32-1374"><a href="#cb32-1374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1375"><a href="#cb32-1375" aria-hidden="true" tabindex="-1"></a><span class="ss">9. </span>**Computational perspective**: GPU parallelism, convergence rates, precision issues, iteration count tuning</span>
<span id="cb32-1376"><a href="#cb32-1376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1377"><a href="#cb32-1377" aria-hidden="true" tabindex="-1"></a>**Key insight**: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!</span>
<span id="cb32-1378"><a href="#cb32-1378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1379"><a href="#cb32-1379" aria-hidden="true" tabindex="-1"></a>**The universal pattern**:</span>
<span id="cb32-1380"><a href="#cb32-1380" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Day 1**: Distance fields and implicit curves—visualizing mathematics on the GPU</span>
<span id="cb32-1381"><a href="#cb32-1381" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Day 2**: Iterating circle inversions to create the Apollonian gasket—first group action</span>
<span id="cb32-1382"><a href="#cb32-1382" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Day 3 (Euclidean)**: Iterating reflections to create tilings—reflection groups make it work</span>
<span id="cb32-1383"><a href="#cb32-1383" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Day 3 (Hyperbolic)**: Same algorithm, different geometry—circle inversion reappears as hyperbolic isometry!</span>
<span id="cb32-1384"><a href="#cb32-1384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1385"><a href="#cb32-1385" aria-hidden="true" tabindex="-1"></a>The through-line is **geometric transformations and their groups**. When we iterate a group action to reach a fundamental domain, we create tilings, fractals, and beautiful mathematical art.</span>
<span id="cb32-1386"><a href="#cb32-1386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1387"><a href="#cb32-1387" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1388"><a href="#cb32-1388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1389"><a href="#cb32-1389" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb32-1390"><a href="#cb32-1390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1391"><a href="#cb32-1391" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #0: Understanding Hyperbolic Distance</span></span>
<span id="cb32-1392"><a href="#cb32-1392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1393"><a href="#cb32-1393" aria-hidden="true" tabindex="-1"></a>**Goal**: Build geometric intuition for how hyperbolic distance works before implementing tilings.</span>
<span id="cb32-1394"><a href="#cb32-1394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1395"><a href="#cb32-1395" aria-hidden="true" tabindex="-1"></a>**Tasks**:</span>
<span id="cb32-1396"><a href="#cb32-1396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1397"><a href="#cb32-1397" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Euclidean distance visualization**: Implement the shader showing Euclidean distance circles (provided in lecture). Drag the center around and observe that circles stay the same size everywhere.</span>
<span id="cb32-1398"><a href="#cb32-1398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1399"><a href="#cb32-1399" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Hyperbolic distance visualization**: Implement the hyperbolic version (provided in lecture). Drag the center and observe how the "circle" changes shape—growing huge near $y \to 0$ and shrinking as $y$ increases.</span>
<span id="cb32-1400"><a href="#cb32-1400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1401"><a href="#cb32-1401" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Observations**: Write 2-3 sentences describing what you observe about how hyperbolic "circles" behave compared to Euclidean ones. Why does the shape change as you drag the center?</span>
<span id="cb32-1402"><a href="#cb32-1402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1403"><a href="#cb32-1403" aria-hidden="true" tabindex="-1"></a>**Expected output**: Two working shaders demonstrating the difference between Euclidean and hyperbolic distance.</span>
<span id="cb32-1404"><a href="#cb32-1404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1405"><a href="#cb32-1405" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1406"><a href="#cb32-1406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1407"><a href="#cb32-1407" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #1: Euclidean Triangle Tiling with Edges and Vertices</span></span>
<span id="cb32-1408"><a href="#cb32-1408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1409"><a href="#cb32-1409" aria-hidden="true" tabindex="-1"></a>**Goal**: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.</span>
<span id="cb32-1410"><a href="#cb32-1410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1411"><a href="#cb32-1411" aria-hidden="true" tabindex="-1"></a>**Tasks**:</span>
<span id="cb32-1412"><a href="#cb32-1412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1413"><a href="#cb32-1413" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Start with the basic triangle tiling from lecture</span>
<span id="cb32-1414"><a href="#cb32-1414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1415"><a href="#cb32-1415" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Add edge visualization** using distance to half-spaces</span>
<span id="cb32-1416"><a href="#cb32-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1417"><a href="#cb32-1417" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Add vertex markers** at the three triangle vertices</span>
<span id="cb32-1418"><a href="#cb32-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1419"><a href="#cb32-1419" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Create an attractive color scheme**</span>
<span id="cb32-1420"><a href="#cb32-1420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1421"><a href="#cb32-1421" aria-hidden="true" tabindex="-1"></a>**Expected output**: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.</span>
<span id="cb32-1422"><a href="#cb32-1422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1423"><a href="#cb32-1423" aria-hidden="true" tabindex="-1"></a>See Appendix E9 for reference implementation.</span>
<span id="cb32-1424"><a href="#cb32-1424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1425"><a href="#cb32-1425" aria-hidden="true" tabindex="-1"></a>**Bonus**: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.</span>
<span id="cb32-1426"><a href="#cb32-1426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1427"><a href="#cb32-1427" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1428"><a href="#cb32-1428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1429"><a href="#cb32-1429" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #2: Hyperbolic Triangle Tiling with Edges and Vertices</span></span>
<span id="cb32-1430"><a href="#cb32-1430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1431"><a href="#cb32-1431" aria-hidden="true" tabindex="-1"></a>**Goal**: Create a beautiful hyperbolic triangle tiling with visible structure.</span>
<span id="cb32-1432"><a href="#cb32-1432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1433"><a href="#cb32-1433" aria-hidden="true" tabindex="-1"></a>**Tasks**:</span>
<span id="cb32-1434"><a href="#cb32-1434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1435"><a href="#cb32-1435" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Start with the basic $(2,3,\infty)$ tiling from lecture</span>
<span id="cb32-1436"><a href="#cb32-1436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1437"><a href="#cb32-1437" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Implement hyperbolic distance functions** (see hints in lecture)</span>
<span id="cb32-1438"><a href="#cb32-1438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1439"><a href="#cb32-1439" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Draw geodesic edges** using hyperbolic distance to geodesics</span>
<span id="cb32-1440"><a href="#cb32-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1441"><a href="#cb32-1441" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Draw vertices** using hyperbolic distance to vertex points</span>
<span id="cb32-1442"><a href="#cb32-1442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1443"><a href="#cb32-1443" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Create an attractive color scheme**</span>
<span id="cb32-1444"><a href="#cb32-1444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1445"><a href="#cb32-1445" aria-hidden="true" tabindex="-1"></a>**Expected output**: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.</span>
<span id="cb32-1446"><a href="#cb32-1446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1447"><a href="#cb32-1447" aria-hidden="true" tabindex="-1"></a>See Appendix H5 for complete reference implementation.</span>
<span id="cb32-1448"><a href="#cb32-1448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1449"><a href="#cb32-1449" aria-hidden="true" tabindex="-1"></a>**Bonus**: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.</span>
<span id="cb32-1450"><a href="#cb32-1450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1451"><a href="#cb32-1451" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1452"><a href="#cb32-1452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1453"><a href="#cb32-1453" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #3: Model Conversions</span></span>
<span id="cb32-1454"><a href="#cb32-1454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1455"><a href="#cb32-1455" aria-hidden="true" tabindex="-1"></a>**Goal**: See the same tiling in different representations of hyperbolic space.</span>
<span id="cb32-1456"><a href="#cb32-1456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1457"><a href="#cb32-1457" aria-hidden="true" tabindex="-1"></a>**Tasks**:</span>
<span id="cb32-1458"><a href="#cb32-1458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1459"><a href="#cb32-1459" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Poincaré Disk** (already provided in lecture): Verify it works with your tiling code</span>
<span id="cb32-1460"><a href="#cb32-1460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1461"><a href="#cb32-1461" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Klein Model**: Implement the transformation from Poincaré disk to Klein disk (see lecture for formula)</span>
<span id="cb32-1462"><a href="#cb32-1462" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="cb32-1463"><a href="#cb32-1463" aria-hidden="true" tabindex="-1"></a>   In the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.</span>
<span id="cb32-1464"><a href="#cb32-1464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1465"><a href="#cb32-1465" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Comparison**: Show your $(2,3,\infty)$ tiling in both the Poincaré disk and Klein model side-by-side. Write a few sentences about what you observe.</span>
<span id="cb32-1466"><a href="#cb32-1466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1467"><a href="#cb32-1467" aria-hidden="true" tabindex="-1"></a>**Deliverable**: Screenshots of your tiling in at least two models, with brief observations.</span>
<span id="cb32-1468"><a href="#cb32-1468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1469"><a href="#cb32-1469" aria-hidden="true" tabindex="-1"></a>See Appendix H7 for Klein model reference.</span>
<span id="cb32-1470"><a href="#cb32-1470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1471"><a href="#cb32-1471" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1472"><a href="#cb32-1472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1473"><a href="#cb32-1473" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required #4: Different Triangle Groups (Challenge!)</span></span>
<span id="cb32-1474"><a href="#cb32-1474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1475"><a href="#cb32-1475" aria-hidden="true" tabindex="-1"></a>**Goal**: Explore other hyperbolic tilings by implementing different triangle groups.</span>
<span id="cb32-1476"><a href="#cb32-1476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1477"><a href="#cb32-1477" aria-hidden="true" tabindex="-1"></a>**The Challenge**: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.</span>
<span id="cb32-1478"><a href="#cb32-1478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1479"><a href="#cb32-1479" aria-hidden="true" tabindex="-1"></a>**Suggested triangles to try**:</span>
<span id="cb32-1480"><a href="#cb32-1480" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**(2, 3, 7)**: Creates Escher-like tilings with 7-fold symmetry</span>
<span id="cb32-1481"><a href="#cb32-1481" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**(2, 4, 6)**: Different symmetry pattern</span>
<span id="cb32-1482"><a href="#cb32-1482" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**(3, 3, 3)**: Equilateral hyperbolic triangle  </span>
<span id="cb32-1483"><a href="#cb32-1483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1484"><a href="#cb32-1484" aria-hidden="true" tabindex="-1"></a>**Approach**: Use the hyperbolic law of cosines (see lecture for formula) to compute geodesic positions.</span>
<span id="cb32-1485"><a href="#cb32-1485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1486"><a href="#cb32-1486" aria-hidden="true" tabindex="-1"></a>**Deliverable**: Working tiling for at least one triangle group other than $(2,3,\infty)$. Include screenshots and document your approach.</span>
<span id="cb32-1487"><a href="#cb32-1487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1488"><a href="#cb32-1488" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1489"><a href="#cb32-1489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1490"><a href="#cb32-1490" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional Exercises</span></span>
<span id="cb32-1491"><a href="#cb32-1491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1492"><a href="#cb32-1492" aria-hidden="true" tabindex="-1"></a>**Optional #1: Unified Abstractions** - Create structs that work for both Euclidean and hyperbolic geometry</span>
<span id="cb32-1493"><a href="#cb32-1493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1494"><a href="#cb32-1494" aria-hidden="true" tabindex="-1"></a>**Optional #2: Decorated Tiles** - Add Escher-style patterns within fundamental domains</span>
<span id="cb32-1495"><a href="#cb32-1495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1496"><a href="#cb32-1496" aria-hidden="true" tabindex="-1"></a>**Optional #3: Pentagon Tilings** - Right-angled pentagons can tile hyperbolic space!</span>
<span id="cb32-1497"><a href="#cb32-1497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1498"><a href="#cb32-1498" aria-hidden="true" tabindex="-1"></a>See lecture for details on these optional exercises.</span>
<span id="cb32-1499"><a href="#cb32-1499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1500"><a href="#cb32-1500" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb32-1501"><a href="#cb32-1501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1502"><a href="#cb32-1502" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking Ahead</span></span>
<span id="cb32-1503"><a href="#cb32-1503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1504"><a href="#cb32-1504" aria-hidden="true" tabindex="-1"></a>We've now seen three days of geometric iteration:</span>
<span id="cb32-1505"><a href="#cb32-1505" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Day 1**: Distance fields and implicit functions</span>
<span id="cb32-1506"><a href="#cb32-1506" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Day 2**: Circle inversion and the Apollonian gasket</span>
<span id="cb32-1507"><a href="#cb32-1507" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Day 3**: Reflection groups in Euclidean and hyperbolic geometry</span>
<span id="cb32-1508"><a href="#cb32-1508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1509"><a href="#cb32-1509" aria-hidden="true" tabindex="-1"></a>The common thread: **group actions on geometric spaces**. Iteratively applying transformations to reach a desired region, whether it's the fundamental domain of a tiling or the gap structure of a fractal.</span>
<span id="cb32-1510"><a href="#cb32-1510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-1511"><a href="#cb32-1511" aria-hidden="true" tabindex="-1"></a>The techniques you've learned—GPU parallelism, iterative algorithms, group theory, geometric transformations—apply across a huge landscape of mathematical visualization!</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>