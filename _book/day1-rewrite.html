<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Day 1: Introduction to Shader Programming – GPU-Accelerated Mathematical Illustration</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./day2.html" rel="next">
<link href="./outline.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-86daaaaad7353f9cc0c554efc1dd6d94.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-f8dc6eab18fde03278982b0b35885446.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ed04f5f1653af6df52378e13bfdac05e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-d37bfdfd9a2222927534875c15a9020f.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./day1-rewrite.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">GPU-Accelerated Mathematical Illustration</a> 
        <div class="sidebar-tools-main tools-wide">
    <a href="https://github.com/yourusername/shader-course" title="Source Code" class="quarto-navigation-tool px-1" aria-label="Source Code"><i class="bi bi-github"></i></a>
    <a href="./GPU-Accelerated-Mathematical-Illustration.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./outline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Outline</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day1-rewrite.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Day 4: Introduction to 3D Rendering</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5a.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Day 5a</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./day5b.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Day 5bs</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./glsl-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">GLSL</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./debug-reference.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Debugging</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./folding-fractals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Folding Fractals</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./schottky.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Schottky Groups, Möbius Maps, and GLSL</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview"><span class="header-section-number">1.1</span> Overview</a></li>
  <li><a href="#what-is-a-shader" id="toc-what-is-a-shader" class="nav-link" data-scroll-target="#what-is-a-shader"><span class="header-section-number">1.2</span> What is a Shader?</a>
  <ul class="collapse">
  <li><a href="#mathematical-perspective" id="toc-mathematical-perspective" class="nav-link" data-scroll-target="#mathematical-perspective">Mathematical Perspective</a></li>
  <li><a href="#why-shadertoy" id="toc-why-shadertoy" class="nav-link" data-scroll-target="#why-shadertoy">Why Shadertoy?</a></li>
  </ul></li>
  <li><a href="#first-shader-solid-colors" id="toc-first-shader-solid-colors" class="nav-link" data-scroll-target="#first-shader-solid-colors"><span class="header-section-number">1.3</span> First Shader: Solid Colors</a>
  <ul class="collapse">
  <li><a href="#basic-structure" id="toc-basic-structure" class="nav-link" data-scroll-target="#basic-structure">Basic Structure</a></li>
  <li><a href="#example-red-screen" id="toc-example-red-screen" class="nav-link" data-scroll-target="#example-red-screen">Example: Red Screen</a></li>
  <li><a href="#glsl-syntax-basics" id="toc-glsl-syntax-basics" class="nav-link" data-scroll-target="#glsl-syntax-basics">GLSL Syntax Basics</a></li>
  <li><a href="#animating-with-time" id="toc-animating-with-time" class="nav-link" data-scroll-target="#animating-with-time">Animating with Time</a></li>
  </ul></li>
  <li><a href="#coordinate-systems" id="toc-coordinate-systems" class="nav-link" data-scroll-target="#coordinate-systems"><span class="header-section-number">1.4</span> Coordinate Systems</a>
  <ul class="collapse">
  <li><a href="#raw-coordinates" id="toc-raw-coordinates" class="nav-link" data-scroll-target="#raw-coordinates">Raw Coordinates</a></li>
  <li><a href="#centered-normalized-coordinates" id="toc-centered-normalized-coordinates" class="nav-link" data-scroll-target="#centered-normalized-coordinates">Centered, Normalized Coordinates</a></li>
  <li><a href="#visualizing-coordinates" id="toc-visualizing-coordinates" class="nav-link" data-scroll-target="#visualizing-coordinates">Visualizing Coordinates</a></li>
  </ul></li>
  <li><a href="#conditional-coloring-half-planes" id="toc-conditional-coloring-half-planes" class="nav-link" data-scroll-target="#conditional-coloring-half-planes"><span class="header-section-number">1.5</span> Conditional Coloring: Half-Planes</a>
  <ul class="collapse">
  <li><a href="#the-concept" id="toc-the-concept" class="nav-link" data-scroll-target="#the-concept">The Concept</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  <li><a href="#the-step-function" id="toc-the-step-function" class="nav-link" data-scroll-target="#the-step-function">The Step Function</a></li>
  <li><a href="#arbitrary-half-planes" id="toc-arbitrary-half-planes" class="nav-link" data-scroll-target="#arbitrary-half-planes">Arbitrary Half-Planes</a></li>
  </ul></li>
  <li><a href="#distance-fields-and-circles" id="toc-distance-fields-and-circles" class="nav-link" data-scroll-target="#distance-fields-and-circles"><span class="header-section-number">1.6</span> Distance Fields and Circles</a>
  <ul class="collapse">
  <li><a href="#distance-to-center" id="toc-distance-to-center" class="nav-link" data-scroll-target="#distance-to-center">Distance to Center</a></li>
  <li><a href="#filled-circle" id="toc-filled-circle" class="nav-link" data-scroll-target="#filled-circle">Filled Circle</a></li>
  <li><a href="#distance-based-coloring" id="toc-distance-based-coloring" class="nav-link" data-scroll-target="#distance-based-coloring">Distance-Based Coloring</a></li>
  <li><a href="#circle-outline" id="toc-circle-outline" class="nav-link" data-scroll-target="#circle-outline">Circle Outline</a></li>
  </ul></li>
  <li><a href="#grids-and-repetition" id="toc-grids-and-repetition" class="nav-link" data-scroll-target="#grids-and-repetition"><span class="header-section-number">1.7</span> Grids and Repetition</a>
  <ul class="collapse">
  <li><a href="#modular-arithmetic" id="toc-modular-arithmetic" class="nav-link" data-scroll-target="#modular-arithmetic">Modular Arithmetic</a></li>
  <li><a href="#creating-a-grid" id="toc-creating-a-grid" class="nav-link" data-scroll-target="#creating-a-grid">Creating a Grid</a></li>
  <li><a href="#alternating-pattern" id="toc-alternating-pattern" class="nav-link" data-scroll-target="#alternating-pattern">Alternating Pattern</a></li>
  <li><a href="#combining-with-circles" id="toc-combining-with-circles" class="nav-link" data-scroll-target="#combining-with-circles">Combining with Circles</a></li>
  </ul></li>
  <li><a href="#implicit-curves" id="toc-implicit-curves" class="nav-link" data-scroll-target="#implicit-curves"><span class="header-section-number">1.8</span> Implicit Curves</a>
  <ul class="collapse">
  <li><a href="#general-principle" id="toc-general-principle" class="nav-link" data-scroll-target="#general-principle">General Principle</a></li>
  <li><a href="#example-parabola" id="toc-example-parabola" class="nav-link" data-scroll-target="#example-parabola">Example: Parabola</a></li>
  <li><a href="#example-circle-implicit-form" id="toc-example-circle-implicit-form" class="nav-link" data-scroll-target="#example-circle-implicit-form">Example: Circle (Implicit Form)</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary"><span class="header-section-number">1.9</span> Summary</a></li>
  <li><a href="#homework" id="toc-homework" class="nav-link" data-scroll-target="#homework"><span class="header-section-number">1.10</span> Homework</a>
  <ul class="collapse">
  <li><a href="#required-parabola-graphing-calculator" id="toc-required-parabola-graphing-calculator" class="nav-link" data-scroll-target="#required-parabola-graphing-calculator">Required: Parabola Graphing Calculator</a></li>
  <li><a href="#optional-1-animated-curve-family" id="toc-optional-1-animated-curve-family" class="nav-link" data-scroll-target="#optional-1-animated-curve-family">Optional #1: Animated Curve Family</a></li>
  <li><a href="#optional-2-beautiful-tiling-pattern" id="toc-optional-2-beautiful-tiling-pattern" class="nav-link" data-scroll-target="#optional-2-beautiful-tiling-pattern">Optional #2: Beautiful Tiling Pattern</a></li>
  </ul></li>
  <li><a href="#looking-ahead" id="toc-looking-ahead" class="nav-link" data-scroll-target="#looking-ahead"><span class="header-section-number">1.11</span> Looking Ahead</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Day 1: Introduction to Shader Programming</span></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="overview"><span class="header-section-number">1.1</span> Overview</h2>
<p>Today we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.</p>
<p>By the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.</p>
<hr>
</section>
<section id="what-is-a-shader" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="what-is-a-shader"><span class="header-section-number">1.2</span> What is a Shader?</h2>
<section id="mathematical-perspective" class="level3">
<h3 class="anchored" data-anchor-id="mathematical-perspective">Mathematical Perspective</h3>
<p>A shader is fundamentally a function <span class="math display">\[f: \mathbb{R}^2 \times \mathbb{R} \times \cdots \to \mathbb{R}^4\]</span> that maps pixel coordinates (and potentially time, mouse position, etc.) to color values. For each pixel on the screen, we evaluate this function to determine what color to display.</p>
<p>Here’s the magic: modern GPUs can evaluate this function for <strong>all pixels simultaneously</strong>. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!</p>
<p>This is completely different from how you might write mathematical visualization code in, say, Python. There you’d have nested loops:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(width):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(height):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        color[x,y] <span class="op">=</span> f(x, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With shaders, there are no loops. You write the function <code>f</code>, and the GPU just <em>does it</em> everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why is this called a “shader”?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Historically, these programs were used for <em>shading</em> 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!</p>
</div>
</div>
</section>
<section id="why-shadertoy" class="level3">
<h3 class="anchored" data-anchor-id="why-shadertoy">Why Shadertoy?</h3>
<p>Shadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.</p>
<p>The platform provides several built-in <strong>uniforms</strong> (read-only global variables that are the same for all pixels):</p>
<ul>
<li><code>iResolution</code>: screen resolution as a <code>vec3</code> (width, height, pixel aspect ratio)</li>
<li><code>iTime</code>: elapsed time in seconds since the shader started</li>
<li><code>iMouse</code>: mouse position and click state as a <code>vec4</code></li>
</ul>
<p>We’ll use these throughout the week to create animated, interactive mathematical visualizations.</p>
<hr>
</section>
</section>
<section id="first-shader-solid-colors" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="first-shader-solid-colors"><span class="header-section-number">1.3</span> First Shader: Solid Colors</h2>
<section id="basic-structure" class="level3">
<h3 class="anchored" data-anchor-id="basic-structure">Basic Structure</h3>
<p>Every Shadertoy shader has the same entry point:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Your code here</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fragCoord</code>: the pixel coordinate we’re currently computing, as a <code>vec2</code> (x, y)</li>
<li><code>fragColor</code>: the output color we need to set, as a <code>vec4</code> (red, green, blue, alpha)</li>
</ul>
<p>Colors are represented in RGBA format with values in <span class="math inline">\([0, 1]\)</span>. So <code>vec4(1.0, 0.0, 0.0, 1.0)</code> represents opaque red, while <code>vec4(0.5, 0.5, 0.5, 1.0)</code> is middle gray.</p>
</section>
<section id="example-red-screen" class="level3">
<h3 class="anchored" data-anchor-id="example-red-screen">Example: Red Screen</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on <code>fragCoord</code>, every pixel gets the same value. Not very exciting—but it’s a start!</p>
</section>
<section id="glsl-syntax-basics" class="level3">
<h3 class="anchored" data-anchor-id="glsl-syntax-basics">GLSL Syntax Basics</h3>
<p>Before we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
GLSL Syntax Rules
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Semicolons are required.</strong> Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.</p>
<p><strong>Floating point literals:</strong> Write <code>1.0</code> not <code>1</code> for floating point values. GLSL is very picky about types—if you write <code>1</code>, it’s an integer, and mixing types causes errors. Get in the habit of always writing the <code>.0</code>.</p>
<p><strong>Vector types:</strong> GLSL has built-in types <code>vec2</code>, <code>vec3</code>, <code>vec4</code> for 2D, 3D, and 4D vectors. You can construct them with:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> v <span class="op">=</span> <span class="dt">vec2</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> w <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec4</span> color <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>v<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Can combine vectors and scalars</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Swizzling:</strong> You can access components by name: <code>v.x</code>, <code>v.y</code> or equivalently <code>v.r</code>, <code>v.g</code> (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: <code>v.yx</code> swaps the coordinates, <code>v.xxx</code> repeats the x-component three times. This is incredibly useful!</p>
</div>
</div>
</section>
<section id="animating-with-time" class="level3">
<h3 class="anchored" data-anchor-id="animating-with-time">Animating with Time</h3>
<p>Let’s make something that changes:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> red <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="bu">sin</span><span class="op">(</span>iTime<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>red<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here <code>iTime</code> grows continuously, <code>sin(iTime)</code> oscillates between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>, and we remap to <span class="math inline">\([0, 1]\)</span> with the affine transformation <span class="math inline">\(x \mapsto \frac{1}{2}(1 + x)\)</span>. The screen now pulses between black and red!</p>
<p>This pattern—<code>0.5 + 0.5 * sin(...)</code>—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range <span class="math inline">\([0,1]\)</span>.</p>
<hr>
</section>
</section>
<section id="coordinate-systems" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="coordinate-systems"><span class="header-section-number">1.4</span> Coordinate Systems</h2>
<section id="raw-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="raw-coordinates">Raw Coordinates</h3>
<p>By default, <code>fragCoord</code> gives pixel coordinates with:</p>
<ul>
<li>Origin <span class="math inline">\((0, 0)\)</span> at the bottom-left</li>
<li><span class="math inline">\(x\)</span> increases rightward to <code>iResolution.x</code></li>
<li><span class="math inline">\(y\)</span> increases upward to <code>iResolution.y</code></li>
</ul>
<p>This is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!</p>
</section>
<section id="centered-normalized-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="centered-normalized-coordinates">Centered, Normalized Coordinates</h3>
<p>Here’s the standard transformation we’ll use in every shader:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Normalize to [0,1]</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> uv <span class="op">=</span> fragCoord <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">xy</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Center at origin: [-0.5, 0.5]</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    uv <span class="op">=</span> uv <span class="op">-</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to account for aspect ratio</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    uv<span class="op">.</span><span class="fu">x</span> <span class="op">*=</span> iResolution<span class="op">.</span><span class="fu">x</span> <span class="op">/</span> iResolution<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now uv is centered and aspect-corrected</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Scale to desired viewing window (e.g., [-2, 2] on x-axis)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> p <span class="op">=</span> uv <span class="op">*</span> <span class="fl">4.0</span><span class="op">;</span>  <span class="co">// Now p is in [-2, 2] × [-h, h] where h depends on aspect ratio</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s break this down step by step:</p>
<ol type="1">
<li><strong>Normalize</strong>: Dividing by <code>iResolution.xy</code> maps from pixel coordinates to <span class="math inline">\([0,1] \times [0,1]\)</span></li>
<li><strong>Center</strong>: Subtracting <span class="math inline">\(0.5\)</span> shifts the origin to the center: <span class="math inline">\([-0.5, 0.5] \times [-0.5, 0.5]\)</span></li>
<li><strong>Aspect correction</strong>: Multiplying <code>uv.x</code> by the aspect ratio ensures that equal distances in <code>uv.x</code> and <code>uv.y</code> correspond to equal screen distances—this makes circles actually circular!</li>
<li><strong>Scale</strong>: Finally, we scale to whatever viewing window we want for our visualization</li>
</ol>
<p>From now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable <code>p</code> for “position.”</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The coordinate transformation boilerplate
</div>
</div>
<div class="callout-body-container callout-body">
<p>You’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit.</p>
</div>
</div>
</section>
<section id="visualizing-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-coordinates">Visualizing Coordinates</h3>
<p>Let’s verify our coordinate system is working by coloring pixels according to their position:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup as above, resulting in p]</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Map x coordinate to red, y to green</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> color_rg <span class="op">=</span> p <span class="op">*</span> <span class="fl">0.5</span> <span class="op">+</span> <span class="fl">0.5</span><span class="op">;</span>  <span class="co">// Remap to [0, 1]</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color_rg<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup!</p>
<hr>
</section>
</section>
<section id="conditional-coloring-half-planes" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="conditional-coloring-half-planes"><span class="header-section-number">1.5</span> Conditional Coloring: Half-Planes</h2>
<section id="the-concept" class="level3">
<h3 class="anchored" data-anchor-id="the-concept">The Concept</h3>
<p>Given a linear function <span class="math inline">\(L(x, y) = ax + by\)</span>, we want to color pixels differently depending on whether <span class="math inline">\(L(p) &lt; 0\)</span> or <span class="math inline">\(L(p) \geq 0\)</span>. This divides the plane into two half-planes—the regions where the function is negative vs.&nbsp;positive.</p>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>GLSL provides a conditional operator (ternary operator) just like C:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup, resulting in p]</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> L <span class="op">=</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span>  <span class="co">// The function L(x,y) = x</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>L <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Left half-plane is red, right half-plane is blue. Simple!</p>
</section>
<section id="the-step-function" class="level3">
<h3 class="anchored" data-anchor-id="the-step-function">The Step Function</h3>
<p>GLSL also provides <code>step(edge, x)</code> which returns <span class="math inline">\(0\)</span> if <span class="math inline">\(x &lt; \text{edge}\)</span> and <span class="math inline">\(1\)</span> otherwise. This is useful for writing cleaner code without explicit conditionals:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> s <span class="op">=</span> <span class="bu">step</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> p<span class="op">.</span><span class="fu">x</span><span class="op">);</span>  <span class="co">// 0 on left, 1 on right</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">),</span> s<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here <code>mix(a, b, t)</code> performs linear interpolation: <span class="math inline">\((1-t)a + tb\)</span>. So when <code>s = 0</code> we get pure red, when <code>s = 1</code> we get pure blue.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why use <code>step</code> instead of the ternary operator?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Both work fine! The ternary operator <code>?:</code> is more explicit and familiar if you know C-like languages. But <code>step</code> and <code>mix</code> are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation.</p>
</div>
</div>
</section>
<section id="arbitrary-half-planes" class="level3">
<h3 class="anchored" data-anchor-id="arbitrary-half-planes">Arbitrary Half-Planes</h3>
<p>For a general line <span class="math inline">\(ax + by = 0\)</span>, we just evaluate the corresponding linear function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">,</span> b <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> L <span class="op">=</span> a <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> b <span class="op">*</span> p<span class="op">.</span><span class="fu">y</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>L <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Try different values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> to see different line orientations. The line itself is where <span class="math inline">\(L = 0\)</span>, and we’re coloring the two sides differently.</p>
<hr>
</section>
</section>
<section id="distance-fields-and-circles" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="distance-fields-and-circles"><span class="header-section-number">1.6</span> Distance Fields and Circles</h2>
<section id="distance-to-center" class="level3">
<h3 class="anchored" data-anchor-id="distance-to-center">Distance to Center</h3>
<p>The distance from a point <span class="math inline">\(p = (x, y)\)</span> to the origin is just the usual Euclidean distance: <span class="math display">\[d = \|p\| = \sqrt{x^2 + y^2}\]</span></p>
<p>In GLSL this is built-in:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>length()</code> function computes the Euclidean norm of a vector. It works for <code>vec2</code>, <code>vec3</code>, <code>vec4</code>—whatever you need.</p>
</section>
<section id="filled-circle" class="level3">
<h3 class="anchored" data-anchor-id="filled-circle">Filled Circle</h3>
<p>A circle of radius <span class="math inline">\(r\)</span> centered at the origin is the set <span class="math inline">\(\{p : \|p\| &lt; r\}\)</span>—just points whose distance from the origin is less than <span class="math inline">\(r\)</span>. So to color the inside vs.&nbsp;outside of a circle, we just compare distances:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup]</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>That’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle.</p>
</section>
<section id="distance-based-coloring" class="level3">
<h3 class="anchored" data-anchor-id="distance-based-coloring">Distance-Based Coloring</h3>
<p>But we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> intensity <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> d <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span>  <span class="co">// Fades from 1 at center to 0 at distance 2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>intensity <span class="op">=</span> <span class="bu">clamp</span><span class="op">(</span>intensity<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// Keep it in [0, 1]</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>intensity<span class="op">);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This creates a radial gradient—bright at the center, dark at the edges. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!</p>
</section>
<section id="circle-outline" class="level3">
<h3 class="anchored" data-anchor-id="circle-outline">Circle Outline</h3>
<p>What if we want to draw just the <em>boundary</em> of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is <em>approximately equal</em> to the radius. Mathematically, we’re coloring the set <span class="math inline">\(\{p : |d(p) - r| &lt; \epsilon\}\)</span> where <span class="math inline">\(\epsilon\)</span> is a small thickness parameter:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>p<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> circle_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>d <span class="op">-</span> r<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span>circle_mask<span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This draws a thin white annulus around the circle. Play with the <code>thickness</code> parameter to see how it affects the line width!</p>
<p>For a smoother, anti-aliased edge, GLSL provides <code>smoothstep</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> circle_mask <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> <span class="bu">smoothstep</span><span class="op">(</span>r <span class="op">-</span> thickness<span class="op">,</span> r <span class="op">+</span> thickness<span class="op">,</span> d<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>smoothstep(a, b, x)</code> function performs smooth Hermite interpolation between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, transitioning gradually instead of having a hard cutoff. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Anti-aliasing in shaders
</div>
</div>
<div class="callout-body-container callout-body">
<p>The harsh cutoffs from using <code>&lt;</code> or the ternary operator create jagged, pixelated edges. Functions like <code>smoothstep</code> give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with <code>smoothstep</code> for smoother results.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="grids-and-repetition" class="level2" data-number="1.7">
<h2 data-number="1.7" class="anchored" data-anchor-id="grids-and-repetition"><span class="header-section-number">1.7</span> Grids and Repetition</h2>
<section id="modular-arithmetic" class="level3">
<h3 class="anchored" data-anchor-id="modular-arithmetic">Modular Arithmetic</h3>
<p>The modulo operation creates periodic repetition. For a period <span class="math inline">\(T\)</span>, the function <span class="math inline">\(p \mapsto (p \bmod T) - T/2\)</span> maps <span class="math inline">\(\mathbb{R}\)</span> to <span class="math inline">\([-T/2, T/2]\)</span> repeatedly—it “folds” the entire real line into a finite interval over and over again.</p>
<p>In GLSL, <code>mod(x, T)</code> computes <span class="math inline">\(x \bmod T\)</span>. This is one of the most powerful tools in shader programming!</p>
</section>
<section id="creating-a-grid" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-grid">Creating a Grid</h3>
<p>To create a grid of repeated cells, we apply <code>mod</code> to our coordinates:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup, resulting in p]</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> spacing <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>p <span class="op">+</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">,</span> spacing<span class="op">)</span> <span class="op">-</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Now cell_p repeats every spacing units</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Draw a circle in each cell</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>cell_p<span class="op">);</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">:</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">);</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This creates an infinite grid of yellow circles! The coordinate transformation <code>cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0</code> ensures that <code>cell_p</code> is always in the range <span class="math inline">\([-\text{spacing}/2, \text{spacing}/2]\)</span>, and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The power of <code>mod</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>Think about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation. This is the kind of efficiency that makes shaders special.</p>
</div>
</div>
</section>
<section id="alternating-pattern" class="level3">
<h3 class="anchored" data-anchor-id="alternating-pattern">Alternating Pattern</h3>
<p>We can create checkerboard-like patterns by using the <em>cell index</em> to vary colors. To get the cell index, we divide by the spacing and floor:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">/</span> spacing<span class="op">);</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> checker <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>cell_id<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> cell_id<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color_a <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color_b <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> bg_color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color_a<span class="op">,</span> color_b<span class="op">,</span> checker<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here <code>floor(p / spacing)</code> gives us integer grid indices <span class="math inline">\((i, j)\)</span>, and we alternate colors based on the parity of <span class="math inline">\(i + j\)</span>. When <span class="math inline">\(i + j\)</span> is even, <code>checker = 0</code> (red), when odd, <code>checker = 1</code> (blue).</p>
</section>
<section id="combining-with-circles" class="level3">
<h3 class="anchored" data-anchor-id="combining-with-circles">Combining with Circles</h3>
<p>Let’s put it all together—a grid of circles on an alternating background:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">mainImage</span><span class="op">(</span><span class="dt">out</span> <span class="dt">vec4</span> fragColor<span class="op">,</span> <span class="dt">in</span> <span class="dt">vec2</span> fragCoord<span class="op">)</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [Coordinate setup]</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> spacing <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_id <span class="op">=</span> <span class="bu">floor</span><span class="op">(</span>p <span class="op">/</span> spacing<span class="op">);</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec2</span> cell_p <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>p <span class="op">+</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">,</span> spacing<span class="op">)</span> <span class="op">-</span> spacing<span class="op">/</span><span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Checkerboard background</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> checker <span class="op">=</span> <span class="bu">mod</span><span class="op">(</span>cell_id<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> cell_id<span class="op">.</span><span class="fu">y</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">);</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> bg_color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">0.3</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">,</span> <span class="fl">0.2</span><span class="op">),</span> checker<span class="op">);</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Circle in each cell</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> d <span class="op">=</span> <span class="bu">length</span><span class="op">(</span>cell_p<span class="op">);</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> circle_color <span class="op">=</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">vec3</span> color <span class="op">=</span> <span class="op">(</span>d <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">?</span> circle_color <span class="op">:</span> bg_color<span class="op">;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Try varying the <code>spacing</code> and <code>r</code> parameters. What happens if you make the circles larger than the cells? What if you use different spacing values for <code>x</code> and <code>y</code>?</p>
<hr>
</section>
</section>
<section id="implicit-curves" class="level2" data-number="1.8">
<h2 data-number="1.8" class="anchored" data-anchor-id="implicit-curves"><span class="header-section-number">1.8</span> Implicit Curves</h2>
<section id="general-principle" class="level3">
<h3 class="anchored" data-anchor-id="general-principle">General Principle</h3>
<p>An implicit curve is defined by an equation <span class="math inline">\(F(x, y) = 0\)</span>. Points on the curve satisfy the equation exactly, while points off the curve have <span class="math inline">\(F(x,y) \neq 0\)</span>. To render the curve, we compute <span class="math inline">\(F(p)\)</span> for each pixel and color based on proximity to zero:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="op">[</span>some function of p<span class="op">.</span><span class="fu">x</span> and p<span class="op">.</span><span class="fu">y</span><span class="op">];</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>background<span class="op">,</span> curve_color<span class="op">,</span> curve_mask<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, whatever you want.</p>
</section>
<section id="example-parabola" class="level3">
<h3 class="anchored" data-anchor-id="example-parabola">Example: Parabola</h3>
<p>The parabola <span class="math inline">\(y = x^2\)</span> can be written implicitly as <span class="math inline">\(F(x, y) = y - x^2 = 0\)</span>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span><span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span><span class="dt">vec3</span><span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.3</span><span class="op">),</span> <span class="dt">vec3</span><span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">),</span> curve_mask<span class="op">);</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>fragColor <span class="op">=</span> <span class="dt">vec4</span><span class="op">(</span>color<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You should see a yellow parabola on a dark blue background. The curve appears wherever <span class="math inline">\(|F(x,y)| &lt; 0.1\)</span>—a thin band around the zero set of <span class="math inline">\(F\)</span>.</p>
<p>One thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker. This is because we’re thresholding on the <em>value</em> of <span class="math inline">\(F\)</span>, not the geometric distance to the curve. For perfectly uniform thickness, you’d need to compute the actual signed distance function—something we’ll talk more about on Day 4.</p>
</section>
<section id="example-circle-implicit-form" class="level3">
<h3 class="anchored" data-anchor-id="example-circle-implicit-form">Example: Circle (Implicit Form)</h3>
<p>We’ve been using <span class="math inline">\(\|p\| &lt; r\)</span> for filled circles, but we can also write the circle implicitly as <span class="math inline">\(x^2 + y^2 - r^2 = 0\)</span>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> <span class="bu">dot</span><span class="op">(</span>p<span class="op">,</span> p<span class="op">)</span> <span class="op">-</span> r <span class="op">*</span> r<span class="op">;</span>  <span class="co">// dot(p,p) = x² + y²</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> thickness <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> curve_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> thickness <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The <code>dot(p, p)</code> computes <span class="math inline">\(x^2 + y^2\)</span> efficiently.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Implicit curves in your homework
</div>
</div>
<div class="callout-body-container callout-body">
<p>When you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation <span class="math inline">\(F(x,y) = y - (ax^2 + bx + c)\)</span> and thresholding on <span class="math inline">\(|F| &lt; \epsilon\)</span>. Make sure to test with various values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> to ensure your grapher is robust!</p>
</div>
</div>
<hr>
</section>
</section>
<section id="summary" class="level2" data-number="1.9">
<h2 data-number="1.9" class="anchored" data-anchor-id="summary"><span class="header-section-number">1.9</span> Summary</h2>
<p>Today we’ve learned the fundamental tools of shader programming:</p>
<ol type="1">
<li><strong>Shaders as parallel functions</strong>: Every pixel evaluates <span class="math inline">\(f(x, y, t, \ldots) \to \text{color}\)</span> simultaneously—no loops required!</li>
<li><strong>GLSL basics</strong>: Syntax, vector types, and built-in functions like <code>length()</code>, <code>step()</code>, and <code>smoothstep()</code></li>
<li><strong>Coordinate systems</strong>: Centering, normalizing, and scaling for mathematical work</li>
<li><strong>Conditional coloring</strong>: Using boolean expressions and <code>step()</code> for discrete color regions</li>
<li><strong>Distance fields</strong>: Using <code>length()</code> to create circles and radial patterns—the foundation for much more complex techniques later</li>
<li><strong>Modular arithmetic</strong>: Creating grids and repeating patterns with <code>mod()</code>—infinite complexity with finite computation</li>
<li><strong>Implicit curves</strong>: Rendering curves defined by <span class="math inline">\(F(x, y) = 0\)</span> by thresholding on <span class="math inline">\(|F|\)</span></li>
</ol>
<p>With these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today.</p>
<hr>
</section>
<section id="homework" class="level2" data-number="1.10">
<h2 data-number="1.10" class="anchored" data-anchor-id="homework"><span class="header-section-number">1.10</span> Homework</h2>
<section id="required-parabola-graphing-calculator" class="level3">
<h3 class="anchored" data-anchor-id="required-parabola-graphing-calculator">Required: Parabola Graphing Calculator</h3>
<p>Create a shader that draws a customizable parabola <span class="math inline">\(y = ax^2 + bx + c\)</span> along with coordinate axes.</p>
<p><strong>Requirements:</strong></p>
<ul>
<li>Define variables <code>a</code>, <code>b</code>, <code>c</code> at the top of your shader (hardcoded values are fine)</li>
<li>Draw the <span class="math inline">\(x\)</span>-axis and <span class="math inline">\(y\)</span>-axis as thick lines (use the implicit line technique: <span class="math inline">\(|y| &lt; \epsilon\)</span> for <span class="math inline">\(x\)</span>-axis, <span class="math inline">\(|x| &lt; \epsilon\)</span> for <span class="math inline">\(y\)</span>-axis)</li>
<li>Plot the parabola <span class="math inline">\(y = ax^2 + bx + c\)</span> as a thick curve</li>
<li>Use distinct colors for axes and parabola</li>
<li>The visualization should work for any reasonable values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span></li>
</ul>
<p><strong>Suggested approach:</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode glsl code-with-copy"><code class="sourceCode glsl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define parameters</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> b <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> c <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Axes</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> x_axis_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">y</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.05</span> <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> y_axis_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>p<span class="op">.</span><span class="fu">x</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.05</span> <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Parabola: F(x,y) = y - (ax² + bx + c) = 0</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> F <span class="op">=</span> p<span class="op">.</span><span class="fu">y</span> <span class="op">-</span> <span class="op">(</span>a <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> b <span class="op">*</span> p<span class="op">.</span><span class="fu">x</span> <span class="op">+</span> c<span class="op">);</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> parabola_mask <span class="op">=</span> <span class="bu">abs</span><span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;</span> <span class="fl">0.1</span> <span class="op">?</span> <span class="fl">1.0</span> <span class="op">:</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Combine</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="dt">vec3</span> color <span class="op">=</span> background<span class="op">;</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> axis_color<span class="op">,</span> <span class="bu">max</span><span class="op">(</span>x_axis_mask<span class="op">,</span> y_axis_mask<span class="op">));</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> <span class="bu">mix</span><span class="op">(</span>color<span class="op">,</span> parabola_color<span class="op">,</span> parabola_mask<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Try different values of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span> and verify your grapher works correctly! What happens with negative <span class="math inline">\(a\)</span>? What about <span class="math inline">\(b \neq 0\)</span>? Make sure the axes and parabola remain visible for all parameter values you try.</p>
</section>
<section id="optional-1-animated-curve-family" class="level3">
<h3 class="anchored" data-anchor-id="optional-1-animated-curve-family">Optional #1: Animated Curve Family</h3>
<p>Create a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build intuition!</p>
<p><strong>Suggestions:</strong></p>
<ul>
<li><strong>Elliptic fibration</strong>: Take a cubic polynomial <span class="math inline">\(y^2 = x^3 + ax + b\)</span> and vary one parameter with <code>iTime</code>. The topology of the curve changes dramatically as you pass through singular values!</li>
<li><strong>Lissajous curves</strong>: Parametric curves <span class="math inline">\(x = A\sin(at + \delta)\)</span>, <span class="math inline">\(y = B\sin(bt)\)</span>. Animate <span class="math inline">\(\delta\)</span> or the frequency ratio to watch the curve morph through different patterns</li>
<li><strong>Cassini ovals</strong>: <span class="math inline">\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\)</span>. Vary the parameter and watch the curve transition from two separate loops to a single figure-eight-like shape</li>
</ul>
<p>Use <code>iTime</code> creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes!</p>
</section>
<section id="optional-2-beautiful-tiling-pattern" class="level3">
<h3 class="anchored" data-anchor-id="optional-2-beautiful-tiling-pattern">Optional #2: Beautiful Tiling Pattern</h3>
<p>Design an aesthetically pleasing tiling pattern using the <code>mod()</code> technique. This is your chance to be creative!</p>
<p><strong>Requirements:</strong></p>
<ul>
<li>Create a non-trivial pattern within a fundamental domain (a single tile)</li>
<li>Use <code>mod()</code> to repeat it across the plane</li>
<li>The pattern should tile seamlessly (edges should match up)</li>
</ul>
<p><strong>Ideas:</strong></p>
<ul>
<li>Geometric patterns: nested circles, polygons, stars</li>
<li>Color gradients that vary by tile position (using <code>cell_id</code>)</li>
<li>Combinations of implicit curves within each tile</li>
<li>Symmetry: use <code>abs()</code> to create reflections within tiles</li>
<li>Distance-based effects: make circles pulse or fade based on <code>iTime</code> and their position in the grid</li>
</ul>
<p><strong>Challenge</strong>: Can you create a pattern that has different symmetries in different tiles? (For example, alternating rotational symmetry using the checkerboard <code>cell_id</code> technique.) Or a pattern where the colors vary smoothly across the tiling, creating a large-scale gradient effect?</p>
<hr>
</section>
</section>
<section id="looking-ahead" class="level2" data-number="1.11">
<h2 data-number="1.11" class="anchored" data-anchor-id="looking-ahead"><span class="header-section-number">1.11</span> Looking Ahead</h2>
<p>Tomorrow we’ll use these techniques to explore <strong>complex dynamics</strong> (the Mandelbrot and Julia sets) and <strong>geometric transformations</strong> (circle inversions and the Apollonian gasket). The coordinate system and implicit curve techniques you’ve learned today will be the foundation for everything to come.</p>
<p>Make sure you’re comfortable with:</p>
<ul>
<li>Setting up coordinates (the standard transformation from <code>fragCoord</code> to centered, aspect-corrected <code>p</code>)</li>
<li>Computing distances and implicit functions<br>
</li>
<li>Using <code>mod()</code> for repetition</li>
<li>Conditionally coloring based on mathematical expressions</li>
</ul>
<p>If any of these feel shaky, now is the time to practice! Everything builds on this foundation.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./outline.html" class="pagination-link" aria-label="Outline">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Outline</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./day2.html" class="pagination-link" aria-label="Day 2: Complex Dynamics and Iterated Inversions">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Day 2: Complex Dynamics and Iterated Inversions</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb23" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Day 1: Introduction to Shader Programming</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">## Overview</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>Today we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We'll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>By the end of today, you'll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="fu">## What is a Shader?</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="fu">### Mathematical Perspective</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>A shader is fundamentally a function</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>$$f: \mathbb{R}^2 \times \mathbb{R} \times \cdots \to \mathbb{R}^4$$</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>that maps pixel coordinates (and potentially time, mouse position, etc.) to color values. For each pixel on the screen, we evaluate this function to determine what color to display.</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>Here's the magic: modern GPUs can evaluate this function for **all pixels simultaneously**. If your screen has 1920×1080 pixels, that's over 2 million function evaluations happening in parallel, typically 60 times per second. We're not looping over pixels one at a time—we're computing them all at once!</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>This is completely different from how you might write mathematical visualization code in, say, Python. There you'd have nested loops:</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(width):</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(height):</span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>        color[x,y] <span class="op">=</span> f(x, y)</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>With shaders, there are no loops. You write the function <span class="in">`f`</span>, and the GPU just *does it* everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.</span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a><span class="fu">## Why is this called a "shader"?</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>Historically, these programs were used for *shading* 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We're going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with "shading" in the traditional sense!</span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why Shadertoy?</span></span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>Shadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it's a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.</span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>The platform provides several built-in **uniforms** (read-only global variables that are the same for all pixels):</span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`iResolution`</span>: screen resolution as a <span class="in">`vec3`</span> (width, height, pixel aspect ratio)</span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`iTime`</span>: elapsed time in seconds since the shader started</span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`iMouse`</span>: mouse position and click state as a <span class="in">`vec4`</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>We'll use these throughout the week to create animated, interactive mathematical visualizations.</span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a><span class="fu">## First Shader: Solid Colors</span></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-51"><a href="#cb23-51" aria-hidden="true" tabindex="-1"></a><span class="fu">### Basic Structure</span></span>
<span id="cb23-52"><a href="#cb23-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-53"><a href="#cb23-53" aria-hidden="true" tabindex="-1"></a>Every Shadertoy shader has the same entry point:</span>
<span id="cb23-54"><a href="#cb23-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-55"><a href="#cb23-55" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-56"><a href="#cb23-56" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-57"><a href="#cb23-57" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-58"><a href="#cb23-58" aria-hidden="true" tabindex="-1"></a><span class="in">    // Your code here</span></span>
<span id="cb23-59"><a href="#cb23-59" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-60"><a href="#cb23-60" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-61"><a href="#cb23-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-62"><a href="#cb23-62" aria-hidden="true" tabindex="-1"></a>**Parameters:**</span>
<span id="cb23-63"><a href="#cb23-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-64"><a href="#cb23-64" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`fragCoord`</span>: the pixel coordinate we're currently computing, as a <span class="in">`vec2`</span> (x, y)</span>
<span id="cb23-65"><a href="#cb23-65" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`fragColor`</span>: the output color we need to set, as a <span class="in">`vec4`</span> (red, green, blue, alpha)</span>
<span id="cb23-66"><a href="#cb23-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-67"><a href="#cb23-67" aria-hidden="true" tabindex="-1"></a>Colors are represented in RGBA format with values in $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$. So <span class="in">`vec4(1.0, 0.0, 0.0, 1.0)`</span> represents opaque red, while <span class="in">`vec4(0.5, 0.5, 0.5, 1.0)`</span> is middle gray.</span>
<span id="cb23-68"><a href="#cb23-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-69"><a href="#cb23-69" aria-hidden="true" tabindex="-1"></a><span class="fu">### Example: Red Screen</span></span>
<span id="cb23-70"><a href="#cb23-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-71"><a href="#cb23-71" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-72"><a href="#cb23-72" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-73"><a href="#cb23-73" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-74"><a href="#cb23-74" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span>
<span id="cb23-75"><a href="#cb23-75" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-76"><a href="#cb23-76" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-77"><a href="#cb23-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-78"><a href="#cb23-78" aria-hidden="true" tabindex="-1"></a>This sets every pixel to red. The function is evaluated once per pixel, but since the output doesn't depend on <span class="in">`fragCoord`</span>, every pixel gets the same value. Not very exciting—but it's a start!</span>
<span id="cb23-79"><a href="#cb23-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-80"><a href="#cb23-80" aria-hidden="true" tabindex="-1"></a><span class="fu">### GLSL Syntax Basics</span></span>
<span id="cb23-81"><a href="#cb23-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-82"><a href="#cb23-82" aria-hidden="true" tabindex="-1"></a>Before we go further, let's talk about some essential GLSL conventions. If you're coming from Python or MATLAB, a few things will feel different:</span>
<span id="cb23-83"><a href="#cb23-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-84"><a href="#cb23-84" aria-hidden="true" tabindex="-1"></a>::: {.callout-important}</span>
<span id="cb23-85"><a href="#cb23-85" aria-hidden="true" tabindex="-1"></a><span class="fu">## GLSL Syntax Rules</span></span>
<span id="cb23-86"><a href="#cb23-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-87"><a href="#cb23-87" aria-hidden="true" tabindex="-1"></a>**Semicolons are required.** Every statement must end with a semicolon. This is not Python! Forget one and your shader won't compile.</span>
<span id="cb23-88"><a href="#cb23-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-89"><a href="#cb23-89" aria-hidden="true" tabindex="-1"></a>**Floating point literals:** Write <span class="in">`1.0`</span> not <span class="in">`1`</span> for floating point values. GLSL is very picky about types—if you write <span class="in">`1`</span>, it's an integer, and mixing types causes errors. Get in the habit of always writing the <span class="in">`.0`</span>.</span>
<span id="cb23-90"><a href="#cb23-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-91"><a href="#cb23-91" aria-hidden="true" tabindex="-1"></a>**Vector types:** GLSL has built-in types <span class="in">`vec2`</span>, <span class="in">`vec3`</span>, <span class="in">`vec4`</span> for 2D, 3D, and 4D vectors. You can construct them with:</span>
<span id="cb23-92"><a href="#cb23-92" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-93"><a href="#cb23-93" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 v = vec2(1.0, 2.0);</span></span>
<span id="cb23-94"><a href="#cb23-94" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 w = vec3(1.0, 2.0, 3.0);</span></span>
<span id="cb23-95"><a href="#cb23-95" aria-hidden="true" tabindex="-1"></a><span class="in">vec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars</span></span>
<span id="cb23-96"><a href="#cb23-96" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-97"><a href="#cb23-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-98"><a href="#cb23-98" aria-hidden="true" tabindex="-1"></a>**Swizzling:** You can access components by name: <span class="in">`v.x`</span>, <span class="in">`v.y`</span> or equivalently <span class="in">`v.r`</span>, <span class="in">`v.g`</span> (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: <span class="in">`v.yx`</span> swaps the coordinates, <span class="in">`v.xxx`</span> repeats the x-component three times. This is incredibly useful!</span>
<span id="cb23-99"><a href="#cb23-99" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-100"><a href="#cb23-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-101"><a href="#cb23-101" aria-hidden="true" tabindex="-1"></a><span class="fu">### Animating with Time</span></span>
<span id="cb23-102"><a href="#cb23-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-103"><a href="#cb23-103" aria-hidden="true" tabindex="-1"></a>Let's make something that changes:</span>
<span id="cb23-104"><a href="#cb23-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-105"><a href="#cb23-105" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-106"><a href="#cb23-106" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-107"><a href="#cb23-107" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-108"><a href="#cb23-108" aria-hidden="true" tabindex="-1"></a><span class="in">    float red = 0.5 + 0.5 * sin(iTime);</span></span>
<span id="cb23-109"><a href="#cb23-109" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(red, 0.0, 0.0, 1.0);</span></span>
<span id="cb23-110"><a href="#cb23-110" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-111"><a href="#cb23-111" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-112"><a href="#cb23-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-113"><a href="#cb23-113" aria-hidden="true" tabindex="-1"></a>Here <span class="in">`iTime`</span> grows continuously, <span class="in">`sin(iTime)`</span> oscillates between $-1$ and $1$, and we remap to $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$ with the affine transformation $x \mapsto \frac{1}{2}(1 + x)$. The screen now pulses between black and red!</span>
<span id="cb23-114"><a href="#cb23-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-115"><a href="#cb23-115" aria-hidden="true" tabindex="-1"></a>This pattern—<span class="in">`0.5 + 0.5 * sin(...)`</span>—comes up constantly when animating. It's the standard way to turn a sinusoid into something that stays in the range $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$.</span>
<span id="cb23-116"><a href="#cb23-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-117"><a href="#cb23-117" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-118"><a href="#cb23-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-119"><a href="#cb23-119" aria-hidden="true" tabindex="-1"></a><span class="fu">## Coordinate Systems</span></span>
<span id="cb23-120"><a href="#cb23-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-121"><a href="#cb23-121" aria-hidden="true" tabindex="-1"></a><span class="fu">### Raw Coordinates</span></span>
<span id="cb23-122"><a href="#cb23-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-123"><a href="#cb23-123" aria-hidden="true" tabindex="-1"></a>By default, <span class="in">`fragCoord`</span> gives pixel coordinates with:</span>
<span id="cb23-124"><a href="#cb23-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-125"><a href="#cb23-125" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Origin $(0, 0)$ at the bottom-left</span>
<span id="cb23-126"><a href="#cb23-126" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$x$ increases rightward to <span class="in">`iResolution.x`</span></span>
<span id="cb23-127"><a href="#cb23-127" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$y$ increases upward to <span class="in">`iResolution.y`</span></span>
<span id="cb23-128"><a href="#cb23-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-129"><a href="#cb23-129" aria-hidden="true" tabindex="-1"></a>This is fine if you're thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!</span>
<span id="cb23-130"><a href="#cb23-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-131"><a href="#cb23-131" aria-hidden="true" tabindex="-1"></a><span class="fu">### Centered, Normalized Coordinates</span></span>
<span id="cb23-132"><a href="#cb23-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-133"><a href="#cb23-133" aria-hidden="true" tabindex="-1"></a>Here's the standard transformation we'll use in every shader:</span>
<span id="cb23-134"><a href="#cb23-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-135"><a href="#cb23-135" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-136"><a href="#cb23-136" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-137"><a href="#cb23-137" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-138"><a href="#cb23-138" aria-hidden="true" tabindex="-1"></a><span class="in">    // Normalize to [0,1]</span></span>
<span id="cb23-139"><a href="#cb23-139" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 uv = fragCoord / iResolution.xy;</span></span>
<span id="cb23-140"><a href="#cb23-140" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-141"><a href="#cb23-141" aria-hidden="true" tabindex="-1"></a><span class="in">    // Center at origin: [-0.5, 0.5]</span></span>
<span id="cb23-142"><a href="#cb23-142" aria-hidden="true" tabindex="-1"></a><span class="in">    uv = uv - 0.5;</span></span>
<span id="cb23-143"><a href="#cb23-143" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-144"><a href="#cb23-144" aria-hidden="true" tabindex="-1"></a><span class="in">    // Scale to account for aspect ratio</span></span>
<span id="cb23-145"><a href="#cb23-145" aria-hidden="true" tabindex="-1"></a><span class="in">    uv.x *= iResolution.x / iResolution.y;</span></span>
<span id="cb23-146"><a href="#cb23-146" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-147"><a href="#cb23-147" aria-hidden="true" tabindex="-1"></a><span class="in">    // Now uv is centered and aspect-corrected</span></span>
<span id="cb23-148"><a href="#cb23-148" aria-hidden="true" tabindex="-1"></a><span class="in">    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)</span></span>
<span id="cb23-149"><a href="#cb23-149" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 p = uv * 4.0;  // Now p is in [-2, 2] × [-h, h] where h depends on aspect ratio</span></span>
<span id="cb23-150"><a href="#cb23-150" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-151"><a href="#cb23-151" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></span>
<span id="cb23-152"><a href="#cb23-152" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-153"><a href="#cb23-153" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-154"><a href="#cb23-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-155"><a href="#cb23-155" aria-hidden="true" tabindex="-1"></a>Let's break this down step by step:</span>
<span id="cb23-156"><a href="#cb23-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-157"><a href="#cb23-157" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Normalize**: Dividing by <span class="in">`iResolution.xy`</span> maps from pixel coordinates to $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$</span>
<span id="cb23-158"><a href="#cb23-158" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Center**: Subtracting $0.5$ shifts the origin to the center: $<span class="co">[</span><span class="ot">-0.5, 0.5</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">-0.5, 0.5</span><span class="co">]</span>$</span>
<span id="cb23-159"><a href="#cb23-159" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Aspect correction**: Multiplying <span class="in">`uv.x`</span> by the aspect ratio ensures that equal distances in <span class="in">`uv.x`</span> and <span class="in">`uv.y`</span> correspond to equal screen distances—this makes circles actually circular!</span>
<span id="cb23-160"><a href="#cb23-160" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Scale**: Finally, we scale to whatever viewing window we want for our visualization</span>
<span id="cb23-161"><a href="#cb23-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-162"><a href="#cb23-162" aria-hidden="true" tabindex="-1"></a>From now on, we'll assume this coordinate setup is done at the start of every shader, storing the result in a variable <span class="in">`p`</span> for "position."</span>
<span id="cb23-163"><a href="#cb23-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-164"><a href="#cb23-164" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-165"><a href="#cb23-165" aria-hidden="true" tabindex="-1"></a><span class="fu">## The coordinate transformation boilerplate</span></span>
<span id="cb23-166"><a href="#cb23-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-167"><a href="#cb23-167" aria-hidden="true" tabindex="-1"></a>You'll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we'll just write it out each time so the transformation is explicit.</span>
<span id="cb23-168"><a href="#cb23-168" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-169"><a href="#cb23-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-170"><a href="#cb23-170" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing Coordinates</span></span>
<span id="cb23-171"><a href="#cb23-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-172"><a href="#cb23-172" aria-hidden="true" tabindex="-1"></a>Let's verify our coordinate system is working by coloring pixels according to their position:</span>
<span id="cb23-173"><a href="#cb23-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-174"><a href="#cb23-174" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-175"><a href="#cb23-175" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-176"><a href="#cb23-176" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-177"><a href="#cb23-177" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup as above, resulting in p]</span></span>
<span id="cb23-178"><a href="#cb23-178" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-179"><a href="#cb23-179" aria-hidden="true" tabindex="-1"></a><span class="in">    // Map x coordinate to red, y to green</span></span>
<span id="cb23-180"><a href="#cb23-180" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]</span></span>
<span id="cb23-181"><a href="#cb23-181" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color_rg, 0.0, 1.0);</span></span>
<span id="cb23-182"><a href="#cb23-182" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-183"><a href="#cb23-183" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-184"><a href="#cb23-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-185"><a href="#cb23-185" aria-hidden="true" tabindex="-1"></a>You should see a smooth gradient: red increases rightward, green increases upward. If you don't see this, something went wrong in your coordinate setup!</span>
<span id="cb23-186"><a href="#cb23-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-187"><a href="#cb23-187" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-188"><a href="#cb23-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-189"><a href="#cb23-189" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conditional Coloring: Half-Planes</span></span>
<span id="cb23-190"><a href="#cb23-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-191"><a href="#cb23-191" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Concept</span></span>
<span id="cb23-192"><a href="#cb23-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-193"><a href="#cb23-193" aria-hidden="true" tabindex="-1"></a>Given a linear function $L(x, y) = ax + by$, we want to color pixels differently depending on whether $L(p) &lt; 0$ or $L(p) \geq 0$. This divides the plane into two half-planes—the regions where the function is negative vs. positive.</span>
<span id="cb23-194"><a href="#cb23-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-195"><a href="#cb23-195" aria-hidden="true" tabindex="-1"></a><span class="fu">### Implementation</span></span>
<span id="cb23-196"><a href="#cb23-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-197"><a href="#cb23-197" aria-hidden="true" tabindex="-1"></a>GLSL provides a conditional operator (ternary operator) just like C:</span>
<span id="cb23-198"><a href="#cb23-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-199"><a href="#cb23-199" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-200"><a href="#cb23-200" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-201"><a href="#cb23-201" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-202"><a href="#cb23-202" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup, resulting in p]</span></span>
<span id="cb23-203"><a href="#cb23-203" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-204"><a href="#cb23-204" aria-hidden="true" tabindex="-1"></a><span class="in">    float L = p.x;  // The function L(x,y) = x</span></span>
<span id="cb23-205"><a href="#cb23-205" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-206"><a href="#cb23-206" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);</span></span>
<span id="cb23-207"><a href="#cb23-207" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-208"><a href="#cb23-208" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-209"><a href="#cb23-209" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-210"><a href="#cb23-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-211"><a href="#cb23-211" aria-hidden="true" tabindex="-1"></a>Left half-plane is red, right half-plane is blue. Simple!</span>
<span id="cb23-212"><a href="#cb23-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-213"><a href="#cb23-213" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Step Function</span></span>
<span id="cb23-214"><a href="#cb23-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-215"><a href="#cb23-215" aria-hidden="true" tabindex="-1"></a>GLSL also provides <span class="in">`step(edge, x)`</span> which returns $0$ if $x &lt; \text{edge}$ and $1$ otherwise. This is useful for writing cleaner code without explicit conditionals:</span>
<span id="cb23-216"><a href="#cb23-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-217"><a href="#cb23-217" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-218"><a href="#cb23-218" aria-hidden="true" tabindex="-1"></a><span class="in">float s = step(0.0, p.x);  // 0 on left, 1 on right</span></span>
<span id="cb23-219"><a href="#cb23-219" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);</span></span>
<span id="cb23-220"><a href="#cb23-220" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-221"><a href="#cb23-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-222"><a href="#cb23-222" aria-hidden="true" tabindex="-1"></a>Here <span class="in">`mix(a, b, t)`</span> performs linear interpolation: $(1-t)a + tb$. So when <span class="in">`s = 0`</span> we get pure red, when <span class="in">`s = 1`</span> we get pure blue.</span>
<span id="cb23-223"><a href="#cb23-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-224"><a href="#cb23-224" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-225"><a href="#cb23-225" aria-hidden="true" tabindex="-1"></a><span class="fu">## Why use `step` instead of the ternary operator?</span></span>
<span id="cb23-226"><a href="#cb23-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-227"><a href="#cb23-227" aria-hidden="true" tabindex="-1"></a>Both work fine! The ternary operator <span class="in">`?:`</span> is more explicit and familiar if you know C-like languages. But <span class="in">`step`</span> and <span class="in">`mix`</span> are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you'll develop a feel for which style is clearer in each situation.</span>
<span id="cb23-228"><a href="#cb23-228" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-229"><a href="#cb23-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-230"><a href="#cb23-230" aria-hidden="true" tabindex="-1"></a><span class="fu">### Arbitrary Half-Planes</span></span>
<span id="cb23-231"><a href="#cb23-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-232"><a href="#cb23-232" aria-hidden="true" tabindex="-1"></a>For a general line $ax + by = 0$, we just evaluate the corresponding linear function:</span>
<span id="cb23-233"><a href="#cb23-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-234"><a href="#cb23-234" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-235"><a href="#cb23-235" aria-hidden="true" tabindex="-1"></a><span class="in">float a = 1.0, b = 1.0;</span></span>
<span id="cb23-236"><a href="#cb23-236" aria-hidden="true" tabindex="-1"></a><span class="in">float L = a * p.x + b * p.y;</span></span>
<span id="cb23-237"><a href="#cb23-237" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);</span></span>
<span id="cb23-238"><a href="#cb23-238" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-239"><a href="#cb23-239" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-240"><a href="#cb23-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-241"><a href="#cb23-241" aria-hidden="true" tabindex="-1"></a>Try different values of $a$ and $b$ to see different line orientations. The line itself is where $L = 0$, and we're coloring the two sides differently.</span>
<span id="cb23-242"><a href="#cb23-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-243"><a href="#cb23-243" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-244"><a href="#cb23-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-245"><a href="#cb23-245" aria-hidden="true" tabindex="-1"></a><span class="fu">## Distance Fields and Circles</span></span>
<span id="cb23-246"><a href="#cb23-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-247"><a href="#cb23-247" aria-hidden="true" tabindex="-1"></a><span class="fu">### Distance to Center</span></span>
<span id="cb23-248"><a href="#cb23-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-249"><a href="#cb23-249" aria-hidden="true" tabindex="-1"></a>The distance from a point $p = (x, y)$ to the origin is just the usual Euclidean distance:</span>
<span id="cb23-250"><a href="#cb23-250" aria-hidden="true" tabindex="-1"></a>$$d = \|p\| = \sqrt{x^2 + y^2}$$</span>
<span id="cb23-251"><a href="#cb23-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-252"><a href="#cb23-252" aria-hidden="true" tabindex="-1"></a>In GLSL this is built-in:</span>
<span id="cb23-253"><a href="#cb23-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-254"><a href="#cb23-254" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-255"><a href="#cb23-255" aria-hidden="true" tabindex="-1"></a><span class="in">float d = length(p);</span></span>
<span id="cb23-256"><a href="#cb23-256" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-257"><a href="#cb23-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-258"><a href="#cb23-258" aria-hidden="true" tabindex="-1"></a>The <span class="in">`length()`</span> function computes the Euclidean norm of a vector. It works for <span class="in">`vec2`</span>, <span class="in">`vec3`</span>, <span class="in">`vec4`</span>—whatever you need.</span>
<span id="cb23-259"><a href="#cb23-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-260"><a href="#cb23-260" aria-hidden="true" tabindex="-1"></a><span class="fu">### Filled Circle</span></span>
<span id="cb23-261"><a href="#cb23-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-262"><a href="#cb23-262" aria-hidden="true" tabindex="-1"></a>A circle of radius $r$ centered at the origin is the set $<span class="sc">\{</span>p : \|p\| &lt; r<span class="sc">\}</span>$—just points whose distance from the origin is less than $r$. So to color the inside vs. outside of a circle, we just compare distances:</span>
<span id="cb23-263"><a href="#cb23-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-264"><a href="#cb23-264" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-265"><a href="#cb23-265" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-266"><a href="#cb23-266" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-267"><a href="#cb23-267" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup]</span></span>
<span id="cb23-268"><a href="#cb23-268" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-269"><a href="#cb23-269" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(p);</span></span>
<span id="cb23-270"><a href="#cb23-270" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 1.0;</span></span>
<span id="cb23-271"><a href="#cb23-271" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-272"><a href="#cb23-272" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);</span></span>
<span id="cb23-273"><a href="#cb23-273" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-274"><a href="#cb23-274" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-275"><a href="#cb23-275" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-276"><a href="#cb23-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-277"><a href="#cb23-277" aria-hidden="true" tabindex="-1"></a>That's it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it's inside or outside the circle.</span>
<span id="cb23-278"><a href="#cb23-278" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-279"><a href="#cb23-279" aria-hidden="true" tabindex="-1"></a><span class="fu">### Distance-Based Coloring</span></span>
<span id="cb23-280"><a href="#cb23-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-281"><a href="#cb23-281" aria-hidden="true" tabindex="-1"></a>But we don't have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:</span>
<span id="cb23-282"><a href="#cb23-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-283"><a href="#cb23-283" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-284"><a href="#cb23-284" aria-hidden="true" tabindex="-1"></a><span class="in">float d = length(p);</span></span>
<span id="cb23-285"><a href="#cb23-285" aria-hidden="true" tabindex="-1"></a><span class="in">float intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2</span></span>
<span id="cb23-286"><a href="#cb23-286" aria-hidden="true" tabindex="-1"></a><span class="in">intensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]</span></span>
<span id="cb23-287"><a href="#cb23-287" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = vec3(intensity);</span></span>
<span id="cb23-288"><a href="#cb23-288" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-289"><a href="#cb23-289" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-290"><a href="#cb23-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-291"><a href="#cb23-291" aria-hidden="true" tabindex="-1"></a>This creates a radial gradient—bright at the center, dark at the edges. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we'll see on Day 4) as the foundation for 3D rendering!</span>
<span id="cb23-292"><a href="#cb23-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-293"><a href="#cb23-293" aria-hidden="true" tabindex="-1"></a><span class="fu">### Circle Outline</span></span>
<span id="cb23-294"><a href="#cb23-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-295"><a href="#cb23-295" aria-hidden="true" tabindex="-1"></a>What if we want to draw just the *boundary* of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is *approximately equal* to the radius. Mathematically, we're coloring the set $<span class="sc">\{</span>p : |d(p) - r| &lt; \epsilon<span class="sc">\}</span>$ where $\epsilon$ is a small thickness parameter:</span>
<span id="cb23-296"><a href="#cb23-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-297"><a href="#cb23-297" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-298"><a href="#cb23-298" aria-hidden="true" tabindex="-1"></a><span class="in">float d = length(p);</span></span>
<span id="cb23-299"><a href="#cb23-299" aria-hidden="true" tabindex="-1"></a><span class="in">float r = 1.0;</span></span>
<span id="cb23-300"><a href="#cb23-300" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.05;</span></span>
<span id="cb23-301"><a href="#cb23-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-302"><a href="#cb23-302" aria-hidden="true" tabindex="-1"></a><span class="in">float circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb23-303"><a href="#cb23-303" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = vec3(circle_mask);</span></span>
<span id="cb23-304"><a href="#cb23-304" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-305"><a href="#cb23-305" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-306"><a href="#cb23-306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-307"><a href="#cb23-307" aria-hidden="true" tabindex="-1"></a>This draws a thin white annulus around the circle. Play with the <span class="in">`thickness`</span> parameter to see how it affects the line width!</span>
<span id="cb23-308"><a href="#cb23-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-309"><a href="#cb23-309" aria-hidden="true" tabindex="-1"></a>For a smoother, anti-aliased edge, GLSL provides <span class="in">`smoothstep`</span>:</span>
<span id="cb23-310"><a href="#cb23-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-311"><a href="#cb23-311" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-312"><a href="#cb23-312" aria-hidden="true" tabindex="-1"></a><span class="in">float circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);</span></span>
<span id="cb23-313"><a href="#cb23-313" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-314"><a href="#cb23-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-315"><a href="#cb23-315" aria-hidden="true" tabindex="-1"></a>The <span class="in">`smoothstep(a, b, x)`</span> function performs smooth Hermite interpolation between $a$ and $b$, transitioning gradually instead of having a hard cutoff. This eliminates jagged edges and makes the circle look much nicer—especially important when you're creating publication-quality mathematical illustrations!</span>
<span id="cb23-316"><a href="#cb23-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-317"><a href="#cb23-317" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-318"><a href="#cb23-318" aria-hidden="true" tabindex="-1"></a><span class="fu">## Anti-aliasing in shaders</span></span>
<span id="cb23-319"><a href="#cb23-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-320"><a href="#cb23-320" aria-hidden="true" tabindex="-1"></a>The harsh cutoffs from using <span class="in">`&lt;`</span> or the ternary operator create jagged, pixelated edges. Functions like <span class="in">`smoothstep`</span> give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We'll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with <span class="in">`smoothstep`</span> for smoother results.</span>
<span id="cb23-321"><a href="#cb23-321" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-322"><a href="#cb23-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-323"><a href="#cb23-323" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-324"><a href="#cb23-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-325"><a href="#cb23-325" aria-hidden="true" tabindex="-1"></a><span class="fu">## Grids and Repetition</span></span>
<span id="cb23-326"><a href="#cb23-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-327"><a href="#cb23-327" aria-hidden="true" tabindex="-1"></a><span class="fu">### Modular Arithmetic</span></span>
<span id="cb23-328"><a href="#cb23-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-329"><a href="#cb23-329" aria-hidden="true" tabindex="-1"></a>The modulo operation creates periodic repetition. For a period $T$, the function $p \mapsto (p \bmod T) - T/2$ maps $\mathbb{R}$ to $<span class="co">[</span><span class="ot">-T/2, T/2</span><span class="co">]</span>$ repeatedly—it "folds" the entire real line into a finite interval over and over again.</span>
<span id="cb23-330"><a href="#cb23-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-331"><a href="#cb23-331" aria-hidden="true" tabindex="-1"></a>In GLSL, <span class="in">`mod(x, T)`</span> computes $x \bmod T$. This is one of the most powerful tools in shader programming!</span>
<span id="cb23-332"><a href="#cb23-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-333"><a href="#cb23-333" aria-hidden="true" tabindex="-1"></a><span class="fu">### Creating a Grid</span></span>
<span id="cb23-334"><a href="#cb23-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-335"><a href="#cb23-335" aria-hidden="true" tabindex="-1"></a>To create a grid of repeated cells, we apply <span class="in">`mod`</span> to our coordinates:</span>
<span id="cb23-336"><a href="#cb23-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-337"><a href="#cb23-337" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-338"><a href="#cb23-338" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-339"><a href="#cb23-339" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-340"><a href="#cb23-340" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup, resulting in p]</span></span>
<span id="cb23-341"><a href="#cb23-341" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-342"><a href="#cb23-342" aria-hidden="true" tabindex="-1"></a><span class="in">    float spacing = 1.0;</span></span>
<span id="cb23-343"><a href="#cb23-343" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;</span></span>
<span id="cb23-344"><a href="#cb23-344" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-345"><a href="#cb23-345" aria-hidden="true" tabindex="-1"></a><span class="in">    // Now cell_p repeats every spacing units</span></span>
<span id="cb23-346"><a href="#cb23-346" aria-hidden="true" tabindex="-1"></a><span class="in">    // Draw a circle in each cell</span></span>
<span id="cb23-347"><a href="#cb23-347" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(cell_p);</span></span>
<span id="cb23-348"><a href="#cb23-348" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 0.3;</span></span>
<span id="cb23-349"><a href="#cb23-349" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-350"><a href="#cb23-350" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);</span></span>
<span id="cb23-351"><a href="#cb23-351" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-352"><a href="#cb23-352" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-353"><a href="#cb23-353" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-354"><a href="#cb23-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-355"><a href="#cb23-355" aria-hidden="true" tabindex="-1"></a>This creates an infinite grid of yellow circles! The coordinate transformation <span class="in">`cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0`</span> ensures that <span class="in">`cell_p`</span> is always in the range $<span class="co">[</span><span class="ot">-\text{spacing}/2, \text{spacing}/2</span><span class="co">]</span>$, and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.</span>
<span id="cb23-356"><a href="#cb23-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-357"><a href="#cb23-357" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb23-358"><a href="#cb23-358" aria-hidden="true" tabindex="-1"></a><span class="fu">## The power of `mod`</span></span>
<span id="cb23-359"><a href="#cb23-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-360"><a href="#cb23-360" aria-hidden="true" tabindex="-1"></a>Think about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There's no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation. This is the kind of efficiency that makes shaders special.</span>
<span id="cb23-361"><a href="#cb23-361" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-362"><a href="#cb23-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-363"><a href="#cb23-363" aria-hidden="true" tabindex="-1"></a><span class="fu">### Alternating Pattern</span></span>
<span id="cb23-364"><a href="#cb23-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-365"><a href="#cb23-365" aria-hidden="true" tabindex="-1"></a>We can create checkerboard-like patterns by using the *cell index* to vary colors. To get the cell index, we divide by the spacing and floor:</span>
<span id="cb23-366"><a href="#cb23-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-367"><a href="#cb23-367" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-368"><a href="#cb23-368" aria-hidden="true" tabindex="-1"></a><span class="in">vec2 cell_id = floor(p / spacing);</span></span>
<span id="cb23-369"><a href="#cb23-369" aria-hidden="true" tabindex="-1"></a><span class="in">float checker = mod(cell_id.x + cell_id.y, 2.0);</span></span>
<span id="cb23-370"><a href="#cb23-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-371"><a href="#cb23-371" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color_a = vec3(1.0, 0.0, 0.0);</span></span>
<span id="cb23-372"><a href="#cb23-372" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color_b = vec3(0.0, 0.0, 1.0);</span></span>
<span id="cb23-373"><a href="#cb23-373" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 bg_color = mix(color_a, color_b, checker);</span></span>
<span id="cb23-374"><a href="#cb23-374" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-375"><a href="#cb23-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-376"><a href="#cb23-376" aria-hidden="true" tabindex="-1"></a>Here <span class="in">`floor(p / spacing)`</span> gives us integer grid indices $(i, j)$, and we alternate colors based on the parity of $i + j$. When $i + j$ is even, <span class="in">`checker = 0`</span> (red), when odd, <span class="in">`checker = 1`</span> (blue).</span>
<span id="cb23-377"><a href="#cb23-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-378"><a href="#cb23-378" aria-hidden="true" tabindex="-1"></a><span class="fu">### Combining with Circles</span></span>
<span id="cb23-379"><a href="#cb23-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-380"><a href="#cb23-380" aria-hidden="true" tabindex="-1"></a>Let's put it all together—a grid of circles on an alternating background:</span>
<span id="cb23-381"><a href="#cb23-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-382"><a href="#cb23-382" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-383"><a href="#cb23-383" aria-hidden="true" tabindex="-1"></a><span class="in">void mainImage(out vec4 fragColor, in vec2 fragCoord)</span></span>
<span id="cb23-384"><a href="#cb23-384" aria-hidden="true" tabindex="-1"></a><span class="in">{</span></span>
<span id="cb23-385"><a href="#cb23-385" aria-hidden="true" tabindex="-1"></a><span class="in">    // [Coordinate setup]</span></span>
<span id="cb23-386"><a href="#cb23-386" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-387"><a href="#cb23-387" aria-hidden="true" tabindex="-1"></a><span class="in">    float spacing = 1.0;</span></span>
<span id="cb23-388"><a href="#cb23-388" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_id = floor(p / spacing);</span></span>
<span id="cb23-389"><a href="#cb23-389" aria-hidden="true" tabindex="-1"></a><span class="in">    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;</span></span>
<span id="cb23-390"><a href="#cb23-390" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-391"><a href="#cb23-391" aria-hidden="true" tabindex="-1"></a><span class="in">    // Checkerboard background</span></span>
<span id="cb23-392"><a href="#cb23-392" aria-hidden="true" tabindex="-1"></a><span class="in">    float checker = mod(cell_id.x + cell_id.y, 2.0);</span></span>
<span id="cb23-393"><a href="#cb23-393" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);</span></span>
<span id="cb23-394"><a href="#cb23-394" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-395"><a href="#cb23-395" aria-hidden="true" tabindex="-1"></a><span class="in">    // Circle in each cell</span></span>
<span id="cb23-396"><a href="#cb23-396" aria-hidden="true" tabindex="-1"></a><span class="in">    float d = length(cell_p);</span></span>
<span id="cb23-397"><a href="#cb23-397" aria-hidden="true" tabindex="-1"></a><span class="in">    float r = 0.3;</span></span>
<span id="cb23-398"><a href="#cb23-398" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 circle_color = vec3(1.0, 1.0, 0.0);</span></span>
<span id="cb23-399"><a href="#cb23-399" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb23-400"><a href="#cb23-400" aria-hidden="true" tabindex="-1"></a><span class="in">    vec3 color = (d &lt; r) ? circle_color : bg_color;</span></span>
<span id="cb23-401"><a href="#cb23-401" aria-hidden="true" tabindex="-1"></a><span class="in">    fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-402"><a href="#cb23-402" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb23-403"><a href="#cb23-403" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-404"><a href="#cb23-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-405"><a href="#cb23-405" aria-hidden="true" tabindex="-1"></a>Try varying the <span class="in">`spacing`</span> and <span class="in">`r`</span> parameters. What happens if you make the circles larger than the cells? What if you use different spacing values for <span class="in">`x`</span> and <span class="in">`y`</span>?</span>
<span id="cb23-406"><a href="#cb23-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-407"><a href="#cb23-407" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-408"><a href="#cb23-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-409"><a href="#cb23-409" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implicit Curves</span></span>
<span id="cb23-410"><a href="#cb23-410" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-411"><a href="#cb23-411" aria-hidden="true" tabindex="-1"></a><span class="fu">### General Principle</span></span>
<span id="cb23-412"><a href="#cb23-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-413"><a href="#cb23-413" aria-hidden="true" tabindex="-1"></a>An implicit curve is defined by an equation $F(x, y) = 0$. Points on the curve satisfy the equation exactly, while points off the curve have $F(x,y) \neq 0$. To render the curve, we compute $F(p)$ for each pixel and color based on proximity to zero:</span>
<span id="cb23-414"><a href="#cb23-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-415"><a href="#cb23-415" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-416"><a href="#cb23-416" aria-hidden="true" tabindex="-1"></a><span class="in">float F = [some function of p.x and p.y];</span></span>
<span id="cb23-417"><a href="#cb23-417" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.05;</span></span>
<span id="cb23-418"><a href="#cb23-418" aria-hidden="true" tabindex="-1"></a><span class="in">float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb23-419"><a href="#cb23-419" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = mix(background, curve_color, curve_mask);</span></span>
<span id="cb23-420"><a href="#cb23-420" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-421"><a href="#cb23-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-422"><a href="#cb23-422" aria-hidden="true" tabindex="-1"></a>This is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, whatever you want.</span>
<span id="cb23-423"><a href="#cb23-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-424"><a href="#cb23-424" aria-hidden="true" tabindex="-1"></a><span class="fu">### Example: Parabola</span></span>
<span id="cb23-425"><a href="#cb23-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-426"><a href="#cb23-426" aria-hidden="true" tabindex="-1"></a>The parabola $y = x^2$ can be written implicitly as $F(x, y) = y - x^2 = 0$:</span>
<span id="cb23-427"><a href="#cb23-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-428"><a href="#cb23-428" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-429"><a href="#cb23-429" aria-hidden="true" tabindex="-1"></a><span class="in">float F = p.y - p.x * p.x;</span></span>
<span id="cb23-430"><a href="#cb23-430" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.1;</span></span>
<span id="cb23-431"><a href="#cb23-431" aria-hidden="true" tabindex="-1"></a><span class="in">float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb23-432"><a href="#cb23-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-433"><a href="#cb23-433" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);</span></span>
<span id="cb23-434"><a href="#cb23-434" aria-hidden="true" tabindex="-1"></a><span class="in">fragColor = vec4(color, 1.0);</span></span>
<span id="cb23-435"><a href="#cb23-435" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-436"><a href="#cb23-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-437"><a href="#cb23-437" aria-hidden="true" tabindex="-1"></a>You should see a yellow parabola on a dark blue background. The curve appears wherever $|F(x,y)| &lt; 0.1$—a thin band around the zero set of $F$.</span>
<span id="cb23-438"><a href="#cb23-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-439"><a href="#cb23-439" aria-hidden="true" tabindex="-1"></a>One thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker. This is because we're thresholding on the *value* of $F$, not the geometric distance to the curve. For perfectly uniform thickness, you'd need to compute the actual signed distance function—something we'll talk more about on Day 4.</span>
<span id="cb23-440"><a href="#cb23-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-441"><a href="#cb23-441" aria-hidden="true" tabindex="-1"></a><span class="fu">### Example: Circle (Implicit Form)</span></span>
<span id="cb23-442"><a href="#cb23-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-443"><a href="#cb23-443" aria-hidden="true" tabindex="-1"></a>We've been using $\|p\| &lt; r$ for filled circles, but we can also write the circle implicitly as $x^2 + y^2 - r^2 = 0$:</span>
<span id="cb23-444"><a href="#cb23-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-445"><a href="#cb23-445" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-446"><a href="#cb23-446" aria-hidden="true" tabindex="-1"></a><span class="in">float r = 1.0;</span></span>
<span id="cb23-447"><a href="#cb23-447" aria-hidden="true" tabindex="-1"></a><span class="in">float F = dot(p, p) - r * r;  // dot(p,p) = x² + y²</span></span>
<span id="cb23-448"><a href="#cb23-448" aria-hidden="true" tabindex="-1"></a><span class="in">float thickness = 0.1;</span></span>
<span id="cb23-449"><a href="#cb23-449" aria-hidden="true" tabindex="-1"></a><span class="in">float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;</span></span>
<span id="cb23-450"><a href="#cb23-450" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-451"><a href="#cb23-451" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-452"><a href="#cb23-452" aria-hidden="true" tabindex="-1"></a>This is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The <span class="in">`dot(p, p)`</span> computes $x^2 + y^2$ efficiently.</span>
<span id="cb23-453"><a href="#cb23-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-454"><a href="#cb23-454" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip}</span>
<span id="cb23-455"><a href="#cb23-455" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implicit curves in your homework</span></span>
<span id="cb23-456"><a href="#cb23-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-457"><a href="#cb23-457" aria-hidden="true" tabindex="-1"></a>When you're implementing the parabola graphing calculator for homework, you'll use this exact implicit curve technique. The key is setting up the equation $F(x,y) = y - (ax^2 + bx + c)$ and thresholding on $|F| &lt; \epsilon$. Make sure to test with various values of $a$, $b$, $c$ to ensure your grapher is robust!</span>
<span id="cb23-458"><a href="#cb23-458" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb23-459"><a href="#cb23-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-460"><a href="#cb23-460" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-461"><a href="#cb23-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-462"><a href="#cb23-462" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb23-463"><a href="#cb23-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-464"><a href="#cb23-464" aria-hidden="true" tabindex="-1"></a>Today we've learned the fundamental tools of shader programming:</span>
<span id="cb23-465"><a href="#cb23-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-466"><a href="#cb23-466" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Shaders as parallel functions**: Every pixel evaluates $f(x, y, t, \ldots) \to \text{color}$ simultaneously—no loops required!</span>
<span id="cb23-467"><a href="#cb23-467" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**GLSL basics**: Syntax, vector types, and built-in functions like <span class="in">`length()`</span>, <span class="in">`step()`</span>, and <span class="in">`smoothstep()`</span></span>
<span id="cb23-468"><a href="#cb23-468" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Coordinate systems**: Centering, normalizing, and scaling for mathematical work</span>
<span id="cb23-469"><a href="#cb23-469" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Conditional coloring**: Using boolean expressions and <span class="in">`step()`</span> for discrete color regions</span>
<span id="cb23-470"><a href="#cb23-470" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Distance fields**: Using <span class="in">`length()`</span> to create circles and radial patterns—the foundation for much more complex techniques later</span>
<span id="cb23-471"><a href="#cb23-471" aria-hidden="true" tabindex="-1"></a><span class="ss">6. </span>**Modular arithmetic**: Creating grids and repeating patterns with <span class="in">`mod()`</span>—infinite complexity with finite computation</span>
<span id="cb23-472"><a href="#cb23-472" aria-hidden="true" tabindex="-1"></a><span class="ss">7. </span>**Implicit curves**: Rendering curves defined by $F(x, y) = 0$ by thresholding on $|F|$</span>
<span id="cb23-473"><a href="#cb23-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-474"><a href="#cb23-474" aria-hidden="true" tabindex="-1"></a>With these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we'll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we've established today.</span>
<span id="cb23-475"><a href="#cb23-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-476"><a href="#cb23-476" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-477"><a href="#cb23-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-478"><a href="#cb23-478" aria-hidden="true" tabindex="-1"></a><span class="fu">## Homework</span></span>
<span id="cb23-479"><a href="#cb23-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-480"><a href="#cb23-480" aria-hidden="true" tabindex="-1"></a><span class="fu">### Required: Parabola Graphing Calculator</span></span>
<span id="cb23-481"><a href="#cb23-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-482"><a href="#cb23-482" aria-hidden="true" tabindex="-1"></a>Create a shader that draws a customizable parabola $y = ax^2 + bx + c$ along with coordinate axes.</span>
<span id="cb23-483"><a href="#cb23-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-484"><a href="#cb23-484" aria-hidden="true" tabindex="-1"></a>**Requirements:**</span>
<span id="cb23-485"><a href="#cb23-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-486"><a href="#cb23-486" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Define variables <span class="in">`a`</span>, <span class="in">`b`</span>, <span class="in">`c`</span> at the top of your shader (hardcoded values are fine)</span>
<span id="cb23-487"><a href="#cb23-487" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Draw the $x$-axis and $y$-axis as thick lines (use the implicit line technique: $|y| &lt; \epsilon$ for $x$-axis, $|x| &lt; \epsilon$ for $y$-axis)</span>
<span id="cb23-488"><a href="#cb23-488" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Plot the parabola $y = ax^2 + bx + c$ as a thick curve</span>
<span id="cb23-489"><a href="#cb23-489" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Use distinct colors for axes and parabola</span>
<span id="cb23-490"><a href="#cb23-490" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The visualization should work for any reasonable values of $a$, $b$, $c$</span>
<span id="cb23-491"><a href="#cb23-491" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-492"><a href="#cb23-492" aria-hidden="true" tabindex="-1"></a>**Suggested approach:**</span>
<span id="cb23-493"><a href="#cb23-493" aria-hidden="true" tabindex="-1"></a><span class="in">```glsl</span></span>
<span id="cb23-494"><a href="#cb23-494" aria-hidden="true" tabindex="-1"></a><span class="in">// Define parameters</span></span>
<span id="cb23-495"><a href="#cb23-495" aria-hidden="true" tabindex="-1"></a><span class="in">float a = 1.0;</span></span>
<span id="cb23-496"><a href="#cb23-496" aria-hidden="true" tabindex="-1"></a><span class="in">float b = 0.0;</span></span>
<span id="cb23-497"><a href="#cb23-497" aria-hidden="true" tabindex="-1"></a><span class="in">float c = 0.0;</span></span>
<span id="cb23-498"><a href="#cb23-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-499"><a href="#cb23-499" aria-hidden="true" tabindex="-1"></a><span class="in">// Axes</span></span>
<span id="cb23-500"><a href="#cb23-500" aria-hidden="true" tabindex="-1"></a><span class="in">float x_axis_mask = abs(p.y) &lt; 0.05 ? 1.0 : 0.0;</span></span>
<span id="cb23-501"><a href="#cb23-501" aria-hidden="true" tabindex="-1"></a><span class="in">float y_axis_mask = abs(p.x) &lt; 0.05 ? 1.0 : 0.0;</span></span>
<span id="cb23-502"><a href="#cb23-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-503"><a href="#cb23-503" aria-hidden="true" tabindex="-1"></a><span class="in">// Parabola: F(x,y) = y - (ax² + bx + c) = 0</span></span>
<span id="cb23-504"><a href="#cb23-504" aria-hidden="true" tabindex="-1"></a><span class="in">float F = p.y - (a * p.x * p.x + b * p.x + c);</span></span>
<span id="cb23-505"><a href="#cb23-505" aria-hidden="true" tabindex="-1"></a><span class="in">float parabola_mask = abs(F) &lt; 0.1 ? 1.0 : 0.0;</span></span>
<span id="cb23-506"><a href="#cb23-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-507"><a href="#cb23-507" aria-hidden="true" tabindex="-1"></a><span class="in">// Combine</span></span>
<span id="cb23-508"><a href="#cb23-508" aria-hidden="true" tabindex="-1"></a><span class="in">vec3 color = background;</span></span>
<span id="cb23-509"><a href="#cb23-509" aria-hidden="true" tabindex="-1"></a><span class="in">color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));</span></span>
<span id="cb23-510"><a href="#cb23-510" aria-hidden="true" tabindex="-1"></a><span class="in">color = mix(color, parabola_color, parabola_mask);</span></span>
<span id="cb23-511"><a href="#cb23-511" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb23-512"><a href="#cb23-512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-513"><a href="#cb23-513" aria-hidden="true" tabindex="-1"></a>Try different values of $a$, $b$, $c$ and verify your grapher works correctly! What happens with negative $a$? What about $b \neq 0$? Make sure the axes and parabola remain visible for all parameter values you try.</span>
<span id="cb23-514"><a href="#cb23-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-515"><a href="#cb23-515" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #1: Animated Curve Family</span></span>
<span id="cb23-516"><a href="#cb23-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-517"><a href="#cb23-517" aria-hidden="true" tabindex="-1"></a>Create a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build intuition!</span>
<span id="cb23-518"><a href="#cb23-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-519"><a href="#cb23-519" aria-hidden="true" tabindex="-1"></a>**Suggestions:**</span>
<span id="cb23-520"><a href="#cb23-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-521"><a href="#cb23-521" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Elliptic fibration**: Take a cubic polynomial $y^2 = x^3 + ax + b$ and vary one parameter with <span class="in">`iTime`</span>. The topology of the curve changes dramatically as you pass through singular values!</span>
<span id="cb23-522"><a href="#cb23-522" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Lissajous curves**: Parametric curves $x = A\sin(at + \delta)$, $y = B\sin(bt)$. Animate $\delta$ or the frequency ratio to watch the curve morph through different patterns</span>
<span id="cb23-523"><a href="#cb23-523" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Cassini ovals**: $(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4$. Vary the parameter and watch the curve transition from two separate loops to a single figure-eight-like shape</span>
<span id="cb23-524"><a href="#cb23-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-525"><a href="#cb23-525" aria-hidden="true" tabindex="-1"></a>Use <span class="in">`iTime`</span> creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes!</span>
<span id="cb23-526"><a href="#cb23-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-527"><a href="#cb23-527" aria-hidden="true" tabindex="-1"></a><span class="fu">### Optional #2: Beautiful Tiling Pattern</span></span>
<span id="cb23-528"><a href="#cb23-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-529"><a href="#cb23-529" aria-hidden="true" tabindex="-1"></a>Design an aesthetically pleasing tiling pattern using the <span class="in">`mod()`</span> technique. This is your chance to be creative!</span>
<span id="cb23-530"><a href="#cb23-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-531"><a href="#cb23-531" aria-hidden="true" tabindex="-1"></a>**Requirements:**</span>
<span id="cb23-532"><a href="#cb23-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-533"><a href="#cb23-533" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Create a non-trivial pattern within a fundamental domain (a single tile)</span>
<span id="cb23-534"><a href="#cb23-534" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Use <span class="in">`mod()`</span> to repeat it across the plane</span>
<span id="cb23-535"><a href="#cb23-535" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The pattern should tile seamlessly (edges should match up)</span>
<span id="cb23-536"><a href="#cb23-536" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-537"><a href="#cb23-537" aria-hidden="true" tabindex="-1"></a>**Ideas:**</span>
<span id="cb23-538"><a href="#cb23-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-539"><a href="#cb23-539" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Geometric patterns: nested circles, polygons, stars</span>
<span id="cb23-540"><a href="#cb23-540" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Color gradients that vary by tile position (using <span class="in">`cell_id`</span>)</span>
<span id="cb23-541"><a href="#cb23-541" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Combinations of implicit curves within each tile</span>
<span id="cb23-542"><a href="#cb23-542" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Symmetry: use <span class="in">`abs()`</span> to create reflections within tiles</span>
<span id="cb23-543"><a href="#cb23-543" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Distance-based effects: make circles pulse or fade based on <span class="in">`iTime`</span> and their position in the grid</span>
<span id="cb23-544"><a href="#cb23-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-545"><a href="#cb23-545" aria-hidden="true" tabindex="-1"></a>**Challenge**: Can you create a pattern that has different symmetries in different tiles? (For example, alternating rotational symmetry using the checkerboard <span class="in">`cell_id`</span> technique.) Or a pattern where the colors vary smoothly across the tiling, creating a large-scale gradient effect?</span>
<span id="cb23-546"><a href="#cb23-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-547"><a href="#cb23-547" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb23-548"><a href="#cb23-548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-549"><a href="#cb23-549" aria-hidden="true" tabindex="-1"></a><span class="fu">## Looking Ahead</span></span>
<span id="cb23-550"><a href="#cb23-550" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-551"><a href="#cb23-551" aria-hidden="true" tabindex="-1"></a>Tomorrow we'll use these techniques to explore **complex dynamics** (the Mandelbrot and Julia sets) and **geometric transformations** (circle inversions and the Apollonian gasket). The coordinate system and implicit curve techniques you've learned today will be the foundation for everything to come.</span>
<span id="cb23-552"><a href="#cb23-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-553"><a href="#cb23-553" aria-hidden="true" tabindex="-1"></a>Make sure you're comfortable with:</span>
<span id="cb23-554"><a href="#cb23-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-555"><a href="#cb23-555" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Setting up coordinates (the standard transformation from <span class="in">`fragCoord`</span> to centered, aspect-corrected <span class="in">`p`</span>)</span>
<span id="cb23-556"><a href="#cb23-556" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Computing distances and implicit functions  </span>
<span id="cb23-557"><a href="#cb23-557" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Using <span class="in">`mod()`</span> for repetition</span>
<span id="cb23-558"><a href="#cb23-558" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Conditionally coloring based on mathematical expressions</span>
<span id="cb23-559"><a href="#cb23-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-560"><a href="#cb23-560" aria-hidden="true" tabindex="-1"></a>If any of these feel shaky, now is the time to practice! Everything builds on this foundation.</span></code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>