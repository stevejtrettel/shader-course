[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPU-Accelerated Mathematical Illustration",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nWe’ll progress from 2D foundations (curves, tilings, fractals) through complex dynamics and hyperbolic geometry, to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to experiment with code through daily homework exercises.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "outline.html",
    "href": "outline.html",
    "title": "1  Outline",
    "section": "",
    "text": "1.1 Course Overview\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nFormat: Five days, each with one hour of lecture and approximately 1.5 hours of required homework, additional hours of optional homework.\nPrerequisites: Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Outline</span>"
    ]
  },
  {
    "objectID": "outline.html#day-1-introduction-to-shader-programming",
    "href": "outline.html#day-1-introduction-to-shader-programming",
    "title": "1  Outline",
    "section": "1.2 Day 1: Introduction to Shader Programming",
    "text": "1.2 Day 1: Introduction to Shader Programming\n\nLearning Objectives\n\nUnderstand the mathematical model of shader programming (function from pixels to colors)\nLearn basic GLSL syntax and conventions\nMaster coordinate system setup and distance calculations\nCreate simple geometric shapes and patterns\n\n\n\nIn-Class Content\n\nMathematical Introduction\n\nWhat is a shader? Framing as a function: color = f(x, y, time, ...)\nWhy GPUs? Parallelism means computing ALL pixels simultaneously\nShadertoy overview: available uniforms (iResolution, iTime, iMouse)\n\n\n\nFirst Shader: Solid Colors\n\nBasic shader structure: void mainImage(out vec4 fragColor, in vec2 fragCoord)\nSetting fragColor = vec4(1.0, 0.0, 0.0, 1.0) for a red screen\nGLSL syntax basics: semicolons, vector types, swizzling\nAnimating colors with iTime\n\n\n\nCoordinate System Setup\n\nConverting fragCoord to centered, normalized coordinates\nStandard boilerplate for coordinate transformation\nHandling aspect ratio correctly\n\n\n\nHalf-Plane Coloring\n\nBoolean expressions: x &lt; 0.0\nConditional coloring with ternary operator or step() function\nGeneralizing to arbitrary lines: ax + by &lt; 0\n\n\n\nCircles and Distance Fields\n\nComputing distance to center with length(p)\nFilled circle: length(p) &lt; radius\nCircle outline: abs(length(p) - radius) &lt; thickness\nOptional: Color gradients based on distance\n\n\n\nGrids and Repetition\n\nUsing mod(p, spacing) to create repeating cells\nCreating a grid of circles\nAlternating patterns with mod(floor(p), 2.0)\n\n\n\n\nHomework\n\nRequired: Parabola Graphing Calculator\nCreate a shader that draws a parabola with customizable coefficients: - Draw x and y axes (thick lines at x=0 and y=0) - Define variables: float a = 1.0; float b = 0.0; float c = 0.0; - Plot the curve y = ax² + bx + c as a thick tube - Should handle any hardcoded values of a, b, c\n\n\nOptional #1: Animated Curve Family\n\nUse iTime to vary parameters and animate a family of curves\nSuggestions: elliptic fibration, Lissajous curves, morphing shapes\n\n\n\nOptional #2: Beautiful Tiling Pattern\n\nDesign a pattern within a fundamental square\nUse mod() to tile it across the screen\nFocus on aesthetic appeal and mathematical structure",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Outline</span>"
    ]
  },
  {
    "objectID": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "href": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "title": "1  Outline",
    "section": "1.3 Day 2: Complex Dynamics and Euclidean Geometry",
    "text": "1.3 Day 2: Complex Dynamics and Euclidean Geometry\n\nLearning Objectives\n\nImplement complex number arithmetic in GLSL\nUnderstand and render the Mandelbrot and Julia sets\nCreate geometric tilings using mathematical transformations\nLearn to use structs for organizing data\n\n\n\nIn-Class Content\n\nComplex Numbers in GLSL\n\nRepresenting complex numbers as vec2\nImplementing complex multiplication\nComplex addition, conjugation, and magnitude\n\n\n\nThe Mandelbrot Set\n\nMathematical definition: iterating z → z² + c\nEscape-time algorithm\nColoring schemes based on iteration count\nDiscussing convergence and divergence\n\n\n\nJulia Sets\n\nFixing c and varying initial z\nRelationship to Mandelbrot set\nCreating visually interesting Julia sets\n\n\n\nIntroduction to Structs\n\nDefining struct types in GLSL\nUse case: organizing geometric data\nExample: storing triangle vertices or transformation data\n\n\n\nEuclidean Triangle Tiling\n\nFundamental domain for triangular tiling\nReflection across edges to create periodic patterns\nSymmetry groups and transformations\n\n\n\nIntroduction to Folding Fractals\n\nThe Sierpinski triangle via iterated reflections\nUsing abs() for geometric folding\nIteration count and coloring\n\n\n\n\nHomework\n\nRequired: Sierpinski Carpet\n\nImplement the 2D Sierpinski carpet using box folding\nUse repeated subdivision and removal pattern\nColor by iteration depth or distance\n\n\n\nOptional: Choose Your Adventure\n\nApollonian Gasket: Implement circle inversion and nested circles\nHyperbolic Triangle Tiling: Port triangle tiling to Poincaré disk or upper half-plane model",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Outline</span>"
    ]
  },
  {
    "objectID": "outline.html#day-3-non-euclidean-geometry-and-fractals",
    "href": "outline.html#day-3-non-euclidean-geometry-and-fractals",
    "title": "1  Outline",
    "section": "1.4 Day 3: Non-Euclidean Geometry and Fractals",
    "text": "1.4 Day 3: Non-Euclidean Geometry and Fractals\n\nLearning Objectives\n\nUnderstand hyperbolic geometry visualization\nImplement circle inversions and Möbius transformations\nCreate hyperbolic tilings in the Poincaré disk or upper half-plane\nMaster 2D folding techniques for fractal generation\n\n\n\nIn-Class Content\n\nReview: Circle Inversions\n\nMathematical definition and properties\nImplementation in GLSL\nGeometric intuition\n\n\n\nHyperbolic Geometry Primer\n\nPoincaré disk or upper half-plane model\nGeodesics as circular arcs\nFundamental domains for triangle groups\n\n\n\nHyperbolic Triangle Tiling\n\nFolding into fundamental domain via inversions\nIterating to create the full tiling\nColoring by fundamental domain or iteration\n\n\n\n2D Folding Fractals\n\nReview Sierpinski triangle folding technique\nSierpinski carpet as box folding\nGeneralizing the folding pattern\nIteration depth and visual effects\n\n\n\nAdvanced Techniques\n\nCombining multiple folding operations\nDomain coloring and visualization strategies\nParameter exploration\n\n\n\n\nHomework\n\nRequired: Fractal Variations\n\nExperiment with different folding patterns\nTry varying iteration depths\nCreate your own folding-based fractal\n\n\n\nOptional: Hyperbolic Variations\n\nImplement different hyperbolic tilings (different triangle groups)\nExplore Escher-style patterns in hyperbolic space\nCombine hyperbolic tiling with procedural decoration",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Outline</span>"
    ]
  },
  {
    "objectID": "outline.html#day-4-introduction-to-3d-rendering",
    "href": "outline.html#day-4-introduction-to-3d-rendering",
    "title": "1  Outline",
    "section": "1.5 Day 4: Introduction to 3D Rendering",
    "text": "1.5 Day 4: Introduction to 3D Rendering\n\nLearning Objectives\n\nUnderstand ray setup and camera models\nImplement analytical ray-object intersection\nLearn the raymarching algorithm and signed distance functions\nApply basic lighting models (diffuse shading)\n\n\n\nIn-Class Content\n\nRay Setup and Camera Model\n\nDefining ray origin and direction from pixel coordinates\nSimple camera model: position, look-at, up vector\nField of view and perspective projection\n\n\n\nAnalytical Ray-Sphere Intersection\n\nDeriving the intersection equation (quadratic)\nSolving for intersection parameter t\nComputing surface normal at intersection point\nRendering the sphere with flat color\n\n\n\nRay-Torus Intersection\n\nImplicit equation for a torus\nComputing gradient for surface normal\nDiscussion: analytical methods become complex quickly\n\n\n\nMotivation for Raymarching\n\nCombining multiple objects is difficult with analytical methods\nBoolean operations (union, intersection) are hard\nArbitrary implicit surfaces require root-finding\n\n\n\nSigned Distance Functions (SDFs)\n\nMathematical definition: minimum distance to surface\nSDFs for basic primitives: sphere, box, plane, torus, cylinder\nProperties: Lipschitz continuity and safe marching\n\n\n\nThe Raymarching Algorithm\n\nSphere tracing: march along ray by the distance to nearest surface\nStopping conditions: hit surface, max iterations, or exit bounds\nEstimating normals via gradient of the SDF\n\n\n\nBasic Lighting\n\nComputing surface normal from SDF gradient\nDiffuse shading: dot product with light direction\nSimple Lambertian lighting model\n\n\n\n\nHomework\n\nRequired: Algebraic Variety Rendering\n\nChoose a polynomial implicit surface (degree 3 or 4)\nImplement root-finding algorithm (bisection, Newton’s method, etc.)\nUse gradient for directional derivative to estimate distance\nOptimization: use sphere bounding box (outside sphere → return sphere SDF, inside → compute polynomial distance)\n\n\n\nOptional: Advanced Lighting and Transformations\n\nSpecular Lighting: Implement Phong or Blinn-Phong model\nTransformations: Use rotation matrices to orient objects in the scene\nComplex Scene: Combine multiple transformed objects with analytical intersections",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Outline</span>"
    ]
  },
  {
    "objectID": "outline.html#day-5-choose-your-adventure",
    "href": "outline.html#day-5-choose-your-adventure",
    "title": "1  Outline",
    "section": "1.6 Day 5: Choose Your Adventure",
    "text": "1.6 Day 5: Choose Your Adventure\nThe final day will be determined based on pacing, student interest, and energy levels. Two complete lectures are prepared:\n\nOption A: Advanced Raymarching Techniques\n\nLearning Objectives\n\nMaster domain operations for efficient complex scenes\nUnderstand and apply boolean operations on SDFs\nCreate 3D fractals via iterated folding\nBuild sophisticated mathematical visualizations\n\n\n\nIn-Class Content\n\nDomain Operations\n\nRepetition: Using mod(p, spacing) for infinite grids of objects\nSymmetry: Using abs() for mirror planes\nPolar repetition: Radial patterns around an axis\nComputational advantage: Zero cost for infinite complexity\n\n\n\nBoolean Operations on SDFs\n\nUnion: min(d1, d2)\nIntersection: max(d1, d2)\nSubtraction: max(d1, -d2)\nSmooth minimum: smin() for organic blending\nBuilding complex shapes from primitive combinations\n\n\n\nThe Menger Sponge\n\nBox folding in 3D with axis-aligned planes\nIterated subdivision pattern\nScaling and repetition\nConnection to Day 2’s Sierpinski carpet\n\n\n\nAdvanced Examples\n\nArchitectural structures via boolean operations\nInfinite repeated patterns via domain operations\nCombining techniques for rich scenes\n\n\n\n\nHomework\n\nRequired: Creative Scene Building\n\nBuild a complex scene using domain operations and boolean combinations\nExperiment with different SDFs and transformations\nFocus on mathematical or aesthetic interest\n\n\n\nOptional: Sierpinski Tetrahedron\n\nImplement 3D Sierpinski tetrahedron via folding\nReflect across four planes (non-axis-aligned)\nConnection to Day 2’s triangle folding in higher dimension\n\n\n\n\n\n\nOption B: Buffers and Temporal Dynamics\n\nLearning Objectives\n\nUnderstand buffer-based computation in Shadertoy\nImplement differential operators (Laplacian)\nSolve partial differential equations on the GPU\nCreate dynamic, evolving mathematical systems\n\n\n\nIn-Class Content\n\nIntroduction to Buffers\n\nReading from previous frame: texture(iChannel0, uv)\nMulti-pass rendering in Shadertoy\nSimple example: reading buffer and applying conditional coloring (bright → yellow, dark → blue)\n\n\n\nEdge Detection and the Laplacian\n\nDiscrete Laplacian stencil (5-point or 9-point)\nSampling neighboring pixels\nVisualizing edges in imagery\nIntroduction to spatial derivatives on discrete grids\n\n\n\nThe Heat Equation\n\nMathematical formulation: u_t = α∇²u\nApplying the Laplacian stencil for diffusion\nTime-stepping: u_new = u_old + dt * α * laplacian(u_old)\nInitial conditions: heat distribution in a fractal or Julia set\nWatching the pattern blur and diffuse\n\n\n\nBoundary Conditions\n\nZero boundary conditions (edges set to 0)\nAvoiding wrap-around artifacts\nDiscussion of periodic boundaries (if time)\n\n\n\nTimestep Stability\n\nCFL condition (briefly mentioned)\nProviding a stable dt value\nWarning: don’t make timestep too large!\n\n\n\n\nHomework\n\nRequired: Interactive Heat Equation or Reaction-Diffusion\n\nInteractive Heat Source: Add heat at mouse position, watch it diffuse\nGray-Scott Reaction-Diffusion: Implement pattern formation (spots, stripes, etc.) - store U and V in different color channels\n\n\n\nOptional: Wave Equation\n\nRequires two buffers (current and previous state)\nImplement u_tt = c²∇²u\nInitial conditions: pluck a “string” or create a disturbance\nWatch waves propagate and reflect",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Outline</span>"
    ]
  }
]