[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPU-Accelerated Mathematical Illustration",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nWe’ll progress from 2D foundations (curves, tilings, fractals) to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to work hard and experiment with code through daily homework exercises. Here are some examples of things we will make:",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "lectures/day1.html",
    "href": "lectures/day1.html",
    "title": "1  Day 1: Introduction",
    "section": "",
    "text": "1.1 Overview\nBy the end of today, you’ll be able to create things like this:\nA family of elliptic curves \\(y^2 = x^3 + ax + b\\), drawn for several values of \\(a\\) simultaneously, with \\(b\\) varying across the screen. The curves shift in brightness to show the family structure, and you can watch singularities appear and disappear along the discriminant locus.\nThis image is computed in real time, every pixel evaluated independently on the GPU. To get here, we’ll learn:\nLet’s begin.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#overview",
    "href": "lectures/day1.html#overview",
    "title": "1  Day 1: Introduction",
    "section": "",
    "text": "What a shader is: a function from coordinates to colors, evaluated in parallel\nHow to set up a coordinate system for mathematical visualization\nHow to draw shapes using distance functions\nHow to render implicit curves \\(F(x,y) = 0\\) with uniform thickness\nHow to add interactivity with mouse input",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#what-is-a-shader",
    "href": "lectures/day1.html#what-is-a-shader",
    "title": "1  Day 1: Introduction",
    "section": "1.2 What is a Shader?",
    "text": "1.2 What is a Shader?\nWe want to draw images on a screen.\nMathematically, an image is a function from a region \\(S \\subset \\mathbb{R}^2\\) to the space of visible colors \\(\\mathcal{C}\\). This color space is three-dimensional, spanned by the responses of the three types of cone cells in our eyes. A convenient basis, roughly aligned with these responses, is red, green, and blue.\nTo realize this on a computer, we discretize. A screen is a grid of pixels: \\(X\\) pixels wide, \\(Y\\) pixels tall. Each pixel is a point in the integer lattice \\[\\{0, 1, \\ldots, X-1\\} \\times \\{0, 1, \\ldots, Y-1\\}.\\]\nColors are represented as RGB triples: red, green, and blue intensities, each in \\([0,1]\\). The constraint to \\([0,1]\\) reflects physical reality—a pixel has a maximum brightness it can display. (We can’t draw the sun.) So an image is a function \\[f\\colon \\{0,\\ldots,X-1\\} \\times \\{0,\\ldots,Y-1\\} \\to [0,1]^3\\] \\[(i,j) \\mapsto (r,g,b).\\]\nIn practice, we add a fourth component: alpha, representing transparency. This matters when compositing multiple layers (we won’t use it in this course, but the machinery expects it). So our shader computes \\[f\\colon (i,j) \\mapsto (r,g,b,1).\\]\nThis is what a shader is. You write a function that takes pixel coordinates and returns an RGBA color. The GPU evaluates your function at every pixel to produce the image.\n\nParallelism\nA 1920×1080 display has over two million pixels. How do we evaluate \\(f\\) at all of them fast enough to animate at 60 frames per second?\nThe answer is parallelism. A GPU contains thousands of cores, and it evaluates \\(f\\) at all pixels simultaneously. There’s no loop over pixels in your code—you write \\(f\\), and the hardware handles the rest.\nThe tradeoff: each pixel’s computation must be independent. Pixel \\((100, 200)\\) cannot ask what color pixel \\((100, 199)\\) received. Every pixel sees the same global inputs—coordinates, time, mouse position—and must determine its color from those alone. Learning to think within this constraint is what shader programming is about.\n\n\n\n\n\n\nNoteWhy “shader”?\n\n\n\nThe name comes from 3D graphics, where these programs computed shading—how light interacts with surfaces. It stuck even though we now use shaders for fractals, simulations, and mathematical visualization.\n\n\n\n\nWhy Shadertoy?\nShader programming normally requires substantial setup: OpenGL contexts, buffer management, compilation, render loops. Shadertoy abstracts all of this—you write one function, press play, and see results. We’ll use it throughout the course.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#first-shaders-colors-and-syntax",
    "href": "lectures/day1.html#first-shaders-colors-and-syntax",
    "title": "1  Day 1: Introduction",
    "section": "1.3 First Shaders: Colors and Syntax",
    "text": "1.3 First Shaders: Colors and Syntax\n\nThe mainImage Function\nIn Shadertoy, your shader is a function called mainImage:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // your code here\n}\nThis function is called once per pixel, every frame. The inputs and outputs:\n\nfragCoord — the pixel coordinates, passed in to your function\nfragColor — the RGBA color, which you write out\n\nThe in and out keywords are explicit about data flow: fragCoord is read-only input, fragColor is where you write your result. The function returns void because the output goes through fragColor, not a return value.\n\n\nHello World: A Solid Color\nThe simplest shader: make every pixel red.\n\n  \n  \n  \n\n\nThe vec4(1.0, 0.0, 0.0, 1.0) constructs a 4-component vector: red=1, green=0, blue=0, alpha=1. Every pixel receives the same color, so the screen fills with red.\n\n\nGLSL Syntax Essentials\nGLSL (OpenGL Shading Language) will feel familiar if you’ve seen C-like syntax, but a few things are worth noting upfront.\nSemicolons are required at the end of each statement.\nFloats must include a decimal point. Write 1.0, not 1. The integer 1 and the float 1.0 are different types, and GLSL is strict about this.\nVector types are built in: vec2, vec3, vec4 for 2, 3, and 4 component vectors. Construct them with:\nvec2 p = vec2(3.0, 4.0);\nvec3 color = vec3(1.0, 0.5, 0.0);\nvec4 rgba = vec4(1.0, 0.0, 0.0, 1.0);\nArithmetic is component-wise. Adding two vectors adds their components:\nvec2(1.0, 2.0) + vec2(3.0, 4.0)  // = vec2(4.0, 6.0)\nScalar-vector operations apply the scalar to each component:\n2.0 * vec2(1.0, 3.0)  // = vec2(2.0, 6.0)\nAccessing components uses .x, .y, .z, .w:\nvec2 p = vec2(3.0, 4.0);\nfloat a = p.x;  // 3.0\nfloat b = p.y;  // 4.0\nFor colors, .r, .g, .b, .a are synonyms—color.r is the same as color.x.\nCommon math functions work as expected: sin, cos, abs, min, max, sqrt, pow. These operate on floats, and apply component-wise to vectors:\nsin(vec2(0.0, 3.14159))  // = vec2(0.0, ~0.0)\nFor loops work as you’d expect:\nfor (int i = 0; i &lt; 5; i++) {\n    // body executes with i = 0, 1, 2, 3, 4\n}\nThe loop variable is an int. Note that some older GPUs require the loop bounds to be constants known at compile time—you can’t always loop up to a variable. We’ll use loops extensively starting tomorrow.\n\n\nUniforms: Global Inputs\nShadertoy provides uniforms—global values that are constant across all pixels. Unlike fragCoord, which takes a different value at each pixel, a uniform has the same value everywhere. They’re how external information (time, screen size, mouse position) gets into your shader.\n\n\n\n\n\n\n\n\nUniform\nType\nDescription\n\n\n\n\niResolution\nvec3\nViewport size: (width, height, pixel_aspect_ratio)\n\n\niTime\nfloat\nSeconds since the shader started\n\n\niMouse\nvec4\nMouse position and click state\n\n\n\nWe’ll use iResolution constantly (for coordinate transforms) and iTime for animation.\n\n\nAnimation: Using iTime\nLet’s make the red channel pulse:\n\n  \n  \n  \n\n\nSince sin(iTime) oscillates between -1 and 1, the expression 0.5 + 0.5 * sin(iTime) oscillates between 0 and 1. The screen pulses from black to red.\nThis is our first animated shader—the output depends on time.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#coordinate-systems",
    "href": "lectures/day1.html#coordinate-systems",
    "title": "1  Day 1: Introduction",
    "section": "1.4 Coordinate Systems",
    "text": "1.4 Coordinate Systems\n\nPixel Coordinates\nThe input fragCoord gives the pixel coordinates of the current pixel. The coordinate system:\n\nOrigin at the bottom-left corner\nfragCoord.x increases to the right\nfragCoord.y increases upward\nRanges from \\((0, 0)\\) to \\((X, Y)\\) where \\(X \\times Y\\) is the screen resolution\n\nThis is workable, but inconvenient for mathematics. We’d prefer coordinates centered at the origin with a reasonable scale. Let’s build up a transformation step by step.\n\n\nStep 1: Normalize to \\([0,1]^2\\)\nDivide by the resolution to map pixel coordinates to the unit square:\nvec2 uv = fragCoord / iResolution.xy;\nNow uv ranges from \\((0,0)\\) at bottom-left to \\((1,1)\\) at top-right.\nSince both coordinates are in \\([0,1]\\), we can visualize them directly as color:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n\n  \n  \n  \n\n\nBlack at bottom-left (0,0), red at bottom-right (1,0), green at top-left (0,1), yellow at top-right (1,1).\n\n\nStep 2: Center the Origin\nSubtract \\((0.5, 0.5)\\) to center the origin:\nuv = uv - vec2(0.5, 0.5);\nNow uv ranges from \\((-0.5, -0.5)\\) to \\((0.5, 0.5)\\), with \\((0,0)\\) at the screen center.\n\n\nStep 3: Aspect Ratio Correction\nWe’ve mapped a rectangle of pixels (\\(X \\times Y\\)) to the square \\([-0.5, 0.5]^2\\). This is an affine transformation, not a similarity—it distorts shapes. A circle in our coordinates would render as an ellipse on screen.\nTo fix this, we scale the \\(x\\)-coordinate by the aspect ratio:\nuv.x *= iResolution.x / iResolution.y;\nNow a circle in our coordinates appears as a circle on screen. (When we draw shapes later, try commenting out this line to see the distortion.)\n\n\nStep 4: Scale to a Useful Range\nFinally, scale to a convenient window:\nvec2 p = uv * 4.0;\nWith a scale factor of 4, our coordinates range roughly from \\(-2\\) to \\(2\\)—a good default for visualizing mathematical objects.\n\n\nThe Standard Boilerplate\nPutting it together, here’s the coordinate setup we’ll use throughout the course:\nvec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]\nuv = uv - vec2(0.5, 0.5);               // center origin\nuv.x *= iResolution.x / iResolution.y;  // aspect correction\nvec2 p = uv * 4.0;                      // scale\nFrom here on, p is our mathematical coordinate, centered at the origin, aspect-corrected, with a reasonable range.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#drawing-with-distance",
    "href": "lectures/day1.html#drawing-with-distance",
    "title": "1  Day 1: Introduction",
    "section": "1.5 Drawing with Distance",
    "text": "1.5 Drawing with Distance\nSo far we’ve colored every pixel the same, or colored based on position as a gradient. Now we want to draw: to render a shape on screen.\nWhat does it mean to draw a shape? For a simple filled region, we need a rule that tells us, for each pixel: are you inside the shape or not? When inside, we do one thing (say, color yellow). When outside, we do another (color blue). The boundary of the shape is where we switch.\n\nHalf-Planes\nThe simplest shape is a half-plane. Consider the rule: is the \\(y\\)-coordinate greater than 0? This divides the plane into two regions—above and below the \\(x\\)-axis.\nfloat L = p.y;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red below\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue above\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nTo color left versus right instead, use p.x in place of p.y.\nMore generally, a line in the plane has the form \\(ax + by + c = 0\\). This divides the plane into two half-planes: where \\(ax + by + c &lt; 0\\) and where \\(ax + by + c &gt; 0\\).\nfloat a = 1.0, b = 1.0, c = 0.0;\nfloat L = a * p.x + b * p.y + c;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue\n}\n\nfragColor = vec4(color, 1.0);\nRecall that \\((a, b)\\) is the normal vector to the line, and \\(c\\) is an offset. Since these are just variables, we can animate them to move the line around:\nfloat a = cos(iTime);\nfloat b = sin(iTime);\nfloat c = 0.5 * sin(iTime * 0.7);\n\n  \n  \n  \n\n\n\n\nCircles\nNow consider the function \\(d(p) = |p|\\), the distance from the origin. Geometrically, the graph of this function is a cone—zero at the origin, increasing linearly in all directions.\nTo draw a filled disk of radius \\(r\\), we could threshold on \\(d &lt; r\\) versus \\(d \\geq r\\). But it’s cleaner to define \\(f(p) = |p| - r\\). This function is negative inside the circle (where \\(d &lt; r\\)) and positive outside (where \\(d &gt; r\\)). The circle itself is the level set \\(f = 0\\).\nfloat d = length(p);\nfloat r = 1.0;\nfloat f = d - r;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow inside\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nTry commenting out the aspect ratio correction (uv.x *= ...) to see the distortion—the circle becomes an ellipse.\nTo center the circle at a point \\(c\\) instead of the origin, compute distance from \\(c\\):\nvec2 center = vec2(1.0, 0.5);\nfloat d = length(p - center);\nSince center and r are variables, you can animate them with iTime to create moving, pulsing circles.\n\n\nDrawing a Ring\nOur function \\(f = d - r\\) is negative inside the circle and positive outside. To draw a filled disk, we colored based on the sign of \\(f\\).\nBut what if we want just the boundary—a ring of some thickness? We want to color one way when \\(f\\) is small in absolute value (near the circle), and a different way when \\(|f|\\) is large (far from the circle).\nSo we look at \\(|f| = |d - r|\\) and ask: is this less than some threshold \\(\\varepsilon\\), or greater? Equivalently, is \\(|d - r| - \\varepsilon\\) negative or positive?\nfloat d = length(p);\nfloat r = 1.0;\nfloat eps = 0.1;\nfloat f = abs(d - r) - eps;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 1.0);  // white ring\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#implicit-curves",
    "href": "lectures/day1.html#implicit-curves",
    "title": "1  Day 1: Introduction",
    "section": "1.6 Implicit Curves",
    "text": "1.6 Implicit Curves\nWe’ve drawn circles using the distance function \\(|p| - r\\). But circles are just one example of curves defined by an equation. Any equation \\(F(x,y) = 0\\) defines a curve—the set of points satisfying that equation. We can draw it the same way: threshold on \\(|F|\\).\n\nA First Example: The Parabola\nConsider \\(F(x,y) = y - x^2\\). The curve \\(F = 0\\) is the parabola \\(y = x^2\\). Points where \\(F &lt; 0\\) lie below the parabola; points where \\(F &gt; 0\\) lie above.\nTo draw the curve itself, we color pixels where \\(|F|\\) is small:\nfloat F = p.y - p.x * p.x;\nfloat eps = 0.1;\n\nvec3 color;\nif (abs(F) &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow curve\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\n\n\nMore Examples\nAn ellipse: \\(F(x,y) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1\\)\nfloat a = 2.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) + (p.y*p.y)/(b*b) - 1.0;\nA hyperbola: \\(F(x,y) = \\frac{x^2}{a^2} - \\frac{y^2}{b^2} - 1\\)\nfloat a = 1.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) - (p.y*p.y)/(b*b) - 1.0;\nThe lemniscate of Bernoulli: \\((x^2 + y^2)^2 = a^2(x^2 - y^2)\\), or \\(F = (x^2+y^2)^2 - a^2(x^2 - y^2)\\)\nfloat a = 1.5;\nfloat r2 = dot(p, p);  // x² + y²\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n\nThe Thickness Problem\nLook carefully at the parabola. The rendered thickness isn’t uniform—it’s thinner where the curve is steep, thicker where it’s flat. The problem gets worse with more complicated curves, especially those with singularities. Here’s the lemniscate:\n\n  \n  \n  \n\n\nNotice how the thickness blows up near the origin, where the curve crosses itself.\nWhy does this happen? The set \\(|F| &lt; \\varepsilon\\) contains all points within \\(\\varepsilon\\) of zero in the \\(F\\) direction. But \\(F\\) doesn’t measure distance to the curve—it’s just some function that happens to be zero on the curve. Where \\(|\\nabla F|\\) is large, \\(F\\) changes rapidly, so the band \\(|F| &lt; \\varepsilon\\) is narrow. Where \\(|\\nabla F|\\) is small, \\(F\\) changes slowly, so the band is wide. At the singular point, \\(\\nabla F = 0\\), and the band becomes infinitely wide.\n\n\nWhy Circles Worked\nFor the circle, we used \\(f(p) = |p| - r\\). This is the signed distance function: it measures actual geometric distance to the curve. The gradient of a distance function has magnitude 1 everywhere (it points toward or away from the curve at unit rate). So \\(|f| &lt; \\varepsilon\\) really does capture points within distance \\(\\varepsilon\\), giving uniform thickness.\nThis is a fact from differential geometry: \\(|\\nabla d| = 1\\) for a distance function \\(d\\). When we use an arbitrary implicit equation \\(F = 0\\), we lose this property.\n\n\nGradient Correction\nWe can fix the non-uniform thickness by dividing by the gradient magnitude. Instead of thresholding \\(|F| &lt; \\varepsilon\\), we threshold \\[\\frac{|F|}{|\\nabla F|} &lt; \\varepsilon.\\]\nThis approximates the signed distance to the curve. The intuition: \\(|F|/|\\nabla F|\\) estimates how far you’d need to travel (in the direction \\(F\\) changes fastest) to reach the curve.\nFor the lemniscate, we compute the gradient analytically: \\[\\nabla F = \\bigl(4x(x^2+y^2) - 2a^2 x,\\; 4y(x^2+y^2) + 2a^2 y\\bigr)\\]\nfloat a = 1.5;\nfloat r2 = dot(p, p);\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\nvec2 grad = vec2(\n    4.0 * p.x * r2 - 2.0 * a * a * p.x,\n    4.0 * p.y * r2 + 2.0 * a * a * p.y\n);\n\nfloat dist = abs(F) / max(length(grad), 0.01);  // avoid division by zero\nfloat eps = 0.05;\n\nvec3 color;\nif (dist &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nCompare with the naive version above to see the difference in thickness uniformity.\n\n\nAnimated Curve Families\nThe lemniscate is part of a one-parameter family called the Cassini ovals, defined by the product of distances from two foci being constant: \\[(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\]\nAs the parameter \\(a\\) varies relative to the fixed focal distance \\(c\\), the topology changes: two separate loops when \\(a &lt; c\\), a lemniscate when \\(a = c\\), a single oval when \\(a &gt; c\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#interactivity-and-abstraction",
    "href": "lectures/day1.html#interactivity-and-abstraction",
    "title": "1  Day 1: Introduction",
    "section": "1.7 Interactivity and Abstraction",
    "text": "1.7 Interactivity and Abstraction\nSo far our shaders respond to time (iTime) but not to user input. Shadertoy provides iMouse for mouse interaction.\n\nThe iMouse Uniform\niMouse is a vec4:\n\niMouse.xy — current mouse position (in pixels)\niMouse.zw — position where the mouse was last clicked\n\nFor now we’ll focus on iMouse.xy.\n\n\nDragging a Circle\nLet’s draw a circle centered at the mouse position. Since iMouse.xy is in pixel coordinates, we need to normalize it the same way we normalize fragCoord:\n// Normalize fragment coordinate\nvec2 uv = fragCoord / iResolution.xy;\nuv = uv - vec2(0.5, 0.5);\nuv.x *= iResolution.x / iResolution.y;\nvec2 p = uv * 4.0;\n\n// Normalize mouse coordinate the same way\nvec2 mouse = iMouse.xy / iResolution.xy;\nmouse = mouse - vec2(0.5, 0.5);\nmouse.x *= iResolution.x / iResolution.y;\nmouse = mouse * 4.0;\n\n// Circle centered at mouse\nfloat d = length(p - mouse);\nfloat r = 0.5;\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nClick and drag to move the circle.\n\n\nWriting a Helper Function\nWe just wrote the same four lines of coordinate normalization twice. This is a sign we should write a function.\nA GLSL function declares its return type, then the function name, then its parameters with their types:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\nFunctions must be defined before they’re used, so they go above mainImage. Here’s the overall structure:\nvec2 normalize_coord(vec2 coord) {\n    // normalization logic here\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = normalize_coord(fragCoord);\n    vec2 mouse = normalize_coord(iMouse.xy);\n    \n    // code using p and mouse\n}\nNow our shader is cleaner, and we won’t make mistakes copying the normalization code.\n\n\nCombining iMouse and iTime: Sun and Earth\nLet’s make a circle orbit around the mouse position:\nvec2 p = normalize_coord(fragCoord);\nvec2 sun = normalize_coord(iMouse.xy);\n\n// Earth orbits the sun\nfloat orbit_radius = 0.8;\nvec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n\n// Draw sun (larger, yellow)\nfloat d_sun = length(p - sun);\n// Draw earth (smaller, blue)\nfloat d_earth = length(p - earth);\n\nvec3 color = vec3(0.02, 0.02, 0.05);  // dark background\nif (d_sun &lt; 0.3) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow sun\n}\nif (d_earth &lt; 0.15) {\n    color = vec3(0.2, 0.5, 1.0);  // blue earth\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nDrag to move the sun; the earth follows in orbit. (Exercise: add a moon orbiting the earth!)\n\n\nMouse as Parameter\nThe mouse doesn’t have to control position—it can control any parameter. A useful pattern: map iMouse.x to a parameter range and drag across the screen to explore a family of curves.\nThe folium of Descartes is the curve \\(x^3 + y^3 = 3axy\\). We can explore its level sets by drawing \\(x^3 + y^3 - 3axy = c\\) for different values of \\(c\\):\nvec2 p = normalize_coord(fragCoord);\n\n// Fixed parameter a\nfloat a = 1.5;\n\n// Map mouse x to level set value c in [-2, 2]\nfloat c = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n\n// Folium of Descartes: x³ + y³ - 3axy = c\nfloat F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;\n\n// Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)\nvec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);\nfloat dist = abs(F) / max(length(grad), 0.01);\n\nvec3 color;\nif (dist &lt; 0.05) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nDrag left and right to sweep through the level sets and watch the curve topology change.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#exercises",
    "href": "lectures/day1.html#exercises",
    "title": "1  Day 1: Introduction",
    "section": "1.8 Exercises",
    "text": "1.8 Exercises\nHomework is organized into four types:\nCheckpoints — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.\nExplorations — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you’re right on track with the course.\nChallenges — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.\nProject — An extended project for someone familiar with shader basics, to make an artwork.\n\n\nCheckpoints\nC1. Solid Colors. Modify the red screen shader to display: (a) green, (b) cyan, (c) a color of your choice using all three RGB channels.\nC2. Vertical Split. Modify the half-plane shader to divide the screen into left (red) and right (blue) instead of top and bottom.\nC3. Off-Center Circle. Draw a filled circle of radius 0.5 centered at the point \\((1, 1)\\) instead of the origin.\nC4. Pulsing Circle. Make a circle whose radius oscillates between 0.5 and 1.5 over time using iTime.\nC5. Ring Thickness. Draw a ring (circle outline) centered at the origin. Experiment with different values of eps to understand how it controls thickness.\n\n\n\nExplorations\nE1. Concentric Rings. Draw several concentric rings (circles of different radii, all centered at the origin). Can you color alternate rings differently?\nE2. Moon Orbit. Extend the sun-earth shader to add a moon that orbits the earth. The moon should be smaller than the earth and orbit faster.\nE3. Your Favorite Curve. Pick an implicit curve from your mathematical experience (or find one online) and render it. Some suggestions: the cardioid \\((x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)\\), the astroid \\(x^{2/3} + y^{2/3} = a^{2/3}\\), or a rose curve in implicit form. Apply gradient correction for uniform thickness.\nE4. Curve Explorer. Take any one-parameter family of curves and build a mouse-controlled explorer (like the folium example). Map iMouse.x to the parameter and drag to explore the family.\nE5. Two Circles. Draw two filled circles at different positions. What happens when they overlap? Can you make one “in front of” the other? Can you make the intersection a different color, like a Venn diagram?\n\n\n\nChallenges\nH1. Parabola Graphing Calculator. Build an interactive graphing calculator for the parabola \\(y = ax^2 + bx + c\\). Requirements: - Draw coordinate axes (the lines \\(x = 0\\) and \\(y = 0\\)) - Draw the parabola using implicit curve techniques - Find the roots (where \\(y = 0\\)) and draw small circles around them - Use mouse position to control two of the coefficients (e.g., \\(a\\) and \\(b\\), with \\(c\\) fixed, or \\(b\\) and \\(c\\) with \\(a\\) fixed)\nAs you drag the mouse, the parabola should reshape and the root indicators should move (or appear/disappear as roots become real or complex).\nH2. Elliptic Curve Explorer. Elliptic curves in Weierstrass form are \\(y^2 = x^3 + ax + b\\). Build a shader where the mouse position controls \\((a, b)\\). Use gradient correction for uniform thickness. The discriminant \\(\\Delta = 4a^3 + 27b^2\\) determines whether the curve is smooth (\\(\\Delta \\neq 0\\)) or singular (\\(\\Delta = 0\\)). Can you display the current value of \\(\\Delta\\) somehow, or change the curve’s color when it becomes singular?\nH3. Signed Distance Functions. For a filled circle, \\(f(p) = |p| - r\\) is the signed distance function: negative inside, positive outside, with \\(|f|\\) giving the actual distance to the boundary. What is the signed distance function for a half-plane? For an axis-aligned rectangle? Implement both and draw them with uniform-thickness boundaries. Note: when you have the true signed distance function, you don’t need the gradient correction trick—that’s the payoff for computing the right thing from the start!\nH4. Smooth Blending. When two circles overlap, we currently just draw one on top of the other. Research smooth minimum functions (e.g., smin) that blend distance fields smoothly. Draw two circles that “melt together” where they meet.\nH5. Inversion. Circle inversion is the map \\(p \\mapsto p / |p|^2\\). Apply this transformation to your coordinate \\(p\\) before drawing a shape. What happens to a line? What happens to a circle not passing through the origin? Experiment with different shapes.\n\n\n\nProject: Grid Patterns\nThis extended project introduces a powerful technique—using modular arithmetic to repeat patterns across the plane. We’ll build up the machinery carefully, since we’ll use it again in Day 2 to create grids of Julia sets.\n\nPart 1: Setting Up a Grid of Square Cells\nWe want to tile the screen with square cells—say, 4 cells across. The challenge: the screen isn’t square, so we need to handle the aspect ratio.\nLet’s say we want N columns of cells. Each cell has width \\(L = \\text{screen\\_width} / N\\) in pixels, and since cells are square, height \\(L\\) as well. The number of rows depends on the screen’s aspect ratio.\nWorking in our normalized coordinates (after aspect correction), the screen spans roughly \\([-2 \\cdot \\text{aspect}, 2 \\cdot \\text{aspect}]\\) in \\(x\\) and \\([-2, 2]\\) in \\(y\\). If we want cells of side length \\(L\\) in these coordinates:\nfloat aspect = iResolution.x / iResolution.y;\nfloat N = 5.0;  // number of columns\nfloat L = (4.0 * aspect) / N;  // cell size in our coordinate system\nNow each cell is an \\(L \\times L\\) square.\n\n\nPart 2: Cell Coordinates and Identity\nFor each pixel, we want two things:\n\nWhich cell are we in? Integer coordinates \\((i, j)\\) identifying the cell.\nWhere in the cell are we? Local coordinates ranging from \\(-L/2\\) to \\(L/2\\), with \\((0,0)\\) at the cell center.\n\nvec2 cell_id = floor(p / L);\nvec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);\nThe cell_id tells us which cell; the cell_p gives local coordinates within that cell.\nIf we want local coordinates normalized to \\([-1, 1]\\) (useful for drawing things at a standard scale), we can rescale:\nvec2 local = cell_p / (L / 2.0);  // now in [-1, 1] x [-1, 1]\nThis is exactly the setup we’ll need for Day 2, where each cell will contain a Julia set with its own coordinate system.\n\n\nPart 3: Drawing in Each Cell\nNow draw something using the local coordinates. A filled circle at the center of each cell:\nfloat d = length(cell_p);\nfloat r = L * 0.4;  // radius relative to cell size\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nTry changing N to get more or fewer columns. The cells stay square regardless of screen shape.\n\n\nPart 4: Varying by Cell\nThe cell_id lets each cell behave differently. Some ideas:\nCheckerboard background:\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\nvec3 bg = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\nRadius varying by cell:\nfloat r = L * (0.2 + 0.15 * mod(cell_id.x + cell_id.y, 3.0));\nWave animation:\nfloat cell_dist = length(cell_id);\nfloat r = L * (0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5));\n\n\nPart 5: Design Challenge\nDesign a grid-based pattern that you find visually interesting. Some directions:\nConnecting shapes: Draw shapes that connect across cell boundaries. Quarter-circles in each corner create a continuous network. What implicit curves tile seamlessly?\nAlternating motifs: Use cell_id to alternate between different shapes—circles in some cells, rings in others, or different orientations.\nColor fields: Map cell_id to colors using distance from origin, stripes, or a palette.\nPhase shifts: Animate cells with different phase offsets to create waves or ripples.\nUsing local coordinates: Draw something more complex in each cell using the \\([-1,1]\\) local coordinate system—perhaps a small implicit curve, or a pattern that changes based on cell_id.\nThe goal is to produce an image you’d be happy to hang on a wall.\n\n\n\nProject: Fourier Epicycles\nThis project builds a visualization of Fourier series using epicycles—circles whose centers sit on the circumferences of other circles. This is how Ptolemy modeled planetary motion, and it turns out to be exactly how Fourier series work geometrically.\n\nPart 1: The Idea\nAny periodic function can be written as a sum of sines and cosines. Geometrically, \\(\\sin(n\\omega t)\\) and \\(\\cos(n\\omega t)\\) describe a point moving around a circle of frequency \\(n\\omega\\). Adding these components corresponds to stacking circles: each circle’s center rides on the previous circle’s edge.\nFor example, the square wave has Fourier series: \\[f(t) = \\sum_{n=1,3,5,...} \\frac{1}{n} \\sin(n\\omega t)\\]\nThis means circles with: - Radii: \\(1, \\frac{1}{3}, \\frac{1}{5}, \\frac{1}{7}, ...\\) - Frequencies: \\(\\omega, 3\\omega, 5\\omega, 7\\omega, ...\\)\nThe more terms we add, the closer the final point’s \\(y\\)-coordinate approximates a square wave.\n\n\nPart 2: Drawing Circles\nStart by drawing a chain of circles. Each circle is centered at the current position, and the next position is computed by moving along the circle:\nvec2 pos = vec2(0.0, 0.0);  // start at origin\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;  // 1, 3, 5, 7, ...\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    // Draw circle at current position\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // color the circle\n    }\n    \n    // Move to next position\n    pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n}\n\n// Draw final point\nfloat d_point = length(p - pos);\nif (d_point &lt; 0.08) {\n    // bright color\n}\nTry this with N = 1, then N = 3, then N = 7. Watch how more circles create more complex motion.\n\n\nPart 3: The Line Segment SDF\nTo draw the arms connecting circle centers, we need the signed distance function for a line segment. Given endpoints \\(a\\) and \\(b\\), the distance from point \\(p\\) to the segment is:\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\nThe math: we project \\(p - a\\) onto the line direction \\(b - a\\), clamp to \\([0, 1]\\) to stay within the segment, then measure the distance to that closest point.\n\n\nPart 4: Connecting the Arms\nNow modify your loop to also draw line segments:\nvec2 pos = vec2(0.0, 0.0);\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n    \n    // Draw circle\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // faint circle color\n    }\n    \n    // Draw arm from pos to next_pos\n    float d_arm = sd_segment(p, pos, next_pos);\n    if (d_arm &lt; 0.015) {\n        // arm color\n    }\n    \n    pos = next_pos;\n}\n\n\nPart 5: Polish and Explore\nNow make it beautiful:\nFading circles: Later circles are smaller and less important. Fade their brightness:\nfloat fade = 1.0 - float(i) / float(N);\nColor variation: Color circles differently based on their index, or based on their frequency.\nDifferent waves: The square wave uses odd harmonics with \\(1/n\\) coefficients. Try: - Triangle wave: odd harmonics with \\(1/n^2\\) coefficients (alternating signs) - Sawtooth wave: all harmonics with \\(1/n\\) coefficients\nMouse control: Map iMouse.x to the number of terms, so dragging adds or removes circles.\nThe goal: create a mesmerizing animation that reveals the geometry hidden inside Fourier series.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html",
    "href": "lectures/day2.html",
    "title": "2  Day 2: Dynamics",
    "section": "",
    "text": "2.1 Overview\nToday we’ll learn how to do per-pixel computation in shaders, to quickly produce images of compelx mathematical objects. In the homework today, you’ll create your own version of the classic mandelbrot fractal zoom:\nToday we explore two kinds of iterative systems:\nBoth share the same GPU-friendly structure: each pixel asks “what happens when I iterate from here?” No pixel depends on any other—perfect for parallel computation.\nAlong the way, we’ll learn to implement complex arithmetic in GLSL and organize geometric data using structs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#overview",
    "href": "lectures/day2.html#overview",
    "title": "2  Day 2: Dynamics",
    "section": "",
    "text": "Complex dynamics: Iterating holomorphic maps gives us the Mandelbrot set, Julia sets, and their cousins\nCircle inversion: Iterating geometric transformations gives us the Apollonian gasket",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#complex-numbers-in-glsl",
    "href": "lectures/day2.html#complex-numbers-in-glsl",
    "title": "2  Day 2: Dynamics",
    "section": "2.2 Complex Numbers in GLSL",
    "text": "2.2 Complex Numbers in GLSL\nThe complex numbers \\(\\mathbb{C}\\) are the plane equipped with a multiplication operation. Today we implement that algebra in GLSL.\n\nRepresentation\nA complex number \\(z = a + bi\\) is naturally represented as a 2D vector:\nvec2 z = vec2(a, b);  // represents a + bi\nWe’ll consistently use the convention that z.x is the real part and z.y is the imaginary part.\n\n\nArithmetic\nAddition of complex numbers is componentwise—exactly what GLSL’s built-in + does for vectors. No helper function needed.\nMultiplication is more interesting. In GLSL, the * operator on vectors is componentwise: vec2(a,b) * vec2(c,d) gives vec2(a*c, b*d). This is not complex multiplication! We need to implement the correct formula ourselves.\nRecall \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\):\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\nThis is the FOIL pattern with \\(i^2 = -1\\) giving the minus sign in the real part.\n\n\nMagnitude\nThe magnitude of \\(z = a + bi\\) is the distance from the origin: \\[|z| = \\sqrt{a^2 + b^2}\\]\nWe can implement this directly:\nfloat cabs(vec2 z) {\n    return sqrt(z.x * z.x + z.y * z.y);\n}\nBut consider: we’ll often have conditions like “is \\(|z|\\) bigger than 2?” rather than needing the actual magnitude. In these cases, we can check \\(|z|^2 &gt; 4\\) instead of \\(|z| &gt; 2\\)—same answer, but no square root. When you’re doing this check millions of times per frame (once per pixel, 60 frames per second), avoiding unnecessary square roots adds up.\nSo we define the squared magnitude:\nfloat cabs2(vec2 z) {\n    return z.x * z.x + z.y * z.y;\n}\nIf we want to be even more efficient, we can use GLSL’s built-in dot product, which computes exactly this sum of products:\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // a² + b²\n}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-mandelbrot-set",
    "href": "lectures/day2.html#the-mandelbrot-set",
    "title": "2  Day 2: Dynamics",
    "section": "2.3 The Mandelbrot Set",
    "text": "2.3 The Mandelbrot Set\nThe Mandelbrot set is perhaps the most iconic fractal—its shape is instantly recognizable, and its discovery in 1980 helped launch the era of computer-generated mathematical visualization. The definition is remarkably simple.\n\nDefinition\nFix a complex number \\(c\\). Starting from \\(z_0 = 0\\), define a sequence by iterating: \\[z_{n+1} = z_n^2 + c\\]\nFor some values of \\(c\\), this sequence stays bounded forever. For others, it escapes to infinity. The Mandelbrot set \\(\\mathcal{M}\\) is the set of all \\(c\\) for which the sequence remains bounded.\nThat’s it! One quadratic formula, iterated. The intricate structure of the Mandelbrot set emerges entirely from this simple rule.\n\n\nRendering Strategy\nTo draw the Mandelbrot set, we test each pixel: is this value of \\(c\\) in \\(\\mathcal{M}\\) or not?\nThis is exactly the kind of question shaders excel at. Each pixel performs its own independent calculation—no pixel needs information from any other pixel. The entire image can be computed in parallel, with thousands of GPU cores each testing their own value of \\(c\\) simultaneously.\nBut there’s a problem: the definition involves iterating “forever” and checking if the sequence “stays bounded.” We can’t iterate infinitely, and we can’t wait forever to decide. We need a practical criterion for when to stop.\n\n\nThe Escape Radius\nWe need two facts that make efficient rendering possible.\nFact 1. The Mandelbrot set is contained in the disk of radius 2. That is, if \\(|c| &gt; 2\\), then \\(c \\notin \\mathcal{M}\\).\nProof. [TODO] \\(\\square\\)\nFact 2. If \\(|c| \\leq 2\\) and \\(|z_n| &gt; 2\\) for some \\(n\\), then the orbit escapes to infinity (so \\(c \\notin \\mathcal{M}\\)).\nProof. [TODO] \\(\\square\\)\nThis gives us a stopping criterion: once \\(|z_n| &gt; 2\\), we know \\(c\\) is not in the Mandelbrot set. We don’t need to keep iterating.\nTogether, these facts justify the escape-time algorithm: iterate until either \\(|z_n| &gt; 2\\) (escaped, not in \\(\\mathcal{M}\\)) or we hit a maximum iteration count (probably in \\(\\mathcal{M}\\)).\n\n\nThe Escape-Time Algorithm\nThese two facts give us our algorithm:\n\nFor each pixel, let \\(c\\) be the corresponding complex number\nStart with \\(z = 0\\)\nIterate \\(z \\mapsto z^2 + c\\)\nIf \\(|z| &gt; 2\\), stop—this point escapes (not in \\(\\mathcal{M}\\))\nIf we reach a maximum iteration count without escaping, assume bounded (in \\(\\mathcal{M}\\))\n\nThe core of this is a loop:\nvec2 z = vec2(0.0, 0.0);\nint max_iter = 100;\nint iter;\n\nfor (iter = 0; iter &lt; max_iter; iter++) {\n    if (cabs2(z) &gt; 4.0) break;  // |z|² &gt; 4 means |z| &gt; 2\n    z = cmul(z, z) + c;\n}\nAfter this loop, iter tells us what happened: if iter == max_iter, we never escaped (probably in \\(\\mathcal{M}\\)). Otherwise, we escaped on iteration iter.\n\n\nBinary Coloring\nThe simplest approach: color points black if they’re in the set, white if they escaped.\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);  // In the set: black\n} else {\n    color = vec3(1.0);  // Escaped: white\n}\n\n\nFull Implementation\nPutting it together with our coordinate setup:\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale and center to show the Mandelbrot set\n    // By Fact 1, the set lies in |c| ≤ 2\n    vec2 c = uv * 4.0;\n    c.x -= 0.5;  // shift left to center the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Binary coloring\n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);  // In the set: black\n    } else {\n        color = vec3(1.0);  // Escaped: white\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThere it is—the Mandelbrot set in black and white!\n\n\nColoring by Iteration Count\nBlack and white shows the set, but we’re throwing away information. The number of iterations before escape tells us how “close” a point is to the boundary—points that escape after 5 iterations are different from points that escape after 50.\nLet’s use iter to create a gradient:\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);\n} else {\n    float t = float(iter) / float(max_iter);\n    color = vec3(t);\n}\n\n  \n  \n  \n\n\nNow we see structure! The boundary reveals intricate detail—tendrils, spirals, bulbs. Points near the boundary take many iterations to escape (bright), while points far away escape quickly (dark).\n\n\nColor Palettes\nGrayscale works, but we can do better. A common technique uses cosines to create smooth, cycling color palettes:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nThe parameters a, b, c, d control the palette’s character. The vector d shifts the phase of each color channel, creating different hues. Try d = vec3(0.00, 0.10, 0.20) for blues and purples, or d = vec3(0.30, 0.20, 0.20) for warmer tones.\n\n  \n  \n  \n\n\nThe color bands correspond to iteration counts—regions of the same color escaped after the same number of iterations. You’ll notice the bands have sharp edges. In the exercises, we’ll show you a technique called smooth coloring that interpolates between iteration counts, eliminating the banding for even smoother gradients.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#other-escape-time-fractals",
    "href": "lectures/day2.html#other-escape-time-fractals",
    "title": "2  Day 2: Dynamics",
    "section": "2.4 Other Escape-Time Fractals",
    "text": "2.4 Other Escape-Time Fractals\nThe Mandelbrot set is one example of an escape-time fractal, but the same algorithm works for many other iterated systems. We just swap out the iteration formula (and sometimes the escape condition). Let’s explore a few.\n\nJulia Sets\nThe Mandelbrot set asks: for which values of \\(c\\) does the orbit of \\(0\\) stay bounded? We can ask a different question: for a fixed \\(c\\), which starting points \\(z_0\\) have bounded orbits?\nFix a complex number \\(c\\). The filled Julia set \\(K_c\\) is the set of all starting points \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded.\nSame iteration, different question. For the Mandelbrot set, we vary \\(c\\) and always start at \\(z_0 = 0\\). For a Julia set, we fix \\(c\\) and vary \\(z_0\\).\nThe code change is minimal:\n// Mandelbrot: c varies, z starts at 0\nvec2 c = p;\nvec2 z = vec2(0.0, 0.0);\n\n// Julia: c is fixed, z starts at pixel position\nvec2 c = vec2(-0.7, 0.27015);  // fixed parameter\nvec2 z = p;\n\n  \n  \n  \n\n\nDifferent values of \\(c\\) produce dramatically different Julia sets. In the exercises, you’ll build an interactive explorer that lets you click anywhere on the Mandelbrot set to see the corresponding Julia set:\n\n  \n  \n  \n\n\n\n\nOthers\nThe Mandelbrot set uses \\(z^2 + c\\). What about \\(z^3 + c\\)? Or \\(z^4 + c\\)?\nFor \\(z^3\\), we can compose our existing cmul function:\nvec2 ccube(vec2 z) {\n    return cmul(cmul(z, z), z);  // z · z · z\n}\nHigher powers give higher-order rotational symmetry: \\(z^3 + c\\) has 3-fold symmetry, \\(z^4 + c\\) has 4-fold symmetry, and so on.\nFor some more variety, the Burning Ship fractal modifies the Mandelbrot iteration by taking the absolute value of the imaginary part after each squaring:\n\\[z_{n+1} = (\\text{Re}(z_n^2) + i|\\text{Im}(z_n^2)|) + c\\]\n\n\nThe Pattern\nAll these fractals share the same structure:\n\nIterate some function \\(f(z, c)\\)\nCheck escape: has \\(|z|\\) exceeded some threshold?\nColor based on iteration count\n\nChanging the iteration function changes the fractal. The exercises include more variations for you to try.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#circle-inversion",
    "href": "lectures/day2.html#circle-inversion",
    "title": "2  Day 2: Dynamics",
    "section": "2.5 Circle Inversion",
    "text": "2.5 Circle Inversion\nWe shift gears from complex dynamics to geometric transformations. Circle inversion is a classical operation that turns circles into circles (or lines), preserves angles, and creates beautiful fractal patterns when iterated.\n\nDefinition\nInversion in the unit circle maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\frac{\\mathbf{p}}{|\\mathbf{p}|^2}\\]\nWhat does this do geometrically? The inverted point lies on the same ray from the origin as \\(\\mathbf{p}\\), but at distance \\(1/r\\) instead of \\(r\\).\n\nPoints inside the unit circle map to points outside\nPoints outside map to points inside\n\nPoints on the unit circle stay fixed\nThe origin maps to “infinity”\n\n\n\nImplementation\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\n\nVisualizing Inversion\nTo see what inversion does, let’s draw some shapes and their images. We’ll draw the unit circle (gray), plus a vertical line and a circle (yellow). To make it clearer, we’ll toggle between showing the original shapes and their inversions:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Compute the inversion of p\n    vec2 p_inv = invert(p);\n    \n    // Toggle between original and inverted every second\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;      // original\n    } else {\n        q = p_inv;  // inverted\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle (the inversion circle)\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a vertical line at x = 2\n    if (abs(q.x - 2.0) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a horizontal line at y = 1.5\n    if (abs(q.y - 1.5) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a circle centered at (2, 0) with radius 0.5\n    float d_circle = abs(length(q - vec2(2.0, 0.0)) - 0.5);\n    if (d_circle &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nWatch the lines become circles! A line not passing through the origin inverts to a circle that does pass through the origin. The circle inverts to another circle (with a different center and radius).\n\n\n\n\n\n\nTipGLSL Shortcuts: mix and step\n\n\n\nThe toggle logic can be written more compactly using built-in functions:\n\nstep(edge, x) returns 0 if x &lt; edge, otherwise 1\nmix(a, b, t) linearly interpolates: returns a when t = 0, b when t = 1\n\nfloat t = step(0.5, fract(iTime * 0.5));\nvec2 q = mix(p, p_inv, t);\nThis is a common pattern for toggling or smoothly transitioning between states.\n\n\n\n\nKey Properties\nCircle inversion maps circles to circles (or to lines, if the circle passes through the center). It’s conformal—it preserves angles between curves. And it’s involutive: applying inversion twice returns to the original point.\n\n\nInverting a Grid\nFor a more dramatic visualization, let’s invert a whole grid of lines. The function mod(q, 0.5) gives the position of q within a repeating \\(0.5 \\times 0.5\\) cell—when either component is near zero, we’re on a grid line:\nvec2 grid = mod(q, 0.5);\nif (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n(If you did the grid project from Day 1, this is familiar!)\nUsing the same toggle shader structure as before, just replacing the individual shapes with this grid:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#structs",
    "href": "lectures/day2.html#structs",
    "title": "2  Day 2: Dynamics",
    "section": "2.6 Structs",
    "text": "2.6 Structs\nSo far our invert function only works for the unit circle at the origin. What if we want to invert through a different circle?\n\nGeneral Circle Inversion\nFor a circle with center \\(\\mathbf{c}\\) and radius \\(R\\), inversion maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nThe idea is the same as before: the inverted point lies on the ray from \\(\\mathbf{c}\\) through \\(\\mathbf{p}\\), at distance \\(R^2/r\\) from the center (where \\(r = |\\mathbf{p} - \\mathbf{c}|\\)). When \\(\\mathbf{c} = \\mathbf{0}\\) and \\(R = 1\\), this reduces to our earlier formula \\(\\mathbf{p}/|\\mathbf{p}|^2\\).\nIn code:\nvec2 invertInCircle(vec2 p, vec2 center, float radius) {\n    vec2 d = p - center;\n    return center + radius * radius * d / dot(d, d);\n}\nThis works, but notice we need to pass two things (center and radius) to describe one object (a circle). If we’re working with multiple circles, every function call needs center1, radius1, center2, radius2, ...—it gets verbose and error-prone.\n\n\nDefining a Struct\nGLSL lets us bundle related data into a struct:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nNow Circle is a type, just like vec2 or float. We can create circles and access their fields:\nCircle c;\nc.center = vec2(1.0, 0.5);\nc.radius = 0.7;\n\n// Or initialize directly:\nCircle c = Circle(vec2(1.0, 0.5), 0.7);\n\n\nInversion with Structs\nNow our inversion function takes a Circle:\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\nMuch cleaner! And when we’re working with multiple circles, we can pass them around as single objects.\n\n\nDemo: Moving Circle\nLet’s animate a circle moving around and watch how the inversion changes. The key new elements are animating the circle’s center and radius:\n// Animate the inversion circle\nCircle inv_circle;\ninv_circle.center = vec2(sin(iTime) * 0.5, cos(iTime * 0.7) * 0.5);\ninv_circle.radius = 1.0 + 0.3 * sin(iTime * 1.3);\n\n// Compute inversion\nvec2 p_inv = invert(p, inv_circle);\n\n  \n  \n  \n\n\nAs the circle moves and breathes, the inverted grid warps and flows.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-apollonian-gasket",
    "href": "lectures/day2.html#the-apollonian-gasket",
    "title": "2  Day 2: Dynamics",
    "section": "2.7 The Apollonian Gasket",
    "text": "2.7 The Apollonian Gasket\nThe Apollonian gasket is a classical fractal arising from circle packing. It’s named after Apollonius of Perga (~200 BCE), who studied the problem of finding circles tangent to three given circles.\n\nThe Setup\nStart with four mutually tangent circles: three “inner” circles that touch each other pairwise, all enclosed by one “outer” circle that touches all three.\nLet’s define these circles using our Circle struct. We’ll place three circles of radius \\(r\\) with centers forming an equilateral triangle, all tangent to each other and to an outer circle:\n// Three inner circles, mutually tangent, plus outer circle\n// For circles of radius r to be mutually tangent, their centers\n// must be 2r apart. This forms an equilateral triangle with side 2r.\nfloat r = 1.0;\nfloat triSide = 2.0 * r;  // distance between inner circle centers\nfloat circumradius = triSide / sqrt(3.0);  // distance from origin to centers\n\nCircle c1 = Circle(vec2(0.0, circumradius), r);\nCircle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\nCircle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\nCircle outer = Circle(vec2(0.0, 0.0), circumradius + r);\nTo draw these circles, we need a distance function:\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\nThis returns the distance from p to the circle’s boundary—zero on the circle, positive elsewhere.\nLet’s draw our starting configuration:\nvec3 color = vec3(0.1, 0.1, 0.15);\n\n// Draw all four circles\nif (distToCircle(p, c1) &lt; 0.03) color = vec3(1.0, 0.3, 0.3);\nif (distToCircle(p, c2) &lt; 0.03) color = vec3(0.3, 1.0, 0.3);\nif (distToCircle(p, c3) &lt; 0.03) color = vec3(0.3, 0.3, 1.0);\nif (distToCircle(p, outer) &lt; 0.03) color = vec3(1.0, 1.0, 1.0);\n\n  \n  \n  \n\n\nThree colored circles inside a white outer circle, all mutually tangent.\n\n\nFrom Drawing to Iteration\nThe gaps between circles are curvilinear triangles. The Apollonian gasket fills each gap with a circle tangent to its three neighbors, then fills the new gaps, and so on forever.\nHere’s the key insight: we can generate this structure by iterating inversions. If a point is inside one of the inner circles, invert through that circle—this “pushes” it out. If a point is outside the outer circle, invert through the outer circle—this “pulls” it in.\nWe need to check: - Is \\(\\mathbf{p}\\) inside circle c1, c2, or c3? (distance from center &lt; radius) - Is \\(\\mathbf{p}\\) outside circle outer? (distance from center &gt; radius)\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nbool isOutside(vec2 p, Circle c) {\n    return length(p - c.center) &gt; c.radius;\n}\nThe iteration: keep inverting until the point lands in a “gap” (inside outer, outside all inner circles) or we hit a maximum iteration count.\n\n\nFull Implementation\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;  // In the gap—done!\n        }\n    }\n    \n    // Color by iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Draw circle boundaries\n    float dMin = min(min(distToCircle(p, c1), distToCircle(p, c2)), \n                     min(distToCircle(p, c3), distToCircle(p, outer)));\n    if (dMin &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\n\n\nVisualizing the Limit Set\nThe limit set of the Apollonian gasket is the fractal boundary—the set of points that never escape to the fundamental domain, no matter how many iterations. Points near the limit set take many iterations before landing in a gap.\nWe can emphasize the limit set by adjusting our coloring. Instead of using a color palette, we use a nonlinear function that suppresses low iteration counts (the “background”) and brightens high iteration counts (near the fractal):\nfloat t = float(iter) / float(max_iter);\nvec3 color = 30.0 * vec3(pow(t, 2.0));\nThe squaring suppresses points that escape quickly, while the factor of 30 boosts the brightness of points near the limit set.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#exercises",
    "href": "lectures/day2.html#exercises",
    "title": "2  Day 2: Dynamics",
    "section": "2.8 Exercises",
    "text": "2.8 Exercises\n\nCheckpoints\nC1. Julia Set. Modify the Mandelbrot shader to render a Julia set. Fix c = vec2(-0.7, 0.27015) and initialize z from the pixel position instead of zero. Verify you get an intricate, connected fractal.\nC2. Cubic Mandelbrot. Change the iteration from \\(z^2 + c\\) to \\(z^3 + c\\). You’ll need to implement complex cubing:\nvec2 ccube(vec2 z) {\n    return cmul(cmul(z, z), z);\n}\nWhat symmetry do you observe?\nC3. Apollonian Animation. Animate the Apollonian gasket by letting the maximum iteration count grow with time. Use int max_iter = int(mod(iTime * 5.0, 50.0)) + 1; so the fractal “builds up” from the four starting circles to the full gasket, then resets. Watch how each iteration reveals a new layer of circles in the gaps.\nC4. Colorize a Fractal. Take any of the black-and-white fractals from today (Mandelbrot, Julia, Burning Ship, or Apollonian) and add color using the cosine palette:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nExperiment with different values of d to shift the hues.\nC5. Circle Art. Create an image with several circles of different sizes scattered across the screen. Color a pixel based on whether it’s inside zero, one, two, or more circles. (Hint: use isInside and count how many circles contain each point.)\n\n\nExplorations\nE1. Julia Explorer (Mouse). Make the Julia parameter c follow the mouse position. Map iMouse.xy to a reasonable region of the complex plane (say, \\([-2, 2] \\times [-2, 2]\\)). Drag around and watch the Julia set morph!\nE2. Julia Animation. Animate the parameter c along a path in the complex plane. Try a circle:\nfloat angle = iTime * 0.3;\nvec2 c = 0.7885 * vec2(cos(angle), sin(angle));\nOr trace the boundary of the main cardioid of the Mandelbrot set—every point on this curve gives a Julia set with a parabolic fixed point:\nvec2 cardioid(float t) {\n    vec2 eit = vec2(cos(t), sin(t));\n    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;\n    return cmul(eit, z);\n}\n\nvec2 c = cardioid(iTime * 0.5);\nWatch the Julia set continuously transform. What happens when c crosses from inside to outside the Mandelbrot set?\nE3. Other Escape-Time Fractals. Implement one or more of these variations on the Mandelbrot iteration:\n\nBurning Ship: \\(z \\leftarrow z^2\\), then \\(\\text{Im}(z) \\leftarrow |\\text{Im}(z)|\\), then \\(z \\leftarrow z + c\\)\nTricorn (Mandelbar): \\(z_{n+1} = \\bar{z}_n^2 + c\\) where \\(\\bar{z}\\) is the complex conjugate\nCeltic: \\(z_{n+1} = |\\text{Re}(z_n^2)| + i\\,\\text{Im}(z_n^2) + c\\)\n\nFor each, figure out how to translate the mathematical formula into GLSL. The escape condition (\\(|z| &gt; 2\\)) stays the same.\nE4. Smooth Coloring. The iteration count is an integer, so coloring by iteration gives discrete bands. But when a point escapes, it doesn’t land exactly on the escape radius—it overshoots. We can use how much it overshot to interpolate between iteration counts.\nThe idea: if \\(|z_n| &gt; 2\\), the “true” fractional iteration where \\(|z| = 2\\) is approximately: \\[n_{\\text{smooth}} = n - \\frac{\\log(\\log|z_n|/\\log 2)}{\\log 2}\\]\nThis comes from the fact that near escape, \\(|z_{n+1}| \\approx |z_n|^2\\), so \\(\\log|z|\\) roughly doubles each iteration.\nImplement this for the Mandelbrot set:\nif (iter &lt; max_iter) {\n    float log_zn = log(cabs2(z)) / 2.0;  // log|z|\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    t = smooth_iter / float(max_iter);\n}\nThe bands should disappear, replaced by smooth gradients.\nE5. Apollonian Coloring. Modify the Apollonian gasket to color by which circle was last inverted through, instead of iteration count. Use a different color for each of the four circles. What patterns emerge?\nE6. Apollonian Variations. The Apollonian gasket works with any four mutually tangent circles—the symmetric configuration we used is just one example. Descartes’ Circle Theorem tells us: if four circles are mutually tangent with curvatures \\(k_1, k_2, k_3, k_4\\) (where curvature = 1/radius, negative for the outer circle), then: \\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\\] Experiment with different configurations: - Change the radii of the three inner circles (they don’t have to be equal!) - Use Descartes’ theorem to find an outer circle tangent to three given inner circles - What happens if the circles overlap instead of being tangent?\n\n\nChallenges\nH1. Julia Explorer (Full). Build an interactive tool: display the Mandelbrot set, and wherever the user clicks, show the Julia set for that parameter overlaid or side-by-side. This requires: - Rendering Mandelbrot in one region - Reading click position from iMouse - Rendering Julia for that c in another region (or blended on top)\nH2. Newton Fractal. The Newton fractal comes from applying Newton’s method to find roots of a polynomial. For \\(f(z) = z^3 - 1\\), Newton’s iteration is: \\[z_{n+1} = z_n - \\frac{f(z_n)}{f'(z_n)} = z_n - \\frac{z_n^3 - 1}{3z_n^2} = \\frac{2z_n^3 + 1}{3z_n^2}\\] Iterate this and color based on which root the orbit converges to (the three cube roots of unity: \\(1\\), \\(e^{2\\pi i/3}\\), \\(e^{4\\pi i/3}\\)). Check convergence by testing if \\(|z^3 - 1| &lt; \\epsilon\\).\nH3. Higher-Power Mandelbrot. Implement \\(z^n + c\\) for general \\(n\\). Use the polar form: if \\(z = re^{i\\theta}\\), then \\(z^n = r^n e^{in\\theta}\\). In code:\nvec2 cpow(vec2 z, float n) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    float rn = pow(r, n);\n    return rn * vec2(cos(n * theta), sin(n * theta));\n}\nTry non-integer values of \\(n\\)! What happens at \\(n = 2.5\\)?\n\n\nProjects\nProject 1: Grid of Julia Sets\nCreate a grid where each cell shows the Julia set for a different value of \\(c\\). The position in the grid determines \\(c\\)—effectively, each cell samples a point in the Mandelbrot parameter space.\nWhen you zoom out, the overall pattern should reveal the Mandelbrot set: cells with connected Julia sets (solid regions) correspond to \\(c \\in \\mathcal{M}\\), while cells with dust-like Julia sets correspond to \\(c \\notin \\mathcal{M}\\).\nUse the grid technique from Day 1:\nfloat grid_size = 8.0;\nvec2 cell_id = floor((p + 2.0) * grid_size / 4.0);\nvec2 cell_p = fract((p + 2.0) * grid_size / 4.0) * 4.0 - 2.0;\n\n// c comes from which cell we're in\nvec2 c = (cell_id / grid_size) * 4.0 - 2.0;\n\n// z starts from position within the cell\nvec2 z = cell_p;\nProject 2: Orbit Visualization\nInstead of just coloring by iteration count, visualize the actual orbit of a point. Make the starting point draggable with the mouse:\n\nLet \\(z_0\\) be the mouse position (normalized to the complex plane)\nFix a parameter \\(c\\) (or let it be controllable too)\nCompute the first \\(N\\) iterates: \\(z_0, z_1, z_2, \\ldots, z_N\\)\nDraw small circles at each iterate position\nConnect consecutive iterates with lines (use the segment SDF from Day 1!)\nColor by iteration index (early iterates one color, later iterates another)\n\nThis reveals the dynamics directly: bounded orbits stay in a region and may converge to a cycle, while escaping orbits spiral outward. Drag the starting point around and watch how the orbit changes—you’ll see the sensitive dependence on initial conditions that makes chaos!\nFor Julia sets, fix c and drag z_0. For the Mandelbrot perspective, fix z_0 = 0 and drag c.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Dynamics</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html",
    "href": "lectures/day3.html",
    "title": "3  Day 3: Tilings",
    "section": "",
    "text": "3.1 The Folding Algorithm\nToday we’ll extend our per-pixel computations to study geometric tilings: we’ll produce some beautiful hyperbolic tilings and if you work through the homework you’ll be able to create something like below: a tiling morphs smoothly between two different views of the same geometry—the unbounded upper half-plane and the circular Poincaré disk.\nOur goal today is to draw beautiful tilings—of the plane, the hyperbolic plane, and beyond—efficiently on the GPU. We’ll learn a powerful technique: fold any point back into a fundamental domain by repeatedly reflecting across boundaries. The algorithm is simple, parallelizes perfectly, and works identically in Euclidean and hyperbolic geometry.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#the-folding-algorithm",
    "href": "lectures/day3.html#the-folding-algorithm",
    "title": "3  Day 3: Tilings",
    "section": "",
    "text": "Tiling a Strip\nLet’s start with the simplest case: tiling the plane with horizontal strips. We define a fundamental domain—the strip where \\(0 &lt; x &lt; 1\\)—and reflect any point outside back in.\nThe reflection across a vertical line \\(x = c\\) is simple: \\((x, y) \\mapsto (2c - x, y)\\).\nThe algorithm:\n\nIf \\(x &lt; 0\\), reflect across \\(x = 0\\)\nIf \\(x &gt; 1\\), reflect across \\(x = 1\\)\nRepeat until the point stops moving\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fold into the strip [0, 1]\n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;           // Reflect across x = 0\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;      // Reflect across x = 1\n    }\n    \n    // Draw a circle in the fundamental domain\n    float d = length(p - vec2(0.5, 0.0));\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    if (d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThe circle tiles the entire strip! But circles are symmetric—we can’t tell if tiles are being reflected or just translated. Let’s draw something asymmetric instead.\nWe’ll use the letter “F”, which has no mirror symmetry. We define a helper function that draws an F centered at the origin:\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    // Vertical bar\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    // Top horizontal bar\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    // Middle horizontal bar\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\nThen we replace the circle drawing with a call to drawF:\nvec3 color = drawF(p - vec2(0.5, 0.0), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n\n  \n  \n  \n\n\nNow we can see what’s happening: the “F” alternates between normal and mirrored! This is reflection, not translation. Each time we cross a boundary, the image flips. We draw the shape once in the fundamental domain, and the folding algorithm tiles it everywhere.\n\n\nSquare Tiling\nExtending to two dimensions is straightforward—just add boundaries for \\(y\\):\n// Fold into the square [0,1] × [0,1]\nfor (int i = 0; i &lt; 20; i++) {\n    if (p.x &lt; 0.0) p.x = -p.x;\n    if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n    if (p.y &lt; 0.0) p.y = -p.y;\n    if (p.y &gt; 1.0) p.y = 2.0 - p.y;\n}\n\n  \n  \n  \n\n\nThe “F” now tiles in both directions, with reflections across all four boundaries creating a kaleidoscopic pattern.\n\n\nCounting Reflections\nLet’s track how many reflections were needed to reach the fundamental domain. This reveals the structure of the tiling:\n// Fold into the square, counting reflections\nint foldCount = 0;\nfor (int i = 0; i &lt; 20; i++) {\n    vec2 p0 = p;\n    \n    if (p.x &lt; 0.0) { p.x = -p.x; foldCount++; }\n    if (p.x &gt; 1.0) { p.x = 2.0 - p.x; foldCount++; }\n    if (p.y &lt; 0.0) { p.y = -p.y; foldCount++; }\n    if (p.y &gt; 1.0) { p.y = 2.0 - p.y; foldCount++; }\n    \n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n// Color by fold count\nfloat t = float(foldCount) / 10.0;\nvec3 color = 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));\n\n  \n  \n  \n\n\nPoints near the fundamental domain (center of screen) need few reflections; points far away need many. The color bands show “distance” in terms of reflection count.\n\n\nParity Coloring\nFor tilings, we often want to distinguish adjacent tiles. The parity of the fold count (odd vs even) gives us a checkerboard pattern:\n// After folding...\nfloat parity = mod(float(foldCount), 2.0);\nvec3 color = (parity &lt; 0.5) \n    ? vec3(0.9, 0.85, 0.8)   // Light\n    : vec3(0.3, 0.35, 0.4);  // Dark\n\n  \n  \n  \n\n\nThis works because each reflection flips orientation—an odd number of reflections gives a mirror image of the fundamental domain, while an even number preserves orientation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#half-spaces-and-reflections",
    "href": "lectures/day3.html#half-spaces-and-reflections",
    "title": "3  Day 3: Tilings",
    "section": "3.2 Half-Spaces and Reflections",
    "text": "3.2 Half-Spaces and Reflections\nLooking at our square tiling code, we see a repeated pattern: check if we’re outside a boundary, reflect if so. Let’s abstract this so we can handle arbitrary shapes—including triangles, which will be our gateway to hyperbolic geometry.\n\nWhat is a Half-Space?\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions:\n\nPoints where \\(ax + by &lt; c\\)\nPoints where \\(ax + by &gt; c\\)\n\nWe encode a half-space by storing the line and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line: ax + by = c\n    float side;     // +1 or -1: which side we want\n};\nThe side parameter determines our inequality: we’re “inside” the half-space when \\((ax + by - c) \\cdot \\text{side} &lt; 0\\).\n\n\nInside Test and Reflection\nTwo functions do all the work. First, checking if a point is inside:\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\nSecond, reflecting into the half-space (only if we’re outside):\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    \n    // Already inside?\n    if (val * h.side &lt; 0.0) return p;\n    \n    // Reflect across the boundary line\n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);  // Unit normal\n    float dist = val / length(vec2(h.a, h.b));  // Signed distance to line\n    count++;\n    return p - 2.0 * dist * n;\n}\n\n\n\n\n\n\nNoteGLSL: The inout Keyword\n\n\n\nThe inout keyword lets a function both read and modify a variable passed to it. When we write:\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count)\nthe count parameter is passed by reference—changes inside the function affect the original variable. This is how we track the total number of reflections: each call to reflectInto can increment the same counter.\nGLSL has three parameter modes: - in (default): pass by value, function gets a copy - out: function must write to it, caller receives the value - inout: function can read and write, changes persist\nThis is similar to reference parameters in C++ or ref in C#.\n\n\nThe reflection formula comes from linear algebra: we move the point by twice its signed distance to the line, in the normal direction. We also increment the count each time we actually reflect.\n\n\nVisualizing Half-Spaces\nLet’s see what a half-space looks like:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\nIn mainImage, we test whether each point is inside and color accordingly:\n// Half-space: x &lt; 1 (left side of vertical line)\nHalfSpace h = HalfSpace(1.0, 0.0, 1.0, 1.0);\n\nvec3 color = inside(p, h) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.15);\n\n// Draw the boundary line\nfloat dist = abs(h.a * p.x + h.b * p.y - h.c) / length(vec2(h.a, h.b));\nif (dist &lt; 0.03) color = vec3(1.0);\n\n  \n  \n  \n\n\nThe blue region is “inside” the half-space. Try changing the parameters to see different lines and sides!\n\n\nSquare Tiling with Half-Spaces\nLet’s rebuild our square tiling using this abstraction. The square \\([0, 1] \\times [0, 1]\\) is defined by four half-spaces:\n\nLeft edge (\\(x = 0\\)): want \\(x &gt; 0\\), so HalfSpace(1.0, 0.0, 0.0, -1.0)\nRight edge (\\(x = 1\\)): want \\(x &lt; 1\\), so HalfSpace(1.0, 0.0, 1.0, 1.0)\nBottom edge (\\(y = 0\\)): want \\(y &gt; 0\\), so HalfSpace(0.0, 1.0, 0.0, -1.0)\nTop edge (\\(y = 1\\)): want \\(y &lt; 1\\), so HalfSpace(0.0, 1.0, 1.0, 1.0)\n\nWe need a function that reflects a point into a half-space if it’s outside:\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    if (val * h.side &lt; 0.0) return p;  // Already inside\n    \n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);\n    float dist = val / length(vec2(h.a, h.b));\n    count++;\n    return p - 2.0 * dist * n;\n}\nNow the folding loop becomes:\n// Four half-spaces defining [0,1] × [0,1]\nHalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\nHalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\nHalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\nHalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n\nint foldCount = 0;\nfor (int i = 0; i &lt; 20; i++) {\n    vec2 p0 = p;\n    p = reflectInto(p, left, foldCount);\n    p = reflectInto(p, right, foldCount);\n    p = reflectInto(p, bottom, foldCount);\n    p = reflectInto(p, top, foldCount);\n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n  \n  \n  \n\n\nIt works! The result is identical to our earlier square tiling, but now the code is structured around half-spaces.\n\n\nTriangle Tiling\nNow the payoff—changing from a square to a triangle just means changing the half-space definitions. An equilateral triangle centered at the origin:\n// Three half-spaces defining equilateral triangle\nHalfSpace h1 = HalfSpace(0.0, 1.0, -0.5, -1.0);           // Bottom edge\nHalfSpace h2 = HalfSpace(0.866, -0.5, -0.5, -1.0);        // Upper-right edge  \nHalfSpace h3 = HalfSpace(-0.866, -0.5, -0.5, -1.0);       // Upper-left edge\n\n// Fold into triangle (three reflections instead of four)\nfor (int i = 0; i &lt; 30; i++) {\n    vec2 p0 = p;\n    p = reflectInto(p, h1, foldCount);\n    p = reflectInto(p, h2, foldCount);\n    p = reflectInto(p, h3, foldCount);\n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n  \n  \n  \n\n\nBeautiful! The “F” shows us exactly how each triangle relates to its neighbors through reflection.\n\n\n\n\n\n\nNoteThe Power of Abstraction\n\n\n\nCompare the square and triangle tilings. The folding loop is identical—only the half-space definitions change. This abstraction will pay off enormously when we move to hyperbolic geometry: the algorithm stays the same, we just need different reflection operations!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#why-it-works",
    "href": "lectures/day3.html#why-it-works",
    "title": "3  Day 3: Tilings",
    "section": "3.3 Why It Works",
    "text": "3.3 Why It Works\nWe’ve seen the folding algorithm work for strips, squares, and triangles. But why does it work? The answer comes from group theory.\n\nReflection Groups\nEach reflection across a half-space boundary is an isometry—a transformation that preserves distances. When we compose reflections, we get more isometries. The set of all such compositions forms a group called a reflection group (or Coxeter group).\nFor our triangle tiling, the group is generated by three reflections \\(r_1, r_2, r_3\\) across the three edges. Every element of the group is a finite product of these generators: \\[g = r_{i_1} \\circ r_{i_2} \\circ \\cdots \\circ r_{i_k}\\]\n\n\nFundamental Domains\nOur triangle (or square) is a fundamental domain for the group action. This means:\n\nThe images of the fundamental domain under all group elements tile the plane: every point lies in some image \\(g(F)\\)\nDifferent images don’t overlap (except on boundaries): if \\(g \\neq h\\), then \\(g(F)\\) and \\(h(F)\\) have disjoint interiors\n\n\n\nWhy the Algorithm Terminates\n[PROOF HERE]\n\n\nThe Orbit Map\nWhat our shader computes is the orbit map: for each point \\(p\\), find the unique group element \\(g\\) such that \\(g(p) \\in F\\). The folded position is \\(g(p)\\), and the fold count tells us \\(|g|\\) (the length of \\(g\\) as a word in the generators).\nParity coloring works because reflections have determinant \\(-1\\): an odd number of reflections reverses orientation, an even number preserves it.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#hyperbolic-geometry",
    "href": "lectures/day3.html#hyperbolic-geometry",
    "title": "3  Day 3: Tilings",
    "section": "3.4 Hyperbolic Geometry",
    "text": "3.4 Hyperbolic Geometry\nSo far we’ve tiled the Euclidean plane. Now we’ll tile the hyperbolic plane—a geometry with constant negative curvature, where the folding algorithm works exactly the same way.\n\nThe Upper Half-Plane Model\nWe represent the hyperbolic plane as the upper half-plane: \\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThe real axis \\(y = 0\\) is the boundary at infinity—not part of the space, but infinitely far away from every interior point.\nWhat makes this hyperbolic rather than Euclidean is the metric: distances are scaled by \\(1/y\\). Near the boundary (\\(y\\) small), distances are stretched enormously. High up (\\(y\\) large), distances are compressed. The Riemannian metric is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\n\n\nHyperbolic Distance\nThe distance between two points \\(z_1 = x_1 + iy_1\\) and \\(z_2 = x_2 + iy_2\\) is: \\[d(z_1, z_2) = \\text{arccosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2 y_1 y_2}\\right)\\]\nThis formula captures the key property: distances grow without bound as either point approaches the boundary (\\(y \\to 0\\)). The boundary is infinitely far from any interior point.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#hyperbolic-reflections-and-tilings",
    "href": "lectures/day3.html#hyperbolic-reflections-and-tilings",
    "title": "3  Day 3: Tilings",
    "section": "3.5 Hyperbolic Reflections and Tilings",
    "text": "3.5 Hyperbolic Reflections and Tilings\n\nGeodesics\nIn hyperbolic geometry, the “straight lines” are called geodesics. In the upper half-plane model, geodesics come in two types:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c\\)\nSemicircles: centered on the real axis\n\nBoth meet the boundary at right angles.\n\n\nHyperbolic Half-Spaces\nJust as in Euclidean geometry, a geodesic divides the plane into two half-spaces. We define a struct for each type:\nstruct HalfSpaceVert {\n    float x;      // vertical line at x = c\n    float side;   // +1: want x &lt; c, -1: want x &gt; c\n};\n\nstruct HalfSpaceCirc {\n    float center;   // center of semicircle (on real axis)\n    float radius;   // radius of semicircle\n    float side;     // +1: want outside circle, -1: want inside\n};\nLet’s visualize one of each:\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nbool inside(vec2 z, HalfSpaceVert h) {\n    return (z.x - h.x) * h.side &lt; 0.0;\n}\n\nbool inside(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    return (dist2 - h.radius * h.radius) * h.side &gt; 0.0;\n}\n\n  Missing Demo\n  Shader demo day3/hyp-halfspaces not found.\n\n\nThe blue region is “inside” the vertical half-space (where \\(x &gt; 1\\)). The orange-tinted region is “inside” the circular half-space (outside the semicircle). Where they overlap, the colors blend.\n\n\nHyperbolic Reflections\nNow we define reflectInto for each type. For a vertical half-space, we flip the \\(x\\)-coordinate:\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    if ((z.x - h.x) * h.side &lt; 0.0) return z;  // Already inside\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\nFor a circular half-space, we use circle inversion:\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;  // Already inside\n    \n    // Circle inversion\n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\n\n\n\n\n\nImportantConnection to Day 2\n\n\n\nThis is exactly the circle inversion formula from Day 2! When we inverted through circles in the Apollonian gasket, we were performing hyperbolic reflections. The Apollonian gasket lives in hyperbolic space—we just didn’t know it yet.\n\n\nLet’s see these reflections in action. We’ll place our “F” and reflect it across each type of half-space, alternating between them:\n\n  \n  \n  \n\n\nThe shader alternates every 2 seconds: first reflecting across the vertical line (F flips horizontally), then across the semicircle (F gets inverted through the circle, distorting its shape).\n\n\nThe (2,3,∞) Triangle\nNow we can tile the hyperbolic plane! The \\((2,3,\\infty)\\) triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an ideal vertex at infinity). We set it up with:\n\nLeft boundary: Vertical line at \\(x = 0\\), want \\(x &gt; 0\\)\nRight boundary: Vertical line at \\(x = 1/2\\), want \\(x &lt; 1/2\\)\nBottom boundary: Unit semicircle centered at origin, want outside\n\nThe vertices are at \\(i\\) (angle \\(\\pi/2\\)), at \\(\\frac{1}{2} + \\frac{\\sqrt{3}}{2}i\\) (angle \\(\\pi/3\\)), and at infinity where the two vertical lines meet (angle \\(0\\)).\n\n  \n  \n  \n\n\nThe blue region is our fundamental domain—the \\((2,3,\\infty)\\) triangle where all three half-space conditions are satisfied. Now let’s tile!\nThe reflectInto functions are the same as before, now with inout int count to track reflections. The mainImage is:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    // (2,3,∞) triangle\n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);        // x &gt; 0\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);        // x &lt; 0.5\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);  // outside unit circle\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThe hyperbolic tiling emerges! Notice how the triangles appear to shrink as they approach the boundary—they’re all the same hyperbolic size, but Euclidean distances compress near \\(y = 0\\).\n\n\n\n\n\n\nNoteCompare to Euclidean\n\n\n\nThe structure is identical to our Euclidean tilings:\nEuclidean triangle:\np = reflectInto(p, h1, foldCount);\np = reflectInto(p, h2, foldCount);\np = reflectInto(p, h3, foldCount);\nHyperbolic triangle:\nz = reflectInto(z, left, foldCount);\nz = reflectInto(z, right, foldCount);\nz = reflectInto(z, bottom, foldCount);\nSame loop structure, same counting. The only difference is the type of half-space (and thus which reflectInto overload is called). This is the power of abstraction!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#other-models",
    "href": "lectures/day3.html#other-models",
    "title": "3  Day 3: Tilings",
    "section": "3.6 Other Models",
    "text": "3.6 Other Models\nThe upper half-plane is just one way to visualize hyperbolic geometry. The Poincaré disk model fits the entire hyperbolic plane inside a unit disk, making the global structure easier to see.\n\nThe Poincaré Disk\nIn the Poincaré disk model: - The hyperbolic plane is the open unit disk \\(\\{z : |z| &lt; 1\\}\\) - The boundary circle \\(|z| = 1\\) represents infinity - Geodesics are circular arcs perpendicular to the boundary (and diameters)\n\n\nThe Cayley Transform\nWe convert between models using the Cayley transform:\n\\[w = \\frac{z - i}{z + i}\\]\nThis maps the upper half-plane to the unit disk, sending \\(i \\mapsto 0\\) and the real axis to the unit circle. The inverse is:\n\\[z = i\\frac{1 + w}{1 - w}\\]\nTo display our tiling in the Poincaré disk, we add complex arithmetic helpers and a conversion function:\n// Complex multiplication and division\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\n// Poincaré disk to upper half-plane\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\nIn mainImage, we start with disk coordinates and convert to UHP before folding:\nvec2 w = normalize_coord(fragCoord);  // Disk coordinates\nvec2 z = diskToUHP(w);                // Convert to UHP\n\n// ... same folding code as before ...\n\n// Darken outside disk\nif (length(w) &gt; 1.0) color = vec3(0.05);\n\n  \n  \n  \n\n\nThe same tiling, now visible in its entirety! The disk model shows the beautiful self-similarity of hyperbolic tilings—triangles recede toward the boundary in an infinite cascade.\n\n\nHyperbolic F Tiling\nLet’s add our “F” to see the reflections clearly. We draw the F in the fundamental domain, and the folding algorithm automatically tiles it across the hyperbolic plane:\n\n  \n  \n  \n\n\nThe “F” tiles the hyperbolic plane! Notice how reflected copies flip orientation—each triangle’s F is a mirror image of its neighbors, exactly as in our Euclidean tilings.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#exercises",
    "href": "lectures/day3.html#exercises",
    "title": "3  Day 3: Tilings",
    "section": "3.7 Exercises",
    "text": "3.7 Exercises\n\nCheckpoints\nC1. Hyperbolic Circles. Draw hyperbolic circles around the mouse position. Use the distance formula: \\[d(z_1, z_2) = \\text{arccosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2 y_1 y_2}\\right)\\]\nIn GLSL, \\(\\text{arccosh}(x) = \\log(x + \\sqrt{x^2 - 1})\\).\nDraw two circles: one with hyperbolic radius 0.1 (small) and one with radius 0.5 (larger). Color pixels where the distance from the mouse is within 0.02 of these target radii.\nNotice how the circles change shape as you move the mouse toward the boundary—they stretch horizontally and compress vertically, reflecting the hyperbolic metric.\nC2. Edges of the (2,3,∞) Tiling. Add edge drawing to the hyperbolic tiling. After folding to the fundamental domain, check hyperbolic distance to each geodesic boundary.\nDistance to vertical geodesic at \\(x = c\\): \\[d(z, \\text{geodesic}) = \\text{arccosh}\\left(\\frac{|z - c|}{y}\\right)\\]\nwhere \\(|z - c| = \\sqrt{(x-c)^2 + y^2}\\) is the Euclidean distance to the point \\((c, 0)\\).\nfloat distToGeodesic(vec2 z, HalfSpaceVert h) {\n    z.x -= h.x;\n    return acosh(length(z) / z.y);\n}\nDistance to semicircular geodesic centered at \\(c\\) with radius \\(r\\):\nThe trick is to apply a Möbius transformation that sends the semicircle to a vertical line, then use the formula above. The transformation \\(w = \\frac{z - (c+r)}{z - (c-r)}\\) sends the endpoints \\(c \\pm r\\) to \\(0\\) and \\(\\infty\\), mapping the semicircle to the imaginary axis.\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    // Möbius transform sending semicircle to imaginary axis\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    \n    // Distance to vertical geodesic at x = 0\n    return acosh(length(w) / w.y);\n}\nDraw the edge white where distance &lt; 0.03. The edges should have consistent hyperbolic thickness—appearing to fan out near the boundary in Euclidean terms.\n\n\nExplorations\nE1. Vertices and Edges in Both Models. Extend C2 to also draw vertices. The \\((2,3,\\infty)\\) triangle has vertices at:\n\n\\(z = i\\) (angle \\(\\pi/2\\))\n\\(z = \\frac{1}{2} + \\frac{\\sqrt{3}}{2}i\\) (angle \\(\\pi/3\\))\n\\(z = \\infty\\) (ideal vertex—don’t draw this one)\n\nAfter folding, check if the folded point is near one of these vertices and draw a small circle.\nThen adapt your shader to work in the Poincaré disk: apply your edge/vertex drawing after folding but before converting back. The same tiling should appear, now curved into the disk.\nE2. The Klein Disk Model. The Klein disk (or Beltrami-Klein model) represents the hyperbolic plane in a unit disk where geodesics appear as straight Euclidean line segments. This makes some properties clearer but distorts angles.\nThe conversions are:\nPoincaré → Klein: \\[k = \\frac{2w}{1 + |w|^2}\\]\nKlein → Poincaré: \\[w = \\frac{k}{1 + \\sqrt{1 - |k|^2}}\\]\nImplement these and display the \\((2,3,\\infty)\\) tiling in the Klein model. Notice how the curved geodesics become straight lines! The triangles look like ordinary Euclidean triangles, but they’re all the same hyperbolic size.\nE3. The Band Model. The band model maps the hyperbolic plane to an infinite horizontal strip of height \\(\\pi\\). It’s useful for visualizing hyperbolic translations.\nThe conversion from Poincaré disk uses the complex logarithm:\nPoincaré → Band: \\[b = \\log\\left(\\frac{1 + w}{1 - w}\\right)\\]\nwhere the result has real part in \\((-\\infty, \\infty)\\) and imaginary part in \\((0, \\pi)\\).\nIn GLSL, implement this as:\nvec2 poincareToБand(vec2 w) {\n    // (1+w)/(1-w) as complex division\n    vec2 num = vec2(1.0, 0.0) + w;\n    vec2 denom = vec2(1.0, 0.0) - w;\n    vec2 ratio = cdiv(num, denom);\n    // Complex log: log|z| + i*arg(z)\n    return vec2(0.5 * log(dot(ratio, ratio)), atan(ratio.y, ratio.x));\n}\nDisplay the tiling in the band model. Horizontal translation in the band corresponds to hyperbolic translation along a geodesic!\nE4. Interactive Möbius Transformations. The isometries of the hyperbolic plane are Möbius transformations: \\[z \\mapsto \\frac{az + b}{cz + d}\\] where \\(a, b, c, d\\) are real and \\(ad - bc = 1\\) (for the upper half-plane).\nThese transformations preserve hyperbolic distances and map geodesics to geodesics. They form the group \\(\\text{PSL}(2, \\mathbb{R})\\).\nSome useful isometries:\nHorizontal translation by distance \\(t\\): \\[z \\mapsto z + t\\]\nScaling (hyperbolic translation along the \\(y\\)-axis) by factor \\(k\\): \\[z \\mapsto kz\\]\nRotation around \\(i\\) by angle \\(\\theta\\): \\[z \\mapsto \\frac{z \\cos(\\theta/2) + \\sin(\\theta/2)}{-z \\sin(\\theta/2) + \\cos(\\theta/2)}\\]\nMake the tiling interactive: use mouse x-position to control horizontal translation and mouse y-position to control scaling. The tiling should slide and zoom while preserving its structure.\n\n\nChallenges\nH1. Animated Model Transitions. Create a smooth animation morphing between the upper half-plane and Poincaré disk.\nThe key insight: the Cayley transform \\(w = \\frac{z - i}{z + i}\\) is itself a Möbius transformation. You can interpolate between the identity and the Cayley transform using a one-parameter family.\nOne approach: the Cayley transform sends \\(i \\mapsto 0\\). Construct a family of Möbius transformations \\(T_t\\) where \\(T_0\\) is the identity and \\(T_1\\) is the Cayley transform. Use the matrix representation and interpolate.\nAlternatively, interpolate the visual effect: blend between UHP coordinates and disk coordinates based on time.\nH2. Dual Tiling. Every tiling has a dual obtained by connecting the centers of adjacent tiles.\nFor the triangle tiling, find the incenter (or centroid) of each fundamental triangle. Draw geodesics connecting centers of adjacent triangles instead of the original edges.\nHint: after folding, you know which fundamental domain you’re in. The center of a \\((2,3,\\infty)\\) triangle is at approximately \\(z = 0.25 + 1.1i\\). Use the fold sequence to transform this center to each tile.\nH3. Single-Edge Tilings. Instead of drawing all three edges of each triangle, draw only ONE edge (say, the circular geodesic at the bottom).\nThis creates a different pattern: pairs of triangles glued along the missing edges form quadrilaterals. You get the “order-2” truncation of the original tiling.\nTry drawing only the left vertical edge, or only the right vertical edge. Each choice produces a different pattern!\n\n\nProjects\nP1. General (p,q,r) Triangle Tilings. Implement tilings for arbitrary triangle groups \\((p, q, r)\\) where the angles are \\(\\pi/p\\), \\(\\pi/q\\), and \\(\\pi/r\\).\nThe geometry: For a hyperbolic triangle (where \\(\\frac{1}{p} + \\frac{1}{q} + \\frac{1}{r} &lt; 1\\)), you need to compute the geodesics forming the edges. This requires solving for:\n\nThe positions of the three vertices\nThe semicircles (or vertical lines) connecting them\n\nFor a triangle with one ideal vertex (like \\((2,3,\\infty)\\)), two edges are vertical lines and one is a semicircle. For a compact triangle (like \\((2,3,7)\\)), all three edges are semicircles.\nThe algorithm: 1. Place one vertex at a convenient location (e.g., on the positive imaginary axis) 2. Use the angle constraints to determine the other vertices 3. Compute the semicircle through each pair of vertices\nImplementation: - Allow the user to input \\(p\\), \\(q\\), \\(r\\) (perhaps via uniforms or compile-time constants) - Validate that the triangle is hyperbolic - Compute and draw the tiling with edges and vertices - Show the tiling in both UHP and Poincaré disk models\nThis is a substantial project requiring both geometric reasoning and careful implementation!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Tilings</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html",
    "href": "lectures/shaders/day1-shaders.html",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "",
    "text": "A.1 A1. red\nThis appendix provides complete, standalone code for each shader referenced in Day 1. Each listing can be copied directly into Shadertoy and run immediately.\nThe simplest shader: every pixel is red.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a1.-red",
    "href": "lectures/shaders/day1-shaders.html#a1.-red",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "",
    "text": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a2.-red-pulsing",
    "href": "lectures/shaders/day1-shaders.html#a2.-red-pulsing",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.2 A2. red-pulsing",
    "text": "A.2 A2. red-pulsing\nRed channel oscillates with time.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a3.-coordinates",
    "href": "lectures/shaders/day1-shaders.html#a3.-coordinates",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.3 A3. coordinates",
    "text": "A.3 A3. coordinates\nVisualizing the coordinate system as color.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a4.-half-plane",
    "href": "lectures/shaders/day1-shaders.html#a4.-half-plane",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.4 A4. half-plane",
    "text": "A.4 A4. half-plane\nDividing the plane into two regions based on y-coordinate.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.y;\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // red below\n    } else {\n        color = vec3(0.0, 0.0, 1.0);  // blue above\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a5.-half-plane-animated",
    "href": "lectures/shaders/day1-shaders.html#a5.-half-plane-animated",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.5 A5. half-plane-animated",
    "text": "A.5 A5. half-plane-animated\nAnimated line dividing the plane, with rotating normal and shifting offset.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = cos(iTime);\n    float b = sin(iTime);\n    float c = 0.5 * sin(iTime * 0.7);\n    float L = a * p.x + b * p.y + c;\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a6.-circle",
    "href": "lectures/shaders/day1-shaders.html#a6.-circle",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.6 A6. circle",
    "text": "A.6 A6. circle\nFilled circle centered at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float f = d - r;\n    \n    vec3 color;\n    if (f &lt; 0.0) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow inside\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a7.-circle-curve",
    "href": "lectures/shaders/day1-shaders.html#a7.-circle-curve",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.7 A7. circle-curve",
    "text": "A.7 A7. circle-curve\nCircle outline (ring) centered at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float eps = 0.1;\n    float f = abs(d - r) - eps;\n    \n    vec3 color;\n    if (f &lt; 0.0) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow ring\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a8.-parabola",
    "href": "lectures/shaders/day1-shaders.html#a8.-parabola",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.8 A8. parabola",
    "text": "A.8 A8. parabola\nThe parabola \\(y = x^2\\) rendered as an implicit curve.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.y - p.x * p.x;\n    float eps = 0.1;\n    \n    vec3 color;\n    if (abs(F) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow curve\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a9.-lemniscate-naive",
    "href": "lectures/shaders/day1-shaders.html#a9.-lemniscate-naive",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.9 A9. lemniscate-naive",
    "text": "A.9 A9. lemniscate-naive\nLemniscate of Bernoulli with naive thresholding (non-uniform thickness).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.5;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n    \n    float eps = 0.15;\n    \n    vec3 color;\n    if (abs(F) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a10.-lemniscate-gradient",
    "href": "lectures/shaders/day1-shaders.html#a10.-lemniscate-gradient",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.10 A10. lemniscate-gradient",
    "text": "A.10 A10. lemniscate-gradient\nLemniscate with gradient correction for uniform thickness.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.5;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n    \n    vec2 grad = vec2(\n        4.0 * p.x * r2 - 2.0 * a * a * p.x,\n        4.0 * p.y * r2 + 2.0 * a * a * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    float eps = 0.05;\n    \n    vec3 color;\n    if (dist &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a11.-lemniscate-animated",
    "href": "lectures/shaders/day1-shaders.html#a11.-lemniscate-animated",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.11 A11. lemniscate-animated",
    "text": "A.11 A11. lemniscate-animated\nCassini ovals animated through the lemniscate transition.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Cassini oval parameters\n    float c = 1.0;  // half-distance between foci\n    float a = 0.8 + 0.4 * sin(iTime * 0.5);  // animate through transition\n    \n    // Implicit equation: (x² + y²)² - 2c²(x² - y²) = a⁴ - c⁴\n    float r2 = dot(p, p);\n    float c2 = c * c;\n    float a4 = a * a * a * a;\n    float c4 = c2 * c2;\n    float F = r2 * r2 - 2.0 * c2 * (p.x * p.x - p.y * p.y) - (a4 - c4);\n    \n    // Gradient\n    vec2 grad = vec2(\n        4.0 * p.x * r2 - 4.0 * c2 * p.x,\n        4.0 * p.y * r2 + 4.0 * c2 * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    float eps = 0.05;\n    \n    vec3 color;\n    if (dist &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a12.-circle-mouse",
    "href": "lectures/shaders/day1-shaders.html#a12.-circle-mouse",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.12 A12. circle-mouse",
    "text": "A.12 A12. circle-mouse\nCircle that follows the mouse position.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize fragment coordinate\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Normalize mouse coordinate the same way\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse - vec2(0.5, 0.5);\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse = mouse * 4.0;\n    \n    // Circle centered at mouse\n    float d = length(p - mouse);\n    float r = 0.5;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 0.9, 0.2);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a13.-sun-earth",
    "href": "lectures/shaders/day1-shaders.html#a13.-sun-earth",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.13 A13. sun-earth",
    "text": "A.13 A13. sun-earth\nSun at mouse click position with orbiting earth.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Use iMouse.zw (last click position) so sun stays put\n    vec2 sun = normalize_coord(iMouse.zw);\n    \n    // Earth orbits the sun\n    float orbit_radius = 0.8;\n    vec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n    \n    // Draw sun (larger, yellow)\n    float d_sun = length(p - sun);\n    // Draw earth (smaller, blue)\n    float d_earth = length(p - earth);\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);  // dark background\n    if (d_sun &lt; 0.3) {\n        color = vec3(1.0, 0.9, 0.2);  // yellow sun\n    }\n    if (d_earth &lt; 0.15) {\n        color = vec3(0.2, 0.5, 1.0);  // blue earth\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a14.-folium-mouse",
    "href": "lectures/shaders/day1-shaders.html#a14.-folium-mouse",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.14 A14. folium-mouse",
    "text": "A.14 A14. folium-mouse\nFolium of Descartes with mouse-controlled level set.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fixed parameter a\n    float a = 1.5;\n    \n    // Map mouse x to level set value c in [-2, 2]\n    float c = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n    \n    // Folium of Descartes: x³ + y³ - 3axy = c\n    float F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;\n    \n    // Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)\n    vec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);\n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color;\n    if (dist &lt; 0.05) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a15.-elliptic-family",
    "href": "lectures/shaders/day1-shaders.html#a15.-elliptic-family",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.15 A15. elliptic-family",
    "text": "A.15 A15. elliptic-family\nFamily of elliptic curves with mouse-controlled center parameters.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Mouse controls the central (a, b) of our family\n    float a_center = mix(-3.0, 1.0, iMouse.x / iResolution.x);\n    float b_center = mix(-2.0, 2.0, iMouse.y / iResolution.y);\n    \n    vec3 color = vec3(0.05, 0.05, 0.1);  // dark background\n    \n    // Draw curves for a range of a values around a_center\n    for (float i = -3.0; i &lt;= 3.0; i += 1.0) {\n        float a = a_center + i * 0.5;  // more spacing\n        float b = b_center;\n        \n        // Elliptic curve: y² = x³ + ax + b\n        float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n        \n        // Gradient\n        vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n        float dist = abs(F) / max(length(grad), 0.01);\n        \n        // Brightness fades quickly: central curve bright, outer curves fade to background\n        float t = abs(i) / 3.0;  // 0 at center, 1 at edges\n        float brightness = 1.0 - t * t;  // quadratic falloff\n        \n        if (dist &lt; 0.03 && brightness &gt; 0.05) {\n            // Check discriminant for this specific curve\n            float disc = 4.0 * a * a * a + 27.0 * b * b;\n            if (abs(disc) &lt; 0.3) {\n                color = mix(color, vec3(1.0, 0.3, 0.3), brightness);  // red for singular\n            } else {\n                color = mix(color, vec3(1.0, 1.0, 0.5), brightness);  // yellow for smooth\n            }\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a16.-grid-circles",
    "href": "lectures/shaders/day1-shaders.html#a16.-grid-circles",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.16 A16. grid-circles",
    "text": "A.16 A16. grid-circles\nGrid of circles with square cells.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float N = 5.0;  // number of columns\n    float L = (4.0 * aspect) / N;  // cell size\n    \n    vec2 cell_id = floor(p / L);\n    vec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg = mix(vec3(0.15, 0.15, 0.25), vec3(0.25, 0.15, 0.15), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = L * 0.35;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = bg;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#notes",
    "href": "lectures/shaders/day1-shaders.html#notes",
    "title": "Appendix A — Appendix: Day 1 Shader Code",
    "section": "A.17 Notes",
    "text": "A.17 Notes\n\nCoordinate Setup\nMost shaders use this standard coordinate setup:\nvec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]\nuv = uv - vec2(0.5, 0.5);               // center origin\nuv.x *= iResolution.x / iResolution.y;  // aspect correction\nvec2 p = uv * 4.0;                      // scale to [-2, 2] range\n\n\nHelper Function\nFor shaders using mouse input, we define:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\n\nGradient Correction\nFor implicit curves \\(F(x,y) = 0\\) with uniform thickness:\nfloat dist = abs(F) / max(length(grad), 0.01);\nwhere grad is \\(\\nabla F\\) computed analytically.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Day 1 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html",
    "href": "lectures/shaders/day2-shaders.html",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "",
    "text": "B.1 Common Functions\nComplete, standalone code for each shader referenced in Day 2. Each listing can be copied directly into Shadertoy and run immediately.\nThese helper functions are used throughout Day 2:",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#common-functions",
    "href": "lectures/shaders/day2-shaders.html#common-functions",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "",
    "text": "// Normalize screen coordinates to centered, aspect-corrected space\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\n// Complex multiplication: (a + bi)(c + di)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Squared magnitude of complex number (avoids sqrt)\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\n// Cosine palette for smooth coloring\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a1.-mandelbrot-zoom",
    "href": "lectures/shaders/day2-shaders.html#a1.-mandelbrot-zoom",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.2 A1. mandelbrot-zoom",
    "text": "B.2 A1. mandelbrot-zoom\nAnimated zoom into the Mandelbrot set with smooth coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    float zoom = pow(1.5, mod(iTime, 30.0));\n    return uv * 4.0 / zoom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Zoom into the seahorse valley\n    vec2 center = vec2(-0.745, 0.186);\n    vec2 c = center + p;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 200;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t * 4.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a2.-mandelbrot-bw",
    "href": "lectures/shaders/day2-shaders.html#a2.-mandelbrot-bw",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.3 A2. mandelbrot-bw",
    "text": "B.3 A2. mandelbrot-bw\nBlack and white Mandelbrot set.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;  // shift left to center the interesting part\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a3.-mandelbrot-gray",
    "href": "lectures/shaders/day2-shaders.html#a3.-mandelbrot-gray",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.4 A3. mandelbrot-gray",
    "text": "B.4 A3. mandelbrot-gray\nMandelbrot set with grayscale iteration coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = vec3(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a4.-mandelbrot-color",
    "href": "lectures/shaders/day2-shaders.html#a4.-mandelbrot-color",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.5 A4. mandelbrot-color",
    "text": "B.5 A4. mandelbrot-color\nMandelbrot set with cosine palette coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a5.-julia-static",
    "href": "lectures/shaders/day2-shaders.html#a5.-julia-static",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.6 A5. julia-static",
    "text": "B.6 A5. julia-static\nJulia set with fixed parameter (black and white).\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fixed parameter - try different values!\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // z starts at pixel position\n    vec2 z = p;\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);  // In the set: black\n    } else {\n        color = vec3(1.0);  // Escaped: white\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a6.-julia-explorer",
    "href": "lectures/shaders/day2-shaders.html#a6.-julia-explorer",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.7 A6. julia-explorer",
    "text": "B.7 A6. julia-explorer\nInteractive Julia set explorer: gray Mandelbrot as parameter space background, black Julia set overlaid, red dot shows current c.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Get c from mouse position\n    vec2 c = normalize_coord(iMouse.xy);\n    c.x -= 0.5;\n    \n    // Default to interesting value if no mouse\n    if (iMouse.x &lt; 1.0) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Mandelbrot iteration (for background)\n    vec2 mc = p;\n    mc.x -= 0.5;\n    vec2 mz = vec2(0.0);\n    int m_iter;\n    for (m_iter = 0; m_iter &lt; 100; m_iter++) {\n        if (cabs2(mz) &gt; 4.0) break;\n        mz = cmul(mz, mz) + mc;\n    }\n    \n    // Julia iteration (for foreground)\n    vec2 jz = p;\n    int j_iter;\n    for (j_iter = 0; j_iter &lt; 100; j_iter++) {\n        if (cabs2(jz) &gt; 4.0) break;\n        jz = cmul(jz, jz) + c;\n    }\n    \n    // Color: light background, Mandelbrot in gray, Julia in black\n    vec3 color = vec3(0.9);  // light background (escaped both)\n    if (m_iter == 100) {\n        color = vec3(0.6);  // Mandelbrot set in gray\n    }\n    if (j_iter == 100) {\n        color = vec3(0.0);  // Julia set in black\n    }\n    \n    // Draw red dot at c position (in Mandelbrot coordinates)\n    vec2 c_pos = c;\n    c_pos.x += 0.5;  // undo the offset we applied to c\n    if (length(p - c_pos) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a7.-inversion-toggle",
    "href": "lectures/shaders/day2-shaders.html#a7.-inversion-toggle",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.8 A7. inversion-toggle",
    "text": "B.8 A7. inversion-toggle\nCircle inversion visualization with toggling.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 p_inv = invert(p);\n    \n    // Toggle between original and inverted every second\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;\n    } else {\n        q = p_inv;\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a vertical line at x = 2\n    if (abs(q.x - 2.0) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a horizontal line at y = 1.5\n    if (abs(q.y - 1.5) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a circle centered at (2, 0) with radius 0.5\n    float d_circle = abs(length(q - vec2(2.0, 0.0)) - 0.5);\n    if (d_circle &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a8.-inversion-grid",
    "href": "lectures/shaders/day2-shaders.html#a8.-inversion-grid",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.9 A8. inversion-grid",
    "text": "B.9 A8. inversion-grid\nCircle inversion of a grid.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 p_inv = invert(p);\n    \n    // Toggle\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;\n    } else {\n        q = p_inv;\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a grid using mod\n    vec2 grid = mod(q, 0.5);\n    if (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a9.-inversion-moving",
    "href": "lectures/shaders/day2-shaders.html#a9.-inversion-moving",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.10 A9. inversion-moving",
    "text": "B.10 A9. inversion-moving\nInversion through a moving circle.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Animate the inversion circle\n    Circle inv_circle;\n    inv_circle.center = vec2(sin(iTime) * 0.5, cos(iTime * 0.7) * 0.5);\n    inv_circle.radius = 1.0 + 0.3 * sin(iTime * 1.3);\n    \n    vec2 p_inv = invert(p, inv_circle);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the inversion circle\n    float d_inv = abs(length(p - inv_circle.center) - inv_circle.radius);\n    if (d_inv &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = mod(p_inv, 0.5);\n    if (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a10.-apollonian-setup",
    "href": "lectures/shaders/day2-shaders.html#a10.-apollonian-setup",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.11 A10. apollonian-setup",
    "text": "B.11 A10. apollonian-setup\nThe four mutually tangent circles (no iteration).\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Three mutually tangent inner circles plus outer circle\n    // For three circles of radius r centered at vertices of equilateral triangle:\n    // - Side length of triangle = 2r (so circles touch)\n    // - Circumradius of triangle = 2r / sqrt(3)\n    // - Outer circle radius = circumradius + r\n    \n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    // Inner circles at vertices of equilateral triangle\n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    \n    // Outer circle tangent to all three from outside\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw all four circles\n    if (distToCircle(p, c1) &lt; 0.03) color = vec3(1.0, 0.3, 0.3);\n    if (distToCircle(p, c2) &lt; 0.03) color = vec3(0.3, 1.0, 0.3);\n    if (distToCircle(p, c3) &lt; 0.03) color = vec3(0.3, 0.3, 1.0);\n    if (distToCircle(p, outer) &lt; 0.03) color = vec3(1.0, 1.0, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a11.-apollonian-iterated",
    "href": "lectures/shaders/day2-shaders.html#a11.-apollonian-iterated",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.12 A11. apollonian-iterated",
    "text": "B.12 A11. apollonian-iterated\nFull Apollonian gasket with iteration.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Draw circle boundaries\n    float dMin = min(min(distToCircle(p, c1), distToCircle(p, c2)), \n                     min(distToCircle(p, c3), distToCircle(p, outer)));\n    if (dMin &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a12.-apollonian-final",
    "href": "lectures/shaders/day2-shaders.html#a12.-apollonian-final",
    "title": "Appendix B — Appendix: Day 2 Shader Code",
    "section": "B.13 A12. apollonian-final",
    "text": "B.13 A12. apollonian-final\nApollonian gasket with coloring emphasizing the limit set.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration count, emphasizing the limit set\n    float t = float(iter) / float(max_iter);\n    vec3 color = 30.0 * vec3(pow(t, 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Day 2 Shader Code</span>"
    ]
  },
  {
    "objectID": "lectures/shaders/day3-shaders.html",
    "href": "lectures/shaders/day3-shaders.html",
    "title": "Appendix C — Day 3: Complete Shader Code",
    "section": "",
    "text": "This document provides complete, standalone shader code for each demo in Day 3. Copy any of these directly into Shadertoy to run.\n\n\nstrip-circle\nBasic strip tiling with a circle in the fundamental domain.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fold into the strip [0, 1]\n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw a circle in the fundamental domain\n    float d = length(p - vec2(0.5, 0.0));\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    if (d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstrip-F\nStrip tiling with the letter F to show reflection behavior.\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    vec3 color = drawF(p - vec2(0.5, 0.0), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-F\nSquare tiling with the letter F.\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if (p.y &lt; 0.0) p.y = -p.y;\n        if (p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    vec3 color = drawF(p - vec2(0.5, 0.5), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-foldcount\nSquare tiling colored by number of reflections.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 20; i++) {\n        vec2 p0 = p;\n        if (p.x &lt; 0.0) { p.x = -p.x; foldCount++; }\n        if (p.x &gt; 1.0) { p.x = 2.0 - p.x; foldCount++; }\n        if (p.y &lt; 0.0) { p.y = -p.y; foldCount++; }\n        if (p.y &gt; 1.0) { p.y = 2.0 - p.y; foldCount++; }\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-parity\nSquare tiling with checkerboard parity coloring.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 20; i++) {\n        vec2 p0 = p;\n        if (p.x &lt; 0.0) { p.x = -p.x; foldCount++; }\n        if (p.x &gt; 1.0) { p.x = 2.0 - p.x; foldCount++; }\n        if (p.y &lt; 0.0) { p.y = -p.y; foldCount++; }\n        if (p.y &gt; 1.0) { p.y = 2.0 - p.y; foldCount++; }\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.9, 0.85, 0.8) : vec3(0.3, 0.35, 0.4);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhalfspace-single\nVisualization of a single half-space.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    HalfSpace h = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    vec3 color = inside(p, h) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.15);\n    \n    float dist = abs(h.a * p.x + h.b * p.y - h.c) / length(vec2(h.a, h.b));\n    if (dist &lt; 0.03) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-halfspace\nSquare tiling using half-space abstraction with F and parity coloring.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    if (val * h.side &lt; 0.0) return p;\n    \n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);\n    float dist = val / length(vec2(h.a, h.b));\n    count++;\n    return p - 2.0 * dist * n;\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 20; i++) {\n        vec2 p0 = p;\n        p = reflectInto(p, left, foldCount);\n        p = reflectInto(p, right, foldCount);\n        p = reflectInto(p, bottom, foldCount);\n        p = reflectInto(p, top, foldCount);\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 bg = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    vec3 fg = (parity &lt; 0.5) ? vec3(0.6, 0.2, 0.2) : vec3(0.2, 0.2, 0.6);\n    \n    vec3 color = drawF(p - vec2(0.5, 0.5), bg, fg);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\ntriangle-tiling\nEuclidean equilateral triangle tiling.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    if (val * h.side &lt; 0.0) return p;\n    \n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);\n    float dist = val / length(vec2(h.a, h.b));\n    count++;\n    return p - 2.0 * dist * n;\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.15 && p.x &lt; 0.0 && p.y &gt; -0.2 && p.y &lt; 0.2) color = fgColor;\n    if (p.x &gt; -0.15 && p.x &lt; 0.15 && p.y &gt; 0.1 && p.y &lt; 0.2) color = fgColor;\n    if (p.x &gt; -0.15 && p.x &lt; 0.08 && p.y &gt; -0.02 && p.y &lt; 0.08) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    HalfSpace h1 = HalfSpace(0.0, 1.0, -0.5, -1.0);\n    HalfSpace h2 = HalfSpace(0.866, -0.5, -0.5, -1.0);\n    HalfSpace h3 = HalfSpace(-0.866, -0.5, -0.5, -1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 30; i++) {\n        vec2 p0 = p;\n        p = reflectInto(p, h1, foldCount);\n        p = reflectInto(p, h2, foldCount);\n        p = reflectInto(p, h3, foldCount);\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 bg = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    vec3 fg = (parity &lt; 0.5) ? vec3(0.6, 0.2, 0.2) : vec3(0.2, 0.2, 0.6);\n    \n    vec3 color = drawF(p, bg, fg);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-halfspaces\nHyperbolic half-spaces in the upper half-plane.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nbool inside(vec2 z, HalfSpaceVert h) {\n    return (z.x - h.x) * h.side &lt; 0.0;\n}\n\nbool inside(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    return (dist2 - h.radius * h.radius) * h.side &gt; 0.0;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 5.0 - vec2(1.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert hv = HalfSpaceVert(1.0, -1.0);\n    HalfSpaceCirc hc = HalfSpaceCirc(2.5, 1.0, 1.0);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    if (inside(z, hv)) color = vec3(0.3, 0.5, 0.7);\n    if (inside(z, hc)) color += vec3(0.4, 0.2, 0.1);\n    \n    if (abs(z.x - hv.x) &lt; 0.03) color = vec3(1.0);\n    if (abs(length(z - vec2(hc.center, 0.0)) - hc.radius) &lt; 0.03 && z.y &gt; 0.0) color = vec3(1.0);\n    \n    if (z.y &lt; 0.02) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-reflect-F\nHyperbolic reflections of F across vertical and circular geodesics.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h) {\n    if ((z.x - h.x) * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    return z;\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.0);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert hv = HalfSpaceVert(-1.5, -1.0);\n    HalfSpaceCirc hc = HalfSpaceCirc(1.5, 2.5, 1.0);\n    \n    float t = mod(iTime, 4.0);\n    if (t &lt; 2.0) {\n        z = reflectInto(z, hv);\n    } else {\n        z = reflectInto(z, hc);\n    }\n    \n    vec3 color = drawF(z - vec2(0.5, 3.5), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n    \n    vec2 z_orig = normalize_coord(fragCoord);\n    \n    if (abs(z_orig.x - hv.x) &lt; 0.04) color = vec3(0.5);\n    if (abs(length(z_orig - vec2(hc.center, 0.0)) - hc.radius) &lt; 0.04 && z_orig.y &gt; 0.0) color = vec3(0.5);\n    if (z_orig.y &lt; 0.02) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-triangle-halfspaces\nThe three half-spaces defining the (2,3,∞) triangle.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nbool inside(vec2 z, HalfSpaceVert h) {\n    return (z.x - h.x) * h.side &lt; 0.0;\n}\n\nbool inside(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    return (dist2 - h.radius * h.radius) * h.side &gt; 0.0;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0 - vec2(0.75, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    if (inside(z, left) && inside(z, right) && inside(z, bottom)) {\n        color = vec3(0.3, 0.5, 0.7);\n    }\n    \n    if (abs(z.x - 0.0) &lt; 0.02 && z.y &gt; 0.0) color = vec3(1.0);\n    if (abs(z.x - 0.5) &lt; 0.02 && z.y &gt; 0.0) color = vec3(1.0);\n    if (abs(length(z) - 1.0) &lt; 0.02 && z.y &gt; 0.0) color = vec3(1.0);\n    \n    if (z.y &lt; 0.01) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-tiling-23inf\nThe (2,3,∞) hyperbolic triangle tiling in the upper half-plane.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0 - vec2(0.75, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    vec2 z_orig = normalize_coord(fragCoord);\n    if (z_orig.y &lt; 0.01) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\npoincare-disk\nThe (2,3,∞) tiling in the Poincaré disk model.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\npoincare-disk-F\nThe (2,3,∞) tiling in the Poincaré disk with F markers.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.06 && p.x &lt; -0.02 && p.y &gt; -0.08 && p.y &lt; 0.08) color = fgColor;\n    if (p.x &gt; -0.06 && p.x &lt; 0.06 && p.y &gt; 0.04 && p.y &lt; 0.08) color = fgColor;\n    if (p.x &gt; -0.06 && p.x &lt; 0.03 && p.y &gt; -0.01 && p.y &lt; 0.03) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 bg = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    vec3 fg = (parity &lt; 0.5) ? vec3(0.6, 0.2, 0.2) : vec3(0.2, 0.2, 0.6);\n    \n    vec3 color = drawF(z - vec2(0.25, 1.2), bg, fg);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Day 3: Complete Shader Code</span>"
    ]
  }
]