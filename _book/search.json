[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPU-Accelerated Mathematical Illustration",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nWe’ll progress from 2D foundations (curves, tilings, fractals) to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to work hard and experiment with code through daily homework exercises. Here are some examples of things we will make:",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "outline.html",
    "href": "outline.html",
    "title": "Outline",
    "section": "",
    "text": "Course Overview\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nFormat: Five days, each with one hour of lecture and approximately 1.5 hours of homework\nPrerequisites: Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required\nAudience: Graduate students, postdocs, and faculty in mathematics",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-1-introduction-to-shader-programming",
    "href": "outline.html#day-1-introduction-to-shader-programming",
    "title": "Outline",
    "section": "Day 1: Introduction to Shader Programming",
    "text": "Day 1: Introduction to Shader Programming\n\nLearning Objectives\n\nUnderstand the mathematical model of shader programming (function from pixels to colors)\nLearn basic GLSL syntax and conventions\nMaster coordinate system setup and distance calculations\nCreate simple geometric shapes and implicit curves\n\n\n\nIn-Class Content\n\nMathematical framing: Shaders as parallel functions computing colors for all pixels simultaneously\nGLSL basics: Syntax, vector types, built-in functions\nCoordinate systems: Centering, normalizing, aspect ratio correction\nConditional coloring: Half-planes and regions defined by inequalities\nDistance fields: Circles, filled and outlined\nRepetition: Using mod() for grids and patterns\nImplicit curves: Rendering curves defined by \\(F(x,y) = 0\\)\n\n\n\nHomework\nRequired: Parabola graphing calculator - Draw coordinate axes - Plot \\(y = ax^2 + bx + c\\) with customizable coefficients - Make it robust for various parameter values\nOptional #1: Animated curve family (vary parameters with time)\nOptional #2: Beautiful tiling pattern using mod()",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "href": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "title": "Outline",
    "section": "Day 2: Complex Dynamics and Euclidean Geometry",
    "text": "Day 2: Complex Dynamics and Euclidean Geometry\n\nLearning Objectives\n\nImplement complex number arithmetic in GLSL\nUnderstand and render the Mandelbrot and Julia sets\nCreate geometric tilings using mathematical transformations\nLearn to use structs for organizing data\n\n\n\nIn-Class Content\n\nComplex Numbers in GLSL\n\nRepresenting complex numbers as vec2\nImplementing complex multiplication\nComplex addition, conjugation, and magnitude\n\n\n\nThe Mandelbrot Set\n\nMathematical definition: iterating z → z² + c with z₀ = 0\nEscape-time algorithm\nColoring schemes based on iteration count\nDiscussing convergence and divergence\n\n\n\nJulia Sets\n\nFixing c and varying initial z\nRelationship to Mandelbrot set\nCreating visually interesting Julia sets\n\n\n\nIntroduction to Structs\n\nDefining struct types in GLSL\nUse case: organizing geometric data\nExample: storing triangle vertices or transformation data\n\n\n\nEuclidean Triangle Tiling\n\nFundamental domain for triangular tiling\nReflection across edges to create periodic patterns\nSymmetry groups and transformations\n\n\n\n\nHomework\n\nRequired: Circle Inversion\n\nImplement circle inversion as an operation on the plane\nFor a circle of radius R centered at origin: p' = R² * p / |p|²\nFor a circle centered at c with radius R: translate, invert, translate back\nVisualize by applying inversion to a grid or pattern\nDemonstrate that circles through the inversion center become lines, and vice versa\n\n\n\nOptional #1: Apollonian Gasket\n\nUse your circle inversion implementation\nStart with three mutually tangent circles\nRepeatedly invert through each circle\nColor by iteration count or which circle was inverted through\nExplore the fractal structure created by nested circles",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-3-fractals-and-hyperbolic-geometry",
    "href": "outline.html#day-3-fractals-and-hyperbolic-geometry",
    "title": "Outline",
    "section": "Day 3: Fractals and Hyperbolic Geometry",
    "text": "Day 3: Fractals and Hyperbolic Geometry\n\nLearning Objectives\n\nExtend folding techniques to box fractals\nUnderstand hyperbolic geometry models and their properties\nImplement computations in the upper half-plane model\nCreate hyperbolic tilings using inversions and Möbius transformations\nConvert between different models of hyperbolic geometry\n\n\n\nIn-Class Content\n\nReview: Sierpinski Triangle via Folding\n\nGenerating fractals through iterated reflections\nUsing abs() for geometric folding\nScaling and iteration\nColoring by iteration depth or distance\n\n\n\nIntroduction to Hyperbolic Geometry\n\nWhy hyperbolic space? Negative curvature vs. Euclidean geometry\nThree primary models: Poincaré disk, upper half-plane, and band model\nHow models are related via Möbius transformations\nProperties: geodesics, distance, angle measurement\n\n\n\nComputations in the Upper Half-Plane Model\n\nDefinition: points {z : Im(z) &gt; 0}\nGeodesics: vertical lines and semicircles perpendicular to real axis\nDistance formula in the upper half-plane\nMöbius transformations as isometries: z → (az + b)/(cz + d) with ad - bc = 1\nMatrix representation of transformations\n\n\n\nHyperbolic Triangle Tiling\n\nSetting up a hyperbolic triangle (angles sum to &lt; π)\nComputing geodesics as circular arcs\nImplementing circle inversion for reflections across geodesics\nFolding points into fundamental domain\nIterating to create the full tiling\nColoring by domain or iteration behavior\n\n\n\nDrawing in Different Models\n\nConverting between Poincaré disk and upper half-plane\nMöbius transformation: w = i(1-z)/(1+z) (disk to half-plane)\nBand model via additional Möbius transformation\nVisualizing the same tiling in multiple models simultaneously\n\n\n\n\nHomework\n\nRequired: Sierpinski Carpet\n\nImplement the 2D Sierpinski carpet using box folding\nUse abs() to create 4-fold symmetry\nScale by 3 at each iteration, removing middle square\nColor by iteration depth or distance\nExperiment with different iteration counts\n\n\n\nRequired: Model Conversion and Möbius Transformation\n\nConvert your hyperbolic tiling from upper half-plane to Poincaré disk (or vice versa)\nApply a Möbius transformation to your tiling (choose your own or use a suggested one)\nRender both the original and transformed tiling\nObserve how the transformation affects the visual appearance\n\n\n\nOptional: Advanced Explorations\n\nAnother Triangle Group: Implement a different hyperbolic triangle group (e.g., (2,3,7), (2,4,6))\nKlein Model: Convert to Klein model via Cayley transform\nConformal Art: Use complex analysis to map to creative domains\nDecorated Tiles: Create Escher-style decorated tiles",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-4-introduction-to-3d-rendering",
    "href": "outline.html#day-4-introduction-to-3d-rendering",
    "title": "Outline",
    "section": "Day 4: Introduction to 3D Rendering",
    "text": "Day 4: Introduction to 3D Rendering\n\nLearning Objectives\n\nSet up camera and generate rays from pixels\nImplement analytical ray-object intersection\nLearn the raymarching algorithm and signed distance functions\nApply basic lighting (diffuse shading)\n\n\n\nIn-Class Content\n\nCamera and ray setup:\n\nPinhole camera model\nRay generation from pixel coordinates\nField of view control\n\nAnalytical intersections:\n\nRay-sphere: solve quadratic equation\nCompute surface normals analytically\nRay-torus: implicit equation and gradient\nBisection method for root-finding\n\nLighting introduction:\n\nSurface normals\nDiffuse lighting: dot product with light direction\nSeeing 3D structure through shading\n\nMotivation for raymarching:\n\nAnalytical methods don’t scale\nComplex surfaces need flexible approach\n\nSigned Distance Functions (SDFs):\n\nDefinition and properties\nSDFs for primitives: sphere, box, plane, torus\nDistance as bound for safe marching\n\nRaymarching algorithm:\n\nSphere tracing: march by SDF value\nStopping conditions\nScene composition (minimum distance)\n\nNormal estimation:\n\nGradient via finite differences\nEstimating partial derivatives\nSame lighting applied to raymarched objects\n\nScene progression:\n\nSingle sphere\nTwo spheres\nSphere and torus\n\n\n\n\nHomework\nRequired: Algebraic variety rendering - Choose polynomial implicit surface (degree 3 or 4) - Implement root-finding (bisection or Newton’s method) - Compute gradient for normals - Optional: bounding sphere optimization\nOptional: - Specular lighting (Phong model) - Rotation matrices for object transformation - Complex multi-object scenes",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-5-choose-your-adventure",
    "href": "outline.html#day-5-choose-your-adventure",
    "title": "Outline",
    "section": "Day 5: Choose Your Adventure",
    "text": "Day 5: Choose Your Adventure\nThe final day will be determined based on pacing, student interest, and energy levels. Two complete lectures are prepared:\n\nOption A: Advanced Raymarching Techniques\n\nLearning Objectives\n\nMaster domain operations for efficient complex scenes\nUnderstand and apply boolean operations on SDFs\nCreate 3D fractals via iterated folding (Menger sponge)\nBuild sophisticated scenes from simple primitives\n\n\n\nIn-Class Content\n\nDomain operations:\n\nRepetition: mod() for infinite object grids\nSymmetry: abs() for mirror planes\nPolar repetition for radial patterns\nZero computational cost for infinite complexity\n\nBoolean operations on SDFs:\n\nUnion: min(d1, d2)\nIntersection: max(d1, d2)\nSubtraction: max(d1, -d2)\nSmooth minimum: smin() for organic blending\n\nMenger sponge:\n\nBox folding in 3D\nAxis-aligned operations\nIterated subdivision\nConnection to 2D fractals\n\nScene building:\n\nCombining techniques\nArchitectural structures\nInfinite repeated patterns\n\n\n\n\nHomework\nRequired: Creative scene building - Build complex scene using domain ops and booleans - Experiment with combinations - Focus on mathematical or aesthetic interest\nOptional: Sierpinski tetrahedron - Implement via 3D folding (non-axis-aligned) - Connection to Day 2’s triangle folding in higher dimension\n\n\n\n\nOption B: Buffers and Temporal Dynamics\n\nLearning Objectives\n\nUnderstand buffer-based computation in Shadertoy\nImplement differential operators (Laplacian)\nSolve partial differential equations on the GPU\nCreate dynamic, evolving mathematical systems\n\n\n\nIn-Class Content\n\nIntroduction to buffers:\n\nReading from previous frame\nMulti-pass rendering\nSimple example: conditional coloring based on buffer\n\nEdge detection and the Laplacian:\n\nDiscrete Laplacian stencil (5-point or 9-point)\nSampling neighboring pixels\nSpatial derivatives on grids\n\nThe heat equation:\n\nMathematical formulation: \\(u_t = \\alpha\\nabla^2 u\\)\nApplying Laplacian for diffusion\nTime-stepping: u_new = u_old + dt * α * laplacian(u_old)\nInitial conditions (e.g., heat in a fractal region)\nWatching patterns blur and diffuse\n\nBoundary conditions:\n\nZero boundaries (edges set to 0)\nAvoiding wrap-around\n\nTimestep stability:\n\nCFL condition (briefly mentioned)\nProviding stable dt value\n\n\n\n\nHomework\nRequired: Interactive heat equation or reaction-diffusion - Option 1: Heat source at mouse position, watch it diffuse - Option 2: Gray-Scott reaction-diffusion (pattern formation)\nOptional: Wave equation - Requires two buffers (current and previous state) - Implement \\(u_{tt} = c^2\\nabla^2 u\\) - Watch waves propagate and reflect",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "day1.html",
    "href": "day1.html",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "1.1 Overview\nToday we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.\nBy the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#what-is-a-shader",
    "href": "day1.html#what-is-a-shader",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.2 What is a Shader?",
    "text": "1.2 What is a Shader?\n\nMathematical Perspective\nA shader is fundamentally a function \\[f: \\mathbb{R}^2 \\times \\mathbb{R} \\times \\cdots \\to \\mathbb{R}^4\\] that maps pixel coordinates (and potentially time, mouse position, etc.) to color values. For each pixel on the screen, we evaluate this function to determine what color to display.\nThe key insight: modern GPUs can evaluate this function for all pixels simultaneously. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second.\nThis parallelism is what makes shaders extraordinarily fast for mathematical visualization—we’re not looping over pixels sequentially, we’re computing them all at once.\n\n\nWhy Shadertoy?\nShadertoy is a web-based platform that abstracts away the complexities of GPU programming (setting up OpenGL contexts, managing buffers, compiling shaders, etc.). You write a single function, and Shadertoy handles everything else.\nThe platform provides several built-in uniforms (read-only global variables): - iResolution: screen resolution as a vec3 (width, height, pixel aspect ratio) - iTime: elapsed time in seconds - iMouse: mouse position and click state as a vec4\nWe’ll use these throughout the week.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#first-shader-solid-colors",
    "href": "day1.html#first-shader-solid-colors",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.3 First Shader: Solid Colors",
    "text": "1.3 First Shader: Solid Colors\n\nBasic Structure\nEvery Shadertoy shader has the same entry point:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Your code here\n}\nParameters: - fragCoord: the pixel coordinate we’re currently computing, as a vec2 (x, y) - fragColor: the output color we need to set, as a vec4 (red, green, blue, alpha)\nColors are represented in RGBA format with values in \\([0, 1]\\). So vec4(1.0, 0.0, 0.0, 1.0) represents opaque red, while vec4(0.5, 0.5, 0.5, 1.0) is middle gray.\n\n\nExample: Red Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nThis sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on fragCoord, every pixel gets the same value.\n\n\nGLSL Syntax Basics\nA few essential points about the GLSL language:\nSemicolons are required. Every statement must end with a semicolon. This is not Python!\nVector types: GLSL has built-in types vec2, vec3, vec4 for 2D, 3D, and 4D vectors. You can construct them with:\nvec2 v = vec2(1.0, 2.0);\nvec3 w = vec3(1.0, 2.0, 3.0);\nvec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars\nSwizzling: You can access components by name: v.x, v.y or v.r, v.g (same thing, different naming convention). We’ll cover more syntax in the appendix.\nFloating point literals: Write 1.0 not 1 for floating point values. GLSL is picky about types.\n\n\nAnimating with Time\nLet’s make something that changes:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\nHere iTime grows continuously, sin(iTime) oscillates between \\(-1\\) and \\(1\\), and we remap to \\([0, 1]\\) with the affine transformation \\(x \\mapsto \\frac{1}{2}(1 + x)\\). The screen now pulses between black and red.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#coordinate-systems",
    "href": "day1.html#coordinate-systems",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.4 Coordinate Systems",
    "text": "1.4 Coordinate Systems\n\nRaw Coordinates\nBy default, fragCoord gives pixel coordinates with: - Origin \\((0, 0)\\) at the bottom-left - \\(x\\) increases rightward to iResolution.x - \\(y\\) increases upward to iResolution.y\nFor mathematical work, we want: - Origin at the center - Coordinates normalized (not in pixels) - Aspect ratio handled correctly\n\n\nCentered, Normalized Coordinates\nHere’s a standard transformation:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Center at origin: [-0.5, 0.5]\n    uv = uv - 0.5;\n    \n    // Scale to account for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Now uv is centered and aspect-corrected\n    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)\n    vec2 p = uv * 4.0;  // Now p is in [-2, 2] × [-h, h] where h depends on aspect ratio\n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nFrom now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable p for “position.”\n\n\nVisualizing Coordinates\nLet’s color pixels by their position:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup as above, resulting in p]\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\nYou should see a smooth gradient: red increases rightward, green increases upward.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#conditional-coloring-half-planes",
    "href": "day1.html#conditional-coloring-half-planes",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.5 Conditional Coloring: Half-Planes",
    "text": "1.5 Conditional Coloring: Half-Planes\n\nThe Concept\nGiven a linear function \\(L(x, y) = ax + by\\), we want to color pixels differently depending on whether \\(L(p) &lt; 0\\) or \\(L(p) \\geq 0\\). This divides the plane into two half-planes.\n\n\nImplementation\nGLSL provides a conditional operator (ternary operator) just like C:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\nLeft half-plane is red, right half-plane is blue.\n\n\nThe Step Function\nGLSL also provides step(edge, x) which returns 0 if \\(x &lt; \\text{edge}\\) and 1 otherwise. This is useful for smooth code:\nfloat s = step(0.0, p.x);  // 0 on left, 1 on right\nvec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\nHere mix(a, b, t) performs linear interpolation: \\((1-t)a + tb\\).\n\n\nArbitrary Half-Planes\nFor a general line \\(ax + by = 0\\):\nfloat a = 1.0, b = 1.0;\nfloat L = a * p.x + b * p.y;\nvec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\nfragColor = vec4(color, 1.0);\nTry different values of \\(a\\) and \\(b\\) to see different line orientations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#distance-fields-and-circles",
    "href": "day1.html#distance-fields-and-circles",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.6 Distance Fields and Circles",
    "text": "1.6 Distance Fields and Circles\n\nDistance to Center\nThe distance from a point \\(p = (x, y)\\) to the origin is simply \\[d = \\|p\\| = \\sqrt{x^2 + y^2}\\]\nIn GLSL:\nfloat d = length(p);\nThe length() function computes the Euclidean norm of a vector.\n\n\nFilled Circle\nA circle of radius \\(r\\) centered at the origin is the set \\(\\{p : \\|p\\| &lt; r\\}\\). We can color inside vs. outside:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis renders a yellow disk on a dark blue background.\n\n\nDistance-Based Coloring\nWe can create gradients by mapping distance to color:\nfloat d = length(p);\nfloat intensity = 1.0 - d / 2.0;  // Fades out with distance\nintensity = clamp(intensity, 0.0, 1.0);  // Keep in [0, 1]\nvec3 color = vec3(intensity);\nfragColor = vec4(color, 1.0);\n\n\nCircle Outline\nTo draw just the boundary of a circle (an annulus of small thickness), we check if \\(d\\) is approximately equal to \\(r\\):\nfloat d = length(p);\nfloat r = 1.0;\nfloat thickness = 0.05;\n\nfloat circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\nvec3 color = vec3(circle_mask);\nfragColor = vec4(color, 1.0);\nMathematically, we’re coloring the set \\(\\{p : |d(p) - r| &lt; \\epsilon\\}\\) where \\(\\epsilon\\) is our thickness parameter.\nFor a smoother edge, we can use smoothstep:\nfloat circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\nThe smoothstep(a, b, x) function performs smooth Hermite interpolation between \\(a\\) and \\(b\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#grids-and-repetition",
    "href": "day1.html#grids-and-repetition",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.7 Grids and Repetition",
    "text": "1.7 Grids and Repetition\n\nModular Arithmetic\nThe modulo operation creates periodic repetition. For a period \\(T\\), the function \\(p \\mapsto (p \\bmod T) - T/2\\) maps \\(\\mathbb{R}\\) to \\([-T/2, T/2]\\) repeatedly.\nIn GLSL, mod(x, T) computes \\(x \\bmod T\\).\n\n\nCreating a Grid\nTo create a grid of repeated cells:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Now cell_p repeats every spacing units\n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis creates an infinite grid of yellow circles!\n\n\nAlternating Pattern\nWe can create checkerboard-like patterns using the cell index:\nvec2 cell_id = floor(p / spacing);\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\n\nvec3 color_a = vec3(1.0, 0.0, 0.0);\nvec3 color_b = vec3(0.0, 0.0, 1.0);\nvec3 bg_color = mix(color_a, color_b, checker);\nHere floor(p / spacing) gives us integer grid indices, and we alternate colors based on the parity of \\(i + j\\).\n\n\nCombining with Circles\nPut it all together for a grid of circles on an alternating background:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#implicit-curves",
    "href": "day1.html#implicit-curves",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.8 Implicit Curves",
    "text": "1.8 Implicit Curves\n\nGeneral Principle\nAn implicit curve is defined by an equation \\(F(x, y) = 0\\). To render it, we compute \\(F(p)\\) for each pixel and color based on proximity to zero:\nfloat F = [some function of p.x and p.y];\nfloat thickness = 0.05;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nvec3 color = mix(background, curve_color, curve_mask);\n\n\nExample: Parabola\nThe parabola \\(y = x^2\\) can be written implicitly as \\(F(x, y) = y - x^2 = 0\\):\nfloat F = p.y - p.x * p.x;\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n\nvec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\nfragColor = vec4(color, 1.0);\n\n\nExample: Circle (Implicit Form)\nWe’ve been using \\(\\|p\\| &lt; r\\) for filled circles, but we can also write the circle implicitly as \\(x^2 + y^2 - r^2 = 0\\):\nfloat r = 1.0;\nfloat F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nThis is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#summary",
    "href": "day1.html#summary",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.9 Summary",
    "text": "1.9 Summary\nToday we’ve learned:\n\nShaders as parallel functions: Every pixel evaluates \\(f(x, y, t, \\ldots) \\to \\text{color}\\) simultaneously\nGLSL basics: Syntax, vector types, and built-in functions\nCoordinate systems: Centering, normalizing, and scaling for mathematical work\nConditional coloring: Using boolean expressions and step() for discrete color regions\nDistance fields: Using length() to create circles and radial patterns\nModular arithmetic: Creating grids and repeating patterns with mod()\nImplicit curves: Rendering curves defined by \\(F(x, y) = 0\\)\n\nWith these tools, you can already create a wide variety of mathematical visualizations!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#homework",
    "href": "day1.html#homework",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.10 Homework",
    "text": "1.10 Homework\n\nRequired: Parabola Graphing Calculator\nCreate a shader that draws a customizable parabola \\(y = ax^2 + bx + c\\) along with coordinate axes.\nRequirements: - Define variables a, b, c at the top of your shader (hardcoded values are fine) - Draw the \\(x\\)-axis and \\(y\\)-axis as thick lines (use the implicit line technique: \\(|y| &lt; \\epsilon\\) for \\(x\\)-axis, \\(|x| &lt; \\epsilon\\) for \\(y\\)-axis) - Plot the parabola \\(y = ax^2 + bx + c\\) as a thick curve - Use distinct colors for axes and parabola - The visualization should work for any reasonable values of \\(a\\), \\(b\\), \\(c\\)\nSuggested approach:\n// Define parameters\nfloat a = 1.0;\nfloat b = 0.0;\nfloat c = 0.0;\n\n// Axes\nfloat x_axis_mask = abs(p.y) &lt; 0.05 ? 1.0 : 0.0;\nfloat y_axis_mask = abs(p.x) &lt; 0.05 ? 1.0 : 0.0;\n\n// Parabola: F(x,y) = y - (ax² + bx + c) = 0\nfloat F = p.y - (a * p.x * p.x + b * p.x + c);\nfloat parabola_mask = abs(F) &lt; 0.1 ? 1.0 : 0.0;\n\n// Combine\nvec3 color = background;\ncolor = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\ncolor = mix(color, parabola_color, parabola_mask);\nTry different values of \\(a\\), \\(b\\), \\(c\\) and verify your grapher works correctly!\n\n\nOptional #1: Animated Curve Family\nCreate a shader that animates through a family of curves.\nSuggestions: - Elliptic fibration: Fix a cubic polynomial and vary a parameter: \\(y^2 = x^3 + ax + b\\) where \\(a\\) or \\(b\\) varies with iTime - Lissajous curves: \\(x = A\\sin(at + \\delta)\\), \\(y = B\\sin(bt)\\), animate \\(\\delta\\) or the frequency ratio\nUse iTime creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families.\n\n\nOptional #2: Beautiful Tiling Pattern\nDesign an aesthetically pleasing tiling pattern using the mod() technique.\nRequirements: - Create a non-trivial pattern within a fundamental domain (a single tile) - Use mod() to repeat it across the plane - The pattern should tile seamlessly (edges should match up)\nIdeas: - Geometric patterns: nested circles, polygons, stars - Color gradients that vary by tile position - Combinations of implicit curves within each tile - Symmetry: use abs() to create reflections within tiles\nChallenge: Can you create a pattern that has different symmetries in different tiles? (For example, alternating rotational symmetry using the checkerboard cell_id technique.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#looking-ahead",
    "href": "day1.html#looking-ahead",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.11 Looking Ahead",
    "text": "1.11 Looking Ahead\nTomorrow we’ll use these techniques to explore complex dynamics (the Mandelbrot and Julia sets) and geometric tilings (including fractals via iterated folding). The coordinate system and implicit curve techniques you’ve learned today will be the foundation for everything to come.\nMake sure you’re comfortable with: - Setting up coordinates - Computing distances and implicit functions\n- Using mod() for repetition - Conditionally coloring based on mathematical expressions",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day2.html",
    "href": "day2.html",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "2.1 Overview\nToday we explore the power of iteration to generate fractals. We’ll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot and Julia sets. Then we’ll shift to geometric iteration: circle inversion, which creates beautiful nested patterns when applied repeatedly. We’ll see how the Apollonian gasket emerges from iterated inversions, and learn to organize geometric data using structs.\nBy the end of today, you’ll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate intricate fractal structures.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#complex-numbers-in-glsl",
    "href": "day2.html#complex-numbers-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.2 Complex Numbers in GLSL",
    "text": "2.2 Complex Numbers in GLSL\n\nRepresentation\nA complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part.\n\n\nComplex Arithmetic\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nDivision: \\(\\frac{a + bi}{c + di} = \\frac{(a + bi)(c - di)}{c^2 + d^2}\\)\nvec2 cdiv(vec2 z, vec2 w) {\n    float denom = dot(w, w);  // c² + d²\n    return vec2(\n        (z.x * w.x + z.y * w.y) / denom,  // Real part\n        (z.y * w.x - z.x * w.y) / denom   // Imaginary part\n    );\n}\nThese are the building blocks we need for complex dynamics.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#the-mandelbrot-set",
    "href": "day2.html#the-mandelbrot-set",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.3 The Mandelbrot Set",
    "text": "2.3 The Mandelbrot Set\n\nDefinition\nThe Mandelbrot set \\(\\mathcal{M}\\) is defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nIn practice, we: 1. Start with \\(z_0 = 0\\) 2. Iterate \\(z_{n+1} = z_n^2 + c\\) for a fixed number of iterations (say, 100) 3. Check if \\(|z_n|\\) has escaped some large radius (typically \\(R = 2\\))\nPoints that escape quickly are definitely not in \\(\\mathcal{M}\\). Points that remain bounded after many iterations are likely in \\(\\mathcal{M}\\).\n\n\nImplementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nColoring Schemes\nThe grayscale rendering shows structure but isn’t very exciting. We can create better colormaps:\nSmooth coloring using escape time:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    // Use a color palette (see below)\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nSimple color palette:\nvec3 palette(float t) {\n    // Create a cyclic color palette\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors. Play with the parameters a, b, c, d to get different color schemes!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#julia-sets",
    "href": "day2.html#julia-sets",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.4 Julia Sets",
    "text": "2.4 Julia Sets\n\nDefinition\nFor a fixed complex parameter \\(c\\), the filled Julia set \\(\\mathcal{K}_c\\) consists of points \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded.\nKey difference from Mandelbrot: Here \\(c\\) is fixed and we vary the initial point \\(z_0\\) (which comes from the pixel position). In Mandelbrot, \\(z_0 = 0\\) and \\(c\\) varies with pixel position.\n\n\nRelationship to Mandelbrot\nThere’s a beautiful connection: the Mandelbrot set is essentially a “parameter space” for Julia sets. Each point \\(c\\) in the complex plane has an associated Julia set \\(\\mathcal{K}_c\\): - If \\(c \\in \\mathcal{M}\\), then \\(\\mathcal{K}_c\\) is connected - If \\(c \\notin \\mathcal{M}\\), then \\(\\mathcal{K}_c\\) is a Cantor dust (totally disconnected)\n\n\nImplementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv * 3.0;  // Initial point z_0 comes from pixel position\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // A classic choice\n    // Try: vec2(-0.4, 0.6), vec2(0.285, 0.01), vec2(-0.8, 0.156)\n    \n    // Iterate z_{n+1} = z_n² + c\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color (same as Mandelbrot)\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    if(iter == max_iter) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nTry different values of \\(c\\) to explore the incredible variety of Julia sets! You can even animate \\(c\\) with time:\nvec2 c = vec2(0.7 * cos(iTime * 0.3), 0.7 * sin(iTime * 0.3));",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#structs-in-glsl",
    "href": "day2.html#structs-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.5 Structs in GLSL",
    "text": "2.5 Structs in GLSL\n\nMotivation\nAs we work with multiple circles for the Apollonian gasket, organizing the data becomes important. GLSL provides structs (similar to C structs) for grouping related data.\n\n\nDefining a Struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n\nUsing Structs\nCircle c1;\nc1.center = vec2(0.0, 0.0);\nc1.radius = 1.0;\n\n// Can also initialize directly\nCircle c2 = Circle(vec2(1.0, 0.5), 0.75);\n\n// Pass to functions\nvec2 invertThroughCircle(vec2 p, Circle circ) {\n    return invertCircle(p, circ.center, circ.radius);\n}\n\n\nWhy Structs?\nThey make the code more readable and maintainable. Compare:\n// Without structs\nvec2 invertThrough3Circles(vec2 p, \n    vec2 c1_center, float c1_radius,\n    vec2 c2_center, float c2_radius,\n    vec2 c3_center, float c3_radius) { ... }\n\n// With structs\nvec2 invertThrough3Circles(vec2 p, Circle c1, Circle c2, Circle c3) { ... }\nMuch cleaner!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#euclidean-triangle-tiling",
    "href": "day2.html#euclidean-triangle-tiling",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.6 Euclidean Triangle Tiling",
    "text": "2.6 Euclidean Triangle Tiling\n\nThe Fundamental Domain\nAn equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can: 1. Reflect across its three edges 2. Repeat this process on the resulting triangles 3. Fill the entire plane with copies of the original triangle\n\n\nSetting Up the Triangle\nLet’s work with an equilateral triangle with vertices at: \\[v_0 = (0, 1), \\quad v_1 = (-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}), \\quad v_2 = (\\frac{\\sqrt{3}}{2}, -\\frac{1}{2})\\]\nThis triangle has side length \\(\\sqrt{3}\\) and is centered at the origin.\n// Define triangle vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866\nvec2 v2 = vec2(0.866, -0.5);\n\n\nReflection Across a Line\nTo reflect a point \\(p\\) across a line through the origin with unit normal \\(\\mathbf{n}\\), we use: \\[p' = p - 2(\\mathbf{n} \\cdot p)\\mathbf{n}\\]\nFor a line through two points (an edge of our triangle), we need to: 1. Compute the perpendicular direction (normal to the edge) 2. Determine which side of the line we’re on 3. Reflect if necessary\nPlaceholder for specific implementation: The exact formulas depend on how we set up our edges. Here’s the structure:\n// Reflect across edge v0-v1\nvec2 edge = v1 - v0;\nvec2 normal = normalize(vec2(-edge.y, edge.x));  // Perpendicular to edge\nfloat dist = dot(p - v0, normal);  // Signed distance to line\nif(dist &lt; 0.0) {\n    p = p - 2.0 * dist * normal;  // Reflect if on wrong side\n}\n\n\nIterative Folding\nThe key insight: we repeatedly reflect \\(p\\) across the three edges of the triangle until it lands inside the fundamental domain.\nvec2 foldToTriangle(vec2 p, int iterations) {\n    // Define the three edges and their normals\n    // [Edge definitions here]\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Reflect across each edge if necessary\n        // [Reflection code for edge 0]\n        // [Reflection code for edge 1]\n        // [Reflection code for edge 2]\n    }\n    \n    return p;\n}\nAfter folding, all points in the plane map to the interior of our triangle. We can then color based on: - The final position within the triangle - The number of reflections needed - Which edge was crossed most recently\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 p = [coordinate setup as usual];\n    \n    // Fold to fundamental domain\n    vec2 p_folded = foldToTriangle(p, 10);\n    \n    // Color based on position in triangle\n    // Could use barycentric coordinates, distance to edges, etc.\n    vec3 color = vec3(p_folded * 0.5 + 0.5, 0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\nNote: The exact implementation requires careful handling of the geometry. The key mathematical ideas are: 1. Reflection formula: \\(p' = p - 2(p \\cdot n)n\\) for a line with normal \\(n\\) through origin 2. Iterative folding brings any point into the fundamental domain 3. Track which reflections occur for interesting coloring",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#sierpinski-triangle-via-folding",
    "href": "day2.html#sierpinski-triangle-via-folding",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.7 Sierpinski Triangle via Folding",
    "text": "2.7 Sierpinski Triangle via Folding\n\nThe Concept\nThe Sierpinski triangle is a fractal that can be generated by: 1. Starting with an equilateral triangle 2. Removing the middle triangle (connecting midpoints) 3. Repeating on each remaining sub-triangle\nEquivalently, we can generate it by iterated folding with scaling.\n\n\nFolding Algorithm\nAt each iteration: 1. Reflect \\(p\\) across the three edges of the triangle (fold it inside) 2. Scale toward the center 3. Repeat\nMathematically, after \\(n\\) iterations, we’ve zoomed in by a factor of \\(2^n\\) and applied \\(n\\) reflections.\n\n\nImplementation Sketch\nvec2 sierpinskiFold(vec2 p, int iterations) {\n    // Triangle vertices (equilateral)\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    float scale = 1.0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Reflect across each edge (fold into triangle)\n        // [Reflection code similar to triangle tiling]\n        \n        // After folding, scale and translate\n        p = p * 2.0;  // Zoom in by factor of 2\n        scale *= 2.0;\n        \n        // [Additional centering/translation may be needed]\n    }\n    \n    return p;\n}\n\n\nColoring by Iteration Depth\nWe can track how many times we hit certain conditions during folding:\nint orbit = 0;  // Track some property during iteration\n\nfor(int i = 0; i &lt; max_iter; i++) {\n    // Folding operations\n    \n    // Track orbit behavior\n    if([some condition]) orbit++;\n}\n\n// Color based on orbit count\nfloat t = float(orbit) / float(max_iter);\nvec3 color = palette(t);\nThe specific conditions to track depend on the geometric setup, but typically we color based on: - Which edge we reflected across most recently - How many reflections were needed - Distance from the center after folding\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    // Apply Sierpinski folding\n    vec2 p_folded = sierpinskiFold(p, 8);\n    \n    // Color based on the folded position\n    float d = length(p_folded);\n    vec3 color = d &lt; 0.1 ? vec3(1.0) : vec3(0.0);\n    \n    // OR: color based on iteration behavior\n    // [More sophisticated coloring]\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Sierpinski triangle should emerge as a self-similar fractal pattern!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#summary",
    "href": "day2.html#summary",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.7 Summary",
    "text": "2.7 Summary\nToday we covered:\n\nComplex arithmetic in GLSL: Representing complex numbers as vec2 and implementing operations\nMandelbrot set: Iterating \\(z_{n+1} = z_n^2 + c\\) with \\(z_0 = 0\\), coloring by escape time\nCircle inversion: A conformal transformation that maps circles to circles (or lines)\nStructs: Organizing geometric data (circles) for cleaner code\nApollonian gasket: Generating fractals through iterated circle inversions\n\nThe key themes: - Iteration creates complexity: Simple rules repeated produce intricate patterns - Two types of iteration: Complex arithmetic (Mandelbrot) and geometric transformations (Apollonian) - Escape-time coloring: Tracking iteration behavior reveals fractal structure - Conformal maps: Circle inversion preserves angles and creates beautiful patterns\nTomorrow we’ll explore geometric tilings in both Euclidean and hyperbolic space, using reflection operations similar to today’s inversions.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#homework",
    "href": "day2.html#homework",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.8 Homework",
    "text": "2.8 Homework\n\nRequired: Julia Sets\nImplement Julia set rendering, exploring the rich variety of patterns for different parameter values.\nBackground: For a fixed complex parameter \\(c\\), the filled Julia set \\(\\mathcal{K}_c\\) consists of points \\(z_0\\) for which the iteration \\(z_{n+1} = z_n^2 + c\\) remains bounded.\nKey difference from Mandelbrot: Here \\(c\\) is fixed and we vary the initial point \\(z_0\\) (which comes from the pixel position). In Mandelbrot, \\(z_0 = 0\\) and \\(c\\) varies with pixel position.\nTask:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = [coordinate setup];\n    vec2 z = uv * 3.0;  // Initial point z_0 from pixel\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // Classic choice\n    \n    // Iterate z_{n+1} = z_n² + c\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on escape\n    [color based on iteration count]\n}\nExploration: Try different values of \\(c\\): - vec2(-0.4, 0.6) - dendrite-like structures - vec2(0.285, 0.01) - spiral patterns - vec2(-0.8, 0.156) - intricate filaments - vec2(-0.7269, 0.1889) - “douady’s rabbit”\nAnimation: Animate \\(c\\) to explore parameter space:\nfloat angle = iTime * 0.3;\nvec2 c = vec2(0.7 * cos(angle), 0.7 * sin(angle));\nWatch how the Julia set morphs as you trace a circle in parameter space!\nExpected output: Beautiful, intricate fractal patterns that vary dramatically with \\(c\\).\n\n\nOptional: Schottky Groups\nExplore a more complex iterated inversion system with four or more circles.\nThe Setup: Unlike the Apollonian gasket where circles are mutually tangent, Schottky groups use disjoint circles (not touching). The classic setup uses 4 circles arranged symmetrically.\nExample configuration:\nvoid setupSchottkyCircles(out Circle[4] circles) {\n    float spacing = 2.5;\n    float radius = 0.8;\n    \n    circles[0] = Circle(vec2(-spacing, 0.0), radius);\n    circles[1] = Circle(vec2(spacing, 0.0), radius);\n    circles[2] = Circle(vec2(0.0, -spacing), radius);\n    circles[3] = Circle(vec2(0.0, spacing), radius);\n}\nIteration pattern: Instead of cycling through all circles each iteration, alternate between pairs: - Invert through circle 0 or 1 (depending on which side you’re on) - Then invert through circle 2 or 3 - Repeat\nvec2 schottkyOrbit(vec2 p, Circle[4] circles, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Horizontal pair: invert through whichever is closer\n        float d0 = length(p - circles[0].center);\n        float d1 = length(p - circles[1].center);\n        \n        if(d0 &lt; d1) {\n            p = invertCircle(p, circles[0].center, circles[0].radius);\n        } else {\n            p = invertCircle(p, circles[1].center, circles[1].radius);\n        }\n        \n        // Vertical pair\n        float d2 = length(p - circles[2].center);\n        float d3 = length(p - circles[3].center);\n        \n        if(d2 &lt; d3) {\n            p = invertCircle(p, circles[2].center, circles[2].radius);\n        } else {\n            p = invertCircle(p, circles[3].center, circles[3].radius);\n        }\n    }\n    \n    return p;\n}\nColoring: Color based on: - Final distance from origin - Which sequence of circles was traversed - Escape iteration - Orbit behavior\nExploration: Try: - Different circle configurations (more circles, different arrangements) - Different iteration rules - Varying circle radii with iTime for animation\nExpected output: Intricate patterns in the space between circles, with self-similar structure emerging from the iterated inversions. Very different from Apollonian gasket—more “webby” and less “circular.”",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#looking-ahead",
    "href": "day2.html#looking-ahead",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.9 Looking Ahead",
    "text": "2.9 Looking Ahead\nTomorrow we’ll shift to geometric tilings: first in Euclidean space, then in hyperbolic geometry. We’ll use reflections across geodesics (similar to today’s circle inversions) to tile the plane with triangles. You’ll see how the same algorithmic ideas (iterated geometric transformations) work in different geometries.\nMake sure you’re comfortable with: - Iteration and escape-time algorithms - Circle inversion (you’ll use it extensively tomorrow in hyperbolic geometry!) - Structs for organizing geometric data - Coloring strategies based on orbit behavior\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day3.html",
    "href": "day3.html",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "3.1 Overview\nToday we explore geometric tilings through reflection operations. We’ll start with triangle tilings in Euclidean space, then venture into hyperbolic geometry where the same techniques produce dramatically different patterns. We’ll work primarily in the upper half-plane model, learning to compute with geodesics and the hyperbolic metric, then transform our work into the Poincaré disk for visualization.\nBy the end of today, you’ll understand how reflection-based tiling algorithms work across different geometries, and have working implementations of both Euclidean and hyperbolic tilings.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#sierpinski-carpet-via-box-folding",
    "href": "day3.html#sierpinski-carpet-via-box-folding",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.2 Sierpinski Carpet via Box Folding",
    "text": "3.2 Sierpinski Carpet via Box Folding\n\nFrom Triangle to Square\nYesterday we created the Sierpinski triangle by folding across the edges of an equilateral triangle. The Sierpinski carpet applies the same principle to a square, using axis-aligned reflections.\n\n\nThe Algorithm\nStarting with a square domain (say \\([-1, 1]^2\\)), we: 1. Fold using abs() to create 4-fold symmetry (map all quadrants to first quadrant) 2. Scale by factor of 3 3. Remove the middle square 4. Repeat\nAfter \\(n\\) iterations, we’ve subdivided the square into a \\(3^n \\times 3^n\\) grid and removed all middle squares at every scale.\n\n\nImplementation\nvec2 sierpinskiCarpetFold(vec2 p, int iterations, out int removed) {\n    removed = 0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Scale by 3, shift to center\n        p = p * 3.0 - vec2(1.0);\n        \n        // Check if we're in the middle square (to be removed)\n        // After scaling and shifting, the middle square is roughly centered\n        if(abs(p.x) &lt; 1.0 && abs(p.y) &lt; 1.0) {\n            removed = 1;\n        }\n    }\n    \n    return p;\n}\nNote: The exact check for “removed” regions depends on the coordinate setup. After the transformation p * 3.0 - 1.0, we’re centering each sub-square. The middle third is the region we’re removing.\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    int removed;\n    vec2 p_folded = sierpinskiCarpetFold(p, 6, removed);\n    \n    vec3 color = removed == 1 ? vec3(0.0) : vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nThe characteristic Sierpinski carpet should emerge: a square with self-similar removed regions at all scales.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#hyperbolic-geometry-models-and-metrics",
    "href": "day3.html#hyperbolic-geometry-models-and-metrics",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.3 Hyperbolic Geometry: Models and Metrics",
    "text": "3.3 Hyperbolic Geometry: Models and Metrics\n\nThe Upper Half-Plane Model\nThe upper half-plane model \\(\\mathbb{H}^2\\) consists of complex numbers with positive imaginary part: \\[\\mathbb{H}^2 = \\{z \\in \\mathbb{C} : \\text{Im}(z) &gt; 0\\}\\]\nThe hyperbolic metric is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2} = \\frac{|dz|^2}{(\\text{Im}(z))^2}\\]\nThis metric “blows up” as we approach the real axis (the boundary at infinity), making the geometry shrink near \\(y = 0\\).\n\n\nGeodesics in the Upper Half-Plane\nGeodesics (hyperbolic “straight lines”) in \\(\\mathbb{H}^2\\) are: 1. Vertical lines \\(\\{x = c\\}\\) for constant \\(c\\) 2. Semicircles centered on the real axis, perpendicular to it\nFor a semicircle of radius \\(R\\) centered at \\((c, 0)\\), the equation is: \\[(x - c)^2 + y^2 = R^2, \\quad y &gt; 0\\]\n\n\nHyperbolic Distance\nThe distance between two points \\(z, w \\in \\mathbb{H}^2\\) is: \\[d(z, w) = \\text{arcosh}\\left(1 + \\frac{|z - w|^2}{2 \\cdot \\text{Im}(z) \\cdot \\text{Im}(w)}\\right)\\]\nIn GLSL:\nfloat hyperbolicDistance(vec2 z, vec2 w) {\n    float diff2 = dot(z - w, z - w);  // |z - w|²\n    float denom = 2.0 * z.y * w.y;    // 2·Im(z)·Im(w)\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // acosh(x) = log(x + sqrt(x²-1))\n}\n\n\nThe Poincaré Disk Model\nThe Poincaré disk model consists of the interior of the unit disk: \\[\\mathbb{D}^2 = \\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\]\nThe metric is: \\[ds^2 = \\frac{4(dx^2 + dy^2)}{(1 - |z|^2)^2}\\]\nGeodesics are circular arcs perpendicular to the unit circle (or diameters).\n\n\nConverting Between Models\nThe Cayley transform maps the upper half-plane to the disk: \\[w = \\frac{z - i}{z + i}\\]\nThe inverse is: \\[z = i\\frac{1 + w}{1 - w}\\]\nIn GLSL (using complex arithmetic from Day 2):\nvec2 uhpToDisk(vec2 z) {\n    // w = (z - i) / (z + i)\n    vec2 numerator = z - vec2(0.0, 1.0);      // z - i\n    vec2 denominator = z + vec2(0.0, 1.0);    // z + i\n    return cdiv(numerator, denominator);\n}\n\nvec2 diskToUHP(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 numerator = vec2(0.0, 1.0) + w;      // i + iw  \n    numerator = vec2(-numerator.y, numerator.x);  // Multiply by i\n    vec2 denominator = vec2(1.0, 0.0) - w;    // 1 - w\n    return cdiv(numerator, denominator);\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#the-23-triangle",
    "href": "day3.html#the-23-triangle",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.4 The (2,3,∞) Triangle",
    "text": "3.4 The (2,3,∞) Triangle\n\nWhy This Triangle?\nThe \\((2, 3, \\infty)\\) triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (the “ideal vertex” at infinity). In the upper half-plane, this triangle has particularly nice edges: - One edge is the unit semicircle centered at the origin: \\(x^2 + y^2 = 1\\), \\(y &gt; 0\\) - Two edges are vertical lines at \\(x = \\pm c\\) for some constant \\(c\\)\nFor the \\((2,3,\\infty)\\) triangle, with the right angle at the origin and the \\(\\pi/3\\) angles at the two vertical edges, we have \\(c = \\sqrt{3}\\) (this can be derived from hyperbolic trigonometry, but we’ll just use it).\nActually, a cleaner setup: let’s use the triangle with: - Geodesic from \\(-1\\) to \\(1\\) (unit semicircle centered at origin) - Vertical geodesic at \\(x = 1\\) - Vertical geodesic at \\(x = -1\\)\nThis creates a fundamental domain bounded by these three geodesics. The angles where they meet determine the triangle group.\n[Note: Need to work out the exact setup here - which specific triangle gives clean angles? The (2,3,∞) triangle or a different choice like (2,4,∞)? Let me provide the framework and you can adjust the specific parameters.]\n\n\nChecking if a Point is in the Triangle\nFor our triangle with: - Bottom edge: unit semicircle - Left edge: vertical line at \\(x = -1\\) - Right edge: vertical line at \\(x = 1\\)\nbool inTriangle(vec2 p) {\n    // Above the semicircle: x² + y² &gt; 1\n    bool aboveSemicircle = dot(p, p) &gt; 1.0;\n    \n    // Between vertical lines: -1 &lt; x &lt; 1\n    bool betweenLines = (p.x &gt; -1.0) && (p.x &lt; 1.0);\n    \n    return aboveSemicircle && betweenLines;\n}\n\n\nReflection Across Geodesics\nReflection across a vertical line \\(x = c\\): \\[\\text{reflect}(x + iy) = (2c - x) + iy\\]\nvec2 reflectVertical(vec2 p, float c) {\n    return vec2(2.0 * c - p.x, p.y);\n}\nReflection across the unit semicircle (circle inversion from yesterday!): Circle inversion with respect to a circle of radius \\(R\\) centered at \\((c_x, c_y)\\) is: \\[\\text{inv}(p) = c + R^2 \\frac{p - c}{|p - c|^2}\\]\nFor our unit circle centered at origin:\nvec2 reflectCircle(vec2 p) {\n    return p / dot(p, p);  // Inversion through unit circle\n}\n\n\nFolding into the Fundamental Domain\nvec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        bool folded = false;\n        \n        // Reflect across left vertical line if needed\n        if(p.x &lt; -1.0) {\n            p = reflectVertical(p, -1.0);\n            folded = true;\n        }\n        \n        // Reflect across right vertical line if needed\n        if(p.x &gt; 1.0) {\n            p = reflectVertical(p, 1.0);\n            folded = true;\n        }\n        \n        // Reflect across semicircle if needed\n        if(dot(p, p) &lt; 1.0) {\n            p = reflectCircle(p);\n            folded = true;\n        }\n        \n        if(folded) foldCount++;\n        else break;  // In fundamental domain\n    }\n    \n    return p;\n}\n\n\nVisualization: Hyperbolic Tiling\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to upper half-plane\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;  // Scale to see interesting region\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Map to upper half-plane (shift up so y &gt; 0)\n    vec2 p = uv + vec2(0.0, 1.5);  // Ensure we're above real axis\n    \n    // Fold to fundamental domain\n    int foldCount;\n    vec2 p_folded = foldToTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);  // Use palette function from Day 2\n    \n    // If we're in the fundamental triangle, use different color\n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result should be a beautiful hyperbolic tiling - the plane tessellated by copies of our fundamental triangle!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#visualizing-in-the-poincaré-disk",
    "href": "day3.html#visualizing-in-the-poincaré-disk",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.5 Visualizing in the Poincaré Disk",
    "text": "3.5 Visualizing in the Poincaré Disk\nNow we’ll see the same tiling in a different model by converting coordinates.\n\nBy Precomposition\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Only render inside unit disk\n    if(length(uv) &gt;= 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 p = diskToUHP(uv);\n    \n    // Now do all computations in UHP\n    int foldCount;\n    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);\n    \n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe tiling now appears in the Poincaré disk—the same mathematical object displayed in a different model!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#distance-to-geodesics",
    "href": "day3.html#distance-to-geodesics",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.6 Distance to Geodesics",
    "text": "3.6 Distance to Geodesics\nFor homework, you’ll want to draw geodesic boundaries. Here’s the framework:\n\nDistance to a Vertical Geodesic\nFor a vertical line \\(x = c\\), the hyperbolic distance from a point \\((x, y)\\) to the line is: \\[d = \\text{arcosh}\\left(\\frac{|x - c|}{\\text{some formula involving } y}\\right)\\]\n[Placeholder: exact formula for distance to vertical geodesic]\n\n\nDistance to a Semicircular Geodesic\nFor a semicircle of radius \\(R\\) centered at \\((c, 0)\\), the distance calculation is more involved. One approach: 1. Find the closest point on the semicircle to \\(p\\) 2. Compute hyperbolic distance between \\(p\\) and that closest point\n[Placeholder: geodesic distance formula or algorithm]\nAlternatively, you can find formulas in hyperbolic geometry references, or derive them from the metric.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#summary",
    "href": "day3.html#summary",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.6 Summary",
    "text": "3.6 Summary\nToday we covered:\n\nEuclidean triangle tiling: Using reflections to tile the plane with equilateral triangles\nHyperbolic geometry models: Upper half-plane and Poincaré disk, with metrics and geodesics\nCoordinate transformations: Cayley transform connecting the two models\nHyperbolic triangle tiling: Using reflections (including circle inversion) to tile hyperbolic space\nMultiple representations: Same tiling visualized in different models\n\nKey insights: - Reflection-based tilings work in any geometry with the appropriate reflection operations - Circle inversion (from Day 2) is fundamental to hyperbolic geometry - The same mathematical object looks different in different models - Geodesics replace straight lines as the fundamental “straight” paths\nThe algorithmic structure is identical across geometries—only the reflection operations change!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#homework",
    "href": "day3.html#homework",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.7 Homework",
    "text": "3.7 Homework\n\nRequired: Drawing Geodesics and Hyperbolic Disks\nImplement visualization of basic hyperbolic objects to understand the geometry.\nPart 1: Draw several geodesics in the upper half-plane\nVertical lines are easy:\n// Distance to vertical line x = c\nfloat distToVertical = abs(p.x - c);\nif(distToVertical &lt; thickness) color = geodesicColor;\nSemicircular geodesics require the implicit equation:\n// Semicircle: (x - cx)² + y² = R², with y &gt; 0\nfloat distToSemicircle = abs(sqrt((p.x - cx) * (p.x - cx) + p.y * p.y) - R);\nif(distToSemicircle &lt; thickness && p.y &gt; 0.0) color = geodesicColor;\nDraw several of each type to visualize the geodesic structure.\nPart 2: Draw hyperbolic disks\nA hyperbolic disk of radius \\(r\\) centered at \\(z_0\\) is the set: \\[\\{z : d_{\\text{hyp}}(z, z_0) &lt; r\\}\\]\nfloat d = hyperbolicDistance(p, center);\nif(d &lt; radius) color = diskColor;\nDraw several disks at different locations and with the same hyperbolic radius. Observe how they appear smaller (in Euclidean sense) near the boundary—this demonstrates the metric’s behavior.\nPart 3: Visualize metric distortion\nCreate a grid of hyperbolic disks of equal hyperbolic radius. Watch how their Euclidean sizes vary across the half-plane.\nOptional enhancement: Repeat in Poincaré disk model by precomposition.\n\n\nRequired: Drawing Triangle Edges and Vertices\nEnhance your hyperbolic tiling by drawing the triangle boundaries.\nTask: For each point, compute the distance to the three geodesics forming your triangle boundary. If the distance is below a threshold, color it as an edge.\nImplementation hints:\n// Distance to vertical line\nfloat d1 = abs(p.x - (-1.0));\nfloat d2 = abs(p.x - 1.0);\n\n// Distance to semicircle (already have this from Part 1)\nfloat d3 = abs(length(p) - 1.0);\n\nfloat edgeThickness = 0.05;\nbool onEdge = (d1 &lt; edgeThickness) || (d2 &lt; edgeThickness) || (d3 &lt; edgeThickness);\n\nif(onEdge) color = vec3(1.0, 1.0, 1.0);  // White edges\nFor vertices, compute Euclidean distance to the three vertex positions and draw small circles.\nExpected output: Your tiling with clearly visible triangle boundaries, making the tessellation structure explicit.\n\n\nRequired: Model Conversion and Möbius Transformation\nWork with different representations of hyperbolic space.\nPart 1: Convert your tiling to Poincaré disk\nYou already have the transformation functions. Create a shader that displays your hyperbolic tiling in the disk model and compare the visual appearance.\nPart 2: Apply a Möbius transformation\nA Möbius transformation has the form: \\[z \\mapsto \\frac{az + b}{cz + d}, \\quad ad - bc = 1\\]\nThese are isometries of hyperbolic space—they permute the tiles but preserve the geometry.\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    vec2 num = cadd(cmul(a, z), b);\n    vec2 den = cadd(cmul(c, z), d);\n    return cdiv(num, den);\n}\nTry some interesting transformations: - Translation: \\(z \\mapsto z + 1\\) (in complex plane, not hyperbolic translation!) - Scaling: \\(z \\mapsto 2z\\) - Rotation: \\(z \\mapsto e^{i\\theta} z\\)\nApply to your tiling:\n// Before folding:\np = mobius(p, vec2(2.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(1.0, 0.0));\nWatch how the tiling transforms!\n\n\nOptional: Advanced Hyperbolic Explorations\nChoose one or more:\n\n1. Different Triangle Groups\nImplement different hyperbolic triangle groups. The \\((p, q, r)\\) notation indicates angles \\(\\pi/p\\), \\(\\pi/q\\), \\(\\pi/r\\) at the three vertices.\nFamous examples: - \\((2, 3, 7)\\): Creates Escher-like tilings - \\((2, 4, 6)\\): Different symmetry structure - \\((3, 3, 3)\\): Equilateral hyperbolic triangle\nEach requires setting up different geodesics for the triangle edges.\n\n\n2. Klein Model\nThe Klein model represents hyperbolic space where geodesics are Euclidean straight lines (but angles are distorted).\nConvert from Poincaré disk to Klein: \\[w = \\frac{2z}{1 + |z|^2}\\]\nVisualize your tiling in this model and observe how geodesics become straight!\n\n\n3. Decorated Tiles\nAdd patterns inside each triangle (like Escher’s Circle Limit prints). Use barycentric coordinates or distance from edges to create decorations within the fundamental domain.\n\n\n4. Conformal Mapping Art\nUse complex analysis to map the disk to other regions (strips, annuli, etc.) and visualize hyperbolic geometry in exotic coordinate systems.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#looking-ahead",
    "href": "day3.html#looking-ahead",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.8 Looking Ahead",
    "text": "3.8 Looking Ahead\nTomorrow we move to 3D! We’ll learn raymarching and signed distance functions to render implicit surfaces. The geometric intuition from reflections and distance computations will carry over, but now in three dimensions with lighting and shading.\nMake sure you’re comfortable with: - Reflection operations (these generalize to 3D) - Distance computations (both Euclidean and hyperbolic) - Iterative algorithms for geometric structures - Working with different coordinate systems/models\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day4.html",
    "href": "day4.html",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "4.1 Overview\nToday we enter the third dimension! We’ll learn how to set up a camera and cast rays from each pixel, then implement ray-object intersection testing. We’ll start with analytical methods (solving equations directly) for spheres and tori, then transition to raymarching with signed distance functions—a more flexible approach that will enable complex scenes.\nBy the end of today, you’ll be able to render implicit surfaces in 3D with basic lighting, setting the foundation for tomorrow’s advanced techniques.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#camera-and-ray-setup",
    "href": "day4.html#camera-and-ray-setup",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.2 Camera and Ray Setup",
    "text": "4.2 Camera and Ray Setup\n\nThe Rendering Equation (Simplified)\nFor each pixel, we need to: 1. Determine which ray in 3D space corresponds to that pixel 2. Find where (if anywhere) the ray intersects scene geometry 3. Compute the color based on surface properties and lighting\n\n\nCoordinate System\nWe’ll use the Three.js convention: - Y-axis points up - Z-axis points toward the camera (out of the screen) - X-axis points right - This is a right-handed coordinate system\n\n\nCamera Model\nWe’ll use a simple pinhole camera model: - Camera positioned at the origin (for now) - Looking down the -Z axis - Field of view (FOV) determines the viewing frustum\n\n\nRay Generation\nFor a pixel at normalized coordinates \\((u, v) \\in [-1, 1]^2\\), we generate a ray with: - Origin: \\(\\mathbf{o} = (0, 0, 0)\\) (camera position) - Direction: \\(\\mathbf{d} = \\text{normalize}(u \\cdot \\text{right}, v \\cdot \\text{up}, -\\text{focal length})\\)\nThe focal length relates to field of view: for FOV angle \\(\\theta\\), we have \\(\\text{focal length} = 1 / \\tan(\\theta/2)\\).\n\n\nImplementation\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nRay getRay(vec2 fragCoord, vec2 resolution, float fov) {\n    // Normalize to [-1, 1]\n    vec2 uv = (fragCoord / resolution) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= resolution.x / resolution.y;\n    \n    // Compute focal length from FOV\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    // Ray from origin through pixel\n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.direction = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    return ray;\n}\n\n\nPoints Along a Ray\nA parametric ray can be written as: \\[\\mathbf{L}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(\\mathbf{o}\\) is the origin, \\(\\mathbf{d}\\) is the direction, and \\(t \\geq 0\\) is the parameter.\nvec3 rayPoint(Ray ray, float t) {\n    return ray.origin + t * ray.direction;\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#analytical-ray-sphere-intersection",
    "href": "day4.html#analytical-ray-sphere-intersection",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.3 Analytical Ray-Sphere Intersection",
    "text": "4.3 Analytical Ray-Sphere Intersection\n\nThe Sphere Equation\nA sphere of radius \\(r\\) centered at the origin is defined implicitly by: \\[x^2 + y^2 + z^2 = r^2\\]\nOr more compactly: \\(|\\mathbf{p}|^2 = r^2\\) for points \\(\\mathbf{p}\\) on the surface.\n\n\nSetting Up the Intersection\nWe want to find where the ray \\(\\mathbf{L}(t) = \\mathbf{o} + t\\mathbf{d}\\) intersects the sphere. Substituting the ray equation into the sphere equation: \\[|\\mathbf{o} + t\\mathbf{d}|^2 = r^2\\]\nExpanding: \\[(\\mathbf{o} + t\\mathbf{d}) \\cdot (\\mathbf{o} + t\\mathbf{d}) = r^2\\] \\[|\\mathbf{o}|^2 + 2t(\\mathbf{o} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nThis is a quadratic equation in \\(t\\): \\[at^2 + bt + c = 0\\]\nwhere: - \\(a = |\\mathbf{d}|^2\\) (which is 1 if \\(\\mathbf{d}\\) is normalized) - \\(b = 2(\\mathbf{o} \\cdot \\mathbf{d})\\) - \\(c = |\\mathbf{o}|^2 - r^2\\)\n\n\nSolving the Quadratic\nThe solutions are: \\[t = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\]\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us: - \\(\\Delta &lt; 0\\): no intersection (ray misses sphere) - \\(\\Delta = 0\\): one intersection (ray is tangent) - \\(\\Delta &gt; 0\\): two intersections (ray enters and exits sphere)\nWe want the smaller positive \\(t\\) (the closer intersection point).\n\n\nImplementation\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 oc = ray.origin - center;  // o - c (sphere center)\n    \n    float a = dot(ray.direction, ray.direction);  // Should be 1 if normalized\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc, oc) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    // Return the closer intersection\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    // Return the closest positive t\n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;  // Behind camera\n}\n\n\nRendering the Sphere\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Sphere parameters\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);  // In front of camera\n    float sphereRadius = 1.0;\n    \n    // Test intersection\n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit the sphere!\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    } else {\n        // Background\n        color = vec3(0.1, 0.1, 0.2);  // Dark blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nResult: You should see a red disk on a blue background. But it looks flat—we can’t see that it’s a sphere!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#adding-lighting-the-surface-normal",
    "href": "day4.html#adding-lighting-the-surface-normal",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.4 Adding Lighting: The Surface Normal",
    "text": "4.4 Adding Lighting: The Surface Normal\n\nComputing the Normal\nFor a sphere centered at \\(\\mathbf{c}\\), the outward normal at a point \\(\\mathbf{p}\\) on the surface is: \\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the vector from the center to the surface point, normalized.\nvec3 sphereNormal(vec3 point, vec3 center, float radius) {\n    return (point - center) / radius;\n}\n\n\nDiffuse Lighting\nThe simplest lighting model: Lambertian diffuse shading. The brightness depends on the angle between the surface normal \\(\\mathbf{n}\\) and the light direction \\(\\mathbf{l}\\): \\[\\text{brightness} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max(0, \\cdots)\\) ensures we don’t get negative light (surfaces facing away from the light are dark).\n\n\nImplementation with Lighting\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute intersection point\n        vec3 hitPoint = rayPoint(ray, t);\n        \n        // Compute normal\n        vec3 normal = sphereNormal(hitPoint, sphereCenter, sphereRadius);\n        \n        // Light direction (fixed, from above and to the right)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        \n        // Diffuse lighting\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Color the sphere\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);  // Red\n        color = sphereColor * diffuse;\n        \n        // Add a bit of ambient light so dark side isn't completely black\n        color += sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nResult: Now the sphere looks 3D! The lighting reveals its curvature.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#ray-torus-intersection",
    "href": "day4.html#ray-torus-intersection",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.5 Ray-Torus Intersection",
    "text": "4.5 Ray-Torus Intersection\n\nThe Torus Equation\nA torus with major radius \\(R\\) (center to tube center) and minor radius \\(r\\) (tube radius) centered at the origin with axis along the Y-axis has the implicit equation: \\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nOr equivalently: \\[\\left(|\\mathbf{p}_{xz}| - R\\right)^2 + p_y^2 = r^2\\]\nwhere \\(\\mathbf{p}_{xz} = (p_x, p_z)\\) is the projection onto the XZ-plane.\n\n\nComputing the Gradient (Normal)\nThe gradient of the implicit function \\(F(x, y, z) = \\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 - r^2\\) gives the normal direction.\nLet \\(q = \\sqrt{x^2 + z^2}\\). Then:\n\\[\\frac{\\partial F}{\\partial x} = 2\\left(q - R\\right) \\cdot \\frac{x}{q}\\]\n\\[\\frac{\\partial F}{\\partial y} = 2y\\]\n\\[\\frac{\\partial F}{\\partial z} = 2\\left(q - R\\right) \\cdot \\frac{z}{q}\\]\nThe normal is: \\[\\mathbf{n} = \\nabla F = \\left(\\frac{\\partial F}{\\partial x}, \\frac{\\partial F}{\\partial y}, \\frac{\\partial F}{\\partial z}\\right)\\]\nnormalized to unit length.\n\n\nImplementation\nvec3 torusNormal(vec3 p, float majorRadius, float minorRadius) {\n    // Project to XZ plane\n    vec2 pxz = vec2(p.x, p.z);\n    float q = length(pxz);\n    \n    // Gradient components\n    float factor = q - majorRadius;\n    vec3 grad;\n    grad.x = 2.0 * factor * p.x / q;\n    grad.y = 2.0 * p.y;\n    grad.z = 2.0 * factor * p.z / q;\n    \n    return normalize(grad);\n}\n\n\nFinding the Intersection\nFinding the exact intersection between a ray and a torus requires solving a quartic equation (degree 4 polynomial). This is algebraically messy!\nWe can: 1. Use a numerical root-finding method (Newton’s method, bisection) 2. Or… use a different approach (foreshadowing: raymarching!)\nFor now, let’s implement a simple bisection method to find the intersection:\nfloat torusImplicit(vec3 p, float R, float r) {\n    vec2 pxz = vec2(p.x, p.z);\n    float q = length(pxz) - R;\n    return q * q + p.y * p.y - r * r;\n}\n\nfloat intersectTorus(Ray ray, float majorRadius, float minorRadius) {\n    // Bisection method to find root of F(ray(t)) = 0\n    float tMin = 0.0;\n    float tMax = 10.0;  // Search range\n    \n    // Check if there's a sign change (indicating a root exists)\n    float fMin = torusImplicit(rayPoint(ray, tMin), majorRadius, minorRadius);\n    float fMax = torusImplicit(rayPoint(ray, tMax), majorRadius, minorRadius);\n    \n    if (fMin * fMax &gt; 0.0) {\n        return -1.0;  // No intersection in range\n    }\n    \n    // Bisection\n    for (int i = 0; i &lt; 50; i++) {\n        float tMid = (tMin + tMax) / 2.0;\n        float fMid = torusImplicit(rayPoint(ray, tMid), majorRadius, minorRadius);\n        \n        if (abs(fMid) &lt; 0.001) {\n            return tMid;  // Found intersection\n        }\n        \n        if (fMin * fMid &lt; 0.0) {\n            tMax = tMid;\n            fMax = fMid;\n        } else {\n            tMin = tMid;\n            fMin = fMid;\n        }\n    }\n    \n    return (tMin + tMax) / 2.0;  // Best estimate\n}\n\n\nRendering the Torus\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Torus parameters\n    float majorRadius = 1.5;\n    float minorRadius = 0.5;\n    vec3 torusCenter = vec3(0.0, 0.0, -4.0);\n    \n    // Adjust ray for torus center (translate)\n    Ray torusRay = ray;\n    torusRay.origin = ray.origin - torusCenter;\n    \n    float t = intersectTorus(torusRay, majorRadius, minorRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = rayPoint(torusRay, t);\n        vec3 normal = torusNormal(hitPoint, majorRadius, minorRadius);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = torusColor * diffuse + torusColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nResult: A beautiful cyan torus with proper 3D lighting!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#motivation-for-raymarching",
    "href": "day4.html#motivation-for-raymarching",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.6 Motivation for Raymarching",
    "text": "4.6 Motivation for Raymarching\n\nThe Problem with Analytical Methods\nNotice what we had to do: - Sphere: Solve a quadratic equation (manageable) - Torus: Solve a quartic equation (we used bisection instead) - Arbitrary implicit surface: Could be any degree polynomial, or transcendental!\nMoreover, combining objects is difficult: - How do we render two spheres? Check each separately, take the closer one. - How do we render the union of a sphere and torus? Check both, take closer. - How do we render the intersection (only where both objects exist)? Much harder! - How about smooth blending between objects? Nearly impossible analytically.\nWe need a more flexible approach that works for: - Arbitrary implicit surfaces - Complex compositions of objects - Procedurally defined geometry\nEnter: Raymarching with Signed Distance Functions",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#signed-distance-functions-sdfs",
    "href": "day4.html#signed-distance-functions-sdfs",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.7 Signed Distance Functions (SDFs)",
    "text": "4.7 Signed Distance Functions (SDFs)\n\nDefinition\nA signed distance function \\(d: \\mathbb{R}^3 \\to \\mathbb{R}\\) gives the distance from any point in space to the closest point on a surface: - \\(d(\\mathbf{p}) &gt; 0\\) if \\(\\mathbf{p}\\) is outside the surface - \\(d(\\mathbf{p}) = 0\\) if \\(\\mathbf{p}\\) is on the surface - \\(d(\\mathbf{p}) &lt; 0\\) if \\(\\mathbf{p}\\) is inside the surface\nImportantly, \\(|d(\\mathbf{p})|\\) is the actual Euclidean distance to the surface.\n\n\nWhy SDFs?\nSDFs have a crucial property: if we’re at a point \\(\\mathbf{p}\\) and the nearest surface is distance \\(d\\) away, we can safely move \\(d\\) units along any direction without hitting anything.\nThis enables sphere tracing: we march along the ray, taking steps proportional to the SDF value, guaranteed not to overshoot the surface.\n\n\nSDF for a Sphere\nFor a sphere of radius \\(r\\) centered at \\(\\mathbf{c}\\): \\[d(\\mathbf{p}) = |\\mathbf{p} - \\mathbf{c}| - r\\]\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n\nSDF for a Box\nFor an axis-aligned box centered at the origin with half-extents \\(\\mathbf{b} = (b_x, b_y, b_z)\\):\nfloat sdBox(vec3 p, vec3 center, vec3 halfExtents) {\n    vec3 q = abs(p - center) - halfExtents;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n(This formula handles both inside and outside the box correctly.)\n\n\nSDF for a Plane\nFor an infinite plane with normal \\(\\mathbf{n}\\) (unit vector) passing through point \\(\\mathbf{p}_0\\): \\[d(\\mathbf{p}) = (\\mathbf{p} - \\mathbf{p}_0) \\cdot \\mathbf{n}\\]\nfloat sdPlane(vec3 p, vec3 planePoint, vec3 normal) {\n    return dot(p - planePoint, normal);\n}\nFor the XZ-plane (Y = 0):\nfloat sdPlaneY(vec3 p, float height) {\n    return p.y - height;\n}\n\n\nSDF for a Torus\nFor a torus with major radius \\(R\\) and minor radius \\(r\\), axis along Y:\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\n\nOther Primitives\nMany more SDFs exist! Cylinders, capsules, cones, ellipsoids, etc. See resources like Inigo Quilez’s SDF functions.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#the-raymarching-algorithm",
    "href": "day4.html#the-raymarching-algorithm",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.8 The Raymarching Algorithm",
    "text": "4.8 The Raymarching Algorithm\n\nSphere Tracing\nThe algorithm: 1. Start at the ray origin 2. Evaluate the SDF at the current point 3. March forward along the ray by that distance 4. Repeat until: - We’re very close to the surface (SDF ≈ 0) → hit! - We’ve marched too far → miss - We’ve taken too many steps → give up\nstruct HitInfo {\n    bool hit;\n    float t;        // Distance along ray\n    vec3 position;  // Hit position\n};\n\nHitInfo raymarch(Ray ray, float maxDist, int maxSteps) {\n    HitInfo info;\n    info.hit = false;\n    \n    float t = 0.0;\n    \n    for (int i = 0; i &lt; maxSteps; i++) {\n        vec3 pos = rayPoint(ray, t);\n        \n        // Evaluate scene SDF (define this based on your scene)\n        float d = sceneSDF(pos);\n        \n        // Close enough to surface?\n        if (abs(d) &lt; 0.001) {\n            info.hit = true;\n            info.t = t;\n            info.position = pos;\n            return info;\n        }\n        \n        // March forward\n        t += d;\n        \n        // Too far?\n        if (t &gt; maxDist) {\n            break;\n        }\n    }\n    \n    return info;\n}\n\n\nScene SDF\nFor a scene with multiple objects, we take the minimum distance to any object:\nfloat sceneSDF(vec3 p) {\n    // Sphere at (0, 0, -3)\n    float sphere = sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n    \n    // Ground plane\n    float ground = sdPlaneY(p, -1.0);\n    \n    // Return minimum distance\n    return min(sphere, ground);\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#normal-estimation-via-gradient",
    "href": "day4.html#normal-estimation-via-gradient",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.9 Normal Estimation via Gradient",
    "text": "4.9 Normal Estimation via Gradient\n\nThe Gradient as Normal\nFor an implicit surface \\(F(\\mathbf{p}) = 0\\), the gradient \\(\\nabla F\\) is perpendicular to the surface (it’s the normal direction).\nFor an SDF \\(d(\\mathbf{p})\\), the gradient points away from the surface: \\[\\mathbf{n} = \\nabla d = \\left(\\frac{\\partial d}{\\partial x}, \\frac{\\partial d}{\\partial y}, \\frac{\\partial d}{\\partial z}\\right)\\]\n\n\nFinite Difference Approximation\nWe estimate each partial derivative using finite differences: \\[\\frac{\\partial d}{\\partial x} \\approx \\frac{d(x + \\epsilon, y, z) - d(x - \\epsilon, y, z)}{2\\epsilon}\\]\nand similarly for \\(y\\) and \\(z\\).\n\n\nImplementation\nvec3 estimateNormal(vec3 p, float epsilon) {\n    // Sample SDF at nearby points\n    float dx = sceneSDF(p + vec3(epsilon, 0.0, 0.0)) - sceneSDF(p - vec3(epsilon, 0.0, 0.0));\n    float dy = sceneSDF(p + vec3(0.0, epsilon, 0.0)) - sceneSDF(p - vec3(0.0, epsilon, 0.0));\n    float dz = sceneSDF(p + vec3(0.0, 0.0, epsilon)) - sceneSDF(p - vec3(0.0, 0.0, epsilon));\n    \n    return normalize(vec3(dx, dy, dz));\n}\nTypical choice: \\(\\epsilon \\approx 0.001\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#putting-it-all-together-raymarched-scenes",
    "href": "day4.html#putting-it-all-together-raymarched-scenes",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.10 Putting It All Together: Raymarched Scenes",
    "text": "4.10 Putting It All Together: Raymarched Scenes\n\nScene 1: Single Sphere\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    HitInfo hit = raymarch(ray, 100.0, 100);\n    \n    vec3 color;\n    if (hit.hit) {\n        vec3 normal = estimateNormal(hit.position, 0.001);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = vec3(1.0, 0.0, 0.0);\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nScene 2: Two Spheres\nfloat sceneSDF(vec3 p) {\n    float sphere1 = sdSphere(p, vec3(-1.2, 0.0, -3.0), 1.0);\n    float sphere2 = sdSphere(p, vec3(1.2, 0.0, -3.0), 0.8);\n    \n    return min(sphere1, sphere2);\n}\nJust change the scene SDF! The raymarching and lighting code stays the same.\n\n\nScene 3: Sphere and Torus\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(0.0, 1.0, -4.0), 1.0);\n    float torus = sdTorus(p, vec3(0.0, -0.5, -4.0), 1.5, 0.4);\n    \n    return min(sphere, torus);\n}\nDifferent object colors: To color objects differently, we need to track which object was hit. One approach:\n// Return both distance and object ID\nvec2 sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(0.0, 1.0, -4.0), 1.0);\n    float torus = sdTorus(p, vec3(0.0, -0.5, -4.0), 1.5, 0.4);\n    \n    if (sphere &lt; torus) {\n        return vec2(sphere, 1.0);  // ID = 1 for sphere\n    } else {\n        return vec2(torus, 2.0);   // ID = 2 for torus\n    }\n}\n\n// Then in main shader, use the ID to choose color",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#summary",
    "href": "day4.html#summary",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.11 Summary",
    "text": "4.11 Summary\nToday we covered:\n\nCamera and ray setup: Generating rays from pixel coordinates with a simple pinhole camera\nAnalytical intersection: Solving equations directly for spheres and tori\nLighting introduction: Using surface normals and dot product for diffuse shading\nSigned distance functions: A flexible representation of geometry as distance fields\nRaymarching algorithm: Sphere tracing to render SDFs efficiently\nNormal estimation: Computing gradients via finite differences\nScene composition: Combining multiple objects by taking minimum distance\n\nKey insights: - Analytical methods require solving equations (quadratic, quartic, etc.) - SDFs provide a unified framework for any geometry - Raymarching works for arbitrary implicit surfaces - The same lighting technique applies to both approaches - Composition is trivial with SDFs (just take minimum)\nTomorrow we’ll explore advanced raymarching techniques: domain operations, boolean operations, and 3D fractals!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#homework",
    "href": "day4.html#homework",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.12 Homework",
    "text": "4.12 Homework\n\nRequired: Algebraic Variety Rendering\nChoose an interesting polynomial implicit surface and render it using ray intersection.\nSuggestions: - Degree 3: Torus-like surfaces, saddles - Degree 4: Quartic surfaces with interesting topology (Klein bottle projections, etc.)\nImplementation approach:\n\nDefine your implicit function \\(F(x, y, z) = 0\\)\n\nExample - a quartic surface:\nfloat implicitFunction(vec3 p) {\n    // Example: (x^2 + y^2 + z^2)^2 - (x^2 + y^2 - 2z^2)\n    float r2 = dot(p, p);\n    return r2 * r2 - (p.x * p.x + p.y * p.y - 2.0 * p.z * p.z);\n}\n\nImplement a root-finding method (bisection or Newton’s method)\n\nBisection template:\nfloat intersectImplicit(Ray ray) {\n    float tMin = 0.0;\n    float tMax = 10.0;\n    \n    // [Bisection loop similar to torus example]\n    // Find where implicitFunction(rayPoint(ray, t)) = 0\n}\n\nCompute the gradient for normals\n\n\\[\\nabla F = \\left(\\frac{\\partial F}{\\partial x}, \\frac{\\partial F}{\\partial y}, \\frac{\\partial F}{\\partial z}\\right)\\]\nvec3 implicitNormal(vec3 p, float epsilon) {\n    float dx = implicitFunction(p + vec3(epsilon, 0, 0)) - implicitFunction(p - vec3(epsilon, 0, 0));\n    float dy = implicitFunction(p + vec3(0, epsilon, 0)) - implicitFunction(p - vec3(0, epsilon, 0));\n    float dz = implicitFunction(p + vec3(0, 0, epsilon)) - implicitFunction(p - vec3(0, 0, epsilon));\n    return normalize(vec3(dx, dy, dz));\n}\n\nOptimization: Bounding sphere (optional but recommended)\n\nTo avoid checking the entire ray, use a bounding sphere:\n// If point is outside bounding sphere, return sphere's SDF\n// If point is inside, compute the actual implicit function\nfloat boundedImplicit(vec3 p) {\n    float boundingSphere = length(p) - 3.0;  // Sphere of radius 3\n    if (boundingSphere &gt; 0.0) {\n        return boundingSphere;  // Outside, use sphere distance\n    }\n    return implicitFunction(p);  // Inside, compute actual\n}\nExpected output: A rendering of your chosen algebraic surface with proper lighting showing its geometric features.\n\n\nOptional: Advanced Lighting and Transformations\nPick one or more to explore:\n\n1. Specular Lighting (Phong Model)\nAdd specular highlights using the Phong reflection model: \\[\\text{specular} = (\\mathbf{r} \\cdot \\mathbf{v})^n\\]\nwhere: - \\(\\mathbf{r}\\) is the reflected light direction: \\(\\mathbf{r} = 2(\\mathbf{n} \\cdot \\mathbf{l})\\mathbf{n} - \\mathbf{l}\\) - \\(\\mathbf{v}\\) is the view direction (toward camera): \\(\\mathbf{v} = -\\text{ray.direction}\\) - \\(n\\) is the shininess exponent (try 32 or 64)\nvec3 r = reflect(-lightDir, normal);  // GLSL has reflect built-in\nfloat specular = pow(max(0.0, dot(r, viewDir)), 32.0);\ncolor += vec3(1.0) * specular;  // Add white specular highlight\n\n\n2. Rotation Matrices\nTransform objects using rotation matrices.\nRotation around Y-axis by angle θ: \\[R_y(\\theta) = \\begin{pmatrix}\n\\cos\\theta & 0 & \\sin\\theta \\\\\n0 & 1 & 0 \\\\\n-\\sin\\theta & 0 & \\cos\\theta\n\\end{pmatrix}\\]\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        -p.x * s + p.z * c\n    );\n}\n\n// Use in SDF:\nfloat sdRotatedTorus(vec3 p, vec3 center, float angle, float R, float r) {\n    vec3 q = rotateY(p - center, angle);\n    return sdTorus(q, vec3(0.0), R, r);\n}\n\n\n3. Complex Scene\nCreate a scene with multiple transformed objects: - Multiple spheres at different positions - Rotated boxes or tori - A ground plane - Experiment with composition",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#looking-ahead",
    "href": "day4.html#looking-ahead",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.13 Looking Ahead",
    "text": "4.13 Looking Ahead\nTomorrow (Day 5) we’ll explore advanced raymarching techniques: - Domain operations (repetition, symmetry) for creating infinite patterns - Boolean operations (union, intersection, smooth blending) - 3D fractals via iterated folding (Menger sponge) - Creating complex scenes from simple primitives\nYou’ll leave with a toolkit for rendering virtually any geometry you can imagine!\nMake sure you’re comfortable with: - The raymarching algorithm (it’s the foundation for Day 5) - SDF composition (taking min/max for combinations) - Normal estimation via gradients - Basic lighting (diffuse shading)\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day2.html#circle-inversion",
    "href": "day2.html#circle-inversion",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.4 Circle Inversion",
    "text": "2.4 Circle Inversion\n\nMathematical Definition\nCircle inversion is a transformation of the plane with respect to a circle. For a circle of radius \\(R\\) centered at a point \\(\\mathbf{c}\\), inversion maps a point \\(\\mathbf{p} \\neq \\mathbf{c}\\) to: \\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nGeometrically: - Points inside the circle map to points outside (and vice versa) - Points on the circle are fixed - The center is mapped to infinity (and infinity to the center)\n\n\nKey Properties\n\nLines through the center remain lines through the center\nLines not through the center become circles through the center\nCircles through the center become lines (not through the center)\nCircles not through the center remain circles (but transformed)\nAngles are preserved (it’s a conformal map)\n\nThese properties make circle inversion extremely useful for generating fractal patterns.\n\n\nImplementation\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);  // Map to \"infinity\"\n    \n    return center + (radius * radius) * diff / r2;\n}\n\n\nVisualizing Circle Inversion\nLet’s see what happens when we apply inversion to a grid:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);  // Create repeating cells\n    float gridLine = step(0.95, max(grid.x, grid.y));  // Draw grid lines\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou’ll see straight grid lines transform into circular arcs!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#the-apollonian-gasket",
    "href": "day2.html#the-apollonian-gasket",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.6 The Apollonian Gasket",
    "text": "2.6 The Apollonian Gasket\n\nConstruction\nThe Apollonian gasket is created by starting with three mutually tangent circles and repeatedly filling the gaps with new tangent circles. We can generate it through iterated circle inversions.\n\n\nA Simple Configuration\nOne clean setup: three circles of equal radius, mutually tangent at a point.\nLet’s use circles of radius 1 centered at the vertices of an equilateral triangle: \\[\\mathbf{c}_1 = (0, \\frac{2}{\\sqrt{3}}), \\quad \\mathbf{c}_2 = (-1, -\\frac{1}{\\sqrt{3}}), \\quad \\mathbf{c}_3 = (1, -\\frac{1}{\\sqrt{3}})\\]\nThese three circles are mutually tangent at the origin.\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3) {\n    float h = 2.0 / sqrt(3.0);  // ≈ 1.1547\n    c1 = Circle(vec2(0.0, h), 1.0);\n    c2 = Circle(vec2(-1.0, -h/2.0), 1.0);\n    c3 = Circle(vec2(1.0, -h/2.0), 1.0);\n}\n\n\nIterative Inversion Algorithm\nStarting from a point \\(\\mathbf{p}\\), we repeatedly invert through each of the three circles in sequence:\nvec2 apollonianOrbit(vec2 p, Circle c1, Circle c2, Circle c3, int iterations, out int escapeIter) {\n    escapeIter = iterations;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Invert through each circle\n        p = invertCircle(p, c1.center, c1.radius);\n        p = invertCircle(p, c2.center, c2.radius);\n        p = invertCircle(p, c3.center, c3.radius);\n        \n        // Check if escaped (moved very far away)\n        if(length(p) &gt; 100.0) {\n            escapeIter = i;\n            break;\n        }\n    }\n    \n    return p;\n}\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup, scaled to show region around origin];\n    \n    // Setup circles\n    Circle c1, c2, c3;\n    setupApollonianCircles(c1, c2, c3);\n    \n    // Run orbit\n    int escapeIter;\n    vec2 p_final = apollonianOrbit(p, c1, c2, c3, 20, escapeIter);\n    \n    // Color based on escape iteration\n    float t = float(escapeIter) / 20.0;\n    vec3 color = palette(t);\n    \n    // Draw the three circles\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float circleDist = min(d1, min(d2, d3));\n    \n    if(circleDist &lt; 0.05) color = vec3(1.0, 1.0, 1.0);  // Draw circles white\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result should show a beautiful nested pattern of circular regions—the Apollonian gasket emerging from iterated inversions!\n\n\nAlternative Coloring\nInstead of escape time, we can color based on which circle we’re closest to after iteration:\n// After orbit\nfloat d1 = length(p_final - c1.center);\nfloat d2 = length(p_final - c2.center);\nfloat d3 = length(p_final - c3.center);\n\nif(d1 &lt; d2 && d1 &lt; d3) color = vec3(1.0, 0.0, 0.0);      // Red for c1\nelse if(d2 &lt; d3) color = vec3(0.0, 1.0, 0.0);            // Green for c2\nelse color = vec3(0.0, 0.0, 1.0);                        // Blue for c3\nThis creates regions colored by which circle’s “basin of attraction” they belong to.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#complex-numbers-in-glsl-1",
    "href": "day2.html#complex-numbers-in-glsl-1",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.10 Complex Numbers in GLSL",
    "text": "2.10 Complex Numbers in GLSL\n\nRepresentation\nA complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part.\n\n\nComplex Arithmetic\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nThese are the building blocks we need for complex dynamics.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#the-mandelbrot-set-1",
    "href": "day2.html#the-mandelbrot-set-1",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.11 The Mandelbrot Set",
    "text": "2.11 The Mandelbrot Set\n\nDefinition\nThe Mandelbrot set \\(\\mathcal{M}\\) is defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nIn practice, we: 1. Start with \\(z_0 = 0\\) 2. Iterate \\(z_{n+1} = z_n^2 + c\\) for a fixed number of iterations (say, 100) 3. Check if \\(|z_n|\\) has escaped some large radius (typically \\(R = 2\\))\nPoints that escape quickly are definitely not in \\(\\mathcal{M}\\). Points that remain bounded after many iterations are likely in \\(\\mathcal{M}\\).\n\n\nImplementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nColoring Schemes\nThe grayscale rendering shows structure but isn’t very exciting. We can create better colormaps:\nSmooth coloring using escape time:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    // Use a color palette (see below)\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nSimple color palette:\nvec3 palette(float t) {\n    // Create a cyclic color palette\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors. Play with the parameters a, b, c, d to get different color schemes!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#looking-ahead-1",
    "href": "day2.html#looking-ahead-1",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.12 Looking Ahead",
    "text": "2.12 Looking Ahead\nTomorrow we’ll continue with fractals and hyperbolic geometry. We’ll start by extending our folding techniques to create the Sierpinski carpet, then dive into hyperbolic space with multiple models (Poincaré disk, upper half-plane, band model) and create beautiful tilings in non-Euclidean geometry.\nMake sure you’re comfortable with: - Complex number iteration and the Mandelbrot/Julia algorithms - Geometric folding operations (reflection via abs(), scaling) - Using iteration count for coloring - Circle inversion (from today’s homework—this will be crucial tomorrow!)\nThe circle inversion you implement today will be the foundation for tomorrow’s hyperbolic tilings, so take your time understanding how it works geometrically.\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day3.html#euclidean-triangle-tiling",
    "href": "day3.html#euclidean-triangle-tiling",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.2 Euclidean Triangle Tiling",
    "text": "3.2 Euclidean Triangle Tiling\n\nThe Fundamental Domain\nAn equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can: 1. Reflect across its three edges 2. Repeat this process on the resulting triangles 3. Fill the entire plane with copies of the original triangle\nThis is a tiling by reflection: the entire plane is covered by reflected copies of our fundamental domain.\n\n\nSetting Up the Triangle\nLet’s work with an equilateral triangle with vertices at: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nThis triangle has side length \\(\\sqrt{3}\\) and is centered at the origin.\n// Define triangle vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866\nvec2 v2 = vec2(0.866, -0.5);\n\n\nReflection Across a Line\nTo reflect a point \\(p\\) across a line through the origin with unit normal \\(\\mathbf{n}\\), we use: \\[p' = p - 2(\\mathbf{n} \\cdot p)\\mathbf{n}\\]\nFor a line through two points (an edge of our triangle), we: 1. Compute the edge direction 2. Find the perpendicular (normal to the edge) 3. Check which side of the line we’re on 4. Reflect if necessary\nImplementation for one edge:\nvec2 reflectAcrossEdge(vec2 p, vec2 v0, vec2 v1) {\n    // Edge direction\n    vec2 edge = v1 - v0;\n    \n    // Normal to edge (perpendicular, pointing outward)\n    vec2 normal = normalize(vec2(-edge.y, edge.x));\n    \n    // Signed distance to line\n    float dist = dot(p - v0, normal);\n    \n    // Reflect if on the wrong side (dist &lt; 0)\n    if(dist &lt; 0.0) {\n        p = p - 2.0 * dist * normal;\n    }\n    \n    return p;\n}\n\n\nIterative Folding into the Triangle\nWe repeatedly reflect \\(p\\) across the three edges until it lands inside the fundamental domain:\nvec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        vec2 p_old = p;\n        \n        // Reflect across each edge if necessary\n        p = reflectAcrossEdge(p, v0, v1);\n        p = reflectAcrossEdge(p, v1, v2);\n        p = reflectAcrossEdge(p, v2, v0);\n        \n        // Check if we're done (no more reflections)\n        if(length(p - p_old) &lt; 0.0001) break;\n        \n        foldCount++;\n    }\n    \n    return p;\n}\n\n\nVisualization: Euclidean Tiling\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold to fundamental domain\n    int foldCount;\n    vec2 p_folded = foldToTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);  // Use palette function from Day 2\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result: a beautiful triangular tiling of the plane, colored by how many reflections were needed to reach the fundamental domain!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#the-23-triangle-in-the-upper-half-plane",
    "href": "day3.html#the-23-triangle-in-the-upper-half-plane",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.4 The (2,3,∞) Triangle in the Upper Half-Plane",
    "text": "3.4 The (2,3,∞) Triangle in the Upper Half-Plane\n\nTriangle Setup\nFor our first hyperbolic tiling, we’ll use a triangle with particularly nice edges in the upper half-plane: - Bottom edge: Unit semicircle centered at origin (equation: \\(x^2 + y^2 = 1\\), \\(y &gt; 0\\)) - Left edge: Vertical geodesic at \\(x = -1\\) - Right edge: Vertical geodesic at \\(x = 1\\)\nThis creates a hyperbolic triangle with one ideal vertex (at infinity on the \\(y\\)-axis) and two finite vertices.\nstruct Geodesic {\n    int type;  // 0 = vertical line, 1 = semicircle\n    vec2 data;  // For vertical: (x_pos, unused), for semicircle: (center_x, radius)\n};\n\nvoid setupTriangle(out Geodesic g1, out Geodesic g2, out Geodesic g3) {\n    g1.type = 1;  // Semicircle\n    g1.data = vec2(0.0, 1.0);  // Center at origin, radius 1\n    \n    g2.type = 0;  // Vertical line\n    g2.data = vec2(-1.0, 0.0);  // At x = -1\n    \n    g3.type = 0;  // Vertical line\n    g3.data = vec2(1.0, 0.0);  // At x = 1\n}\n\n\nChecking if a Point is in the Triangle\nbool inTriangle(vec2 p) {\n    // Above the semicircle: x² + y² &gt; 1\n    bool aboveSemicircle = dot(p, p) &gt; 1.0;\n    \n    // Between vertical lines: -1 &lt; x &lt; 1\n    bool betweenLines = (p.x &gt; -1.0) && (p.x &lt; 1.0);\n    \n    return aboveSemicircle && betweenLines;\n}\n\n\nReflection Across Geodesics\nReflection across a vertical line \\(x = c\\): \\[\\text{reflect}(x + iy) = (2c - x) + iy\\]\nvec2 reflectVertical(vec2 p, float c) {\n    return vec2(2.0 * c - p.x, p.y);\n}\nReflection across a semicircle (circle inversion from yesterday!): For a circle of radius \\(R\\) centered at \\((c_x, 0)\\):\nvec2 reflectCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    return center + (radius * radius) * diff / r2;\n}\n\n\nFolding into the Fundamental Domain\nvec2 foldToHyperbolicTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        bool folded = false;\n        \n        // Reflect across left vertical line if needed\n        if(p.x &lt; -1.0) {\n            p = reflectVertical(p, -1.0);\n            folded = true;\n        }\n        \n        // Reflect across right vertical line if needed\n        if(p.x &gt; 1.0) {\n            p = reflectVertical(p, 1.0);\n            folded = true;\n        }\n        \n        // Reflect across semicircle if needed\n        if(dot(p, p) &lt; 1.0) {\n            p = reflectCircle(p, vec2(0.0, 0.0), 1.0);\n            folded = true;\n        }\n        \n        if(folded) foldCount++;\n        else break;  // In fundamental domain\n    }\n    \n    return p;\n}\n\n\nVisualization: Hyperbolic Tiling\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to upper half-plane\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift up so y &gt; 0\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Fold to fundamental domain\n    int foldCount;\n    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);\n    \n    // Highlight fundamental domain\n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result: a beautiful hyperbolic tiling! Notice how the triangles appear to shrink near the real axis—they’re all the same hyperbolic size, but Euclidean distances compress.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "href": "outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "title": "Outline",
    "section": "Day 2: Complex Dynamics and Iterated Inversions",
    "text": "Day 2: Complex Dynamics and Iterated Inversions\n\nLearning Objectives\n\nImplement complex number arithmetic in GLSL\nRender the Mandelbrot set through escape-time iteration\nMaster circle inversion as a conformal transformation\nUse structs to organize geometric data\nGenerate the Apollonian gasket through iterated inversions\n\n\n\nIn-Class Content\n\nComplex arithmetic: Addition, multiplication, division, conjugation\nMandelbrot set:\n\nIteration \\(z_{n+1} = z_n^2 + c\\) with \\(z_0 = 0\\)\nEscape-time algorithm\nSmooth coloring and palettes\n\nCircle inversion:\n\nMathematical definition and properties\nConformal mapping (preserves angles, maps circles to circles/lines)\nImplementation and visualization\n\nStructs in GLSL: Organizing circle data (center, radius)\nApollonian gasket:\n\nThree mutually tangent circles\nIterated inversions generate fractal structure\nColoring by escape time or basin of attraction\n\n\n\n\nHomework\nRequired: Julia sets - Implement for fixed \\(c\\), varying initial \\(z_0\\) - Explore parameter space (try different values of \\(c\\)) - Optional: animate \\(c\\) to watch morphing\nOptional: Schottky groups - Four or more disjoint circles - Alternating inversion patterns - Create intricate nested structures",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "href": "outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "title": "Outline",
    "section": "Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "text": "Day 3: Geometric Tilings in Euclidean and Hyperbolic Space\n\nLearning Objectives\n\nCreate Euclidean triangle tilings through reflection\nUnderstand hyperbolic geometry models (upper half-plane, Poincaré disk)\nImplement hyperbolic triangle tilings using circle inversion\nConvert between different hyperbolic models\n\n\n\nIn-Class Content\n\nEuclidean triangle tiling:\n\nFundamental domain (equilateral triangle)\nReflection across edges\nIterative folding algorithm\nColoring by reflection count\n\nHyperbolic geometry introduction:\n\nUpper half-plane model: \\(\\mathbb{H}^2 = \\{z : \\text{Im}(z) &gt; 0\\}\\)\nHyperbolic metric: \\(ds^2 = \\frac{dx^2 + dy^2}{y^2}\\)\nGeodesics: vertical lines and semicircles\nHyperbolic distance formula\n\nPoincaré disk model:\n\nUnit disk representation\nCayley transform between models\n\nHyperbolic triangle tiling:\n\n\\((2,3,\\infty)\\) triangle with nice edges\nReflection across vertical geodesics (simple)\nReflection across circular geodesics (circle inversion!)\nFolding algorithm\nVisualization in both models\n\n\n\n\nHomework\nRequired #1: Draw geodesics and hyperbolic disks - Visualize geodesics in upper half-plane - Draw hyperbolic disks (constant hyperbolic distance) - Observe metric distortion\nRequired #2: Draw triangle edges and vertices - Compute distance to geodesics - Render triangle boundaries explicitly - Mark vertices\nRequired #3: Model conversion and Möbius transformations - Convert tiling to Poincaré disk - Apply Möbius transformations (isometries) - Observe how tiling transforms\nOptional: - Different triangle groups (e.g., \\((2,3,7)\\) for Escher-like tilings) - Klein model (geodesics become straight lines) - Decorated tiles (Escher-style patterns)",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#resources-and-further-exploration",
    "href": "outline.html#resources-and-further-exploration",
    "title": "Outline",
    "section": "Resources and Further Exploration",
    "text": "Resources and Further Exploration\n\nShadertoy\n\nMain site: https://www.shadertoy.com\nCommunity examples and tutorials\nGLSL documentation\n\n\n\nReferences\n\nComplex dynamics and fractals\nHyperbolic geometry and tilings\nSigned distance functions (Inigo Quilez: https://iquilezles.org/articles/distfunctions/)\nGPU computing for scientific visualization\n\n\n\nAdvanced Topics\n\nPath tracing and global illumination\nNon-Euclidean ray tracing\nReal-time denoising\nMore complex PDEs and simulations",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#assessment-philosophy",
    "href": "outline.html#assessment-philosophy",
    "title": "Outline",
    "section": "Assessment Philosophy",
    "text": "Assessment Philosophy\nThis is a workshop-style course focused on skill development. Success means: - Completing required homework to keep pace - Experimenting with optional problems based on interest - Developing intuition for when shader programming is appropriate - Leaving with working code templates for future projects\nPhilosophy: Getting something working and understanding it is more valuable than perfect, polished results. The goal is to build practical skills and mathematical intuition, not to create production-quality graphics.",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#schedule-summary",
    "href": "outline.html#schedule-summary",
    "title": "Outline",
    "section": "Schedule Summary",
    "text": "Schedule Summary\n\n\n\n\n\n\n\n\nDay\nTopic\nKey Concepts\n\n\n\n\n1\nShader Basics\nCoordinates, distance fields, implicit curves\n\n\n2\nComplex Dynamics\nMandelbrot, circle inversion, Apollonian gasket\n\n\n3\nGeometric Tilings\nEuclidean and hyperbolic tilings, models\n\n\n4\n3D Rendering\nRaymarching, SDFs, lighting\n\n\n5\nAdvanced (flexible)\nDomain ops + fractals OR buffers + PDEs\n\n\n\nEach day: 1 hour lecture + ~1.5 hours homework Total: 5 lectures, 10-12 programming assignments (5 required, 5-7 optional)",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "folding-fractals.html",
    "href": "folding-fractals.html",
    "title": "Appendix C — Folding Fractals",
    "section": "",
    "text": "C.1 Overview\nThis appendix explores a fascinating technique for generating fractals: iterated folding with scaling. While reflection-based tiling (Days 2-3) fills space with copies of a fundamental domain, folding fractals add scaling at each iteration, creating self-similar structures that exhibit fractal geometry.\nWe’ll explore three classic examples: 1. Sierpinski Triangle (2D, triangle-based) 2. Sierpinski Carpet (2D, square-based) 3. Menger Sponge (3D, cube-based)\nThese connect naturally to course content: the folding operations use techniques from Day 2-3 (reflection, abs()), and the Menger sponge extends to 3D using Day 4’s coordinate systems.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#fundamental-concept-folding-scaling-fractals",
    "href": "folding-fractals.html#fundamental-concept-folding-scaling-fractals",
    "title": "Appendix C — Folding Fractals",
    "section": "C.2 Fundamental Concept: Folding + Scaling = Fractals",
    "text": "C.2 Fundamental Concept: Folding + Scaling = Fractals\n\nThe General Pattern\nAll folding fractals follow this pattern:\n\nFold: Use geometric operations (reflection, abs()) to bring the point into a fundamental region\nScale: Zoom in by some factor (typically 2 or 3)\nRepeat: Iterate this process\nClassify: After \\(n\\) iterations, check if the point is in a “removed” region or “kept” region\n\nAfter \\(n\\) iterations: - We’ve zoomed in by factor \\(s^n\\) (where \\(s\\) is the scale factor) - The fractal structure emerges from the removal pattern - The result is self-similar: zooming in reveals the same pattern\n\n\nConnection to Tilings\nRecall from Day 3: - Tiling: Fold → repeat (fills space with copies) - Fractal: Fold → scale → repeat (creates self-similar structure with removed regions)\nThe key difference is the scaling step!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#sierpinski-triangle",
    "href": "folding-fractals.html#sierpinski-triangle",
    "title": "Appendix C — Folding Fractals",
    "section": "C.3 Sierpinski Triangle",
    "text": "C.3 Sierpinski Triangle\n\nMathematical Description\nThe Sierpinski triangle is constructed by: 1. Start with an equilateral triangle 2. Remove the middle triangle (formed by connecting edge midpoints) 3. Recursively repeat on each remaining sub-triangle\nEquivalently: iteratively fold into the triangle and scale by 2.\n\n\nMathematical Foundation: Reflection Across a Line\nBefore implementing the fractal, we need the correct reflection formula.\nA line in the plane can be written as \\(ax + by = c\\), with normal vector \\(\\mathbf{n} = (a, b)\\).\nReflection formula: For a point \\(\\mathbf{p} = (x, y)\\), the reflection \\(\\mathbf{p}'\\) across the line is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere: - \\(d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\) is the signed distance to the line - \\(\\hat{\\mathbf{n}} = \\frac{(a,b)}{\\sqrt{a^2 + b^2}}\\) is the unit normal\nCombining these: \\[\\mathbf{p}' = \\mathbf{p} - \\frac{2(ax + by - c)}{a^2 + b^2}(a, b)\\]\n\n\nLine Struct\nLet’s organize line data properly:\nstruct Line {\n    float a, b, c;  // Line equation: ax + by = c\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    // Signed distance from point to line (unnormalized)\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    \n    // Normal vector squared length\n    float normSq = line.a * line.a + line.b * line.b;\n    \n    // Reflection formula\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\n\nSetting Up the Triangle\nFor an equilateral triangle with vertices: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nWe need the three edge lines:\nEdge from \\(v_0\\) to \\(v_1\\): Direction vector: \\(v_1 - v_0 = (-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2})\\) Normal (perpendicular): \\((\\frac{3}{2}, -\\frac{\\sqrt{3}}{2})\\) or simplified: \\((3, -\\sqrt{3})\\) Line equation: \\(3x - \\sqrt{3}y = c\\), passing through \\(v_0 = (0,1)\\): \\(c = -\\sqrt{3}\\)\nEdge from \\(v_1\\) to \\(v_2\\): This is horizontal: \\(y = -\\frac{1}{2}\\) Line equation: \\(0x + 1y = -\\frac{1}{2}\\) or \\((0, 1, -0.5)\\)\nEdge from \\(v_2\\) to \\(v_0\\): By symmetry: \\(-3x - \\sqrt{3}y = -\\sqrt{3}\\)\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    \n    // Edge v0 to v1\n    e1.a = 3.0;\n    e1.b = -sqrt3;\n    e1.c = -sqrt3;\n    \n    // Edge v1 to v2 (horizontal)\n    e2.a = 0.0;\n    e2.b = 1.0;\n    e2.c = -0.5;\n    \n    // Edge v2 to v0\n    e3.a = -3.0;\n    e3.b = -sqrt3;\n    e3.c = -sqrt3;\n}\n\n\nThe Folding Algorithm\nNow we can properly fold into the triangle:\n\n\nThe Folding Algorithm\nNow we can properly fold into the triangle:\nvec2 foldIntoTriangle(vec2 p, Line e1, Line e2, Line e3, int maxIter) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        vec2 p_old = p;\n        \n        // Reflect across each edge if we're on the wrong side\n        // Check sign of distance: if negative, we're on wrong side\n        float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n        if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n        \n        float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n        if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n        \n        float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n        if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        \n        // Converged? (no more reflections)\n        if(length(p - p_old) &lt; 0.0001) break;\n    }\n    \n    return p;\n}\n\n\nAdding the Scaling Step\nFor the Sierpinski fractal, we fold and then scale:\nvec2 sierpinskiTriangle(vec2 p, int iterations, out int depth) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    depth = 0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into fundamental triangle\n        p = foldIntoTriangle(p, e1, e2, e3, 10);\n        \n        // Scale by 2 toward center\n        vec2 center = vec2(0.0, 0.0);  // Approximate center\n        p = (p - center) * 2.0 + center;\n        \n        depth++;\n        \n        // Optional: early exit if escaped\n        if(length(p) &gt; 100.0) break;\n    }\n    \n    return p;\n}\n\n\nDetermining if Point is in Fractal\nAfter folding, we need to check if we’re in the “removed” middle triangle. Using barycentric coordinates:\n\n### Determining if Point is in Fractal\n\nAfter folding, we need to check if we're in the \"removed\" middle triangle. The middle triangle has vertices at the midpoints of the original triangle's edges.\n\nFor an equilateral triangle with vertices $v_0, v_1, v_2$, the midpoints are:\n$$m_{01} = \\frac{v_0 + v_1}{2}, \\quad m_{12} = \\frac{v_1 + v_2}{2}, \\quad m_{20} = \\frac{v_2 + v_0}{2}$$\n\nWe can check if point $p$ is inside this middle triangle using barycentric coordinates:\n\n```glsl\nbool inMiddleTriangle(vec2 p) {\n    // Vertices of original triangle\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    // Midpoints (vertices of removed triangle)\n    vec2 m01 = (v0 + v1) * 0.5;\n    vec2 m12 = (v1 + v2) * 0.5;\n    vec2 m20 = (v2 + v0) * 0.5;\n    \n    // Check if p is inside triangle m01-m12-m20\n    // Using sign of cross products\n    vec2 e0 = m12 - m01;\n    vec2 e1 = m20 - m12;\n    vec2 e2 = m01 - m20;\n    \n    vec2 p0 = p - m01;\n    vec2 p1 = p - m12;\n    vec2 p2 = p - m20;\n    \n    float s0 = e0.x * p0.y - e0.y * p0.x;\n    float s1 = e1.x * p1.y - e1.y * p1.x;\n    float s2 = e2.x * p2.y - e2.y * p2.x;\n    \n    // All same sign means inside\n    return (s0 &gt;= 0.0 && s1 &gt;= 0.0 && s2 &gt;= 0.0) || \n           (s0 &lt;= 0.0 && s1 &lt;= 0.0 && s2 &lt;= 0.0);\n}\n\n\nComplete Implementation\nstruct Line {\n    float a, b, c;\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    float normSq = line.a * line.a + line.b * line.b;\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    e1 = Line(3.0, -sqrt3, -sqrt3);\n    e2 = Line(0.0, 1.0, -0.5);\n    e3 = Line(-3.0, -sqrt3, -sqrt3);\n}\n\nvec2 sierpinskiTriangle(vec2 p, int iterations, out bool inFractal) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into triangle\n        for(int j = 0; j &lt; 10; j++) {\n            float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n            if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n            \n            float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n            if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n            \n            float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n            if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        }\n        \n        // Check if in removed region\n        if(inMiddleTriangle(p)) {\n            inFractal = false;\n        }\n        \n        // Scale by 2\n        p = p * 2.0;\n    }\n    \n    return p;\n}\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 3.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal;\n    vec2 p_final = sierpinskiTriangle(uv, 6, inFractal);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color by final position\n        float t = length(p_final) * 0.1;\n        color = palette(t);\n    } else {\n        // Removed region\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Sierpinski triangle should now render with mathematically correct reflections!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#sierpinski-carpet",
    "href": "folding-fractals.html#sierpinski-carpet",
    "title": "Appendix C — Folding Fractals",
    "section": "C.4 Sierpinski Carpet",
    "text": "C.4 Sierpinski Carpet\n\nMathematical Description\nThe Sierpinski carpet is the square analog: 1. Start with a square 2. Divide into a 3×3 grid of sub-squares 3. Remove the central sub-square 4. Recursively repeat on each remaining sub-square\nNote: Unlike the triangle, the carpet uses axis-aligned divisions, so the implementation is both simpler AND mathematically exact—no approximations needed!\n\n\nThe Algorithm\nMuch simpler than the triangle because we can use axis-aligned operations!\nAt each iteration: 1. Fold using abs() to create 4-fold symmetry (all quadrants map to first quadrant) 2. Scale by factor of 3 3. Check if we’re in the removed middle region\n\n\nImplementation\nbool sierpinskiCarpet(vec2 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant (creates 4-fold symmetry)\n        p = abs(p);\n        \n        // Scale by 3 and recenter\n        p = p * 3.0 - vec2(1.0);\n        \n        // After this transformation, the \"removed\" region is\n        // approximately where both |p.x| &lt; 1 and |p.y| &lt; 1\n    }\n    \n    // Check if in removed region\n    // After n iterations, if we're in the central square, we're removed\n    return (abs(p.x) &lt; 1.0 && abs(p.y) &lt; 1.0);\n}\n\n\nMore Robust Version\nvec2 carpetFold(vec2 p, int iterations, out bool inFractal) {\n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Check if in middle third in both dimensions\n        // In normalized [0,1] space, middle third is [1/3, 2/3]\n        vec2 normalizedP = fract(p);  // Get fractional part\n        \n        bool inMiddleX = (normalizedP.x &gt; 0.33 && normalizedP.x &lt; 0.67);\n        bool inMiddleY = (normalizedP.y &gt; 0.33 && normalizedP.y &lt; 0.67);\n        \n        if(inMiddleX && inMiddleY) {\n            inFractal = false;\n        }\n        \n        // Scale by 3\n        p = p * 3.0;\n    }\n    \n    return p;\n}\n\n\nClean Implementation\nA cleaner approach using the subdivision pattern:\nbool inSierpinskiCarpet(vec2 p, int iterations) {\n    // Normalize to [0, 1]\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Which cell of 3×3 grid are we in?\n        vec2 cell = floor(p * 3.0);\n        \n        // Middle cell (1,1) is removed\n        if(cell.x == 1.0 && cell.y == 1.0) {\n            return false;  // In removed region\n        }\n        \n        // Zoom into current cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;  // In fractal\n}\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal = inSierpinskiCarpet(uv, 6);\n    \n    vec3 color = inFractal ? vec3(1.0, 1.0, 0.8) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#menger-sponge-3d-extension",
    "href": "folding-fractals.html#menger-sponge-3d-extension",
    "title": "Appendix C — Folding Fractals",
    "section": "C.5 Menger Sponge (3D Extension)",
    "text": "C.5 Menger Sponge (3D Extension)\n\nMathematical Description\nThe Menger sponge is the 3D analog of the Sierpinski carpet: 1. Start with a cube 2. Divide into a 3×3×3 grid of sub-cubes (27 total) 3. Remove the central sub-cube and the 6 face-centered sub-cubes (7 removed, 20 remain) 4. Recursively repeat on each remaining sub-cube\nNote: Like the carpet, the sponge uses axis-aligned divisions, giving us an exact, mathematically precise implementation.\n\n\nThe Algorithm\nSame pattern as the carpet, but in 3D!\n\nFold using abs(p) to create octahedral symmetry\nScale by factor of 3\nCheck if we’re in a removed region (middle cross pattern)\n\n\n\nImplementation\nbool inMengerSponge(vec3 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        p = abs(p);\n        \n        // Which cell of 3×3×3 grid?\n        vec3 cell = floor(p * 3.0);\n        \n        // Removed regions: center cube and face centers\n        // Center: (1,1,1)\n        // Face centers: (1,1,0), (1,1,2), (1,0,1), (1,2,1), (0,1,1), (2,1,1)\n        // Pattern: at least 2 coordinates equal to 1\n        \n        float ones = 0.0;\n        if(cell.x == 1.0) ones += 1.0;\n        if(cell.y == 1.0) ones += 1.0;\n        if(cell.z == 1.0) ones += 1.0;\n        \n        if(ones &gt;= 2.0) {\n            return false;  // Removed region\n        }\n        \n        // Zoom into cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;\n}\n\n\nAlternative: Using SDF Approach\nWe can also implement the Menger sponge as a signed distance function for use with Day 4’s raymarching:\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdMengerSponge(vec3 p, int iterations) {\n    float d = sdBox(p, vec3(1.0));  // Start with unit cube\n    \n    float scale = 1.0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        vec3 a = mod(p * scale, 2.0) - 1.0;\n        scale *= 3.0;\n        \n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        \n        // Distance to cross (removed region)\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / scale;\n        \n        d = max(d, c);\n    }\n    \n    return d;\n}\n\n\nRendering with Raymarching\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray (using Day 4 techniques)\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Raymarch\n    float t = 0.0;\n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = ray.origin + t * ray.direction;\n        float d = sdMengerSponge(pos, 4);\n        \n        if(abs(d) &lt; 0.001) {\n            // Hit!\n            vec3 normal = estimateNormal(pos);  // Day 4 technique\n            \n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            float diffuse = max(0.0, dot(normal, lightDir));\n            \n            vec3 color = vec3(1.0, 0.8, 0.6) * diffuse + vec3(0.1);\n            fragColor = vec4(color, 1.0);\n            return;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) break;\n    }\n    \n    // Miss\n    fragColor = vec4(0.1, 0.1, 0.2, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#general-principles-of-folding-fractals",
    "href": "folding-fractals.html#general-principles-of-folding-fractals",
    "title": "Appendix C — Folding Fractals",
    "section": "C.6 General Principles of Folding Fractals",
    "text": "C.6 General Principles of Folding Fractals\n\nKey Ingredients\n\nSymmetry operations:\n\nabs() for axis-aligned symmetry\nReflections for arbitrary symmetry\n\nScaling factor:\n\nFactor of 2: Sierpinski triangle\nFactor of 3: Sierpinski carpet, Menger sponge\nGeneral factor \\(s\\): determines fractal dimension\n\nRemoval pattern:\n\nWhich regions get removed at each level\nDefines the fractal’s structure\n\nIteration:\n\nMore iterations = more detail\nComputational cost grows linearly\nVisual complexity grows exponentially\n\n\n\n\nFractal Dimension\nThe fractal dimension \\(D\\) can be computed from the scaling factor \\(s\\) and the number of remaining pieces \\(N\\):\n\\[D = \\frac{\\log N}{\\log s}\\]\nExamples: - Sierpinski triangle: \\(N = 3\\) pieces, scale factor \\(s = 2\\) \\[D = \\frac{\\log 3}{\\log 2} \\approx 1.585\\]\n\nSierpinski carpet: \\(N = 8\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 8}{\\log 3} \\approx 1.893\\]\nMenger sponge: \\(N = 20\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 20}{\\log 3} \\approx 2.727\\]\n\nThe fractal dimension is between the topological dimension and the embedding dimension, reflecting the fractal’s “in-between” nature!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#coloring-strategies",
    "href": "folding-fractals.html#coloring-strategies",
    "title": "Appendix C — Folding Fractals",
    "section": "C.7 Coloring Strategies",
    "text": "C.7 Coloring Strategies\n\nBy Iteration Depth\nTrack which iteration first identifies a point as removed:\nint firstRemovedIter = -1;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    // [Folding and scaling]\n    \n    if([in removed region] && firstRemovedIter &lt; 0) {\n        firstRemovedIter = i;\n    }\n}\n\nfloat t = float(firstRemovedIter) / float(iterations);\nvec3 color = palette(t);\n\n\nBy Distance After Folding\nvec2 p_final = [after all folding];\nfloat d = length(p_final);\nvec3 color = vec3(d * 0.5);  // Grayscale by distance\n\n\nBy Cell Position\nFor grid-based fractals (carpet, sponge), color by which sub-cell the point lands in:\nvec3 cell = floor(p * 3.0);\nvec3 color = cell / 3.0;  // RGB from cell coordinates\n\n\nHybrid: Distance Field + Fractal\nFor 3D fractals, combine distance estimation with fractal membership:\nfloat d = sdMengerSponge(p, iterations);\nvec3 color;\n\nif(d &lt; 0.0) {\n    // Inside sponge\n    color = vec3(1.0, 0.8, 0.6);\n} else {\n    // Outside, but show distance\n    color = vec3(0.1) + vec3(0.2) / (1.0 + d);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#variations-and-experiments",
    "href": "folding-fractals.html#variations-and-experiments",
    "title": "Appendix C — Folding Fractals",
    "section": "C.8 Variations and Experiments",
    "text": "C.8 Variations and Experiments\n\nDifferent Folding Operations\nTry different symmetry groups: - Hexagonal symmetry (6-fold) - Octahedral symmetry (for 3D) - Custom reflection patterns\n\n\nDifferent Scale Factors\n\nScale by 4: sparser fractal\nScale by 1.5: denser fractal\nNon-integer scales: unusual structures\n\n\n\nAnimated Parameters\nfloat scale = 2.0 + 0.5 * sin(iTime);\np = p * scale;\nWatch the fractal morph as the scale factor changes!\n\n\nColor by Orbit\nTrack the “orbit” of the point through the folding process:\nfloat orbit = 0.0;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    orbit += length(p);  // Accumulate total distance traveled\n    // [Folding operations]\n}\n\nvec3 color = palette(orbit / 10.0);\n\n\n3D Variations\n\nCross-Menger: Different removal pattern (only center)\nJerusalem Cube: Variation with different symmetry\nHybrid fractals: Combine different removal patterns at different scales",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#connection-to-course-topics",
    "href": "folding-fractals.html#connection-to-course-topics",
    "title": "Appendix C — Folding Fractals",
    "section": "C.9 Connection to Course Topics",
    "text": "C.9 Connection to Course Topics\n\nDay 2: Iteration Creates Fractals\nBoth folding fractals and the Mandelbrot set/Apollonian gasket share the principle: simple operations iterated create complex structure.\n\nMandelbrot: \\(z \\to z^2 + c\\) (complex arithmetic iteration)\nApollonian: Repeated circle inversions (geometric iteration)\nSierpinski: Fold + scale (geometric iteration with scaling)\n\n\n\nDay 3: Folding Without Scaling\nEuclidean and hyperbolic tilings use folding without scaling: - Reflection brings points into fundamental domain - No scaling → fills space with copies - With scaling → creates fractal structure\n\n\nDay 4: 3D Rendering\nThe Menger sponge naturally extends to 3D: - Can be rendered as SDF (raymarching) - Can be rendered as boolean test (simple ray casting) - Demonstrates 3D coordinate folding",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#exercises",
    "href": "folding-fractals.html#exercises",
    "title": "Appendix C — Folding Fractals",
    "section": "C.10 Exercises",
    "text": "C.10 Exercises\n\nExercise 1: Hexagonal Sierpinski\nCreate a Sierpinski gasket based on a hexagon instead of a triangle: - Use 6-fold symmetry - Scale by factor of 3 - Remove appropriate regions\n\n\nExercise 2: Animate the Scale Factor\nModify the Sierpinski carpet to have a time-varying scale factor:\nfloat scale = 3.0 + sin(iTime);\nWatch how the fractal structure changes!\n\n\nExercise 3: 3D Cross\nImplement a 3D fractal using only cross-shaped removal (remove only the center cube, not the face centers). Compare to the standard Menger sponge.\n\n\nExercise 4: Hybrid Fractal\nCombine two different fractals: - First 3 iterations: Sierpinski triangle folding - Next 3 iterations: Sierpinski carpet folding - Observe the unusual resulting structure\n\n\nExercise 5: Distance-Colored Sponge\nRender the Menger sponge with colors based on distance from the surface: - Use sdMengerSponge as a distance field - Color by distance for points outside - Different color for points inside",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#further-reading",
    "href": "folding-fractals.html#further-reading",
    "title": "Appendix C — Folding Fractals",
    "section": "C.11 Further Reading",
    "text": "C.11 Further Reading\n\nMathematical Theory\n\nHausdorff dimension and box-counting dimension\nIterated function systems (IFS)\nSelf-similar sets and scaling symmetries\n\n\n\nComputational Techniques\n\nEscape-time algorithms\nDistance estimation for fractals\nEfficient rendering of fractal geometry\n\n\n\nApplications\n\nProcedural generation in games/graphics\nAntenna design (fractal antennas)\nModeling natural phenomena (coastlines, plants)\nCompression algorithms",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#summary",
    "href": "folding-fractals.html#summary",
    "title": "Appendix C — Folding Fractals",
    "section": "C.12 Summary",
    "text": "C.12 Summary\nFolding fractals demonstrate: 1. Iteration + scaling creates self-similar structure 2. Simple operations produce complex results 3. GPU parallelism enables real-time fractal rendering 4. Fractals connect to many course topics (iteration, symmetry, 3D)\nThe techniques here—folding, scaling, iteration—are fundamental to both mathematical fractals and computer graphics. These methods extend naturally from 2D to 3D, and from static to animated, making them powerful tools for mathematical visualization.\nKey takeaway: Fractals aren’t just beautiful—they’re computationally accessible. A few dozen lines of shader code can generate infinite complexity!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#complete-example-animated-sierpinski-carpet",
    "href": "folding-fractals.html#complete-example-animated-sierpinski-carpet",
    "title": "Appendix C — Folding Fractals",
    "section": "C.13 Complete Example: Animated Sierpinski Carpet",
    "text": "C.13 Complete Example: Animated Sierpinski Carpet\nvec3 palette(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nbool inCarpet(vec2 p, int iterations) {\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        vec2 cell = floor(p * 3.0);\n        if(cell.x == 1.0 && cell.y == 1.0) return false;\n        p = fract(p * 3.0);\n    }\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom animation\n    float zoom = exp(sin(iTime * 0.3) * 2.0);\n    uv *= zoom;\n    \n    // Rotation animation\n    float angle = iTime * 0.2;\n    float c = cos(angle), s = sin(angle);\n    uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n    \n    int iterations = 6;\n    bool inFractal = inCarpet(uv, iterations);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color based on distance from center\n        float d = length(uv);\n        color = palette(d * 0.5 + iTime * 0.1);\n    } else {\n        color = vec3(0.05, 0.05, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis creates a beautiful, animated Sierpinski carpet that zooms and rotates, with colors flowing through the fractal structure!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  }
]