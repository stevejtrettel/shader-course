[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPU-Accelerated Mathematical Illustration",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\n\n  \n  \n  \n\n\nWe’ll progress from 2D foundations (curves, tilings, fractals) to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to work hard and experiment with code through daily homework exercises. Here are some examples of things we will make:",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "outline.html",
    "href": "outline.html",
    "title": "Outline",
    "section": "",
    "text": "Course Overview\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nFormat: Five days, each with one hour of lecture and approximately 1.5 hours of homework\nPrerequisites: Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required\nAudience: Graduate students, postdocs, and faculty in mathematics",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-1-introduction-to-shader-programming",
    "href": "outline.html#day-1-introduction-to-shader-programming",
    "title": "Outline",
    "section": "Day 1: Introduction to Shader Programming",
    "text": "Day 1: Introduction to Shader Programming\n\nLearning Objectives\n\nUnderstand the mathematical model of shader programming (function from pixels to colors)\nLearn basic GLSL syntax and conventions\nMaster coordinate system setup and distance calculations\nCreate simple geometric shapes and implicit curves\n\n\n\nIn-Class Content\n\nMathematical framing: Shaders as parallel functions computing colors for all pixels simultaneously\nGLSL basics: Syntax, vector types, built-in functions\nCoordinate systems: Centering, normalizing, aspect ratio correction\nConditional coloring: Half-planes and regions defined by inequalities\nDistance fields: Circles, filled and outlined\nRepetition: Using mod() for grids and patterns\nImplicit curves: Rendering curves defined by \\(F(x,y) = 0\\)\n\n\n\nHomework\nRequired: Parabola graphing calculator - Draw coordinate axes - Plot \\(y = ax^2 + bx + c\\) with customizable coefficients - Make it robust for various parameter values\nOptional #1: Animated curve family (vary parameters with time)\nOptional #2: Beautiful tiling pattern using mod()",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "href": "outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "title": "Outline",
    "section": "Day 2: Complex Dynamics and Iterated Inversions",
    "text": "Day 2: Complex Dynamics and Iterated Inversions\n\nLearning Objectives\n\nImplement complex number arithmetic in GLSL\nRender the Mandelbrot set through escape-time iteration\nMaster circle inversion as a conformal transformation\nUse structs to organize geometric data\nGenerate the Apollonian gasket through iterated inversions\n\n\n\nIn-Class Content\n\nComplex arithmetic: Addition, multiplication, division, conjugation\nMandelbrot set:\n\nIteration \\(z_{n+1} = z_n^2 + c\\) with \\(z_0 = 0\\)\nEscape-time algorithm\nSmooth coloring and palettes\n\nCircle inversion:\n\nMathematical definition and properties\nConformal mapping (preserves angles, maps circles to circles/lines)\nImplementation and visualization\n\nStructs in GLSL: Organizing circle data (center, radius)\nApollonian gasket:\n\nThree mutually tangent circles\nIterated inversions generate fractal structure\nColoring by escape time or basin of attraction\n\n\n\n\nHomework\nRequired: Julia sets - Implement for fixed \\(c\\), varying initial \\(z_0\\) - Explore parameter space (try different values of \\(c\\)) - Optional: animate \\(c\\) to watch morphing\nOptional: Schottky groups - Four or more disjoint circles - Alternating inversion patterns - Create intricate nested structures",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "href": "outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "title": "Outline",
    "section": "Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "text": "Day 3: Geometric Tilings in Euclidean and Hyperbolic Space\n\nLearning Objectives\n\nCreate Euclidean triangle tilings through reflection\nUnderstand hyperbolic geometry models (upper half-plane, Poincaré disk)\nImplement hyperbolic triangle tilings using circle inversion\nConvert between different hyperbolic models\n\n\n\nIn-Class Content\n\nEuclidean triangle tiling:\n\nFundamental domain (equilateral triangle)\nReflection across edges\nIterative folding algorithm\nColoring by reflection count\n\nHyperbolic geometry introduction:\n\nUpper half-plane model: \\(\\mathbb{H}^2 = \\{z : \\text{Im}(z) &gt; 0\\}\\)\nHyperbolic metric: \\(ds^2 = \\frac{dx^2 + dy^2}{y^2}\\)\nGeodesics: vertical lines and semicircles\nHyperbolic distance formula\n\nPoincaré disk model:\n\nUnit disk representation\nCayley transform between models\n\nHyperbolic triangle tiling:\n\n\\((2,3,\\infty)\\) triangle with nice edges\nReflection across vertical geodesics (simple)\nReflection across circular geodesics (circle inversion!)\nFolding algorithm\nVisualization in both models\n\n\n\n\nHomework\nRequired #1: Draw geodesics and hyperbolic disks - Visualize geodesics in upper half-plane - Draw hyperbolic disks (constant hyperbolic distance) - Observe metric distortion\nRequired #2: Draw triangle edges and vertices - Compute distance to geodesics - Render triangle boundaries explicitly - Mark vertices\nRequired #3: Model conversion and Möbius transformations - Convert tiling to Poincaré disk - Apply Möbius transformations (isometries) - Observe how tiling transforms\nOptional: - Different triangle groups (e.g., \\((2,3,7)\\) for Escher-like tilings) - Klein model (geodesics become straight lines) - Decorated tiles (Escher-style patterns)",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-4-introduction-to-3d-rendering",
    "href": "outline.html#day-4-introduction-to-3d-rendering",
    "title": "Outline",
    "section": "Day 4: Introduction to 3D Rendering",
    "text": "Day 4: Introduction to 3D Rendering\n\nLearning Objectives\n\nSet up camera and generate rays from pixels\nImplement analytical ray-object intersection\nLearn the raymarching algorithm and signed distance functions\nApply basic lighting (diffuse shading)\n\n\n\nIn-Class Content\n\nCamera and ray setup:\n\nPinhole camera model\nRay generation from pixel coordinates\nField of view control\n\nAnalytical intersections:\n\nRay-sphere: solve quadratic equation\nCompute surface normals analytically\nRay-torus: implicit equation and gradient\nBisection method for root-finding\n\nLighting introduction:\n\nSurface normals\nDiffuse lighting: dot product with light direction\nSeeing 3D structure through shading\n\nMotivation for raymarching:\n\nAnalytical methods don’t scale\nComplex surfaces need flexible approach\n\nSigned Distance Functions (SDFs):\n\nDefinition and properties\nSDFs for primitives: sphere, box, plane, torus\nDistance as bound for safe marching\n\nRaymarching algorithm:\n\nSphere tracing: march by SDF value\nStopping conditions\nScene composition (minimum distance)\n\nNormal estimation:\n\nGradient via finite differences\nEstimating partial derivatives\nSame lighting applied to raymarched objects\n\nScene progression:\n\nSingle sphere\nTwo spheres\nSphere and torus\n\n\n\n\nHomework\nRequired: Algebraic variety rendering - Choose polynomial implicit surface (degree 3 or 4) - Implement root-finding (bisection or Newton’s method) - Compute gradient for normals - Optional: bounding sphere optimization\nOptional: - Specular lighting (Phong model) - Rotation matrices for object transformation - Complex multi-object scenes",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-5-choose-your-adventure",
    "href": "outline.html#day-5-choose-your-adventure",
    "title": "Outline",
    "section": "Day 5: Choose Your Adventure",
    "text": "Day 5: Choose Your Adventure\nThe final day will be determined based on pacing, student interest, and energy levels. Two complete lectures are prepared:\n\nOption A: Advanced Raymarching Techniques\n\nLearning Objectives\n\nMaster domain operations for efficient complex scenes\nUnderstand and apply boolean operations on SDFs\nCreate 3D fractals via iterated folding (Menger sponge)\nBuild sophisticated scenes from simple primitives\n\n\n\nIn-Class Content\n\nDomain operations:\n\nRepetition: mod() for infinite object grids\nSymmetry: abs() for mirror planes\nPolar repetition for radial patterns\nZero computational cost for infinite complexity\n\nBoolean operations on SDFs:\n\nUnion: min(d1, d2)\nIntersection: max(d1, d2)\nSubtraction: max(d1, -d2)\nSmooth minimum: smin() for organic blending\n\nMenger sponge:\n\nBox folding in 3D\nAxis-aligned operations\nIterated subdivision\nConnection to 2D fractals\n\nScene building:\n\nCombining techniques\nArchitectural structures\nInfinite repeated patterns\n\n\n\n\nHomework\nRequired: Creative scene building - Build complex scene using domain ops and booleans - Experiment with combinations - Focus on mathematical or aesthetic interest\nOptional: Sierpinski tetrahedron - Implement via 3D folding (non-axis-aligned) - Connection to Day 2’s triangle folding in higher dimension\n\n\n\n\nOption B: Buffers and Temporal Dynamics\n\nLearning Objectives\n\nUnderstand buffer-based computation in Shadertoy\nImplement differential operators (Laplacian)\nSolve partial differential equations on the GPU\nCreate dynamic, evolving mathematical systems\n\n\n\nIn-Class Content\n\nIntroduction to buffers:\n\nReading from previous frame\nMulti-pass rendering\nSimple example: conditional coloring based on buffer\n\nEdge detection and the Laplacian:\n\nDiscrete Laplacian stencil (5-point or 9-point)\nSampling neighboring pixels\nSpatial derivatives on grids\n\nThe heat equation:\n\nMathematical formulation: \\(u_t = \\alpha\\nabla^2 u\\)\nApplying Laplacian for diffusion\nTime-stepping: u_new = u_old + dt * α * laplacian(u_old)\nInitial conditions (e.g., heat in a fractal region)\nWatching patterns blur and diffuse\n\nBoundary conditions:\n\nZero boundaries (edges set to 0)\nAvoiding wrap-around\n\nTimestep stability:\n\nCFL condition (briefly mentioned)\nProviding stable dt value\n\n\n\n\nHomework\nRequired: Interactive heat equation or reaction-diffusion - Option 1: Heat source at mouse position, watch it diffuse - Option 2: Gray-Scott reaction-diffusion (pattern formation)\nOptional: Wave equation - Requires two buffers (current and previous state) - Implement \\(u_{tt} = c^2\\nabla^2 u\\) - Watch waves propagate and reflect",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#resources-and-further-exploration",
    "href": "outline.html#resources-and-further-exploration",
    "title": "Outline",
    "section": "Resources and Further Exploration",
    "text": "Resources and Further Exploration\n\nShadertoy\n\nMain site: https://www.shadertoy.com\nCommunity examples and tutorials\nGLSL documentation\n\n\n\nReferences\n\nComplex dynamics and fractals\nHyperbolic geometry and tilings\nSigned distance functions (Inigo Quilez: https://iquilezles.org/articles/distfunctions/)\nGPU computing for scientific visualization\n\n\n\nAdvanced Topics\n\nPath tracing and global illumination\nNon-Euclidean ray tracing\nReal-time denoising\nMore complex PDEs and simulations",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#assessment-philosophy",
    "href": "outline.html#assessment-philosophy",
    "title": "Outline",
    "section": "Assessment Philosophy",
    "text": "Assessment Philosophy\nThis is a workshop-style course focused on skill development. Success means: - Completing required homework to keep pace - Experimenting with optional problems based on interest - Developing intuition for when shader programming is appropriate - Leaving with working code templates for future projects\nPhilosophy: Getting something working and understanding it is more valuable than perfect, polished results. The goal is to build practical skills and mathematical intuition, not to create production-quality graphics.",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#schedule-summary",
    "href": "outline.html#schedule-summary",
    "title": "Outline",
    "section": "Schedule Summary",
    "text": "Schedule Summary\n\n\n\n\n\n\n\n\nDay\nTopic\nKey Concepts\n\n\n\n\n1\nShader Basics\nCoordinates, distance fields, implicit curves\n\n\n2\nComplex Dynamics\nMandelbrot, circle inversion, Apollonian gasket\n\n\n3\nGeometric Tilings\nEuclidean and hyperbolic tilings, models\n\n\n4\n3D Rendering\nRaymarching, SDFs, lighting\n\n\n5\nAdvanced (flexible)\nDomain ops + fractals OR buffers + PDEs\n\n\n\nEach day: 1 hour lecture + ~1.5 hours homework Total: 5 lectures, 10-12 programming assignments (5 required, 5-7 optional)",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "lectures/day1.html",
    "href": "lectures/day1.html",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "1.1 Overview\nToday we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.\nBy the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#overview",
    "href": "lectures/day1.html#overview",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "NoteRoadmap for Today\n\n\n\nWe’ll build up shader programming in layers:\n\nCore concept: Shaders as parallel functions (What is a Shader?)\nSetup: Coordinate systems and GLSL syntax (First Shader, Coordinate Systems)\nBasic techniques: Conditional coloring and distance fields (Half-Planes, Distance Fields)\n\nRepetition: Grids via modular arithmetic (Grids and Repetition)\nApplication: Implicit curves (Implicit Curves)\n\nEach section builds on the previous, so if something feels unclear, it’s worth revisiting earlier material before moving forward.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#what-is-a-shader",
    "href": "lectures/day1.html#what-is-a-shader",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.2 What is a Shader?",
    "text": "1.2 What is a Shader?\n\nMathematical Perspective\nA shader is fundamentally a function \\[f: \\mathbb{R}^2 \\times \\mathbb{R} \\times \\cdots \\to [0,1]^4\\] that maps pixel coordinates \\((x,y)\\), time \\(t\\), and potentially other parameters to RGBA color values. For today, we’ll focus on the spatial dependence—thinking of the shader as a function \\(f: \\mathbb{R}^2 \\to [0,1]^4\\) that assigns a color to each point in the plane. The domain \\([0,1]^4\\) represents the red, green, blue, and alpha (transparency) channels, each normalized to the unit interval.\nHere’s the magic: modern GPUs can evaluate this function for all pixels simultaneously. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!\nThis is completely different from how you might write mathematical visualization code in, say, Python or MATLAB. There you’d have nested loops:\nfor x in range(width):\n    for y in range(height):\n        color[x,y] = f(x, y)\nWith shaders, there are no loops. You write the function \\(f\\), and the GPU just does it everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.\nThe computational model is fundamentally different: in traditional CPU programming you have sequential control flow with explicit loops, while in shader programming you express computation as a pure mathematical function that gets evaluated independently at every pixel. The GPU architecture is specifically designed for this kind of massively parallel workload—it has thousands of small processors that can each evaluate your function simultaneously. This is why a relatively modest GPU can outperform even a powerful CPU on graphics tasks by orders of magnitude.\n\n\n\n\n\n\nNoteWhy is this called a “shader”?\n\n\n\nHistorically, these programs were used for shading 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!\n\n\n\n\nWhy Shadertoy?\nShadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.\nShadertoy launched in 2013, created by Pol Jeremias-Vila and Íñigo Quílez (we’ll see more of Íñigo’s work throughout this week—he’s pioneered many shader techniques). Before platforms like Shadertoy, shader programming required managing the entire OpenGL or DirectX pipeline yourself—compiling shaders, linking programs, setting up vertex buffers, managing textures. It was the domain of graphics programmers, not mathematicians.\nThe genius of Shadertoy was recognizing that for many visualizations, you don’t need that complexity. Just give people a function to fill in, handle the boilerplate invisibly, and suddenly shaders become accessible to anyone. It’s democratized GPU programming in much the same way that Python notebooks democratized scientific computing—lower the barrier to entry, and a whole new community emerges.\nThe platform provides several built-in uniforms (read-only global variables that are the same for all pixels):\n\niResolution: screen resolution as a vec3 (width, height, pixel aspect ratio)\niTime: elapsed time in seconds since the shader started\niMouse: mouse position and click state as a vec4\n\nWe’ll use these throughout the week to create animated, interactive mathematical visualizations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#first-shader-solid-colors",
    "href": "lectures/day1.html#first-shader-solid-colors",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.3 First Shader: Solid Colors",
    "text": "1.3 First Shader: Solid Colors\n\nBasic Structure\nEvery Shadertoy shader has the same entry point:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Your code here\n}\nParameters:\n\nfragCoord: the pixel coordinate we’re currently computing, as a vec2 giving the \\((x, y)\\) position\nfragColor: the output color we need to set, as a vec4 giving the \\((r, g, b, a)\\) color\n\nColors are represented in RGBA format with values in \\([0, 1]\\). So vec4(1.0, 0.0, 0.0, 1.0) represents opaque red, while vec4(0.5, 0.5, 0.5, 1.0) is middle gray.\n\n\nExample: Red Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nThis sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on fragCoord, every pixel gets the same value. Not very exciting—but it’s a start!\n\n\nGLSL Syntax Basics\nBefore we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:\n\n\n\n\n\n\nImportantGLSL Syntax Rules\n\n\n\nSemicolons are required. Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.\nFloating point literals: Write 1.0 not 1 for floating point values. GLSL is very picky about types—if you write 1, it’s an integer, and mixing types causes errors. Get in the habit of always writing the .0.\nVector types: GLSL has built-in types vec2, vec3, vec4 for 2D, 3D, and 4D vectors. You can construct them with:\nvec2 v = vec2(1.0, 2.0);\nvec3 w = vec3(1.0, 2.0, 3.0);\nvec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars\nSwizzling: You can access components by name: v.x, v.y or equivalently v.r, v.g (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: v.yx swaps the coordinates, v.xxx repeats the x-component three times. This is incredibly useful!\n\n\n\n\nAnimating with Time\nLet’s make something that changes:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\nHere iTime grows continuously, sin(iTime) oscillates between \\(-1\\) and \\(1\\), and we remap this to \\([0, 1]\\) with the affine transformation \\(t \\mapsto \\frac{1}{2}(1 + t)\\). The screen now pulses between black and red!\nThis pattern—0.5 + 0.5 * sin(...)—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range \\([0,1]\\). You’ll use this so often it becomes second nature.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#coordinate-systems",
    "href": "lectures/day1.html#coordinate-systems",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.4 Coordinate Systems",
    "text": "1.4 Coordinate Systems\n\nRaw Coordinates\nBy default, fragCoord gives pixel coordinates with:\n\nOrigin \\((0, 0)\\) at the bottom-left\n\\(x\\) increases rightward to iResolution.x\n\\(y\\) increases upward to iResolution.y\n\nThis is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!\n\n\nCentered, Normalized Coordinates\nHere’s the standard transformation we’ll use in every shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Center at origin: [-0.5, 0.5]\n    uv = uv - 0.5;\n    \n    // Scale to account for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Now uv is centered and aspect-corrected\n    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)\n    vec2 p = uv * 4.0;  \n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nLet’s understand this transformation rigorously. We’re composing four maps. Let’s write \\(w =\\) iResolution.x and \\(h =\\) iResolution.y for the width and height in pixels.\nStep 1: Normalization \\[T_1: [0, w] \\times [0, h] \\to [0,1]^2, \\quad T_1(x,y) = \\left(\\frac{x}{w}, \\frac{y}{h}\\right)\\]\nThis makes our coordinates resolution-independent—the same shader code works whether your screen is 1920×1080 or 800×600. A point that’s halfway across the screen is \\((0.5, v)\\) regardless of how many pixels wide the screen actually is.\nStep 2: Centering \\[T_2: [0,1]^2 \\to [-\\tfrac{1}{2}, \\tfrac{1}{2}]^2, \\quad T_2(u,v) = (u - \\tfrac{1}{2}, v - \\tfrac{1}{2})\\]\nNow the origin is at the center of the screen, which is much more natural for mathematical work. We can think about positive and negative coordinates, circles centered at the origin, and so on.\nStep 3: Aspect correction \\[T_3(u,v) = \\left(\\frac{w}{h} \\cdot u, v\\right)\\]\nThis is crucial! Without it, circles would appear as ellipses on non-square screens. The aspect ratio \\(w/h\\) stretches the \\(x\\)-coordinate so that one unit in \\(x\\) corresponds to the same screen distance as one unit in \\(y\\). On a typical 16:9 display (\\(w/h \\approx 1.78\\)), this means the \\(x\\)-axis spans a wider range than the \\(y\\)-axis—as it should to maintain equal scaling. A circle of radius \\(r\\) will actually appear circular on screen, not squashed.\nStep 4: Scaling to viewing window \\[T_4(u,v) = s \\cdot (u,v)\\]\nFinally, we scale by whatever factor gives us the mathematical viewing window we want. If we choose \\(s = 4\\), then on a 16:9 screen our coordinates range roughly from \\([-3.56, 3.56]\\) in \\(x\\) and \\([-2, 2]\\) in \\(y\\)—notice the \\(x\\)-range is wider to match the screen aspect ratio.\nThe composition \\(T_4 \\circ T_3 \\circ T_2 \\circ T_1\\) is our complete coordinate transformation, taking us from raw pixel coordinates to a centered, aspect-corrected mathematical coordinate system.\nFrom now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable p for “position.”\n\n\n\n\n\n\nTipThe coordinate transformation boilerplate\n\n\n\nYou’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit and you can modify it when needed.\n\n\n\n\nVisualizing Coordinates\nLet’s verify our coordinate system is working by coloring pixels according to their position:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\nYou should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup! This is a good debugging technique—whenever you’re unsure about your coordinates, visualize them directly as colors.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#conditional-coloring-half-planes",
    "href": "lectures/day1.html#conditional-coloring-half-planes",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.5 Conditional Coloring: Half-Planes",
    "text": "1.5 Conditional Coloring: Half-Planes\n\nThe Concept\nGiven a linear function \\(L(x, y) = ax + by + c\\), we want to color pixels differently depending on whether \\(L(p) &lt; 0\\) or \\(L(p) \\geq 0\\). This divides the plane into two half-planes—the regions where the function is negative versus positive.\nThe line itself is the zero set: \\(\\{(x,y) : L(x,y) = 0\\}\\). This is the boundary between the two regions.\n\n\nImplementation\nGLSL provides a conditional operator (ternary operator) just like C:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\nLeft half-plane is red, right half-plane is blue. The syntax (condition) ? value_if_true : value_if_false should be familiar if you’ve programmed in C, Java, or JavaScript.\n\n\nThe Step Function\nGLSL also provides step(edge, x) which returns \\(0\\) if \\(x &lt; \\text{edge}\\) and \\(1\\) otherwise. The name comes from its graph—a step function in the calculus sense, jumping discontinuously from 0 to 1 at the edge value. This is useful for writing cleaner code without explicit conditionals:\nfloat s = step(0.0, p.x);  // 0 on left, 1 on right\nvec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\nHere mix(a, b, t) performs linear interpolation: \\((1-t)a + tb\\). So when s = 0 we get pure red, when s = 1 we get pure blue. The mix function is one of GLSL’s most useful tools—you’ll use it constantly for blending colors, smoothly transitioning between values, and implementing linear interpolation in all sorts of contexts.\n\n\n\n\n\n\nNoteWhy use step instead of the ternary operator?\n\n\n\nBoth work fine! The ternary operator ?: is more explicit and familiar if you know C-like languages. But step and mix are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation. For now, use whichever makes sense to you.\n\n\n\n\nArbitrary Half-Planes\nFor a general line \\(ax + by + c = 0\\), we just evaluate the corresponding linear function:\nfloat a = 1.0, b = 1.0, c = 0.0;\nfloat L = a * p.x + b * p.y + c;\nvec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\nfragColor = vec4(color, 1.0);\nTry different values of \\(a\\), \\(b\\), and \\(c\\) to see different line orientations and positions. The line itself is where \\(L = 0\\), and we’re coloring the two sides differently. Notice that scaling \\((a,b,c)\\) by a positive constant doesn’t change the geometry—it’s the zero set that matters, not the specific values of the function away from zero.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#distance-fields-and-circles",
    "href": "lectures/day1.html#distance-fields-and-circles",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.6 Distance Fields and Circles",
    "text": "1.6 Distance Fields and Circles\n\nDistance to Center\nThe distance from a point \\(p = (x, y)\\) to the origin is just the usual Euclidean distance: \\[d = \\|p\\| = \\sqrt{x^2 + y^2}\\]\nIn GLSL this is built-in:\nfloat d = length(p);\nThe length() function computes the Euclidean norm of a vector. It works for vec2, vec3, vec4—whatever you need. Under the hood it’s computing the square root of the dot product of the vector with itself, but there’s no need to write that out explicitly.\n\n\nFilled Circle\nA circle of radius \\(r\\) centered at the origin is the set \\(\\{p : \\|p\\| &lt; r\\}\\)—just points whose distance from the origin is less than \\(r\\). So to color the inside versus outside of a circle, we just compare distances:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThat’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle. Simple, elegant, and fast—millions of distance calculations per frame, all happening in parallel.\n\n\nDistance-Based Coloring\nBut we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:\nfloat d = length(p);\nfloat intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\nintensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\nvec3 color = vec3(intensity);\nfragColor = vec4(color, 1.0);\nThis creates a radial gradient—bright at the center, dark at the edges. The clamp function ensures we stay within \\([0,1]\\) even if our formula would produce values outside that range. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!\nDistance fields will become increasingly important as the week progresses. On Day 4, we’ll use them as the foundation for raymarching—a technique for rendering 3D geometry without any triangles or polygons, purely by iteratively evaluating distance functions. The length(p) function we used for circles today generalizes to arbitrary implicit surfaces: $d(p) = $ “distance to the surface defined by \\(F(p) = 0\\).” It’s a beautiful connection between analysis and computer graphics.\n\n\nCircle Outline\nWhat if we want to draw just the boundary of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is approximately equal to the radius. Mathematically, we’re coloring the set \\(\\{p : |d(p) - r| &lt; \\epsilon\\}\\) where \\(\\epsilon\\) is a small thickness parameter:\nfloat d = length(p);\nfloat r = 1.0;\nfloat thickness = 0.05;\n\nfloat circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\nvec3 color = vec3(circle_mask);\nfragColor = vec4(color, 1.0);\nThis draws a thin white annulus around the circle. Play with the thickness parameter to see how it affects the line width!\nFor a smoother, anti-aliased edge, GLSL provides smoothstep:\nfloat circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\nThe smoothstep(a, b, x) function performs smooth Hermite interpolation. For \\(x \\in [a,b]\\), it returns \\[s(t) = 3t^2 - 2t^3 \\quad \\text{where } t = \\frac{x-a}{b-a}\\]\nThis is a cubic polynomial with \\(s(0) = 0\\), \\(s(1) = 1\\), and crucially \\(s'(0) = s'(1) = 0\\)—the zero derivatives at the endpoints mean it transitions smoothly without visible “kinks.” For \\(x &lt; a\\) it returns \\(0\\), for \\(x &gt; b\\) it returns \\(1\\).\nThe result is anti-aliasing: instead of a hard transition at a single pixel, the edge is blurred over the interval \\([a,b]\\). For circle outlines, using smoothstep(r - thickness, r + thickness, d) creates a smooth transition zone of width \\(2 \\cdot \\text{thickness}\\) around the target radius. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!\n\n\n\n\n\n\nTipAnti-aliasing in shaders\n\n\n\nThe harsh cutoffs from using &lt; or the ternary operator create jagged, pixelated edges—what computer graphics people call “aliasing” (the signal is being undersampled relative to its frequency content, creating artifacts). Functions like smoothstep give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with smoothstep for smoother results.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#grids-and-repetition",
    "href": "lectures/day1.html#grids-and-repetition",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.7 Grids and Repetition",
    "text": "1.7 Grids and Repetition\n\nModular Arithmetic\nThe modulo operation creates periodic repetition. For a period \\(T\\), the function \\(p \\mapsto (p \\bmod T) - T/2\\) maps \\(\\mathbb{R}\\) to \\([-T/2, T/2]\\) repeatedly—it “folds” the entire real line into a finite interval over and over again.\nMore precisely, recall that \\(x \\bmod T\\) is the unique value in \\([0, T)\\) satisfying \\(x \\equiv r \\pmod{T}\\)—that is, \\(x = nT + r\\) for some integer \\(n\\). Geometrically, this takes the real line and wraps it into the interval \\([0,T)\\). Subtracting \\(T/2\\) recenters this to \\([-T/2, T/2]\\).\nIn GLSL, mod(x, T) computes \\(x \\bmod T\\). This is one of the most powerful tools in shader programming!\n\n\nCreating a Grid\nTo create a grid of repeated cells, we apply mod to our coordinates:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Now cell_p repeats every spacing units\n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis creates an infinite grid of yellow circles! The coordinate transformation cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0 ensures that cell_p is always in the range \\([-\\text{spacing}/2, \\text{spacing}/2]\\), and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.\nThink about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation.\nCompare this to how you might approach this in Python or MATLAB: you’d probably set up a nested loop over grid cells, compute the center of each cell, then draw a circle there. That’s \\(O(n^2)\\) work for an \\(n \\times n\\) grid. With shaders, it’s \\(O(1)\\) in the grid size—the cost is entirely in the number of pixels, not the number of circles. This is why shaders can render infinitely complex patterns at the same framerate as simple ones.\n\n\n\n\n\n\nNoteThe power of mod\n\n\n\nThis computational efficiency through coordinate transformations is a recurring theme in shader programming. You’ll see it again when we talk about domain repetition for fractals (Day 2), symmetry groups for hyperbolic tilings (Day 3), and space folding for raymarched scenes (Day 4). The key insight is always the same: instead of explicitly iterating over instances, transform the coordinate system so that all instances share the same local coordinates.\n\n\n\n\nAlternating Pattern\nWe can create checkerboard-like patterns by using the cell index to vary colors. To get the cell index, we divide by the spacing and floor:\nvec2 cell_id = floor(p / spacing);\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\n\nvec3 color_a = vec3(1.0, 0.0, 0.0);\nvec3 color_b = vec3(0.0, 0.0, 1.0);\nvec3 bg_color = mix(color_a, color_b, checker);\nHere floor(p / spacing) gives us integer grid indices \\((i, j)\\), and we alternate colors based on the parity of \\(i + j\\). When \\(i + j\\) is even, checker = 0 (giving us color_a), when odd, checker = 1 (giving us color_b).\nNotice the elegant separation: cell_id tells us which cell we’re in, while cell_p tells us where within that cell. This separation of global position and local coordinates is fundamental to working with repeating patterns.\n\n\nCombining with Circles\nLet’s put it all together—a grid of circles on an alternating background:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}\nTry varying the spacing and r parameters. What happens if you make the circles larger than the cells? (They overlap across cell boundaries!) What if you use different spacing values for x and y? (You get a rectangular rather than square lattice.) This simple framework is incredibly flexible.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#implicit-curves",
    "href": "lectures/day1.html#implicit-curves",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.8 Implicit Curves",
    "text": "1.8 Implicit Curves\n\nGeneral Principle\nAn implicit curve is defined by an equation \\(F(x, y) = 0\\). Points on the curve satisfy the equation exactly, while points off the curve have \\(F(x,y) \\neq 0\\). To render the curve, we compute \\(F(p)\\) for each pixel and color based on proximity to zero:\nfloat F = [some function of p.x and p.y];\nfloat thickness = 0.05;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nvec3 color = mix(background, curve_color, curve_mask);\nThis is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, transcendental curves, whatever you want. If you can write down a formula \\(F(x,y)\\), you can visualize its zero set.\n\n\nExample: Parabola\nThe parabola \\(y = x^2\\) can be written implicitly as \\(F(x, y) = y - x^2 = 0\\):\nfloat F = p.y - p.x * p.x;\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n\nvec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\nfragColor = vec4(color, 1.0);\nYou should see a yellow parabola on a dark blue background. The curve appears wherever \\(|F(x,y)| &lt; 0.1\\)—a thin band around the zero set of \\(F\\).\nOne thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker, while in the steep regions it appears thinner. Why does this happen?\nWe’re thresholding on the value of \\(F\\), not the geometric distance to the curve. Near the vertex at \\((0,0)\\), the parabola is nearly horizontal—small changes in \\(y\\) correspond to small changes in \\(x\\), so the set \\(\\{p : |y - x^2| &lt; \\epsilon\\}\\) is a thick vertical band. But on the steep parts where \\(|x|\\) is large, the parabola is nearly vertical—now the same change in \\(y\\) corresponds to a large change in \\(x\\), so the band is thin.\nTo see this more precisely, consider the gradient: \\(\\nabla F = (-2x, 1)\\). Near the vertex this has magnitude close to \\(1\\), but for large \\(|x|\\) it has magnitude approximately \\(2|x|\\). The visual thickness is roughly inversely proportional to \\(|\\nabla F|\\)—where the gradient is small, the level sets are far apart, and where it’s large, they’re close together.\nTo get uniform thickness, we’d need the signed distance function to the curve: \\[d(p) = \\inf\\{\\|p - q\\| : F(q) = 0\\}\\]\nThen thresholding on \\(|d(p)| &lt; \\epsilon\\) gives exactly thickness \\(\\epsilon\\) everywhere. Computing exact signed distance functions is nontrivial (we’ll see techniques for this on Day 4 when we discuss raymarching), but for many applications the naive thresholding on \\(|F|\\) works fine—especially if you tune the thickness parameter appropriately or use different thickness values in different regions.\n\n\nExample: Circle (Implicit Form)\nWe’ve been using \\(\\|p\\| &lt; r\\) for filled circles, but we can also write the circle implicitly as \\(x^2 + y^2 - r^2 = 0\\):\nfloat r = 1.0;\nfloat F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nThis is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The dot(p, p) computes \\(x^2 + y^2\\) as a single GPU operation—more efficient than p.x * p.x + p.y * p.y and certainly cleaner than writing it out! For circles, the signed distance function and the implicit function are particularly closely related: \\(d(p) = |\\|p\\| - r|\\), so the naive implicit approach actually works quite well.\n\n\nMore Examples\nLet’s look at a few more interesting curves:\nHyperbola: \\(xy = 1\\)\nfloat F = p.x * p.y - 1.0;\nEllipse: \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\)\nfloat a = 2.0, b = 1.0;\nfloat F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;\nLemniscate of Bernoulli: \\((x^2 + y^2)^2 = a^2(x^2 - y^2)\\)\nfloat a = 1.0;\nfloat r2 = dot(p, p);\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\nEach of these creates beautiful curves! Try implementing them and experimenting with different parameters.\n\n\n\n\n\n\nTipImplicit curves in your homework\n\n\n\nWhen you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation \\(F(x,y) = y - (ax^2 + bx + c)\\) and thresholding on \\(|F| &lt; \\epsilon\\). Make sure to test with various values of \\(a\\), \\(b\\), \\(c\\) to ensure your grapher is robust!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#summary",
    "href": "lectures/day1.html#summary",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.9 Summary",
    "text": "1.9 Summary\nToday we’ve learned the fundamental tools of shader programming:\n\nShaders as parallel functions: Every pixel evaluates \\(f(x, y, t, \\ldots) \\to \\text{color}\\) simultaneously—no loops required! The computational model is fundamentally different from sequential CPU programming.\nGLSL basics: Syntax rules (semicolons, .0 for floats), vector types (vec2, vec3, vec4), and essential built-in functions like length(), dot(), step(), and smoothstep()\nCoordinate systems: The four-step transformation (normalize, center, aspect-correct, scale) that takes us from pixel coordinates to a mathematical coordinate system suitable for visualization\nConditional coloring: Using boolean expressions, the ternary operator, and step() combined with mix() to create discrete color regions based on mathematical predicates\nDistance fields: Using length() to create circles and radial patterns—the foundation for much more complex techniques we’ll explore on Day 4 with raymarching\nModular arithmetic: Creating grids and repeating patterns with mod()—achieving infinite complexity with finite computation through coordinate transformations rather than explicit iteration\nImplicit curves: Rendering curves defined by \\(F(x, y) = 0\\) by thresholding on \\(|F|\\)—a general technique that works for any curve we can express as an equation, though we must be aware of the non-uniform thickness issue\n\nWith these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#homework",
    "href": "lectures/day1.html#homework",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.10 Homework",
    "text": "1.10 Homework\n\nRequired: Parabola Graphing Calculator\nCreate a shader that draws a customizable parabola \\(y = ax^2 + bx + c\\) along with coordinate axes.\nRequirements:\n\nDefine variables a, b, c at the top of your shader (hardcoded values are fine—we’re not building a GUI yet)\nDraw the \\(x\\)-axis and \\(y\\)-axis as thin lines using the implicit line technique: \\(|y| &lt; \\epsilon\\) for the \\(x\\)-axis, \\(|x| &lt; \\epsilon\\) for the \\(y\\)-axis\nPlot the parabola \\(y = ax^2 + bx + c\\) as a thicker curve\nUse distinct colors for axes (suggest a neutral gray) and parabola (suggest something bright)\nThe visualization should work for any reasonable values of \\(a\\), \\(b\\), \\(c\\)—make sure to test edge cases!\n\nWhat it should look like: A coordinate plane with thin gray axes, and a colored curve tracing out your parabola. The entire parabola should be visible in your viewing window (you may need to adjust your scaling factor depending on your parameters).\nTest cases to verify: - \\(a=1, b=0, c=0\\) (standard parabola opening upward) - \\(a=-1, b=0, c=1\\) (downward-opening parabola shifted up) - \\(a=0.5, b=1, c=-0.5\\) (general case with all parameters nonzero) - \\(a=0, b=1, c=0\\) (degenerate case—just a line! Your code should handle this gracefully)\nSuggested approach:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Axes\n    float axis_thickness = 0.02;\n    float x_axis_mask = abs(p.y) &lt; axis_thickness ? 1.0 : 0.0;\n    float y_axis_mask = abs(p.x) &lt; axis_thickness ? 1.0 : 0.0;\n    vec3 axis_color = vec3(0.3, 0.3, 0.3);\n    \n    // Parabola: F(x,y) = y - (ax² + bx + c) = 0\n    float F = p.y - (a * p.x * p.x + b * p.x + c);\n    float curve_thickness = 0.08;\n    float parabola_mask = abs(F) &lt; curve_thickness ? 1.0 : 0.0;\n    vec3 parabola_color = vec3(1.0, 0.8, 0.0);\n    \n    // Combine (axes behind parabola)\n    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\n    color = mix(color, parabola_color, parabola_mask);\n    \n    fragColor = vec4(color, 1.0);\n}\nTry different values of \\(a\\), \\(b\\), \\(c\\) and verify your grapher works correctly! What happens with negative \\(a\\)? What about \\(b \\neq 0\\)? Make sure the axes and parabola remain visible for all parameter values you try. If the parabola goes off-screen, you may need to adjust your coordinate scaling in the setup.\n\n\nOptional #1: Animated Curve Family\nCreate a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build geometric intuition!\nEasier options:\n\nCircle family: Draw circles of varying radii: \\(x^2 + y^2 = r^2\\) where \\(r = 1 + 0.5\\sin(\\text{iTime})\\). Simple but mesmerizing!\nRotating ellipse: \\((x\\cos\\theta + y\\sin\\theta)^2/a^2 + (-x\\sin\\theta + y\\cos\\theta)^2/b^2 = 1\\) with \\(\\theta = \\text{iTime}\\). Watch an ellipse rotate continuously.\n\nMore challenging options:\n\nLissajous curves: Use parametric equations \\(x = A\\sin(at + \\delta)\\), \\(y = B\\sin(bt)\\) and animate \\(\\delta\\) with iTime. To render a parametric curve implicitly, you’ll need to be clever—one approach is to sample many points along the curve and draw circles at each point (we’ll learn better techniques for this later).\nCassini ovals: \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). Fix \\(c = 1\\) and vary \\(a\\) with iTime. Watch the curve transition from two separate loops to a single figure-eight-like shape as \\(a\\) passes through the critical value \\(a = c\\)!\nCubic curves: Take \\(y^2 = x^3 + ax + b\\) and vary one parameter with iTime. The topology of the curve changes dramatically as you pass through singular values—this is the beginning of the theory of elliptic curves!\n\nUse iTime creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes (these are the singularities of the family)!\n\n\nOptional #2: Beautiful Tiling Pattern\nDesign an aesthetically pleasing tiling pattern using the mod() technique. This is your chance to be creative and make something visually striking!\nRequirements:\n\nCreate a non-trivial pattern within a fundamental domain (a single tile)\nUse mod() to repeat it across the plane\nThe pattern should tile seamlessly—edges must match up so there are no visible discontinuities at tile boundaries\n\nIdeas to get you started:\n\nGeometric patterns: Nested circles, polygons approximated by implicit curves, star shapes using angular coordinates\nColor gradients: Use cell_id to vary colors smoothly across tiles, creating large-scale gradient effects superimposed on the local pattern\nMultiple implicit curves: Combine several curves within each tile using boolean operations (intersection, union, etc.)\nSymmetry: Use abs() to create reflections within tiles—this is a simple way to get complex patterns with built-in symmetry\nDistance-based effects: Make features pulse or fade based on iTime and their position in the grid—create waves propagating across the tiling\n\nAdvanced challenge: Can you create a pattern that has different symmetries in different tiles? For example, alternate between rotational and reflectional symmetry using the checkerboard cell_id technique. Or create a pattern where the colors vary smoothly across the entire infinite tiling, creating a large-scale gradient effect that’s independent of the tile boundaries?\nThink about Islamic geometric patterns, Escher tilings, or quasiperiodic tilings (though true quasiperiodicity requires techniques beyond simple mod—we’ll see that on Day 3!). The goal is to create something mathematically interesting and visually beautiful.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#looking-ahead",
    "href": "lectures/day1.html#looking-ahead",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.11 Looking Ahead",
    "text": "1.11 Looking Ahead\nTomorrow we’ll use these techniques to explore complex dynamics and geometric transformations:\n\nMandelbrot and Julia sets: Using the implicit curve technique to visualize the boundary of escape sets for complex iteration\nCircle inversions: A geometric transformation that takes lines and circles to lines and circles, creating beautiful fractal-like patterns\nApollonian gasket: An infinite packing of circles constructed via repeated inversions—a stunning example of how simple geometric rules create intricate structures\n\nThe coordinate systems, distance fields, and implicit curve techniques you’ve learned today will be the foundation for everything to come. Make sure you’re comfortable with:\n\nSetting up coordinates (the standard four-step transformation from fragCoord to centered, aspect-corrected p)\nComputing distances with length() and dot products\nUsing mod() for repetition and understanding the separation of global cell_id and local cell_p\nConditionally coloring based on mathematical expressions, using both explicit conditionals and smooth interpolation with smoothstep\n\nIf any of these feel shaky, now is the time to practice! Work through the homework problems, experiment with variations, and make sure you understand not just how the code works but why the mathematics gives the visual results you see. Everything this week builds on this foundation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html",
    "href": "lectures/day2.html",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "2.1 Overview\nToday we explore the power of iteration to generate fractals. We’ll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set, then understand its companion, the Julia set. After that, we shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We’ll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles.\nBy the end of today, you’ll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#overview",
    "href": "lectures/day2.html#overview",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "NoteRoadmap for Today\n\n\n\nWe’ll explore iteration in two different mathematical settings:\n\nComplex dynamics: Iterating holomorphic maps (Mandelbrot and Julia sets)\nGeometric dynamics: Iterating circle inversions (Apollonian gasket)\n\nBoth produce fractals through the same fundamental mechanism: simple rules applied repeatedly reveal infinite complexity. The common thread is conformality—both complex multiplication and circle inversion preserve angles, and this angle preservation is key to the beautiful structures we’ll see.\nAlong the way, we’ll learn shader programming techniques for organizing data (structs), implementing mathematical operations efficiently, and creating sophisticated coloring schemes.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#complex-numbers-in-glsl",
    "href": "lectures/day2.html#complex-numbers-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.2 Complex Numbers in GLSL",
    "text": "2.2 Complex Numbers in GLSL\n\nRepresentation\nA complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). This is the natural representation—complex numbers are the 2D plane with a particular multiplication structure! In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part. You already know complex numbers geometrically as rotations and scalings in the plane—here we’re just implementing that algebra in shader code.\n\n\nComplex Arithmetic\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations. Some of these are trivial, others require a bit more work:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nAddition of complex numbers is just vector addition—componentwise! You might not even need this function since you can just write z + w directly, but it’s here for completeness.\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nThis implements the familiar FOIL pattern with \\(i^2 = -1\\), giving us that minus sign in the real part.\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nThe squared magnitude is just the dot product with itself. This is computationally cheaper than taking the square root, so when we just need to check if \\(|z| &gt; 2\\), we’ll check if \\(|z|^2 &gt; 4\\) instead—millions of avoided square roots per frame!\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nThe magnitude is the Euclidean distance from the origin—exactly what length() computes!\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nThe conjugate flips the sign of the imaginary part—reflection across the real axis.\nDivision: \\(\\frac{a + bi}{c + di} = \\frac{(a + bi)(c - di)}{c^2 + d^2}\\)\nvec2 cdiv(vec2 z, vec2 w) {\n    float denom = dot(w, w);  // c² + d²\n    return vec2(\n        (z.x * w.x + z.y * w.y) / denom,  // Real part\n        (z.y * w.x - z.x * w.y) / denom   // Imaginary part\n    );\n}\nDivision multiplies numerator and denominator by the conjugate of \\(w\\) to rationalize. The denominator becomes real (\\(c^2 + d^2\\)), and the numerator becomes a new complex number we can compute directly.\n\n\n\n\n\n\nTipComputational Efficiency in Complex Arithmetic\n\n\n\nNotice we use dot(z, z) for magnitude squared—this is a single GPU operation rather than component-wise multiplication and addition. Similarly, dot(w, w) in the division routine. For operations you’ll compute millions of times per frame, these micro-optimizations add up!\nWe’re also using helper functions rather than inlining the formulas everywhere. This makes the code much more readable (cmul(z, z) vs vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)) and easier to debug. If you make a sign error once in cmul, you fix it once. If you inline the formula fifty times, you’ll hunt for bugs forever!\n\n\nThese are the building blocks we need for complex dynamics. Let’s put them to work!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-mandelbrot-set",
    "href": "lectures/day2.html#the-mandelbrot-set",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.3 The Mandelbrot Set",
    "text": "2.3 The Mandelbrot Set\n\nDefinition\nThe Mandelbrot set \\(\\mathcal{M}\\) is one of the most famous objects in mathematics—and for good reason! It’s defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nThat’s it! Just iterate this simple quadratic map starting from \\(z_0 = 0\\), and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.\n\n\nThe Escape Radius Theorem\nIn practice, we can’t iterate to infinity, so we need a criterion to detect escape. Fortunately, there’s a beautiful theorem that tells us exactly when to stop:\nTheorem (Escape Radius). If \\(|z_n| &gt; 2\\) for any \\(n\\), then \\(|z_n| \\to \\infty\\) as \\(n \\to \\infty\\).\nThis means: once the orbit leaves the disk of radius 2, it’s definitely escaping to infinity. Points that escape are not in the Mandelbrot set, while points that remain bounded after many iterations are (likely) in the set or very close to its boundary.\nProof. Suppose \\(|z_n| &gt; 2\\) and write \\(|z_n| = 2 + \\epsilon\\) for some \\(\\epsilon &gt; 0\\). Then \\[\\begin{align*}\n|z_{n+1}| &= |z_n^2 + c|\\\\\n&\\geq |z_n^2| - |c|\\\\\n&= |z_n|^2 - |c|\\\\\n&&gt; |z_n|^2 - 2 \\quad \\text{(since $c$ is in or near $\\mathcal{M}$, which fits in $|z| \\leq 2$)}\\\\\n&= (2 + \\epsilon)^2 - 2\\\\\n&= 4 + 4\\epsilon + \\epsilon^2 - 2\\\\\n&= 2 + 4\\epsilon + \\epsilon^2\\\\\n&&gt; 2 + 2\\epsilon = |z_n| + \\epsilon\n\\end{align*}\\]\nSo once \\(|z_n| &gt; 2\\), we have \\(|z_{n+1}| &gt; |z_n| + \\epsilon\\), meaning the magnitude grows by at least \\(\\epsilon\\) each iteration. This linear growth accelerates: if \\(|z_{n+1}| &gt; 2 + \\epsilon\\), then \\(|z_{n+2}| &gt; |z_{n+1}| + \\epsilon' &gt; 2 + 2\\epsilon\\), and so on. More carefully, the orbit actually grows exponentially (roughly like \\(|z_n| \\sim 2^{2^n}\\) for large \\(n\\)), but the key point is: it definitely escapes to infinity.\nComputational Implication: We only need to check if \\(|z_n| &gt; 2\\). The moment this happens, we can stop iterating—this point will never be in the Mandelbrot set. This single theorem makes efficient rendering possible!\n\n\nHistorical Context\nThe Mandelbrot set was discovered remarkably recently—1980! Benoit Mandelbrot, working at IBM, was among the first to have access to computers powerful enough to visualize iterative processes in the complex plane. Before computers, studying these sets was nearly impossible—you’d need to manually iterate complex arithmetic hundreds of times for millions of points.\nInterestingly, the mathematical theory predates visualization by over 60 years. Gaston Julia and Pierre Fatou studied iterative complex dynamics extensively in 1918, but without computers, they could only reason about these sets abstractly. They knew Julia sets existed and had deep properties, but had never seen one! When Mandelbrot generated the first images in 1980, it revolutionized the field—suddenly the intricate structure of these sets was visible, creating an explosion of interest in fractal geometry and complex dynamics.\nThe Mandelbrot set became iconic partly because it’s so accessible: anyone can understand the definition (iterate \\(z \\mapsto z^2 + c\\)), yet it produces infinitely intricate beauty. It also sparked broader interest in fractals, chaos theory, and the idea that simple rules can generate complex behavior—themes that would influence everything from physics to economics to art.\n\n\nBasic Implementation\nLet’s code it up:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\nThat’s the entire Mandelbrot set renderer! The coordinate scaling is tuned to show the “interesting part”—the main cardioid body and its surrounding bulbs. The set extends roughly from \\(-2.5\\) to \\(0.5\\) on the real axis, so we shift our coordinate system accordingly.\n\n\n\n\n\n\nNoteWhy This Is Perfect for GPUs\n\n\n\nNotice what’s happening computationally: every pixel performs its own independent calculation. There’s no communication between pixels, no shared data structures, no synchronization needed. Each pixel just iterates its own complex number and decides when to stop.\nThis is embarrassingly parallel—the ideal workload for GPU architecture. A modern GPU has thousands of small processors, and they can all work on different pixels simultaneously. No pixel needs to wait for another pixel’s result. The entire screen (potentially millions of pixels) is computed in parallel, which is why we can render the Mandelbrot set at 60fps even with 100+ iterations per pixel.\nMemory-wise, this is also very efficient: each pixel only needs to store its current \\(z\\) value (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures. The computation is stateless—we only care about the current iterate, not the full orbit.\nThis contrasts sharply with sequential CPU code, where you’d iterate over pixels one at a time. Even with clever optimizations and SIMD vectorization, you’d be orders of magnitude slower than a GPU shader doing the same work.\n\n\n\n\nSmooth Coloring\nThe grayscale rendering shows the structure of the set, but it has harsh banding—sudden transitions between integer iteration counts create visible stripes. We can do much better by interpolating between iteration steps!\nThe key insight is that near escape, the orbit grows exponentially. Specifically, once \\(|z_n|\\) is large, we have approximately \\(|z_{n+1}| \\approx |z_n|^2\\), which means \\(\\log |z_{n+1}| \\approx 2\\log|z_n|\\). Taking logs repeatedly, we get \\[\\log\\log|z_{n+1}| \\approx \\log(2\\log|z_n|) = \\log 2 + \\log\\log|z_n|\\]\nThis suggests that \\(\\log\\log|z_n|\\) grows approximately linearly near escape, increasing by \\(\\log 2\\) per iteration. We can use this to compute a fractional iteration count!\nHere’s the formula:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;  // = log|z_n|\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nThe variable nu represents how far we’ve progressed toward the next integer iteration. When \\(|z_n| = 2\\) exactly (just hitting the escape threshold), \\(nu = 0\\) and we get the integer iteration count. When \\(|z_n|\\) is large (deep into escape), \\(nu\\) approaches 1. Subtracting nu from iter + 1 gives us a continuous, smooth value that transitions gradually between iteration levels.\nThis eliminates banding entirely! The result is smooth, continuous color gradients that look much more professional and reveal the fractal structure more clearly.\n\n\n\n\n\n\nTipSmooth Coloring as Anti-Aliasing\n\n\n\nSmooth coloring is fundamentally an anti-aliasing technique. Without it, nearby pixels with iteration counts of, say, 45 and 46 get completely different colors—creating harsh edges. With smooth coloring, these pixels get nearly identical colors (say, iteration 45.3 and 45.8), producing a smooth gradient.\nThis is especially important at high zoom levels, where tiny changes in position lead to different integer iteration counts. The smooth interpolation ensures that small changes in \\(c\\) produce small changes in color, which is exactly what we want for a continuous mathematical function.\n\n\n\n\nColor Palettes\nNow we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:\nvec3 palette(float t) {\n    // Create a cyclic color palette using cosines\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters control different aspects:\n\na and b control the range and center of the colors (here, mapping to \\([0,1]\\))\nc controls the frequency of color cycling\nd controls the phase offset, shifting the entire palette\n\nPlay with these parameters to get different color schemes! Try d = vec3(0.0, 0.1, 0.2) for a blue-purple palette, or d = vec3(0.3, 0.2, 0.2) for warmer tones. You can also adjust c to make the colors cycle faster or slower through the iteration range.\nThe beauty of this cosine approach is that it’s smooth (continuous derivatives), cyclic (no seams), and efficient (just a few trig operations). Other approaches exist—hand-picked color stops with interpolation, HSV color spaces, perceptually uniform LAB spaces—but cosine palettes are a great default for fractal visualization.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#julia-sets",
    "href": "lectures/day2.html#julia-sets",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.4 Julia Sets",
    "text": "2.4 Julia Sets\nThe Julia set is the natural companion to the Mandelbrot set, and understanding their relationship is key to understanding complex dynamics. Where the Mandelbrot set varies \\(c\\) and fixes \\(z_0 = 0\\), the Julia set does the opposite: it fixes \\(c\\) and varies \\(z_0\\).\n\nDefinition\nFor a fixed complex number \\(c\\), the filled Julia set \\(K_c\\) is the set of initial conditions \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded. The Julia set \\(J_c\\) is the boundary of \\(K_c\\)—the set where the dynamics are chaotic, neither definitely bounded nor definitely escaping.\nThink about what this means: every point \\(c\\) in the complex plane has an associated Julia set \\(J_c\\). The Mandelbrot set is telling us about the topology of these Julia sets! Specifically:\n\nIf \\(c \\in \\mathcal{M}\\) (inside the Mandelbrot set), then \\(J_c\\) is connected—a single, intricate curve\nIf \\(c \\notin \\mathcal{M}\\) (outside the Mandelbrot set), then \\(J_c\\) is totally disconnected—a Cantor-like dust of points\n\nThis is one of the most beautiful connections in mathematics: the Mandelbrot set is a map of parameter space, showing which values of \\(c\\) produce connected Julia sets. Julia and Fatou proved this in 1918 without ever seeing a picture—they understood these sets purely abstractly!\n\n\nImplementation as Homework\nYou’ll implement Julia set rendering in the homework. The algorithm is nearly identical to the Mandelbrot set—just swap what’s fixed and what varies! Instead of setting z = vec2(0.0) and varying c across pixels, you’ll set c to a fixed value and let z be the pixel coordinate.\nThe key changes: 1. Fix c to an interesting value (we’ll give suggestions) 2. Initialize z from the pixel position (that’s your \\(z_0\\)) 3. Iterate \\(z \\mapsto z^2 + c\\) exactly as before 4. Use the same escape criterion and coloring\nThis will give you a Julia set! Try different values of \\(c\\) to see how the topology changes. You can make c depend on time (iTime) for animation, or on mouse position (iMouse) for interactive exploration.\nSome interesting values to try: - \\(c = -0.7 + 0.27015i\\) — classic Julia set, intricate tendrils - \\(c = -0.4 + 0.6i\\) — dendrite-like fractal trees - \\(c = 0.285 + 0.01i\\) — beautiful spiral patterns - \\(c = -0.8 + 0.156i\\) — highly filamentary - \\(c = -0.70176 - 0.3842i\\) — “San Marco dragon”\nValues inside the Mandelbrot set give connected Julia sets (single curves), while values outside give disconnected Julia sets (dust). The most interesting Julia sets often come from values right near the boundary of \\(\\mathcal{M}\\)—this is where the transition between connected and disconnected happens!\n\n\n\n\n\n\nTipExploring Parameter Space\n\n\n\nWhen you implement Julia sets, try this: tie \\(c\\) to your mouse position. Move the mouse around and watch the Julia set morph in real time! This is an incredibly powerful way to build intuition for how the parameter \\(c\\) affects the dynamics.\nYou’ll notice that small changes in \\(c\\) can produce dramatic changes in the Julia set topology—this is the sensitive dependence on parameters that makes complex dynamics so rich. Near the boundary of the Mandelbrot set, tiny movements create entirely different structures.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#interlude-from-complex-to-geometric-dynamics",
    "href": "lectures/day2.html#interlude-from-complex-to-geometric-dynamics",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.5 Interlude: From Complex to Geometric Dynamics",
    "text": "2.5 Interlude: From Complex to Geometric Dynamics\nWe’ve been iterating algebraic functions in the complex plane: \\(z \\mapsto z^2 + c\\). Now we shift to iterating geometric transformations of the plane itself: circle inversion. The mathematical frameworks are different—holomorphic dynamics versus conformal geometry—but they share fundamental similarities.\nBoth complex multiplication and circle inversion are conformal maps: they preserve angles between curves. In complex dynamics, this comes from the Cauchy-Riemann equations and the geometric interpretation of multiplication as rotation and scaling. In circle inversion, it’s a theorem we’ll state shortly. This angle preservation is crucial—it’s what makes the fractal structures we generate geometrically coherent and visually beautiful.\nThere’s also a deep connection we’ll explore tomorrow: circle inversion is actually an isometry of hyperbolic space! The inversions we’re about to do are the same transformations that generate Kleinian groups and tessellate the hyperbolic plane. So in some sense, we’re already working in non-Euclidean geometry without realizing it. Tomorrow we’ll make this explicit when we explore hyperbolic tilings.\nFor now, let’s learn circle inversion and use it to build the Apollonian gasket—a fractal structure every bit as intricate as the Mandelbrot set, but generated through pure Euclidean geometry.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#circle-inversion",
    "href": "lectures/day2.html#circle-inversion",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.6 Circle Inversion",
    "text": "2.6 Circle Inversion\nCircle inversion is a beautiful geometric operation that will be the foundation for everything we do with geometric dynamics. It’s a transformation of the plane that turns inside into outside, maps circles to circles (or lines), and preserves angles—making it a powerful tool for creating fractal patterns.\n\nMathematical Definition\nCircle inversion is a transformation with respect to a circle. For a circle of radius \\(R\\) centered at a point \\(\\mathbf{c}\\), inversion maps a point \\(\\mathbf{p} \\neq \\mathbf{c}\\) to: \\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nThe vector \\(\\mathbf{p} - \\mathbf{c}\\) points from the center to \\(\\mathbf{p}\\). We normalize this direction by dividing by its squared length, then scale by \\(R^2\\), and finally translate back by the center. Geometrically:\n\nPoints inside the circle map to points outside (and vice versa)\nPoints on the circle are fixed (they map to themselves)\nThe closer you are to the center, the farther away you go\nThe center itself maps to infinity, and infinity maps to the center\n\nHere’s another way to think about it: draw a ray from the center through \\(\\mathbf{p}\\). The inversion of \\(\\mathbf{p}\\) is the unique point on this ray such that the product of distances from the center is \\(R^2\\). If \\(\\mathbf{p}\\) is at distance \\(r\\) from the center, its image is at distance \\(R^2/r\\).\n\n\nKey Properties\nCircle inversion has remarkable geometric properties. These aren’t obvious from the formula, but they’re all classical theorems:\n\nLines through the center remain lines through the center (they’re “flipped inside out” along the ray)\nLines not through the center become circles through the center\nCircles through the center become lines (not through the center)\nCircles not through the center generally remain circles, but with different center and radius\nAngles are preserved (conformal property)\n\nThe angle preservation is the deepest property. It’s not at all obvious from the formula, but it can be proved using the chain rule and careful calculation. The key insight is that inversion is locally similar to a complex conjugation-like operation, which preserves angles.\nWhy These Properties Matter for Iteration: When we iterate inversions through multiple circles, these properties ensure that the geometry remains coherent. Circles stay circles (or become lines), and the angles between curves are preserved. This means repeated inversion creates intricate but geometrically regular patterns—the hallmark of fractals generated by conformal maps.\nAnother key fact: inversion is involutive—applying it twice returns to the original point (assuming the point isn’t the center). Mathematically, \\(\\text{inv}(\\text{inv}(\\mathbf{p})) = \\mathbf{p}\\). This makes inversion a geometric reflection of sorts, which will be important when we think about symmetry groups tomorrow.\n\n\n\n\n\n\nNoteHistorical Context: Circle Inversion\n\n\n\nCircle inversion has ancient roots—Apollonius of Perga studied related problems involving tangent circles around 200 BCE. But the modern theory of inversion as a geometric transformation developed in the 19th century as part of projective and non-Euclidean geometry.\nA key insight was recognizing that circle inversion is related to stereographic projection: if you place a sphere on the plane, inversion in a circle corresponds to reflection through the sphere! This connection links circle inversion to spherical geometry and ultimately to hyperbolic geometry.\nIn the late 19th and early 20th centuries, mathematicians realized that groups of circle inversions (Kleinian groups) could tessellate hyperbolic space and create fractal limit sets. This anticipates the fractal geometry revolution of the 1970s-80s, though the connection wasn’t fully appreciated until computers made visualization possible.\n\n\n\n\nImplementation\nThe formula translates directly to GLSL:\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);  // squared distance from center\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);  // Map to \"infinity\"\n    \n    return center + (radius * radius) * diff / r2;\n}\nThe only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it’s effectively off-screen. The threshold 0.0001 is small enough to catch points numerically close to the center but large enough to avoid precision issues.\nComputationally, circle inversion is very cheap: just one dot product, a division, a multiplication, and some vector operations. This efficiency is important because we’ll be doing many inversions per pixel when generating fractals!\n\n\nVisualizing Circle Inversion\nLet’s see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);  // Create repeating cells\n    float gridLine = step(0.95, max(grid.x, grid.y));  // Draw grid lines\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle itself (for reference)\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou’ll see straight grid lines transform into beautiful circular arcs! Lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.\nThis visualization really helps build intuition. You can see: - The circle itself (in red) is unchanged—points on it are fixed - The grid inside the circle maps to a grid outside (and vice versa) - Lines become curves, but the angles where they intersect are preserved - The pattern has a pole singularity at the center (infinite distortion)\n\n\n\n\n\n\nTipExploring Circle Inversion\n\n\n\nHere are some experiments to try:\n\nMultiple circles: Create a grid of circles using mod() (like we did on Day 1) and invert through each cell’s circle independently. You’ll see beautiful overlapping patterns!\nAnimated radius: Make circleRadius = 1.0 + 0.5 * sin(iTime) to watch the grid breathe in and out. This helps you see how the inversion depends on the circle’s size.\nDifferent patterns: Instead of a grid, try drawing circles or other shapes in the inverted space. Circles become circles (or lines), creating intricate nested patterns.\nOff-center inversion: Move the inversion circle away from the origin. Watch how the asymmetry creates even more complex distortions.\n\nEach of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#structs-in-glsl",
    "href": "lectures/day2.html#structs-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.7 Structs in GLSL",
    "text": "2.7 Structs in GLSL\nBefore we build the Apollonian gasket, we need to talk about organizing our data. We’re about to deal with multiple circles, and passing around center1, radius1, center2, radius2, etc. gets unwieldy fast. GLSL provides structs (just like in C) for grouping related data together.\n\nDefining and Using Structs\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nNow Circle is a type we can use just like vec2 or float. Creating and using structs is straightforward:\n// Declare and initialize\nCircle c1 = Circle(vec2(0.0, 0.0), 1.0);\n\n// Or declare first, set later\nCircle c2;\nc2.center = vec2(1.0, 0.5);\nc2.radius = 0.75;\n\n// Pass to functions\nvec2 invertThroughCircle(vec2 p, Circle circ) {\n    return invertCircle(p, circ.center, circ.radius);\n}\nThis makes the code dramatically more readable. Compare:\n// Without structs - messy!\nvec2 iterate(vec2 p, vec2 c1_cen, float c1_rad, vec2 c2_cen, float c2_rad, vec2 c3_cen, float c3_rad);\n\n// With structs - clean!\nvec2 iterate(vec2 p, Circle c1, Circle c2, Circle c3);\nFor the Apollonian gasket, we’ll have three circles we need to track and pass around. Structs make this much more manageable and semantically clear—we’re working with circles as geometric objects, not just pairs of vectors and floats.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-apollonian-gasket",
    "href": "lectures/day2.html#the-apollonian-gasket",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.8 The Apollonian Gasket",
    "text": "2.8 The Apollonian Gasket\nNow for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It’s named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles around 200 BCE, though the fractal interpretation is much more modern.\n\nDescartes Circle Theorem\nTo understand the Apollonian gasket, we need to know about a beautiful theorem: Descartes Circle Theorem (1643).\nGiven four mutually tangent circles (each tangent to the other three), let their curvatures be \\(k_1, k_2, k_3, k_4\\) where curvature \\(k = 1/r\\) (positive for external tangency, negative for internal). Then: \\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\\]\nThis can be rearranged to solve for the fourth curvature given three: \\[k_4 = k_1 + k_2 + k_3 \\pm 2\\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}\\]\nThe \\(\\pm\\) gives two solutions—the two circles tangent to the original three (one inside the curvilinear triangle they form, one outside).\nWhat makes this magical for fractals: if you start with three mutually tangent circles with integer curvatures, then all circles in the Apollonian gasket have integer curvatures! This is the Apollonian gasket’s connection to number theory—it’s a fractal made entirely of circles with rational radii.\nWe won’t use this formula directly in our shader (we’ll set up circles geometrically), but it explains why certain configurations are special and why the patterns are so regular despite infinite nesting.\n\n\nSetup: Three Mutually Tangent Circles\nWe start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For this to work, the distance between any two circle centers must be exactly twice the radius (so they touch edge-to-edge). The three centers form an equilateral triangle, and we’ll position this triangle symmetrically at the origin:\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\nWith \\(r = 0.5\\), the circumradius \\(d \\approx 0.577\\), and the outer circle has radius \\(R = d + r \\approx 1.077\\). All four circles are mutually tangent—each inner circle touches the other two inner circles and the outer circle.\nThis is just one possible configuration! You could use different radii (related by Descartes’ theorem), different arrangements, or even animated circles. The key is that they start mutually tangent—this ensures the iteration creates a proper Apollonian packing.\n\n\nThe Iteration Algorithm\nThe algorithm is beautifully simple:\n\nStart with a point \\(p\\)\nCheck which circles contain \\(p\\)\nIf \\(p\\) is inside a circle, invert through that circle\nRepeat until \\(p\\) is outside all circles or we hit max iterations\nColor based on iteration behavior\n\nHere’s the implementation:\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        // If we didn't move, we're in the gaps - done!\n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\nWe also track which circle we last inverted through (lastCircle) and how many iterations we performed (finalIter). These will be useful for coloring!\nWhy This Creates a Fractal: Each time we invert through a circle, we “push” the point away from that circle’s center. But because the four circles are mutually tangent, pushing away from one circle might push us into another circle, triggering another inversion. The interplay between these four inversions (three inner circles plus the outer circle) creates a complex orbit.\nPoints in the “gaps” between the inner circles (the curvilinear triangles) escape quickly—they’re inside the outer circle but not inside any inner circle, so no inversion happens. But points near the tangency points get bounced back and forth between circles many times before escaping. And at the actual tangency points (where circles touch), the orbit never escapes—these are fixed points or periodic orbits of the iterated inversions.\nThe fractal structure emerges because these dynamics are self-similar: zooming in near any tangency point reveals the same pattern of nested circles and gaps. This self-similarity is a direct consequence of the conformal nature of circle inversion—the transformation preserves angles, so local geometry looks the same at all scales.\n\n\nColoring Strategies\nThere are several interesting ways to color the Apollonian gasket:\nBy iteration count (like the Mandelbrot set):\nfloat t = float(finalIter) / float(maxIter);\nvec3 color = palette(t);\nThis shows the “depth” of the orbit—points that escape quickly are colored differently from points that bounce around many times.\nBy last circle hit:\nvec3 colors[4] = vec3[4](\n    vec3(1.0, 0.0, 0.0),  // Circle 1: red\n    vec3(0.0, 1.0, 0.0),  // Circle 2: green\n    vec3(0.0, 0.0, 1.0),  // Circle 3: blue\n    vec3(1.0, 1.0, 0.0)   // Outer circle: yellow\n);\nvec3 color = colors[lastCircle];\nThis shows the basin of attraction—which circle’s “influence” each point ultimately fell into. Yellow regions show points that escaped through the outer circle.\nBy final distance from circles:\nfloat d1 = abs(length(p - c1.center) - c1.radius);\nfloat d2 = abs(length(p - c2.center) - c2.radius);\nfloat d3 = abs(length(p - c3.center) - c3.radius);\nfloat d = min(d1, min(d2, d3));\nvec3 color = vec3(smoothstep(0.0, 0.05, d));\nThis highlights the circle boundaries themselves, making the geometric structure more apparent.\nEach coloring reveals different aspects of the fractal. Try combining them—for example, color by iteration count but modulate brightness by distance to circles.\n\n\nPutting It All Together\nHere’s a complete Apollonian gasket renderer:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup the four circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by iteration count with palette\n    float t = float(finalIter) / float(maxIter);\n    vec3 color = palette(t);\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);  // White circle outlines\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful nested pattern of circles! The fractal structure is immediately apparent—circles within circles within circles, filling every gap with smaller circles.\nZoom in (by scaling p differently in the coordinate setup) to see the self-similarity. No matter how far you zoom, you’ll keep finding the same pattern repeated at smaller scales. This is true fractality—infinite detail that never runs out.\n\n\n\n\n\n\nNoteComputational Efficiency\n\n\n\nDespite the complexity of the output, this algorithm is remarkably efficient. Each iteration just checks three distances (cheap) and potentially does one inversion (also cheap—just a few arithmetic operations). With 50 iterations, we’re doing maybe 150 distance checks and 50 inversions per pixel.\nCompare this to raymarching (Day 4), where we might do hundreds of distance evaluations per pixel! The Apollonian gasket is very GPU-friendly.\nThe key is that we terminate early—most pixels escape in just a few iterations. Only points near the fractal boundary require many iterations. This is similar to the Mandelbrot set: most of the computational work focuses on the interesting regions (the boundary), while simple regions (deep inside or far outside) are handled quickly.\n\n\n\n\nHistorical Context and Connections\nThe Apollonian gasket connects several mathematical threads across millennia:\nAncient roots: Apollonius of Perga (~200 BCE) studied the problem of constructing circles tangent to three given circles (the “Problem of Apollonius”). He found geometric constructions but couldn’t have imagined the infinite fractal structure we’re visualizing.\nRenaissance mathematics: René Descartes (1643) discovered the circle theorem bearing his name, giving an algebraic formula for tangent circles. This turned Apollonius’s geometric problem into arithmetic.\n19th century: The connection to projective geometry and circle inversions was developed. Mathematicians realized that packing problems could be studied through group theory—the inversions form a discrete subgroup of the group of Möbius transformations.\n20th century: With computers, the fractal nature became visible. The Apollonian gasket was recognized as a limit set of a Kleinian group—a group of isometries of hyperbolic space. This connects to tomorrow’s material: the inversions we’re doing are actually hyperbolic isometries! In the Poincaré disk model (which we’ll see tomorrow), these inversions are reflections through hyperbolic geodesics.\nThe gasket also has connections to number theory: if the initial circles have integer curvatures, all circles in the packing do too (by Descartes’ theorem). This has led to deep questions about the distribution of integers in these packings, which remain active research areas today.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#summary",
    "href": "lectures/day2.html#summary",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.9 Summary",
    "text": "2.9 Summary\nToday we’ve explored two powerful iterative processes that generate fractals:\n\nComplex dynamics: The Mandelbrot and Julia sets emerge from iterating \\(z \\mapsto z^2 + c\\)\n\nImplemented complex arithmetic in GLSL efficiently\nLearned escape-time algorithms and the crucial escape radius theorem\nDeveloped smooth coloring techniques for anti-aliased rendering\nUnderstood the parameter space (Mandelbrot) vs dynamical space (Julia) distinction\nSaw how 1980s computational power revolutionized a 1918 theory\n\nGeometric dynamics: The Apollonian gasket emerges from iterating circle inversions\n\nCircle inversion as a conformal transformation preserving angles\nUsed structs to organize geometric data cleanly\nApplied Descartes Circle Theorem to understand tangent circle configurations\nIterated inversions through three circles to create fractal patterns\nConnected ancient Greek geometry to modern fractal theory\n\n\nBoth processes show how incredibly simple rules—a quadratic map, a geometric transformation—generate infinite complexity through iteration. The key in both cases is conformality: angle-preserving maps create geometrically coherent fractals. This is one of the core insights of fractal geometry and dynamical systems.\nThe computational perspective is also crucial: both algorithms are embarrassingly parallel, making them perfect for GPU rendering. Each pixel’s calculation is independent, and we can terminate early when orbits escape. The result is real-time rendering of infinitely detailed mathematical objects.\nTomorrow we’ll push geometric iteration further, moving from Euclidean to hyperbolic geometry. The circle inversions we’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space. We’ll explore the upper half-plane and Poincaré disk models, create \\((2,3,7)\\) and \\((2,3,\\infty)\\) triangle tilings, and see how the same algorithmic ideas (iterated geometric transformations) work in non-Euclidean geometry. The results will be even more intricate because hyperbolic space has “more room” than Euclidean space—triangles can have angle sums less than \\(\\pi\\), allowing denser tilings and more complex fractal structures.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#homework",
    "href": "lectures/day2.html#homework",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.10 Homework",
    "text": "2.10 Homework\n\nRequired: Julia Set Explorer\nImplement a Julia set renderer starting from the Mandelbrot code. The algorithm is nearly identical—you just need to swap what’s fixed and what varies!\nRequirements:\n\nStart from the Mandelbrot implementation\nFix c to a constant value (see suggestions below)\nInitialize z from the pixel position instead of zero\nIterate \\(z_{n+1} = z_n^2 + c\\) exactly as before\nUse the same escape criterion and coloring\n\nSuggested structure:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;  // Scale for Julia set viewing\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // Classic Julia set\n    \n    // Initialize z from pixel position (this is the key change!)\n    vec2 z = p;  // z_0 = pixel position\n    \n    // [Rest of iteration exactly like Mandelbrot]\n}\nInteresting parameters to try: - vec2(-0.7, 0.27015) — classic Julia set, intricate tendrils - vec2(-0.4, 0.6) — dendrite-like fractal trees\n- vec2(0.285, 0.01) — beautiful spiral patterns - vec2(-0.8, 0.156) — highly filamentary structure - vec2(-0.70176, -0.3842) — “San Marco dragon” - vec2(-0.835, -0.2321) — another classic - vec2(-0.7269, 0.1889) — “Douady’s rabbit” (famous example)\nExtension Options (pick one or both):\nOption A: Animated Parameter Space\nMake \\(c\\) depend on time to watch the Julia set morph:\nfloat angle = iTime * 0.3;\nfloat radius = 0.7885;  // Distance from origin in parameter space\nvec2 c = vec2(radius * cos(angle), radius * sin(angle));\nWatch how the Julia set changes topology as you trace a circle in the complex plane! You’ll see it transition from connected to disconnected, develop tendrils, and create organic shapes.\nOption B: Mouse-Controlled Exploration\nTie \\(c\\) to mouse position for interactive exploration:\nvec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;\nmouse_uv.x *= iResolution.x / iResolution.y;\nvec2 c = mouse_uv * 3.0;  // Scale to cover interesting parameter range\nNow you can explore parameter space by moving the mouse! This really helps build intuition for how \\(c\\) affects the Julia set. Try finding the boundary of the Mandelbrot set—parameters right at the edge produce the most intricate Julia sets.\n\n\n\n\n\n\nTipUnderstanding Connected vs Disconnected\n\n\n\nAs you explore parameter space, pay attention to whether the Julia set appears as a single connected structure or as disconnected dust. Values of \\(c\\) inside the Mandelbrot set give connected Julia sets, while values outside give disconnected ones. The most beautiful Julia sets often come from values right near the boundary of \\(\\mathcal{M}\\)!\n\n\n\n\n\nOptional #1: Grid of Julia Sets\nCreate a grid where each cell shows the Julia set for that value of \\(c\\), revealing the Mandelbrot set as an emergent pattern!\nThe idea: The Mandelbrot set is a map of Julia set topology. If we draw a grid of Julia sets for different values of \\(c\\), we should see the Mandelbrot set emerge in the overall pattern—cells with connected Julia sets (solid regions) correspond to points in \\(\\mathcal{M}\\), while cells with disconnected Julia sets (dust) are outside.\nImplementation strategy:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Divide screen into grid cells\n    float grid_size = 8.0;  // 8×8 grid of Julia sets\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;  // Local coordinates within cell\n    \n    // Map cell_id to parameter c\n    vec2 c = (cell_id / grid_size) * 4.0 - vec2(2.5, 2.0);\n    c.x -= 0.5;  // Center on interesting region of Mandelbrot set\n    \n    // Run Julia set iteration with z = cell_p, fixed c\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Optional: draw grid lines to separate cells\n    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);\n    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a grid of tiny Julia sets! If you look carefully at the overall pattern, you’ll notice it resembles the Mandelbrot set—cells with connected Julia sets (solid colored regions) correspond to points inside \\(\\mathcal{M}\\), while cells with disconnected Julia sets (fine dust patterns) are outside.\nThis is one of the most beautiful visualizations in complex dynamics—the Mandelbrot set literally encodes the topology of all Julia sets!\nVariations to try: - Adjust grid_size (larger for more detail, smaller for clearer overview) - Change the parameter space region being sampled - Color cells based on whether the Julia set appears connected (black) or disconnected (white)—you’ll get a pixelated approximation of the Mandelbrot set!\n\n\n\nOptional #2: Other Iterated Inversions\nExplore variations on the Apollonian gasket theme! The key is setting up circles in interesting configurations and iterating inversions.\nDifferent circle arrangements:\nFour circles in a square:\nvoid setupSquareCircles(out Circle c1, out Circle c2, out Circle c3, out Circle c4) {\n    float r = 0.5;\n    float d = 1.5;  // Distance from center\n    c1 = Circle(vec2(d, 0.0), r);\n    c2 = Circle(vec2(0.0, d), r);\n    c3 = Circle(vec2(-d, 0.0), r);\n    c4 = Circle(vec2(0.0, -d), r);\n}\nModify the iteration loop to check four circles instead of three!\nNested circles:\n// One large circle containing several smaller ones\nc1 = Circle(vec2(0.0, 0.0), 2.0);  // Large outer circle\nc2 = Circle(vec2(-0.5, 0.0), 0.4);  // Small inner circles\nc3 = Circle(vec2(0.5, 0.0), 0.4);\nAnimated radii:\nMake the circles pulse:\nc1.radius = 0.5 + 0.2 * sin(iTime);\nc2.radius = 0.5 + 0.2 * sin(iTime + 2.0 * 3.14159 / 3.0);\nc3.radius = 0.5 + 0.2 * sin(iTime + 4.0 * 3.14159 / 3.0);\nWatch the fractal breathe!\nAlternating inversion patterns:\nInstead of inverting through whichever circle contains the point, try a fixed cycling pattern:\n// Cycle through circles in order\nint circle_index = i % 3;\nif(circle_index == 0) {\n    p = invertCircle(p, c1.center, c1.radius);\n} else if(circle_index == 1) {\n    p = invertCircle(p, c2.center, c2.radius);\n} else {\n    p = invertCircle(p, c3.center, c3.radius);\n}\nThis creates very different patterns—more regular and less space-filling than the gasket, but with interesting self-similarity.\nChallenge problems: - Can you create a configuration that tiles the plane with circular patterns? - What about spiraling structures? - Can you make a fractal that’s asymmetric (not rotationally symmetric)? - Try combining inversion with other transformations (rotation, scaling)\nThe key is experimentation—try different setups and see what emerges!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#looking-ahead",
    "href": "lectures/day2.html#looking-ahead",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.11 Looking Ahead",
    "text": "2.11 Looking Ahead\nTomorrow we continue with geometric transformations, but move from Euclidean to hyperbolic geometry. The circle inversions you’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space!\nWe’ll explore: - Multiple models of the hyperbolic plane (upper half-plane, Poincaré disk) - Geodesics (straight lines in hyperbolic geometry—they look like circles in our Euclidean view!) - Triangle tilings with \\((2,3,7)\\) and \\((2,3,\\infty)\\) symmetry groups - Why hyperbolic space is different: triangles with angle sum less than \\(\\pi\\), exponential growth of area\nThe same algorithmic ideas we’ve used today (iterated geometric transformations, escape-time coloring, distance-based rendering) will work in hyperbolic space. But the results will be even more intricate because hyperbolic space has “more room” than Euclidean space—allowing denser tilings and more complex fractal structures.\nMake sure you’re comfortable with: - Iteration and escape-time algorithms (we’ll use similar ideas for tiling) - Circle inversion (this becomes reflection through hyperbolic geodesics!) - Structs for organizing geometric data - Coloring strategies based on orbit behavior\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html",
    "href": "lectures/day3.html",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "3.1 Overview\nToday we explore geometric tilings through reflection operations. We’ll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.\nThe key insight: the algorithm stays the same across geometries—only the reflection operations change. This mirrors what we saw on Day 2 with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region. But today we’ll understand why this works through the lens of group theory.\nBy the end of today, you’ll understand: - How to construct reflections using linear algebra - Why the folding algorithm works (reflection groups and fundamental domains) - The structure of hyperbolic geometry in the upper half-plane model - How to implement hyperbolic triangle tilings using the same algorithmic pattern - How to convert between different models of hyperbolic space - The connection between circle inversion (Day 2) and hyperbolic isometries",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#overview",
    "href": "lectures/day3.html#overview",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "NoteRoadmap for Today\n\n\n\nPart 1: Euclidean Geometry - Simple tilings (strip, square) - Half-space abstraction - Triangle tilings - Why this works: Reflection groups\nPart 2: Hyperbolic Geometry - The upper half-plane model and metric - Geodesics and reflections (connection to Day 2!) - Triangle tilings in \\(\\mathbb{H}^2\\) - Multiple models (Poincaré disk, Klein) - Historical context and applications\nThe unifying theme is geometric transformations and their groups—the same mathematical structure underlies fractals, tilings, and symmetry across all geometries.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#part-1-reflection-and-tilings-in-euclidean-geometry",
    "href": "lectures/day3.html#part-1-reflection-and-tilings-in-euclidean-geometry",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.2 Part 1: Reflection and Tilings in Euclidean Geometry",
    "text": "3.2 Part 1: Reflection and Tilings in Euclidean Geometry\n\nStarting Simple: The Folding Algorithm\nBefore we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.\n\nTiling a Strip\nImagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip \\(0 &lt; x &lt; 1\\)—and reflect any point outside this strip back inside.\nThe algorithm is remarkably simple: - If \\(x &lt; 0\\), reflect across \\(x = 0\\) - If \\(x &gt; 1\\), reflect across \\(x = 1\\)\n- Repeat until the point stops moving\nFor a vertical line at \\(x = c\\), reflection just flips the \\(x\\)-coordinate: \\((x, y) \\mapsto (2c - x, y)\\).\nHere’s a complete shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.\nWhat’s happening geometrically? Every point on the screen gets mapped back to the fundamental domain \\([0,1]\\). Points that were in reflected copies of the domain get folded back through a sequence of reflections. Since we draw the same pattern in the fundamental domain, all the reflected copies show the same pattern.\n\n\n\nSquare Tiling\nLet’s extend to two dimensions. Now we have four boundaries: \\(x = 0\\), \\(x = 1\\), \\(y = 0\\), and \\(y = 1\\). Same algorithm, just more boundaries to check:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);\n    \n    // Circle at center\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nPerfect! A full 2D tiling.\n\n\n\nSquare Tiling with Fold Count\nLet’s track how many reflections were needed. This helps us understand the geometry and creates beautiful visualizations:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! The color gradient shows how many reflections were needed—points near the fundamental domain require few iterations, while points far away need many.\nNotice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain and we can stop.\n\n\n\n\n\n\nTipComputational Efficiency: Iteration Count\n\n\n\nWhy does this converge so quickly? Each reflection moves the point strictly closer to the fundamental domain (in the sense of reducing the number of boundary crossings). For a viewport of size \\(4 \\times 4\\) and fundamental domain of size \\(1 \\times 1\\), we need at most \\(\\lceil \\log_2(4) \\rceil = 2\\) reflections per axis, so 4 reflections total in the worst case.\nThe 20-iteration limit is very conservative—most pixels converge in under 5 iterations. We could dynamically adjust this based on the coordinate scale, but for real-time rendering, a fixed conservative bound works well.\n\n\n\n\n\n\nAbstracting: Half-Spaces\nLooking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.\n\nWhat is a Half-Space?\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions: - Points where \\(ax + by &lt; c\\) - Points where \\(ax + by &gt; c\\)\nWe’ll encode a half-space by storing the line parameters and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line parameters: ax + by = c\n    float side;     // +1 or -1 for which side\n};\nThe side parameter determines which inequality we want: - side = -1.0 means we want \\(ax + by &gt; c\\) (equivalently, \\((ax + by - c) \\cdot (-1) &lt; 0\\)) - side = 1.0 means we want \\(ax + by &lt; c\\) (equivalently, \\((ax + by - c) \\cdot (1) &lt; 0\\))\nThis might seem redundant—we could always use \\(ax + by &lt; c\\) and just flip the signs of \\(a, b, c\\) to get the other side. But having an explicit side parameter makes the code clearer and will be essential in hyperbolic geometry where sign-flipping doesn’t work as cleanly.\n\n\nVisualizing Half-Spaces\nBefore we implement reflections, let’s visualize what a half-space is. Here’s a shader that colors one side of a line:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1 (left side of vertical line at x=1)\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the left side of the line colored blue, the right side dark. Try changing the half-space parameters to see how it affects the coloring!\n\n\n\n\n\n\nTipExercise: Drawing the Boundary Line\n\n\n\nWant to see where the line is? Add this distance function:\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\nThen draw the line:\nfloat d = distToHalfSpace(p, hs);\nif(d &lt; 0.02) color = vec3(1.0);  // White boundary\nThis computes the perpendicular distance from the point to the line, then colors points near the line white. See Appendix E4b for the complete implementation!\n\n\n\n\nIntersecting Half-Spaces: Making a Square\nNow let’s intersect four half-spaces to create a square region. We’ll use additive coloring—each half-space we’re inside adds to the color, so the interior (inside all four) will be brightest:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Additive coloring - each half-space adds brightness\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, left))   color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, right))  color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, bottom)) color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, top))    color += vec3(0.1, 0.15, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the square region brightest (inside all four half-spaces), with regions inside fewer half-spaces progressively darker. This additive approach makes it easy to see how the regions overlap!\n\n\n\n\n\n\nTipExercise: Improved Visualization\n\n\n\nFor a cleaner look, you might want to:\n\nBinary coloring (inside domain or not):\n\nbool in_square = inside(p, left) && inside(p, right) && \n                 inside(p, bottom) && inside(p, top);\nvec3 color = in_square ? vec3(0.4, 0.6, 0.8) : vec3(0.1, 0.1, 0.2);\n\nDraw boundaries using the distance function from earlier\nCreate an insideDomain() function:\n\nbool insideDomain(vec2 p, HalfSpace hs1, HalfSpace hs2, \n                  HalfSpace hs3, HalfSpace hs4) {\n    return inside(p, hs1) && inside(p, hs2) && \n           inside(p, hs3) && inside(p, hs4);\n}\nSee Appendix E5b for complete enhanced versions!\n\n\n\n\nThree Half-Spaces Make a Triangle\nLet’s visualize three half-spaces defining a triangle:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, hs1)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs2)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs3)) color += vec3(0.15, 0.2, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a triangle region where all three half-spaces overlap! The additive coloring helps visualize the structure.\n\n\n\nThe Reflection Formula\nNow we’re ready to implement reflection. To reflect a point \\(\\mathbf{p} = (x, y)\\) across the line \\(ax + by = c\\), we use linear algebra. The normal vector to the line is \\(\\mathbf{n} = (a, b)\\). After normalizing to \\(\\hat{\\mathbf{n}} = \\mathbf{n}/|\\mathbf{n}|\\), the reflection formula is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere \\(d\\) is the signed distance from \\(\\mathbf{p}\\) to the line:\n\\[d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\]\nThis is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.\nOur reflectInto function checks if we’re on the correct side and only reflects if necessary—it extends our inside() test by conditionally reflecting:\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    // Compute which side of the line we're on\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    // Check if we're already on the correct side (this is our inside() test!)\n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;  // Already inside, nothing to do\n    }\n    \n    // We're on the wrong side - reflect across the boundary line\n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\nThis function encapsulates the entire pattern: check if we’re on the correct side (the inside() test), and only reflect if we’re not. So reflectInto() extends and renames our visualization function to also perform the reflection!\n\n\n\n\nSquare Tiling with Half-Spaces\nLet’s rewrite our square tiling using this abstraction. For the square \\([0, 1] \\times [0, 1]\\), we need four half-spaces:\n\nLeft edge (\\(x = 0\\)): We want \\(x &gt; 0\\) → HalfSpace(1.0, 0.0, 0.0, -1.0)\nRight edge (\\(x = 1\\)): We want \\(x &lt; 1\\) → HalfSpace(1.0, 0.0, 1.0, 1.0)\nBottom and top: Similarly for \\(y\\)\n\nComplete shader:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1]×[0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);\n    \n    // Fold into the square\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, left);\n        p = reflectInto(p, right);\n        p = reflectInto(p, bottom);\n        p = reflectInto(p, top);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis looks identical to our earlier version, but now our code is flexible. The beauty: changing from a square to a triangle only requires changing the half-space definitions!\n\n\n\nTriangle Tiling\nNow we’re ready for triangles. We’ll use an equilateral triangle with vertices at:\n\\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nThis triangle is centered at the origin with one vertex pointing up.\n\nComputing Half-Spaces from Edges\nFor each edge, we need to compute the line parameters \\((a, b, c)\\) and determine the correct side. The process:\n\nTake two vertices defining an edge: \\(\\mathbf{v}_i\\) and \\(\\mathbf{v}_j\\)\nCompute edge direction: \\(\\mathbf{d} = \\mathbf{v}_j - \\mathbf{v}_i\\)\nCompute perpendicular (rotate 90° counterclockwise): \\(\\mathbf{n} = (-d_y, d_x)\\)\nLine equation: \\(n_x \\cdot x + n_y \\cdot y = c\\) where \\(c = \\mathbf{n} \\cdot \\mathbf{v}_i\\)\nTest origin: if \\((n_x \\cdot 0 + n_y \\cdot 0 - c) &lt; 0\\), then side = -1.0, else side = 1.0\n\n\n\n\n\n\n\nNoteDerivation of Triangle Half-Space Parameters\n\n\n\n\n\nEdge from \\(v_0 = (0, 1)\\) to \\(v_1 = (-\\sqrt{3}/2, -1/2)\\):\n\nEdge direction: \\(\\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\\)\nPerpendicular (90° CCW): \\(\\mathbf{n} = (1.5, -0.866)\\)\nLine: \\(1.5x - 0.866y = c\\) where \\(c = \\mathbf{n} \\cdot v_0 = (1.5)(0) + (-0.866)(1) = -0.866\\)\nFor origin (inside): \\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\\)\nWe want inside when \\((ax + by - c) &lt; 0\\), so we need side = -1.0\n\nResult: HalfSpace(1.5, -0.866, -0.866, -1.0)\nSimilar calculations give: - Edge \\(v_1\\) to \\(v_2\\): HalfSpace(0.0, 1.732, -0.866, -1.0) - Edge \\(v_2\\) to \\(v_0\\): HalfSpace(-1.5, -0.866, -0.866, -1.0)\n\n\n\nThe computed parameters are:\n\nEdge \\(v_0\\) to \\(v_1\\): HalfSpace(1.5, -0.866, -0.866, -1.0)\nEdge \\(v_1\\) to \\(v_2\\): HalfSpace(0.0, 1.732, -0.866, -1.0)\n\nEdge \\(v_2\\) to \\(v_0\\): HalfSpace(-1.5, -0.866, -0.866, -1.0)\n\nWe already verified these work with our visualization shader above!\n\n\nTriangle Tiling Shader\nNow we can implement the tiling by copying our reflection shader and just changing the half-spaces:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into the triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! You should see an infinite triangle tiling. The alternating colors show which triangles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.\n\n\n\n\n\n\nTipExercise: Visualizing Triangle Structure\n\n\n\nWant to see the edges and vertices of your triangles? This requires computing distances to half-spaces and vertices.\nFor edges (drawing the boundaries):\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\n// In main rendering:\nfloat d1 = distToHalfSpace(p, hs1);\nfloat d2 = distToHalfSpace(p, hs2);\nfloat d3 = distToHalfSpace(p, hs3);\nfloat border = min(d1, min(d2, d3));\n\nif(border &lt; 0.02) color = vec3(1.0);  // White edges\nFor vertices (marking the corners):\n// Define vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);\nvec2 v2 = vec2(0.866, -0.5);\n\n// Check distance after folding\nfloat dv0 = length(p - v0);\nfloat dv1 = length(p - v1);\nfloat dv2 = length(p - v2);\nfloat vertex_dist = min(dv0, min(dv1, dv2));\n\nif(vertex_dist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);  // Red vertices\nSee Appendix E9 for the complete enhanced version!\n\n\n\n\n\n\nWhy Does This Algorithm Work? Reflection Groups\nWe’ve implemented the folding algorithm, but why does it work? Why does iteratively reflecting guarantee we reach the fundamental domain? The answer lies in group theory.\n\nReflections Generate a Group\nEach reflection \\(r_i\\) across a half-space boundary is an isometry of the Euclidean plane—it preserves distances and angles. Composing reflections gives us more isometries. The set of all compositions of our reflections forms a group under composition:\n\nIdentity: Reflecting twice across the same line returns to the original point (\\(r_i \\circ r_i = \\text{id}\\))\nClosure: Composing reflections gives another isometry (which might be a reflection, rotation, or glide reflection)\nInverses: Every isometry has an inverse (just reflect again)\nAssociativity: Composition is associative\n\nThis group, generated by reflections across the boundaries of our fundamental domain, is called a reflection group or Coxeter group.\n\n\nThe Fundamental Domain and Orbit\nOur fundamental domain \\(F\\) (the square \\([0,1]^2\\) or triangle) is a fundamental domain for the group action. This means:\n\nEvery point in the plane is equivalent to exactly one point in \\(F\\) (modulo boundary points)\nThe orbit of \\(F\\) under the group (all images \\(g(F)\\) for \\(g\\) in the group) tiles the entire plane\nDifferent tiles \\(g(F)\\) and \\(h(F)\\) only overlap on their boundaries\n\nWhen we start with a point \\(p\\) outside \\(F\\), there exists a sequence of group elements (reflections) that maps \\(p\\) into \\(F\\). Our algorithm finds this sequence!\n\n\nWhy the Algorithm Terminates\nHere’s the key insight: each reflection across a boundary of \\(F\\) either: - Keeps the point inside \\(F\\) (if it’s already on the correct side) - Moves the point strictly closer to \\(F\\) (if it’s on the wrong side)\n“Closer” here means we reduce some discrete measure—like the number of boundaries we’re on the wrong side of. Since this number is finite and decreases with each reflection, the algorithm must terminate.\nFormally, we can define a height function \\(h(p)\\) that counts how many half-space boundaries \\(p\\) violates. Initially \\(h(p) \\geq 0\\). Each reflection that actually moves the point decreases \\(h(p)\\) by at least 1. When \\(h(p) = 0\\), the point is inside \\(F\\) and the algorithm stops.\n\n\n\n\n\n\nImportantThe Pattern Across Days\n\n\n\nThis is the same fundamental principle we’ve seen throughout:\nDay 2 (Apollonian gasket): - Group: Iterated circle inversions - Fundamental domain: The gaps between circles - Algorithm: Invert until inside the domain\nDay 3 (Euclidean tilings): - Group: Reflections across boundaries - Fundamental domain: The square/triangle - Algorithm: Reflect until inside the domain\nDay 3 (Hyperbolic, coming soon): - Group: Hyperbolic reflections (same structure!) - Fundamental domain: Hyperbolic triangle - Algorithm: Reflect until inside the domain (identical code!)\nThe unifying theme is group actions and fundamental domains. We’re always finding the unique representative of an orbit that lies in the fundamental domain.\n\n\n\n\nComputational Implications\nUnderstanding the group theory gives us insight into the computation:\nConvergence rate: For a viewport of size \\(V\\) and fundamental domain of size \\(F\\), we need at most \\(O(\\log(V/F))\\) reflections per coordinate axis. This is why small iteration limits (20-30) work well.\nParallelism: Each pixel’s orbit is independent—perfect for GPU parallelism. Millions of pixels computing orbits simultaneously with no communication needed.\nThreshold choice: The 0.0001 threshold for detecting convergence balances precision and performance. Smaller thresholds catch more subtle movements but risk floating-point noise; larger thresholds might terminate early but rarely matter for visualization.\nWhy it’s efficient: Most tiles are “nearby” in the group—they’re reached by short sequences of reflections. Only tiles far from the origin require many reflections, and these appear very small on screen (contributing few pixels).\nThis completes our Euclidean foundation. We now understand: 1. The folding algorithm in concrete examples 2. The half-space abstraction that makes it general 3. Why it works: reflection groups and fundamental domains 4. Computational properties: convergence, parallelism, efficiency\nNext, we’ll take this exact algorithmic structure into hyperbolic geometry!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#part-2-hyperbolic-geometry",
    "href": "lectures/day3.html#part-2-hyperbolic-geometry",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.3 Part 2: Hyperbolic Geometry",
    "text": "3.3 Part 2: Hyperbolic Geometry\n\nIntroduction to Hyperbolic Geometry\nHyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant negative curvature. For over two millennia, mathematicians believed Euclidean geometry was the only logically consistent geometry—Euclid’s parallel postulate seemed necessary. The discovery of hyperbolic geometry in the early 19th century revolutionized mathematics.\n\nHistorical Context: The Discovery\nThe story of hyperbolic geometry is one of the great dramas in mathematical history. For centuries, mathematicians tried to prove Euclid’s fifth postulate (the parallel postulate) from the other four axioms. What if you could have multiple parallel lines through a point?\nThree mathematicians independently discovered that this “impossible” geometry was actually perfectly consistent:\nJános Bolyai (1802-1860), a Hungarian mathematician, developed hyperbolic geometry in the 1820s. His father, a mathematician himself, warned him: “For God’s sake, I beseech you, give it up. Fear it no less than sensual passions because it too may take all your time and deprive you of your health, peace of mind and happiness in life.” But János persisted, publishing his work in 1832 as an appendix to his father’s book.\nNikolai Lobachevsky (1792-1856), a Russian mathematician, published the first account of hyperbolic geometry in 1829. He called it “imaginary geometry” and faced considerable resistance from the mathematical establishment. His work was largely ignored during his lifetime.\nCarl Friedrich Gauss (1777-1855), the “Prince of Mathematicians,” had discovered hyperbolic geometry even earlier but never published it. In his private correspondence, he revealed he’d been working on non-Euclidean geometry since the 1790s but feared the “clamor of the Boeotians” (his term for mathematical philistines). When he read Bolyai’s work in 1832, he wrote that he could not praise it “because to praise it would be to praise myself”—he’d discovered the same results years earlier but kept them private.\nThe discovery had profound implications: geometry was not a single truth about space but a family of possible consistent systems. This philosophical shift influenced everything from Einstein’s general relativity (which uses non-Euclidean geometry for curved spacetime) to modern physics and mathematics.\n\n\nModern Applications\nHyperbolic geometry appears throughout modern mathematics and physics:\n\nComplex analysis: The upper half-plane model is fundamental to the theory of modular forms, elliptic curves, and the Riemann mapping theorem\nNumber theory: The action of \\(SL(2,\\mathbb{Z})\\) on \\(\\mathbb{H}^2\\) produces modular forms—functions crucial to the proof of Fermat’s Last Theorem\nTopology: The study of 3-manifolds and knot theory often requires understanding hyperbolic structures\nTeichmüller theory: Moduli spaces of Riemann surfaces have natural hyperbolic metrics\nKleinian groups: Discrete subgroups of hyperbolic isometries produce fractal limit sets (like we saw with the Apollonian gasket!)\nGeneral relativity: Anti-de Sitter space has constant negative curvature—hyperbolic geometry in spacetime\nMachine learning: Recent work uses hyperbolic embeddings to represent hierarchical data efficiently\n\n\n\nKey Properties\nWhat makes hyperbolic geometry different from Euclidean geometry?\nParallel lines: Given a line and a point not on it, there are infinitely many lines through the point that don’t intersect the given line (all parallel to it). This is the defining feature that distinguishes hyperbolic geometry.\nTriangle angles: The sum of angles in a triangle is less than \\(\\pi\\). In fact, the area of a hyperbolic triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) is exactly: \\[\\text{Area} = \\pi - (\\alpha + \\beta + \\gamma)\\] This is the Gauss-Bonnet theorem for hyperbolic triangles—a beautiful connection between geometry (angles) and topology (area).\nExponential growth: In Euclidean geometry, the circumference of a circle grows linearly with radius (\\(C = 2\\pi r\\)). In hyperbolic geometry, it grows exponentially: \\(C \\sim e^r\\) for large \\(r\\). This means hyperbolic space has “more room” than Euclidean space—there’s exponentially more area at distance \\(r\\) from a point.\nNo similarity: In Euclidean geometry, you can scale any shape—a small triangle and a large triangle with the same angles are similar. In hyperbolic geometry, there’s an absolute unit of length built into the curvature. All triangles with angles \\((\\pi/2, \\pi/3, \\pi/7)\\) are congruent—there’s no “scaled version.” This makes hyperbolic geometry richer but more rigid.\nThese properties create the “extra room” that allows much richer tiling structures than Euclidean geometry.\n\n\n\n\nThe Upper Half-Plane Model\nWe’ll work in the upper half-plane model of hyperbolic geometry, denoted \\(\\mathbb{H}^2\\):\n\\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThis is just complex numbers with positive imaginary part—the upper half of the complex plane. The real axis \\(\\{y = 0\\}\\) forms the boundary “at infinity”—it’s not actually part of \\(\\mathbb{H}^2\\), but represents points infinitely far away in hyperbolic distance.\n\nThe Hyperbolic Metric\nThe hyperbolic metric is what makes \\(\\mathbb{H}^2\\) a hyperbolic space:\n\\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\nThis gives \\(\\mathbb{H}^2\\) the structure of a complete Riemannian manifold with constant curvature \\(-1\\).\nWhat does this mean? The factor \\(1/y^2\\) is a conformal factor that scales the Euclidean metric. As \\(y \\to 0\\) (approaching the boundary), this scaling factor blows up—distances that look small Euclidean-wise are enormous hyperbolically. As \\(y \\to \\infty\\) (going “up” in the upper half-plane), the scaling factor goes to zero—large Euclidean distances are actually finite hyperbolically.\nThe metric is conformal to the Euclidean metric—it preserves angles but not lengths. If two curves meet at angle \\(\\theta\\) in the Euclidean sense, they also meet at angle \\(\\theta\\) in the hyperbolic sense! This is why you can trust your eyes when looking at pictures—angles are what they appear to be.\n\n\nThe Distance Formula\nIntegrating the metric along paths gives the hyperbolic distance between two points \\(z_1 = x_1 + iy_1\\) and \\(z_2 = x_2 + iy_2\\):\n\\[d_{\\mathbb{H}^2}(z_1, z_2) = \\text{arcosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2y_1 y_2}\\right)\\]\nwhere \\(|z_1 - z_2| = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\\) is the usual Euclidean distance.\nNotice the \\(1/y_1 y_2\\) factor—points near the boundary (\\(y\\) small) are very far apart hyperbolically even if they’re close Euclidean-wise.\nDerivation sketch: For a vertical line from \\(z_1 = x + iy_1\\) to \\(z_2 = x + iy_2\\), the hyperbolic length is: \\[\\int_{y_1}^{y_2} \\frac{dy}{y} = \\log(y_2) - \\log(y_1) = \\log(y_2/y_1)\\]\nFor a general path, you need to integrate along the geodesic connecting the points (which might not be a straight Euclidean line), giving the arcosh formula above.\n\n\nVisualizing Hyperbolic Distance\nLet’s make this concrete with an interactive shader. We’ll start with Euclidean distance, then switch to hyperbolic to see the difference.\nEuclidean distance circles:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);  // Shift up so we're in y &gt; 0\n    \n    // Mouse position as center (or default)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);  // Default if no click\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Euclidean distance\n    float dist = length(p - center);\n    \n    // Draw a disk of radius 0.5 using two circles\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer circle (slightly larger)\n    if(dist &lt; radius + 0.02) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner circle (slightly smaller) - \"cuts out\" interior\n    if(dist &lt; radius - 0.02) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center point\n    if(length(p - center) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nClick and drag around—the circle stays the same size everywhere. This is Euclidean distance: uniform across the plane. Notice how we draw the boundary: we draw a filled circle at radius \\(r + \\epsilon\\) (outer edge), then draw another filled circle at radius \\(r - \\epsilon\\) (inner edge) in a different color. The ring between them is our boundary!\nHyperbolic distance circles:\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // arccosh(arg)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Mouse position as center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Hyperbolic distance\n    float dist = hyperbolicDistance(p, center);\n    \n    // Draw a hyperbolic disk using two \"circles\"\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer boundary\n    if(dist &lt; radius + 0.05) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner region\n    if(dist &lt; radius - 0.05) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center\n    if(hyperbolicDistance(p, center) &lt; 0.1) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow drag the center around! Notice how the “circle” changes shape as you move it. Near the bottom (\\(y \\to 0\\)), the circle appears huge Euclidean-wise—that’s because we’re near the boundary where hyperbolic distances blow up. Higher up (\\(y\\) large), the circle appears smaller.\nThis visualization makes the \\(1/y^2\\) conformal factor visceral: hyperbolic space is compressed near the boundary.\n\n\n\n\nThe Boundary at Infinity\nThe real axis \\(\\{y = 0\\}\\) is not part of \\(\\mathbb{H}^2\\), but we can think of it as the boundary at infinity—points infinitely far away in hyperbolic distance.\nIdeal points as equivalence classes: An ideal point on the boundary can be defined as an equivalence class of geodesics that asymptotically approach each other. Two geodesics are equivalent if the hyperbolic distance between them goes to zero as you go to infinity along them.\nFor example, the vertical line \\(\\{x = 0\\}\\) and the vertical line \\(\\{x = \\epsilon\\}\\) (for small \\(\\epsilon\\)) both approach the point \\(0\\) on the real axis. As you go up (\\(y \\to \\infty\\)), the hyperbolic distance between corresponding points goes to zero—they’re asymptotically parallel.\nGeometric intuition: In the Poincaré disk model (which we’ll see soon), the boundary at infinity is literally the unit circle \\(|z| = 1\\). Points on this circle are infinitely far away from any interior point, but they still have geometric meaning—they represent directions or “points at infinity.”\nWhy this matters: When we define hyperbolic triangles, we can have vertices “at infinity” on the boundary. These are called ideal vertices or ideal triangles. For instance, our \\((2,3,\\infty)\\) triangle has one vertex at the point \\(\\infty\\) in the upper half-plane (straight up the imaginary axis). The angle at an ideal vertex is zero—the sides become asymptotically parallel as they approach the boundary.\nThe Gauss-Bonnet theorem still works: for a triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), the area is \\(\\pi - (\\alpha + \\beta + \\gamma)\\). If one angle is zero (ideal vertex), the area is \\(\\pi - \\alpha - \\beta &gt; 0\\)—ideal triangles have finite area!\n\n\n\nGeodesics and Reflections\n\nGeodesics in the Upper Half-Plane\nGeodesics (the “straight lines” of hyperbolic geometry—curves that locally minimize distance) in \\(\\mathbb{H}^2\\) have exactly two forms:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c \\in \\mathbb{R}\\)\nSemicircles: Centered on the real axis, perpendicular to it\n\nThese curves meet the boundary at right angles—this is the characterizing property of geodesics in this model.\nWhy these are geodesics: Reflections across these curves are isometries (they preserve the hyperbolic metric \\(ds^2 = \\frac{dx^2+dy^2}{y^2}\\)). An isometry’s fixed point set is always a geodesic! So we just need to verify that reflection across vertical lines and semicircles preserves the metric.\nFor vertical lines, this is obvious: reflecting across \\(x = c\\) sends \\((x,y) \\mapsto (2c-x, y)\\), which preserves both the Euclidean distance \\(dx^2 + dy^2\\) and the \\(y\\)-coordinate, hence preserves \\(\\frac{dx^2+dy^2}{y^2}\\).\nFor semicircles, we use circle inversion from Day 2! A semicircle centered at \\((c, 0)\\) with radius \\(R\\) is preserved by the inversion: \\[z \\mapsto c + R^2 \\frac{z - c}{|z - c|^2}\\]\nCircle inversion is conformal (preserves angles) and scales distances by exactly \\(1/y^2\\) near the boundary—precisely the conformal factor in the hyperbolic metric! So inversions through semicircles are hyperbolic isometries. Their fixed point sets (the semicircles themselves) are therefore geodesics.\n\n\n\n\n\n\nImportantConnection to Day 2: Circle Inversion is a Hyperbolic Isometry!\n\n\n\nThis is a profound connection: the circle inversions we used on Day 2 for the Apollonian gasket were actually hyperbolic isometries all along! The Apollonian gasket lives in hyperbolic space—the gaps between circles are hyperbolic regions, and the inversions are reflections across hyperbolic geodesics (semicircles).\nWhen we iterated inversions on Day 2, we were doing exactly what we’re doing today—finding the fundamental domain of a group action! The Apollonian gasket is a hyperbolic object, just like our triangle tilings. The same group-theoretic principles apply.\nThis is why the techniques work across days: we’re always working with group actions, whether we realize it or not. The mathematics unifies everything.\n\n\n\n\nImplementing Reflections\nFor vertical lines (like \\(x = c\\)), reflection is simple—flip the \\(x\\)-coordinate:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    // Check if we're on the correct side\n    if((z.x - x_pos) * side &lt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Reflect: (x,y) ↦ (2c - x, y)\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\nFor semicircles (geodesics from point \\(p\\) to point \\(q\\) on the real axis), we use circle inversion. The semicircle has center \\((c, 0)\\) where \\(c = (p+q)/2\\) and radius \\(R = |p-q|/2\\):\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    \n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);  // Squared distance from center\n    \n    // Check if we're on the correct side\n    if((dist2 - radius * radius) * side &gt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Circle inversion (from Day 2!)\n    vec2 inverted = vec2(center, 0.0) + (radius * radius) * rel / dist2;\n    return inverted;\n}\nNote: We’re inverting through a circle in the Euclidean sense (using Euclidean distance dist2), but this operation is actually a hyperbolic isometry! The magic is that circle inversion’s conformal properties exactly match the hyperbolic metric’s requirements.\n\n\n\n\n\n\nNoteWhy Two Types of Reflections?\n\n\n\nIn Euclidean geometry, all reflections across lines look the same—just the orientation changes. Why do we need two different functions in hyperbolic geometry?\nThe answer is that we’re working in a model of hyperbolic geometry (the upper half-plane). The vertical lines and semicircles are the images of geodesics in this model. In the intrinsic hyperbolic geometry, all reflections across geodesics are the same—there’s only one type of reflection.\nBut when we represent hyperbolic geometry in the Euclidean upper half-plane, geodesics appear as two different types of curves (vertical lines and semicircles), so we need two different formulas. This is an artifact of the model, not the geometry itself.\nIn the Poincaré disk model (coming soon), ALL geodesics are circular arcs perpendicular to the boundary circle, so we’d only need one reflection function there!\n\n\n\n\n\n\nThe (2,3,∞) Triangle\nLet’s build our first hyperbolic triangle tiling. The notation \\((p, q, r)\\) means the triangle has angles \\(\\pi/p\\), \\(\\pi/q\\), and \\(\\pi/r\\) at its three vertices. So \\((2,3,\\infty)\\) means angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an ideal vertex at infinity).\nWhy this triangle exists in hyperbolic geometry: The Gauss-Bonnet theorem tells us the area of a hyperbolic triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) is: \\[\\text{Area} = \\pi - (\\alpha + \\beta + \\gamma)\\]\nFor a \\((2,3,\\infty)\\) triangle: \\[\\text{Area} = \\pi - \\left(\\frac{\\pi}{2} + \\frac{\\pi}{3} + 0\\right) = \\pi - \\frac{5\\pi}{6} = \\frac{\\pi}{6} &gt; 0\\]\nSo this triangle has finite positive area and can tile the hyperbolic plane. In Euclidean geometry, \\(\\pi/2 + \\pi/3 = 5\\pi/6 &lt; \\pi\\), but that’s not enough—we’d need the sum to equal exactly \\(\\pi\\) to get zero curvature. Since \\(5\\pi/6 &lt; \\pi\\), there’s negative curvature left over, making this a hyperbolic triangle.\nConfiguration: We’ll use a particularly nice setup in the upper half-plane: - Left boundary: Vertical line at \\(x = -1\\) - Right boundary: Vertical line at \\(x = 1\\)\n- Bottom boundary: Unit semicircle from \\(-1\\) to \\(1\\) (centered at origin, radius \\(1\\))\nThis creates a triangle with: - Two finite vertices at approximately \\((-1, 0)\\) and \\((1, 0)\\) (technically infinitesimally above the real axis) - One ideal vertex at \\(\\infty\\) (straight up the imaginary axis) - Angles of \\(\\pi/2\\) at the bottom two vertices (vertical line meets semicircle at right angles) - Angle of \\(\\pi/3\\) between the two vertical lines when measured hyperbolically - Angle of \\(0\\) at the ideal vertex \\(\\infty\\)\n\nImplementation\nHere’s the complete shader:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis \\(y = 0\\))—they’re all the same hyperbolic size, but Euclidean distances compress due to the \\(1/y^2\\) metric.\nThe alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.\n\n\n\n\n\n\nNoteCompare to Euclidean\n\n\n\nLook at the structure of this shader compared to the Euclidean triangle tiling:\nEuclidean:\np = reflectInto(p, hs1);\np = reflectInto(p, hs2);\np = reflectInto(p, hs3);\nHyperbolic:\nz = reflectIntoVertical(z, -1.0, -1.0);\nz = reflectIntoVertical(z, 1.0, 1.0);\nz = reflectIntoCircular(z, -1.0, 1.0, 1.0);\nThe algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.\n\n\n\n\n\n\n\n\nTipComputational Analysis\n\n\n\nGPU Parallelism: Just like Days 1 and 2, this algorithm is embarrassingly parallel. Each pixel computes independently—no communication, no shared state, perfect for GPU architecture.\nConvergence: The folding algorithm works for the same group-theoretic reasons as the Euclidean case. The three reflections generate a discrete group of hyperbolic isometries, and our fundamental triangle is a fundamental domain for this group’s action on \\(\\mathbb{H}^2\\).\nPrecision issues: Near \\(y \\to 0\\), floating-point precision degrades. The large conformal factor \\(1/y^2\\) amplifies small errors in distance calculations. This is why we darken the region \\(y &lt; 0\\)—technically it’s not part of the hyperbolic plane, but also our numerics become unreliable there.\nThreshold \\(0.0001\\): This convergence threshold balances precision and performance. Smaller thresholds catch more subtle movements but risk getting stuck in floating-point noise; larger thresholds might terminate early. For visualization purposes, \\(0.0001\\) is a good sweet spot.\nMemory efficiency: Each pixel only needs to store its current position z (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures—just stateless iteration. This is as memory-efficient as you can get!\n\n\n\n\n\n\n\n\nTipExercise: Visualizing Hyperbolic Triangle Structure\n\n\n\nWant to see the edges and vertices of your hyperbolic triangles? This requires computing hyperbolic distances.\nFor hyperbolic distance:\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\nFor drawing edges (vertical lines):\n// Distance to vertical line x = c\nfloat distToVertical = abs(z.x - c);\nif(distToVertical &lt; 0.02) color = vec3(1.0);\nFor drawing edges (semicircular geodesics):\n// Distance to semicircle from p to q\nfloat center = (p + q) / 2.0;\nfloat radius = abs(p - q) / 2.0;\nfloat distToCircle = abs(length(z - vec2(center, 0.0)) - radius);\n// Only draw if above real axis\nif(z.y &gt; 0.0 && distToCircle &lt; 0.02) color = vec3(1.0);\nFor vertices:\n// Check hyperbolic distance to vertices after folding\nvec2 v1 = vec2(-1.0, 0.01);  // Left vertex (slightly above axis)\nvec2 v2 = vec2(1.0, 0.01);   // Right vertex\nif(hyperbolicDistance(z, v1) &lt; 0.1 || hyperbolicDistance(z, v2) &lt; 0.1) {\n    color = vec3(1.0, 0.0, 0.0);  // Red vertices\n}\nSee Appendix H5 for the complete enhanced implementation!\n\n\n\n\n\n\nMultiple Models of Hyperbolic Space\nThe upper half-plane is just one way to represent hyperbolic geometry. There are several other models, each with advantages:\n\nThe Poincaré Disk Model\nThe Poincaré disk model represents all of \\(\\mathbb{H}^2\\) as the interior of the unit disk \\(\\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\). The boundary circle \\(|z| = 1\\) represents points at infinity.\nGeodesics in this model are: - Diameters of the disk (straight lines through the origin) - Circular arcs perpendicular to the boundary circle\nThe conformal factor here is \\(\\frac{4}{(1-|z|^2)^2}\\), which blows up as \\(|z| \\to 1\\) (approaching the boundary).\nAdvantages: - The entire hyperbolic plane fits in a bounded region (the disk) - All geodesics look similar (circular arcs)—no distinction between vertical and circular - Visually intuitive for understanding the full structure at once\nDisadvantages: - Harder to compute distances - More complex reflection formulas\n\n\nConverting Between Models: The Cayley Transform\nWe can convert between the upper half-plane and Poincaré disk using the Cayley transform (also called the Möbius transformation):\n\\[w = \\frac{z - i}{z + i}\\]\nThis maps: - Upper half-plane \\(\\{z : \\operatorname{Im}(z) &gt; 0\\}\\) → Poincaré disk \\(\\{w : |w| &lt; 1\\}\\) - Real axis \\(\\{z : \\operatorname{Im}(z) = 0\\}\\) → Unit circle \\(\\{w : |w| = 1\\}\\) - Point \\(i\\) in the upper half-plane → origin \\(0\\) in the disk\nThe inverse transform is: \\[z = i\\frac{1 + w}{1 - w}\\]\nHere’s the implementation:\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 uhpToDisk(vec2 z) {\n    // w = (z - i) / (z + i)\n    vec2 i = vec2(0.0, 1.0);\n    return cdiv(z - i, z + i);\n}\n\nvec2 diskToUhp(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\nTo display your tiling in the Poincaré disk:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;  // Fit disk in viewport\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 z = diskToUhp(uv);\n    \n    // Run your tiling algorithm in UHP\n    // ... (fold into (2,3,∞) triangle as before)\n    \n    // Color and render\n    fragColor = vec4(color, 1.0);\n}\n\n\nThe Klein Model\nThe Klein model (also called the Beltrami-Klein model or projective disk model) is another disk representation. Its defining feature: geodesics are Euclidean straight lines! This makes some geometric properties clearer but sacrifices the conformal property—angles are distorted.\nConverting from Poincaré disk to Klein disk:\n\\[\\text{Klein}(w) = \\frac{2w}{1 + |w|^2}\\]\nvec2 poincareToKlein(vec2 w) {\n    float denom = 1.0 + dot(w, w);\n    return 2.0 * w / denom;\n}\nThe inverse:\n\\[w = \\frac{\\text{Klein}(w)}{1 + \\sqrt{1 - |\\text{Klein}(w)|^2}}\\]\nvec2 kleinToPoincare(vec2 k) {\n    float k2 = dot(k, k);\n    float denom = 1.0 + sqrt(1.0 - k2);\n    return k / denom;\n}\nAdvantages of Klein: - Geodesics are straight lines (simplest to compute) - Great for understanding incidence relationships\nDisadvantages: - Not conformal—angles are distorted - Harder to see hyperbolic distances\n\n\n\n\nOther Triangle Groups\nThe \\((2,3,\\infty)\\) triangle is just the beginning. Many other hyperbolic triangles can tile the plane! The most famous is the \\((2,3,7)\\) triangle.\n\nThe \\((2,3,7)\\) Triangle\nThis triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(\\pi/7\\). Its area is: \\[\\text{Area} = \\pi - \\left(\\frac{\\pi}{2} + \\frac{\\pi}{3} + \\frac{\\pi}{7}\\right) = \\frac{\\pi}{42}\\]\nThis is one of the smallest compact hyperbolic triangles! It produces incredibly dense tilings—the \\((2,3,7)\\) tiling has a 7-fold symmetry that creates intricate patterns reminiscent of M.C. Escher’s work.\nIn fact, Escher’s famous Circle Limit prints (especially Circle Limit III with the fish) are based on tilings by \\((2,3,7)\\) and related triangle groups. The hyperbolic geometry creates the exponential compression toward the boundary that gives these prints their distinctive character.\nClassification of hyperbolic triangles: Not every combination \\((p,q,r)\\) gives a hyperbolic triangle. The Gauss-Bonnet formula tells us we need: \\[\\frac{1}{p} + \\frac{1}{q} + \\frac{1}{r} &lt; 1\\]\nfor a hyperbolic triangle (negative curvature). If the sum equals exactly \\(1\\), we get a Euclidean triangle. If the sum is greater than \\(1\\), we get a spherical triangle (positive curvature).\nExamples: - \\((2,3,7)\\): \\(\\frac{1}{2} + \\frac{1}{3} + \\frac{1}{7} = \\frac{41}{42} &lt; 1\\) ✓ Hyperbolic - \\((2,3,\\infty)\\): \\(\\frac{1}{2} + \\frac{1}{3} + 0 = \\frac{5}{6} &lt; 1\\) ✓ Hyperbolic - \\((3,3,3)\\): \\(\\frac{1}{3} + \\frac{1}{3} + \\frac{1}{3} = 1\\) ✓ Euclidean (equilateral triangle) - \\((2,3,5)\\): \\(\\frac{1}{2} + \\frac{1}{3} + \\frac{1}{5} = \\frac{31}{30} &gt; 1\\) ✓ Spherical (icosahedron face)\nImplementing other triangle groups requires computing where the third geodesic should be, given the angle constraints. This is non-trivial and involves hyperbolic trigonometry—we leave this as an advanced homework exercise!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#summary",
    "href": "lectures/day3.html#summary",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.4 Summary",
    "text": "3.4 Summary\nToday we learned:\n\nThe folding algorithm: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry\nHalf-space structure: Boundary + side gives a unified way to encode regions in Euclidean geometry\nWhy it works: Reflection groups and fundamental domains—the group-theoretic perspective that unifies all our iterative algorithms across Days 2 and 3\nHyperbolic geometry: Negative curvature space with two types of geodesics (vertical lines and semicircles in the UHP model)\nConnection to Day 2: Circle inversion is a hyperbolic isometry! The Apollonian gasket is actually a hyperbolic object\nTwo reflection functions: reflectIntoVertical and reflectIntoCircular parallel the Euclidean reflectInto\nMultiple models: Converting between upper half-plane and Poincaré disk using the Cayley transform\nHistorical context: The dramatic discovery of hyperbolic geometry by Gauss, Bolyai, and Lobachevsky in the 19th century\nComputational perspective: GPU parallelism, convergence rates, precision issues, iteration count tuning\n\nKey insight: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!\nThe universal pattern: - Day 1: Distance fields and implicit curves—visualizing mathematics on the GPU - Day 2: Iterating circle inversions to create the Apollonian gasket—first group action - Day 3 (Euclidean): Iterating reflections to create tilings—reflection groups make it work - Day 3 (Hyperbolic): Same algorithm, different geometry—circle inversion reappears as hyperbolic isometry!\nThe through-line is geometric transformations and their groups. When we iterate a group action to reach a fundamental domain, we create tilings, fractals, and beautiful mathematical art.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#homework",
    "href": "lectures/day3.html#homework",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.5 Homework",
    "text": "3.5 Homework\n\nRequired #0: Understanding Hyperbolic Distance\nGoal: Build geometric intuition for how hyperbolic distance works before implementing tilings.\nTasks:\n\nEuclidean distance visualization: Implement the shader showing Euclidean distance circles (provided in lecture). Drag the center around and observe that circles stay the same size everywhere.\nHyperbolic distance visualization: Implement the hyperbolic version (provided in lecture). Drag the center and observe how the “circle” changes shape—growing huge near \\(y \\to 0\\) and shrinking as \\(y\\) increases.\nObservations: Write 2-3 sentences describing what you observe about how hyperbolic “circles” behave compared to Euclidean ones. Why does the shape change as you drag the center?\n\nExpected output: Two working shaders demonstrating the difference between Euclidean and hyperbolic distance.\n\n\n\nRequired #1: Euclidean Triangle Tiling with Edges and Vertices\nGoal: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.\nTasks:\n\nStart with the basic triangle tiling from lecture\nAdd edge visualization using distance to half-spaces\nAdd vertex markers at the three triangle vertices\nCreate an attractive color scheme\n\nExpected output: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.\nSee Appendix E9 for reference implementation.\nBonus: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.\n\n\n\nRequired #2: Hyperbolic Triangle Tiling with Edges and Vertices\nGoal: Create a beautiful hyperbolic triangle tiling with visible structure.\nTasks:\n\nStart with the basic \\((2,3,\\infty)\\) tiling from lecture\nImplement hyperbolic distance functions (see hints in lecture)\nDraw geodesic edges using hyperbolic distance to geodesics\nDraw vertices using hyperbolic distance to vertex points\nCreate an attractive color scheme\n\nExpected output: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.\nSee Appendix H5 for complete reference implementation.\nBonus: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.\n\n\n\nRequired #3: Model Conversions\nGoal: See the same tiling in different representations of hyperbolic space.\nTasks:\n\nPoincaré Disk (already provided in lecture): Verify it works with your tiling code\nKlein Model: Implement the transformation from Poincaré disk to Klein disk (see lecture for formula)\nIn the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.\nComparison: Show your \\((2,3,\\infty)\\) tiling in both the Poincaré disk and Klein model side-by-side. Write a few sentences about what you observe.\n\nDeliverable: Screenshots of your tiling in at least two models, with brief observations.\nSee Appendix H7 for Klein model reference.\n\n\n\nRequired #4: Different Triangle Groups (Challenge!)\nGoal: Explore other hyperbolic tilings by implementing different triangle groups.\nThe Challenge: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.\nSuggested triangles to try: - (2, 3, 7): Creates Escher-like tilings with 7-fold symmetry - (2, 4, 6): Different symmetry pattern - (3, 3, 3): Equilateral hyperbolic triangle\nApproach: Use the hyperbolic law of cosines (see lecture for formula) to compute geodesic positions.\nDeliverable: Working tiling for at least one triangle group other than \\((2,3,\\infty)\\). Include screenshots and document your approach.\n\n\n\nOptional Exercises\nOptional #1: Unified Abstractions - Create structs that work for both Euclidean and hyperbolic geometry\nOptional #2: Decorated Tiles - Add Escher-style patterns within fundamental domains\nOptional #3: Pentagon Tilings - Right-angled pentagons can tile hyperbolic space!\nSee lecture for details on these optional exercises.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "lectures/day3.html#looking-ahead",
    "href": "lectures/day3.html#looking-ahead",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.6 Looking Ahead",
    "text": "3.6 Looking Ahead\nWe’ve now seen three days of geometric iteration: - Day 1: Distance fields and implicit functions - Day 2: Circle inversion and the Apollonian gasket - Day 3: Reflection groups in Euclidean and hyperbolic geometry\nThe common thread: group actions on geometric spaces. Iteratively applying transformations to reach a desired region, whether it’s the fundamental domain of a tiling or the gap structure of a fractal.\nThe techniques you’ve learned—GPU parallelism, iterative algorithms, group theory, geometric transformations—apply across a huge landscape of mathematical visualization!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "lectures/day4.html",
    "href": "lectures/day4.html",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "4.1 Overview\nToday we enter the third dimension! We’ll learn how to cast rays from a camera and test for intersections with 3D objects. We’ll start with analytical methods (solving equations directly) for spheres and tori, then transition to raymarching with signed distance functions—a more flexible approach that enables complex procedural scenes.\nBy the end of today, you’ll understand: - How to set up a camera and generate rays for each pixel - Analytical ray-object intersection for simple surfaces - Why analytical methods become challenging for complex geometry - Signed distance functions as an alternative representation - The raymarching algorithm (sphere tracing) - How to compose multiple objects and assign materials",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "lectures/day4.html#part-1-analytical-ray-tracing",
    "href": "lectures/day4.html#part-1-analytical-ray-tracing",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.2 Part 1: Analytical Ray Tracing",
    "text": "4.2 Part 1: Analytical Ray Tracing\n\nCamera and Ray Setup\n\nThe Rendering Pipeline\nFor each pixel, we need to: 1. Generate a ray from the camera through that pixel 2. Find where (if anywhere) the ray intersects scene geometry 3. Compute color based on surface properties and lighting\n\n\nCoordinate System\nWe’ll use the standard graphics convention: - Y-axis points up - Z-axis points toward the camera (out of the screen) - X-axis points right - Right-handed coordinate system\n\n\nPinhole Camera Model\nOur camera sits at the origin looking down the negative Z-axis. For a pixel at normalized coordinates \\((u, v) \\in [-1, 1]^2\\), we generate a ray:\nRay origin: \\(\\mathbf{o} = (0, 0, 0)\\) (camera position)\nRay direction: \\(\\mathbf{d} = \\text{normalize}(u, v, -f)\\)\nwhere \\(f\\) is the focal length, related to field of view by: \\(f = 1/\\tan(\\text{FOV}/2)\\).\n\n\nParametric Ray Equation\nA ray can be written as: \\[\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(t \\geq 0\\) is the parameter. Points along the ray correspond to different values of \\(t\\).\n\n\nImplementation\nLet’s start by visualizing our rays without any intersections:\nShader 1: Ray Visualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates to [-1, 1]\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Field of view\n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    // Ray direction (camera at origin, looking down -Z)\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Color based on ray direction (visualize the rays)\n    vec3 color = rayDir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a colorful gradient showing the direction of each ray. This confirms our camera setup is working!\n\n\n\n\nRay-Sphere Intersection\n\nThe Sphere Equation\nA sphere of radius \\(r\\) centered at position \\(\\mathbf{c}\\) is defined by: \\[|\\mathbf{p} - \\mathbf{c}|^2 = r^2\\]\nAll points \\(\\mathbf{p}\\) satisfying this equation lie on the sphere’s surface.\n\n\nFinding the Intersection\nWe want to find where our ray \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) intersects the sphere. Substituting the ray equation into the sphere equation: \\[|\\mathbf{o} + t\\mathbf{d} - \\mathbf{c}|^2 = r^2\\]\nLet \\(\\mathbf{oc} = \\mathbf{o} - \\mathbf{c}\\) (vector from sphere center to ray origin). Expanding: \\[|\\mathbf{oc} + t\\mathbf{d}|^2 = r^2\\] \\[|\\mathbf{oc}|^2 + 2t(\\mathbf{oc} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nThis is a quadratic equation in \\(t\\): \\[at^2 + bt + c = 0\\]\nwhere: - \\(a = |\\mathbf{d}|^2\\) (equals 1 if direction is normalized) - \\(b = 2(\\mathbf{oc} \\cdot \\mathbf{d})\\) - \\(c = |\\mathbf{oc}|^2 - r^2\\)\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us: - \\(\\Delta &lt; 0\\): no intersection (ray misses sphere) - \\(\\Delta = 0\\): one intersection (ray grazes sphere) - \\(\\Delta &gt; 0\\): two intersections (ray enters and exits)\nWe want the smaller positive \\(t\\) (the entry point).\n\n\nImplementation\nShader 2: Basic Sphere\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);  // Should be 1.0 if rayDir is normalized\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    // Return the closer intersection\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    // Return closest positive t\n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;  // Both behind camera\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere parameters\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    // Test intersection\n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit the sphere\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    } else {\n        // Background\n        color = vec3(0.1, 0.1, 0.2);  // Dark blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a flat red disk! It looks 2D because we don’t have lighting yet—we can’t see the sphere’s curvature.\n\n\n\n\nAdding Lighting\nTo see the 3D structure, we need to compute lighting based on the surface normal.\n\nSurface Normal\nFor a sphere centered at \\(\\mathbf{c}\\), the outward normal at surface point \\(\\mathbf{p}\\) is: \\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the vector from center to surface, normalized.\n\n\nDiffuse Lighting\nThe simplest lighting model: Lambertian diffuse shading. Surface brightness depends on the angle between the normal \\(\\mathbf{n}\\) and light direction \\(\\mathbf{l}\\): \\[\\text{brightness} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max(0, \\cdots)\\) ensures surfaces facing away from the light remain dark.\nShader 3: Sphere with Lighting\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) return -1.0;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvec3 sphereNormal(vec3 hitPoint, vec3 sphereCenter, float radius) {\n    return (hitPoint - sphereCenter) / radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit point\n        vec3 hitPoint = rayOrigin + t * rayDir;\n        \n        // Surface normal\n        vec3 normal = sphereNormal(hitPoint, sphereCenter, sphereRadius);\n        \n        // Light direction (from above and to the right)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        \n        // Diffuse lighting\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Sphere color\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);  // Red\n        color = sphereColor * diffuse;\n        \n        // Add ambient light so dark side isn't completely black\n        color += sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow the sphere looks 3D! The lighting reveals its curvature. Beautiful!\n\n\n\n\nRay-Torus Intersection: Where Analytical Gets Complex\n\nThe Torus Equation\nA torus with major radius \\(R\\) (distance from center to tube center) and minor radius \\(r\\) (tube thickness) has the implicit equation: \\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nOr in vector form: \\[\\left(|\\mathbf{p}_{xz}| - R\\right)^2 + p_y^2 = r^2\\]\nwhere \\(\\mathbf{p}_{xz} = (p_x, p_z)\\) is the projection onto the XZ-plane.\n\n\nThe Challenge\nSubstituting our ray equation into this gives a quartic polynomial (degree 4): \\[at^4 + bt^3 + ct^2 + dt + e = 0\\]\nUnlike quadratics (which have a simple formula), quartic equations require sophisticated algebraic methods. Here’s what solving it actually looks like:\nShader 4: Analytical Torus\n// From Inigo Quilez - https://www.shadertoy.com/view/XdSGWy\n// Analytical quartic solver for torus intersection\nfloat intersectTorus(vec3 ro, vec3 rd, vec2 tor)\n{\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01)\n    {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0)\n    {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4)\n    {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    return result;\n}\n\nvec3 torusNormal(vec3 pos, vec2 tor)\n{\n    return normalize(pos * (dot(pos,pos) - tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Torus parameters\n    vec2 torus = vec2(1.0, 0.4);  // (major radius, minor radius)\n    vec3 torusCenter = vec3(0.0, 0.0, -3.5);\n    \n    // Adjust ray for torus position\n    vec3 ro = rayOrigin - torusCenter;\n    \n    float t = intersectTorus(ro, rayDir, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ro + t * rayDir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = torusColor * diffuse + torusColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nLook at that intersection code! Over 80 lines of complex algebra just to render one torus. And this is still a relatively simple surface—imagine arbitrary algebraic varieties, or trying to combine multiple objects with boolean operations.\nAnalytical methods work beautifully for simple geometry, but we need a more flexible approach for complex scenes.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "lectures/day4.html#part-2-signed-distance-functions-and-raymarching",
    "href": "lectures/day4.html#part-2-signed-distance-functions-and-raymarching",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.3 Part 2: Signed Distance Functions and Raymarching",
    "text": "4.3 Part 2: Signed Distance Functions and Raymarching\n\nIntroduction to SDFs\nA signed distance function (SDF) gives the distance from any point in space to the nearest surface:\n\\[d(\\mathbf{p}) = \\begin{cases}\n&gt; 0 & \\text{outside surface} \\\\\n= 0 & \\text{on surface} \\\\\n&lt; 0 & \\text{inside surface}\n\\end{cases}\\]\nCrucially, \\(|d(\\mathbf{p})|\\) is the actual Euclidean distance to the surface.\n\nWhy SDFs?\nSDFs have a powerful property: if we’re at point \\(\\mathbf{p}\\) and the surface is distance \\(d\\) away, we can safely move \\(d\\) units in any direction without hitting anything. This enables sphere tracing—we march along the ray taking steps proportional to the SDF value.\n\n\nSDF Examples\nLet’s see SDFs for shapes we’ve already rendered analytically:\nSphere:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nCompare this to our 30+ line analytical intersection! Much simpler.\nTorus:\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\nAgain, dramatically simpler than the quartic solver!\nOther Primitives\nMany more SDFs exist: boxes, cylinders, capsules, cones, pyramids, etc. See Inigo Quilez’s comprehensive library for a complete reference. Each SDF is typically just a few lines of code.\n\n\n\n\nThe Raymarching Algorithm\nSphere tracing works like this:\n\nStart at the ray origin\nEvaluate the SDF at current position\nMarch forward along the ray by that distance (safe step!)\nRepeat until:\n\nVery close to surface (SDF ≈ 0) → hit!\nToo far away → miss\nToo many steps → give up\n\n\nHere’s the algorithm:\nfloat sceneSDF(vec3 p) {\n    // Define scene geometry (we'll implement this)\n    return 0.0;\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out float hitDist, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        // Close enough to surface?\n        if(abs(d) &lt; 0.001) {\n            hitDist = t;\n            hitPos = pos;\n            return true;\n        }\n        \n        // March forward\n        t += d;\n        \n        // Too far?\n        if(t &gt; 100.0) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\nNormal Estimation via Gradient\nFor an SDF \\(d(\\mathbf{p})\\), the gradient \\(\\nabla d\\) points perpendicular to the surface (it’s the normal direction). We estimate it using finite differences:\n\\[\\frac{\\partial d}{\\partial x} \\approx \\frac{d(x + \\epsilon, y, z) - d(x - \\epsilon, y, z)}{2\\epsilon}\\]\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\n\nFirst Raymarch Shader\nShader 5: Single Sphere with Raymarching\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        \n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Raymarch\n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        color = sphereColor * diffuse + sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nSame result as the analytical sphere, but now we have a flexible framework!\n\n\n\n\nThe Power of SDFs: Instant Shape Swapping\nHere’s where SDFs shine: changing shapes is trivial. Just swap out one SDF for another!\nShader 6: Shapeshifting\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdBox(vec3 p, vec3 center, vec3 halfExtents) {\n    vec3 q = abs(p - center) - halfExtents;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    // Uncomment ONE of these to see different shapes!\n    // Everything else stays the same - same raymarch, same lighting, same normal calculation\n    \n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n    //return sdTorus(p, vec3(0.0, 0.0, -3.0), 1.0, 0.4);\n    //return sdBox(p, vec3(0.0, 0.0, -3.0), vec3(0.8, 0.8, 0.8));\n    \n    // Try any SDF from https://iquilezles.org/articles/distfunctions/\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nComment/uncomment different SDFs in sceneSDF() to instantly see different shapes! Try adding more from Quilez’s library. The raymarching algorithm doesn’t care what shape you use—it just follows the distance field.\n\n\n\nComposing Multiple Objects\nTo combine multiple objects, we simply take the minimum distance to any object. The closest surface wins!\nShader 7: Multiple Objects with Materials\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Global variable to track which object we hit\nfloat gMaterialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;  // Start with very large distance\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.2, 0.0, -3.5), 0.8);\n    if(sphere &lt; d) {\n        d = sphere;\n        gMaterialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p, vec3(1.2, 0.0, -3.5), 1.0, 0.3);\n    if(torus &lt; d) {\n        d = torus;\n        gMaterialID = 2.0;\n    }\n    \n    // Ground plane\n    float plane = sdPlane(p, -1.0);\n    if(plane &lt; d) {\n        d = plane;\n        gMaterialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float matID) {\n    if(matID &lt; 1.5) return vec3(1.0, 0.0, 0.0);      // Sphere: red\n    if(matID &lt; 2.5) return vec3(0.0, 0.7, 1.0);      // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                       // Plane: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos, out float matID) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            matID = gMaterialID;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    float matID;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos, matID);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = getMaterialColor(matID);\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThree objects with different colors! Adding more objects is trivial—just add another SDF check in sceneSDF(). Compare this to analytical methods where combining objects requires sophisticated CSG (constructive solid geometry) techniques.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "lectures/day4.html#summary",
    "href": "lectures/day4.html#summary",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.4 Summary",
    "text": "4.4 Summary\nToday we learned two approaches to 3D rendering:\nAnalytical Ray Tracing: - Solve equations directly for ray-surface intersection - Exact solutions, very efficient for simple geometry - Sphere: straightforward quadratic equation - Torus: complex quartic equation requiring sophisticated algebra - Becomes increasingly difficult for complex surfaces - Standard in production ray tracers for well-defined geometry\nSDF-Based Raymarching: - Represent surfaces as distance fields - March along rays using sphere tracing - Simple, uniform code for any geometry - Easy composition: just take minimum distance - Flexible—works for procedural, implicit, or arbitrary surfaces - Slightly slower than analytical, but much more versatile\nKey Concepts: - Camera setup and ray generation - Parametric ray equation: \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) - Surface normals for lighting - Diffuse (Lambertian) shading - Signed distance functions (SDFs) - Sphere tracing algorithm - Normal estimation via gradient (finite differences) - Material tracking for multiple objects\nTomorrow we’ll explore advanced raymarching: domain operations for infinite repetition, boolean operations for smooth blending, and 3D fractals!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "lectures/day4.html#homework",
    "href": "lectures/day4.html#homework",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.5 Homework",
    "text": "4.5 Homework\n\nRequired: Algebraic Variety Rendering\nImplement analytical ray tracing for an interesting polynomial implicit surface.\nGoal: Experience the challenges of analytical methods firsthand, then appreciate SDFs even more!\nSuggested surfaces: - Degree 3: Saddle surfaces, cubic varieties - Degree 4: Klein bottle projections, quartic surfaces with interesting topology - Cassini ovals in 3D: \\((x^2 + y^2 + z^2)^2 - 2a^2(x^2 - y^2) = b^4 - a^4\\)\nImplementation steps:\n\nDefine your implicit function \\(F(x,y,z) = 0\\)\n\nExample—a quartic surface:\nfloat implicitFunction(vec3 p) {\n    float r2 = dot(p, p);\n    return r2 * r2 - (p.x*p.x + p.y*p.y - 2.0*p.z*p.z);\n}\n\nImplement root finding (bisection method)\n\nfloat intersectImplicit(vec3 rayOrigin, vec3 rayDir) {\n    float tMin = 0.0;\n    float tMax = 10.0;\n    \n    // Check for sign change\n    float fMin = implicitFunction(rayOrigin + tMin * rayDir);\n    float fMax = implicitFunction(rayOrigin + tMax * rayDir);\n    \n    if(fMin * fMax &gt; 0.0) return -1.0;  // No root\n    \n    // Bisection\n    for(int i = 0; i &lt; 50; i++) {\n        float tMid = (tMin + tMax) / 2.0;\n        float fMid = implicitFunction(rayOrigin + tMid * rayDir);\n        \n        if(abs(fMid) &lt; 0.001) return tMid;\n        \n        if(fMin * fMid &lt; 0.0) {\n            tMax = tMid;\n            fMax = fMid;\n        } else {\n            tMin = tMid;\n            fMin = fMid;\n        }\n    }\n    \n    return (tMin + tMax) / 2.0;\n}\n\nCompute normal via gradient\n\nvec3 implicitNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = implicitFunction(p + vec3(eps, 0, 0)) - implicitFunction(p - vec3(eps, 0, 0));\n    float dy = implicitFunction(p + vec3(0, eps, 0)) - implicitFunction(p - vec3(0, eps, 0));\n    float dz = implicitFunction(p + vec3(0, 0, eps)) - implicitFunction(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nOptimization: Bounding volume (optional but recommended)\n\nUse a bounding sphere to avoid checking the entire ray:\n// First check if ray intersects bounding sphere\n// Only compute implicit function if inside bounds\nExpected output: A rendered algebraic surface with proper lighting showing its geometric features.\nReflection question: After implementing this, compare the effort to using SDFs. Which approach would you prefer for a complex scene with many objects?\n\n\n\nOptional Exercises\n\n1. Specular Lighting (Phong Model)\nAdd shiny highlights using the Phong reflection model:\n\\[\\text{specular} = (R \\cdot V)^n\\]\nwhere \\(R\\) is reflected light direction, \\(V\\) is view direction, \\(n\\) is shininess.\nvec3 R = reflect(-lightDir, normal);  // Reflected light\nvec3 V = -rayDir;                      // View direction\nfloat spec = pow(max(0.0, dot(R, V)), 32.0);\ncolor += vec3(1.0) * spec * 0.5;  // White specular highlight\nTry different shininess values (8, 16, 32, 64, 128) to see the effect!\n\n\n2. Camera Movement\nImplement an orbiting camera using time:\nfloat angle = iTime * 0.5;\nvec3 rayOrigin = vec3(3.0 * cos(angle), 1.0, 3.0 * sin(angle));\n\n// Look-at matrix\nvec3 target = vec3(0.0, 0.0, -3.0);\nvec3 forward = normalize(target - rayOrigin);\nvec3 right = normalize(cross(vec3(0, 1, 0), forward));\nvec3 up = cross(forward, right);\n\n// Transform ray direction\nvec3 rd = normalize(uv.x * right + uv.y * up + focalLength * forward);\n\n\n3. Complex SDF Scene\nCreate a scene with 5+ objects using different SDFs from Quilez’s library: - Mix primitives: spheres, boxes, cylinders, tori, cones - Position them creatively - Use different materials - Add interesting lighting\n\n\n4. Soft Shadows (Preview of Day 5)\nCast rays from the surface toward the light to check for occlusion:\nfloat softShadow(vec3 pos, vec3 lightDir) {\n    float t = 0.01;  // Start slightly above surface\n    float shadow = 1.0;\n    \n    for(int i = 0; i &lt; 50; i++) {\n        float d = sceneSDF(pos + lightDir * t);\n        shadow = min(shadow, 8.0 * d / t);  // Penumbra factor\n        t += d;\n        if(t &gt; 10.0 || d &lt; 0.001) break;\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\nApply this to your diffuse lighting for more realistic shadows!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "lectures/day4.html#looking-ahead-to-day-5",
    "href": "lectures/day4.html#looking-ahead-to-day-5",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.6 Looking Ahead to Day 5",
    "text": "4.6 Looking Ahead to Day 5\nTomorrow we’ll explore advanced raymarching techniques that would be nearly impossible with analytical methods:\n\nDomain operations: Infinite repetition, symmetry, twisting\nBoolean operations: Union, intersection, smooth blending\n3D fractals: Menger sponge, Mandelbulb via iterated transformations\nAdvanced lighting: Ambient occlusion, global illumination\n\nMake sure you’re comfortable with: - The raymarching algorithm (it’s the foundation) - How SDFs compose (taking minimum/maximum) - Normal estimation via gradients - The material tracking pattern we developed\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html",
    "href": "appendices/day1-shaders.html",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "A.1 A1. Basic Red Screen\nThis appendix provides complete, standalone Shadertoy code for each shader program presented in Day 1. Each listing includes all necessary setup and can be copied directly into Shadertoy (https://www.shadertoy.com/new) and run immediately.\nThe simplest possible shader - every pixel is red.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a1.-basic-red-screen",
    "href": "appendices/day1-shaders.html#a1.-basic-red-screen",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a2.-animated-color-pulsing-red",
    "href": "appendices/day1-shaders.html#a2.-animated-color-pulsing-red",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.2 A2. Animated Color (Pulsing Red)",
    "text": "A.2 A2. Animated Color (Pulsing Red)\nUsing iTime to animate the red channel.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a3.-coordinate-visualization",
    "href": "appendices/day1-shaders.html#a3.-coordinate-visualization",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.3 A3. Coordinate Visualization",
    "text": "A.3 A3. Coordinate Visualization\nVisualizing the coordinate system by mapping position to color.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a4.-half-plane-coloring-ternary-operator",
    "href": "appendices/day1-shaders.html#a4.-half-plane-coloring-ternary-operator",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.4 A4. Half-Plane Coloring (Ternary Operator)",
    "text": "A.4 A4. Half-Plane Coloring (Ternary Operator)\nDividing the plane into two regions based on a linear function.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a5.-half-plane-with-step-function",
    "href": "appendices/day1-shaders.html#a5.-half-plane-with-step-function",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.5 A5. Half-Plane with Step Function",
    "text": "A.5 A5. Half-Plane with Step Function\nSame as above but using step() and mix().\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float s = step(0.0, p.x);  // 0 on left, 1 on right\n    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a6.-arbitrary-half-plane",
    "href": "appendices/day1-shaders.html#a6.-arbitrary-half-plane",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.6 A6. Arbitrary Half-Plane",
    "text": "A.6 A6. Arbitrary Half-Plane\nDividing along an arbitrary line \\(ax + by + c = 0\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.0, b = 1.0, c = 0.0;\n    float L = a * p.x + b * p.y + c;\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a7.-filled-circle",
    "href": "appendices/day1-shaders.html#a7.-filled-circle",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.7 A7. Filled Circle",
    "text": "A.7 A7. Filled Circle\nUsing distance from origin to create a disk.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a8.-distance-based-coloring-radial-gradient",
    "href": "appendices/day1-shaders.html#a8.-distance-based-coloring-radial-gradient",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.8 A8. Distance-Based Coloring (Radial Gradient)",
    "text": "A.8 A8. Distance-Based Coloring (Radial Gradient)\nUsing distance value itself to create a gradient.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\n    intensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\n    \n    vec3 color = vec3(intensity);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a9.-circle-outline-hard-edge",
    "href": "appendices/day1-shaders.html#a9.-circle-outline-hard-edge",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.9 A9. Circle Outline (Hard Edge)",
    "text": "A.9 A9. Circle Outline (Hard Edge)\nDrawing just the boundary of a circle with hard threshold.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float thickness = 0.05;\n    \n    float circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\n    vec3 color = vec3(circle_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a10.-circle-outline-smooth-with-smoothstep",
    "href": "appendices/day1-shaders.html#a10.-circle-outline-smooth-with-smoothstep",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.10 A10. Circle Outline (Smooth with Smoothstep)",
    "text": "A.10 A10. Circle Outline (Smooth with Smoothstep)\nAnti-aliased circle outline using smoothstep().\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float thickness = 0.05;\n    \n    float circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\n    vec3 color = vec3(circle_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a11.-grid-of-circles",
    "href": "appendices/day1-shaders.html#a11.-grid-of-circles",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.11 A11. Grid of Circles",
    "text": "A.11 A11. Grid of Circles\nUsing mod() to create repeating circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a12.-grid-with-alternating-background",
    "href": "appendices/day1-shaders.html#a12.-grid-with-alternating-background",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.12 A12. Grid with Alternating Background",
    "text": "A.12 A12. Grid with Alternating Background\nCreating a checkerboard pattern behind the circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a13.-complete-grid-pattern",
    "href": "appendices/day1-shaders.html#a13.-complete-grid-pattern",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.13 A13. Complete Grid Pattern",
    "text": "A.13 A13. Complete Grid Pattern\nFull example combining grid cells, checkerboard, and circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a14.-implicit-curve-parabola",
    "href": "appendices/day1-shaders.html#a14.-implicit-curve-parabola",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.14 A14. Implicit Curve: Parabola",
    "text": "A.14 A14. Implicit Curve: Parabola\nDrawing a parabola using the implicit equation \\(y = x^2\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.y - p.x * p.x;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a15.-implicit-curve-circle",
    "href": "appendices/day1-shaders.html#a15.-implicit-curve-circle",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.15 A15. Implicit Curve: Circle",
    "text": "A.15 A15. Implicit Curve: Circle\nDrawing a circle using the implicit equation \\(x^2 + y^2 = r^2\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float r = 1.0;\n    float F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a16.-implicit-curve-hyperbola",
    "href": "appendices/day1-shaders.html#a16.-implicit-curve-hyperbola",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.16 A16. Implicit Curve: Hyperbola",
    "text": "A.16 A16. Implicit Curve: Hyperbola\nDrawing a hyperbola \\(xy = 1\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.x * p.y - 1.0;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a17.-implicit-curve-ellipse",
    "href": "appendices/day1-shaders.html#a17.-implicit-curve-ellipse",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.17 A17. Implicit Curve: Ellipse",
    "text": "A.17 A17. Implicit Curve: Ellipse\nDrawing an ellipse \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 2.0, b = 1.0;\n    float F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a18.-parabola-graphing-calculator-homework-template",
    "href": "appendices/day1-shaders.html#a18.-parabola-graphing-calculator-homework-template",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.18 A18. Parabola Graphing Calculator (Homework Template)",
    "text": "A.18 A18. Parabola Graphing Calculator (Homework Template)\nTemplate for the required homework assignment.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // TODO: Draw x-axis (|y| &lt; thickness)\n    // TODO: Draw y-axis (|x| &lt; thickness)\n    // TODO: Draw parabola (|y - (ax² + bx + c)| &lt; thickness)\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a19.-parabola-graphing-calculator-complete-solution",
    "href": "appendices/day1-shaders.html#a19.-parabola-graphing-calculator-complete-solution",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.19 A19. Parabola Graphing Calculator (Complete Solution)",
    "text": "A.19 A19. Parabola Graphing Calculator (Complete Solution)\nComplete implementation of the required homework.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Axes\n    float axis_thickness = 0.02;\n    float x_axis_mask = abs(p.y) &lt; axis_thickness ? 1.0 : 0.0;\n    float y_axis_mask = abs(p.x) &lt; axis_thickness ? 1.0 : 0.0;\n    vec3 axis_color = vec3(0.3, 0.3, 0.3);\n    \n    // Parabola: F(x,y) = y - (ax² + bx + c) = 0\n    float F = p.y - (a * p.x * p.x + b * p.x + c);\n    float curve_thickness = 0.08;\n    float parabola_mask = abs(F) &lt; curve_thickness ? 1.0 : 0.0;\n    vec3 parabola_color = vec3(1.0, 0.8, 0.0);\n    \n    // Combine (axes behind parabola)\n    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\n    color = mix(color, parabola_color, parabola_mask);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a20.-animated-curve-family-circle",
    "href": "appendices/day1-shaders.html#a20.-animated-curve-family-circle",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.20 A20. Animated Curve Family: Circle",
    "text": "A.20 A20. Animated Curve Family: Circle\nAnimating through different circle radii.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Animated radius\n    float r = 1.0 + 0.5 * sin(iTime);\n    \n    float F = dot(p, p) - r * r;\n    float thickness = 0.08;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a21.-animated-curve-family-rotating-ellipse",
    "href": "appendices/day1-shaders.html#a21.-animated-curve-family-rotating-ellipse",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.21 A21. Animated Curve Family: Rotating Ellipse",
    "text": "A.21 A21. Animated Curve Family: Rotating Ellipse\nEllipse that rotates over time.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Rotation angle from time\n    float theta = iTime * 0.5;\n    \n    // Rotate coordinates\n    vec2 p_rot = vec2(\n        p.x * cos(theta) + p.y * sin(theta),\n        -p.x * sin(theta) + p.y * cos(theta)\n    );\n    \n    // Ellipse in rotated coordinates\n    float a = 2.0, b = 1.0;\n    float F = (p_rot.x * p_rot.x) / (a * a) + (p_rot.y * p_rot.y) / (b * b) - 1.0;\n    float thickness = 0.08;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a22.-beautiful-tiling-geometric-pattern",
    "href": "appendices/day1-shaders.html#a22.-beautiful-tiling-geometric-pattern",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.22 A22. Beautiful Tiling: Geometric Pattern",
    "text": "A.22 A22. Beautiful Tiling: Geometric Pattern\nExample of a custom tiling pattern using circles and symmetry.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Use symmetry within each cell\n    cell_p = abs(cell_p);  // 4-fold symmetry\n    \n    // Multiple circles at different positions\n    float d1 = length(cell_p - vec2(0.2, 0.2));\n    float d2 = length(cell_p - vec2(0.4, 0.0));\n    float d3 = length(cell_p - vec2(0.0, 0.4));\n    \n    float r = 0.15;\n    float mask = (d1 &lt; r || d2 &lt; r || d3 &lt; r) ? 1.0 : 0.0;\n    \n    // Vary color by cell position\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 color1 = vec3(0.2, 0.4, 0.6);\n    vec3 color2 = vec3(0.6, 0.2, 0.4);\n    vec3 bg = mix(color1, color2, checker);\n    \n    vec3 circle_color = vec3(1.0, 0.9, 0.7);\n    vec3 color = mix(bg, circle_color, mask);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a23.-beautiful-tiling-distance-based-animation",
    "href": "appendices/day1-shaders.html#a23.-beautiful-tiling-distance-based-animation",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.23 A23. Beautiful Tiling: Distance-Based Animation",
    "text": "A.23 A23. Beautiful Tiling: Distance-Based Animation\nPattern that pulses based on time and distance.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Distance from cell center\n    float d = length(cell_p);\n    \n    // Distance from origin (in cell coordinates)\n    float cell_dist = length(cell_id);\n    \n    // Animated radius that propagates outward\n    float r = 0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5);\n    \n    float mask = smoothstep(r + 0.05, r - 0.05, d);\n    \n    // Color based on cell distance\n    vec3 color1 = vec3(0.2, 0.3, 0.5);\n    vec3 color2 = vec3(0.8, 0.3, 0.4);\n    float t = fract(cell_dist * 0.2);\n    vec3 circle_color = mix(color1, color2, t);\n    \n    vec3 bg = vec3(0.1, 0.1, 0.15);\n    vec3 color = mix(bg, circle_color, mask);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#notes-on-using-these-shaders",
    "href": "appendices/day1-shaders.html#notes-on-using-these-shaders",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.24 Notes on Using These Shaders",
    "text": "A.24 Notes on Using These Shaders\n\nGetting Started\n\nGo to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\nCoordinate System\nAll shaders (except A1 and A2) use the standard coordinate transformation:\nvec2 uv = fragCoord / iResolution.xy;  // Normalize to [0,1]\nuv = uv - 0.5;                          // Center at origin\nuv.x *= iResolution.x / iResolution.y; // Aspect ratio correction\nvec2 p = uv * 4.0;                      // Scale viewing window\nThis gives you coordinates centered at the origin with equal scaling in x and y.\n\n\nModifying Parameters\nCoordinate scaling: - Change uv * 4.0 to zoom in/out (smaller number = zoom in)\nColors: - Modify vec3(r, g, b) values (each in range [0, 1]) - Red: vec3(1.0, 0.0, 0.0) - Green: vec3(0.0, 1.0, 0.0) - Blue: vec3(0.0, 0.0, 1.0) - Yellow: vec3(1.0, 1.0, 0.0) - Cyan: vec3(0.0, 1.0, 1.0) - Magenta: vec3(1.0, 0.0, 1.0)\nDistance and thickness: - thickness parameters control line width - Larger thickness = thicker lines/curves\nGrid patterns: - spacing controls grid cell size - Smaller spacing = more cells\nAnimation: - Use iTime for time-based animation - sin(iTime) oscillates between -1 and 1 - 0.5 + 0.5 * sin(iTime) oscillates between 0 and 1\n\n\nCommon Modifications to Try\nMake circles pulse:\nfloat r = 0.3 + 0.1 * sin(iTime);\nMake grid spacing animate:\nfloat spacing = 1.0 + 0.3 * sin(iTime * 0.5);\nAdd mouse interaction:\nvec2 mouse = iMouse.xy / iResolution.xy;\nmouse = mouse - 0.5;\nmouse.x *= iResolution.x / iResolution.y;\n// Use mouse position to control parameters\nCombine techniques: - Put implicit curves on a grid using mod() - Add animation to any parameter with iTime - Use distance fields to create smooth transitions\n\n\nTroubleshooting\nShader won’t compile: - Check for missing semicolons - Make sure all numbers are floats: 1.0 not 1 - Verify parentheses and braces are balanced\nNothing shows up: - Check your coordinate scaling - might be zoomed too far in/out - Verify colors are in [0, 1] range - Make sure alpha channel is 1.0: vec4(color, 1.0)\nCircles look like ellipses: - Make sure you include the aspect ratio correction: uv.x *= iResolution.x / iResolution.y;\n\n\nNext Steps\nOnce you’re comfortable with these basics: - Combine multiple techniques in one shader - Create your own implicit curves - Design custom tiling patterns - Add animation and interactivity - Experiment with color palettes and smooth transitions\nThe goal is to understand how coordinate transformations, distance functions, and conditionals work together to create mathematical visualizations on the GPU!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html",
    "href": "appendices/day2-shaders.html",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "B.1 A1. Basic Mandelbrot Set (Grayscale)\nThis appendix provides complete, standalone Shadertoy code for each shader program presented in Day 2. Each listing includes all necessary helper functions and can be copied directly into Shadertoy (https://www.shadertoy.com/new) and run immediately.\nThis is the simplest Mandelbrot renderer, showing just the escape-time iteration count in grayscale.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html#a1.-basic-mandelbrot-set-grayscale",
    "href": "appendices/day2-shaders.html#a1.-basic-mandelbrot-set-grayscale",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Grayscale coloring\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html#a2.-mandelbrot-set-with-smooth-coloring",
    "href": "appendices/day2-shaders.html#a2.-mandelbrot-set-with-smooth-coloring",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "B.2 A2. Mandelbrot Set with Smooth Coloring",
    "text": "B.2 A2. Mandelbrot Set with Smooth Coloring\nThis adds smooth coloring and a cosine-based color palette for much better visual quality.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        // Smooth iteration count\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        // Inside the set: black\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html#a3.-julia-set-explorer",
    "href": "appendices/day2-shaders.html#a3.-julia-set-explorer",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "B.3 A3. Julia Set Explorer",
    "text": "B.3 A3. Julia Set Explorer\nTemplate for Julia set implementation. Students fill in the iteration code based on Mandelbrot.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // HOMEWORK: Initialize z from pixel position\n    // HOMEWORK: Iterate z_{n+1} = z_n^2 + c\n    // HOMEWORK: Use smooth coloring like Mandelbrot\n    \n    // Placeholder color (replace with your implementation)\n    vec3 color = vec3(0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\n\nA3b. Julia Set (Complete Solution)\nHere’s a complete working Julia set for reference:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // Initialize z from pixel position (key difference from Mandelbrot!)\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nA3c. Julia Set with Mouse Control\nFor interactive exploration of parameter space:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // c controlled by mouse position\n    vec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 c = mouse_uv * 3.0;\n    \n    // Fallback if mouse hasn't been clicked\n    if(iMouse.z &lt; 0.5) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Initialize z from pixel position\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nA3d. Julia Set with Animation\nAnimating through parameter space:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Animate c around a circle in parameter space\n    float angle = iTime * 0.3;\n    float radius = 0.7885;\n    vec2 c = vec2(radius * cos(angle), radius * sin(angle));\n    \n    // Initialize z from pixel position\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html#a4.-circle-inversion-visualization",
    "href": "appendices/day2-shaders.html#a4.-circle-inversion-visualization",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "B.4 A4. Circle Inversion Visualization",
    "text": "B.4 A4. Circle Inversion Visualization\nVisualizes circle inversion by showing how it deforms a grid.\n// Circle inversion function\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);\n    float gridLine = step(0.95, max(grid.x, grid.y));\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle itself (for reference)\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html#a5.-apollonian-gasket",
    "href": "appendices/day2-shaders.html#a5.-apollonian-gasket",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "B.5 A5. Apollonian Gasket",
    "text": "B.5 A5. Apollonian Gasket\nComplete Apollonian gasket implementation with iteration coloring.\n// Circle struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n// Circle inversion\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\n// Setup four mutually tangent circles (three inner + one outer)\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\n\n// Iterate inversions through four circles (three inner + one outer)\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by iteration count\n    float t = float(finalIter) / float(maxIter);\n    vec3 color = palette(t);\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\nA5b. Apollonian Gasket (Basin Coloring)\nAlternative coloring showing which circle’s basin each point falls into:\n// Circle struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n// Circle inversion\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\n// Setup four mutually tangent circles (three inner + one outer)\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\n\n// Iterate inversions through four circles (three inner + one outer)\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by which circle we last hit\n    vec3 colors[4];\n    colors[0] = vec3(1.0, 0.0, 0.0);  // Circle 1: Red\n    colors[1] = vec3(0.0, 1.0, 0.0);  // Circle 2: Green\n    colors[2] = vec3(0.0, 0.0, 1.0);  // Circle 3: Blue\n    colors[3] = vec3(1.0, 1.0, 0.0);  // Outer circle: Yellow\n    \n    vec3 color = colors[lastCircle];\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html#a6.-grid-of-julia-sets-optional-homework",
    "href": "appendices/day2-shaders.html#a6.-grid-of-julia-sets-optional-homework",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "B.6 A6. Grid of Julia Sets (Optional Homework)",
    "text": "B.6 A6. Grid of Julia Sets (Optional Homework)\nShows many Julia sets in a grid, revealing the Mandelbrot set structure.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv ;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Divide screen into grid cells\n    float grid_size = 50.0;  // 8×8 grid\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;  // Local coordinates within cell\n    \n    // Map cell_id to parameter c\n    vec2 c = (cell_id / grid_size) * 3.0 - vec2(2.5, 1.5);\n    c.x -= 0.5;  // Center on Mandelbrot set\n    \n    // Run Julia set iteration\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    // Draw grid lines\n    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);\n    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day2-shaders.html#notes-on-using-these-shaders",
    "href": "appendices/day2-shaders.html#notes-on-using-these-shaders",
    "title": "Appendix B — Appendix: Complete Shader Code for Day 2",
    "section": "B.7 Notes on Using These Shaders",
    "text": "B.7 Notes on Using These Shaders\n\nGetting Started\n\nGo to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\nModifying Parameters\nEach shader has parameters you can adjust at the top of mainImage():\nMandelbrot/Julia: - max_iter - More iterations reveal finer detail (try 200) - Color scale factor in uv * 3.5 - Zoom in/out - Offset c.x -= 0.5 - Pan the view\nJulia specific: - vec2 c = ... - Change the parameter to see different Julia sets - Try values from the homework section\nCircle Inversion: - circleCenter - Move the inversion circle - circleRadius - Change the size - Grid frequency in p_inverted * 2.0 - Denser or sparser grid\nApollonian Gasket: - maxIter - More iterations show deeper nesting - R and r in setup function - Change circle sizes - Color palette parameters in palette() function\n\n\nPerformance Tips\nIf a shader runs slowly: - Reduce max_iter (try 50 instead of 100) - Lower the resolution (bottom right resolution dropdown in Shadertoy) - Some computers may struggle with smooth coloring - remove it for speed\n\n\nExploring Further\nAll of these shaders are starting points! Try: - Combining techniques (Julia set with Apollonian coloring scheme) - Animating parameters with iTime - Adding mouse interaction with iMouse - Creating your own color palettes - Experimenting with different circle configurations\nThe goal is to understand how simple iterative processes create complex fractals, and how to implement them efficiently on the GPU!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 2</span>"
    ]
  },
  {
    "objectID": "appendices/day3-shaders.html",
    "href": "appendices/day3-shaders.html",
    "title": "Appendix C — Appendix: Complete Shader Code for Day 3",
    "section": "",
    "text": "C.1 Part 1: Euclidean Tilings\nThis appendix provides complete, standalone Shadertoy code for each shader program presented in Day 3. Each listing includes all necessary helper functions and can be copied directly into Shadertoy (https://www.shadertoy.com/new) and run immediately.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 3</span>"
    ]
  },
  {
    "objectID": "appendices/day3-shaders.html#part-1-euclidean-tilings",
    "href": "appendices/day3-shaders.html#part-1-euclidean-tilings",
    "title": "Appendix C — Appendix: Complete Shader Code for Day 3",
    "section": "",
    "text": "E1. Strip Tiling (Basic)\nSimple horizontal strip tiling showing the folding algorithm in one dimension.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE2. Square Tiling (Basic)\n2D square tiling extending the folding algorithm to both dimensions.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);\n    \n    // Circle at center\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE3. Square Tiling with Fold Count\nSquare tiling colored by the number of reflections needed to reach the fundamental domain.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE4a. Single Half-Space Visualization\nVisualizes one side of a line (a half-space).\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1 (left side of vertical line at x=1)\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE4b. Single Half-Space with Boundary Line\nSame as E4a but with the boundary line drawn.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the boundary line\n    float d = distToHalfSpace(p, hs);\n    if(d &lt; 0.02) color = vec3(1.0);  // White boundary\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE5a. Four Half-Spaces (Additive Coloring)\nIntersecting four half-spaces to create a square using additive coloring.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Additive coloring - each half-space adds brightness\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, left))   color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, right))  color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, bottom)) color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, top))    color += vec3(0.1, 0.15, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE5b. Four Half-Spaces with Boundaries\nEnhanced version with binary coloring and boundary lines.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Binary coloring: inside domain or not\n    bool in_square = inside(p, left) && inside(p, right) && \n                     inside(p, bottom) && inside(p, top);\n    vec3 color = in_square ? vec3(0.4, 0.6, 0.8) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw boundaries\n    float d1 = distToHalfSpace(p, left);\n    float d2 = distToHalfSpace(p, right);\n    float d3 = distToHalfSpace(p, bottom);\n    float d4 = distToHalfSpace(p, top);\n    float d = min(min(d1, d2), min(d3, d4));\n    \n    if(d &lt; 0.02) color = vec3(1.0);  // White boundaries\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE6. Three Half-Spaces for Triangle (Additive)\nVisualizing three half-spaces defining an equilateral triangle.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, hs1)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs2)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs3)) color += vec3(0.15, 0.2, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE7. Euclidean Triangle Tiling (Basic)\nFull triangle tiling using half-space reflections.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle\n    for(int i = 0; i &lt; 20; i++) {\n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n    }\n    \n    // Simple coloring\n    vec3 color = vec3(0.3, 0.5, 0.7);\n    \n    // Draw a circle in fundamental domain\n    float d = length(p - vec2(0.0, -0.3));\n    if(d &lt; 0.2) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE8. Euclidean Triangle Tiling with Fold Count\nTriangle tiling colored by reflection count with convergence check.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle with iteration count\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nE9. Euclidean Triangle Tiling with Edges and Vertices\nComplete triangle tiling with visible structure (reference implementation for homework).\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle with parity tracking\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by parity (alternating pattern)\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Draw edges\n    float d1 = distToHalfSpace(p, hs1);\n    float d2 = distToHalfSpace(p, hs2);\n    float d3 = distToHalfSpace(p, hs3);\n    float d_edge = min(min(d1, d2), d3);\n    \n    if(d_edge &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);  // White edges\n    }\n    \n    // Draw vertices (approximate positions)\n    vec2 v1 = vec2(-0.577, -0.333);\n    vec2 v2 = vec2(0.577, -0.333);\n    vec2 v3 = vec2(0.0, 0.667);\n    \n    float d_v1 = length(p - v1);\n    float d_v2 = length(p - v2);\n    float d_v3 = length(p - v3);\n    float d_vert = min(min(d_v1, d_v2), d_v3);\n    \n    if(d_vert &lt; 0.08) {\n        color = vec3(1.0, 0.0, 0.0);  // Red vertices\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 3</span>"
    ]
  },
  {
    "objectID": "appendices/day3-shaders.html#part-2-hyperbolic-tilings",
    "href": "appendices/day3-shaders.html#part-2-hyperbolic-tilings",
    "title": "Appendix C — Appendix: Complete Shader Code for Day 3",
    "section": "C.2 Part 2: Hyperbolic Tilings",
    "text": "C.2 Part 2: Hyperbolic Tilings\n\nH1. Euclidean Distance Visualization (For Comparison)\nShows standard Euclidean distance circles for comparison with hyperbolic.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);  // Shift up so we're in y &gt; 0\n    \n    // Mouse position as center (or default)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);  // Default if no click\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Euclidean distance\n    float dist = length(p - center);\n    \n    // Draw a disk of radius 0.5 using two circles\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer circle (slightly larger)\n    if(dist &lt; radius + 0.02) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner circle (slightly smaller) - \"cuts out\" interior\n    if(dist &lt; radius - 0.02) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center point\n    if(length(p - center) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH2. Hyperbolic Distance Visualization\nShows hyperbolic distance “circles” in the upper half-plane model.\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // arccosh(arg)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Mouse position as center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Hyperbolic distance\n    float dist = hyperbolicDistance(p, center);\n    \n    // Draw a hyperbolic disk using two \"circles\"\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer boundary\n    if(dist &lt; radius + 0.05) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner region\n    if(dist &lt; radius - 0.05) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center\n    if(hyperbolicDistance(p, center) &lt; 0.1) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH3a. Single Vertical Geodesic Half-Space\nVisualizes one side of a vertical geodesic (hyperbolic “line”).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Vertical geodesic at x = 0, showing right side (x &gt; 0)\n    float x_pos = 0.0;\n    float side = -1.0;  // side = -1.0 means x &gt; x_pos\n    \n    // Check which side we're on\n    bool on_right_side = (z.x - x_pos) * side &lt; 0.0;\n    \n    vec3 color = on_right_side ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the geodesic (vertical line)\n    if(abs(z.x - x_pos) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH3b. Single Circular Geodesic Half-Space\nVisualizes one side of a semicircular geodesic.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Semicircular geodesic from p to q on real axis\n    float p = -1.0;\n    float q = 1.0;\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    \n    // Distance from center\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    // side = 1.0 means outside the circle\n    float side = 1.0;\n    bool outside_circle = (dist2 - radius * radius) * side &gt; 0.0;\n    \n    vec3 color = outside_circle ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the geodesic (semicircle)\n    float dist_to_circle = abs(length(rel) - radius);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH3c. Three Geodesics Additively Colored (Building the Triangle)\nShows the three geodesics of the (2,3,∞) triangle using additive coloring.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Three geodesics of (2,3,∞) triangle\n    // Left vertical line: x = -1, want x &gt; -1\n    bool inside_left = (z.x - (-1.0)) * (-1.0) &lt; 0.0;\n    \n    // Right vertical line: x = 1, want x &lt; 1\n    bool inside_right = (z.x - 1.0) * 1.0 &lt; 0.0;\n    \n    // Semicircle from -1 to 1, want outside (above)\n    float center = 0.0;\n    float radius = 1.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    bool inside_circle = (dist2 - radius * radius) * 1.0 &gt; 0.0;\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside_left)   color += vec3(0.15, 0.2, 0.25);\n    if(inside_right)  color += vec3(0.15, 0.2, 0.25);\n    if(inside_circle) color += vec3(0.15, 0.2, 0.25);\n    \n    // Draw the three geodesics\n    if(abs(z.x - (-1.0)) &lt; 0.02) color = vec3(1.0);  // Left line\n    if(abs(z.x - 1.0) &lt; 0.02) color = vec3(1.0);     // Right line\n    \n    float dist_to_circle = abs(length(rel) - radius);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) color = vec3(1.0);  // Semicircle\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH4. Basic (2,3,∞) Triangle Tiling\nComplete hyperbolic triangle tiling with simple coloring.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n    }\n    \n    // Simple coloring\n    vec3 color = vec3(0.6, 0.7, 0.9);\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH5. (2,3,∞) Triangle Tiling with Fold Count\nHyperbolic tiling colored by iteration count showing alternating pattern.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH6. (2,3,∞) Triangle Tiling with Edges and Vertices\nComplete hyperbolic tiling with visible structure (reference for homework).\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Draw geodesic edges\n    // Left vertical line (x = -1)\n    if(abs(z.x - (-1.0)) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Right vertical line (x = 1)\n    if(abs(z.x - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Semicircle from -1 to 1\n    vec2 rel = z - vec2(0.0, 0.0);\n    float dist_to_circle = abs(length(rel) - 1.0);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Draw vertices using hyperbolic distance\n    vec2 v1 = vec2(-1.0, 0.01);  // Left vertex (slightly above axis)\n    vec2 v2 = vec2(1.0, 0.01);   // Right vertex\n    \n    if(hyperbolicDistance(z, v1) &lt; 0.15 || hyperbolicDistance(z, v2) &lt; 0.15) {\n        color = vec3(1.0, 0.0, 0.0);  // Red vertices\n    }\n    \n    // Darken if below the real axis\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH7. Poincaré Disk Model\nSame (2,3,∞) tiling displayed in the Poincaré disk using the Cayley transform.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\n// Cayley transform: Poincaré disk -&gt; Upper half-plane\nvec2 cayleyDiskToUHP(vec2 w) {\n    // z = i(1-w)/(1+w)\n    vec2 numer = vec2(-w.y, 1.0 - w.x);  // i(1-w) = i - iw\n    vec2 denom = vec2(1.0 + w.x, w.y);    // 1 + w\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\n// Inverse Cayley: Upper half-plane -&gt; Poincaré disk\nvec2 cayleyUHPToDisk(vec2 z) {\n    // w = (z-i)/(z+i)\n    vec2 numer = vec2(z.x, z.y - 1.0);    // z - i\n    vec2 denom = vec2(z.x, z.y + 1.0);    // z + i\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for Poincaré disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 w = uv;  // Point in Poincaré disk\n    \n    // Convert to upper half-plane\n    vec2 z = cayleyDiskToUHP(w);\n    \n    // Fold into the (2,3,∞) triangle (in UHP)\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken outside unit disk\n    if(length(w) &gt; 1.0) {\n        color *= 0.3;\n    }\n    \n    // Draw boundary circle\n    if(abs(length(w) - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 0.0);  // Yellow boundary\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nH8. Klein Disk Model\nSame tiling in the Klein model where geodesics appear as straight lines.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\n// Poincaré disk -&gt; Klein disk\nvec2 poincareToKlein(vec2 w) {\n    float w_mag2 = dot(w, w);\n    return 2.0 * w / (1.0 + w_mag2);\n}\n\n// Klein disk -&gt; Poincaré disk\nvec2 kleinToPoincare(vec2 p) {\n    float p_mag2 = dot(p, p);\n    float denom = 1.0 + sqrt(1.0 - p_mag2);\n    return p / denom;\n}\n\n// Cayley transform: Poincaré disk -&gt; Upper half-plane\nvec2 cayleyDiskToUHP(vec2 w) {\n    vec2 numer = vec2(-w.y, 1.0 - w.x);\n    vec2 denom = vec2(1.0 + w.x, w.y);\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for Klein disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 k = uv;  // Point in Klein disk\n    \n    // Convert Klein -&gt; Poincaré -&gt; Upper half-plane\n    vec2 w = kleinToPoincare(k);\n    vec2 z = cayleyDiskToUHP(w);\n    \n    // Fold into the (2,3,∞) triangle (in UHP)\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken outside unit disk\n    if(length(k) &gt; 1.0) {\n        color *= 0.3;\n    }\n    \n    // Draw boundary circle\n    if(abs(length(k) - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 0.0);  // Yellow boundary\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 3</span>"
    ]
  },
  {
    "objectID": "appendices/day3-shaders.html#notes-on-using-these-shaders",
    "href": "appendices/day3-shaders.html#notes-on-using-these-shaders",
    "title": "Appendix C — Appendix: Complete Shader Code for Day 3",
    "section": "C.3 Notes on Using These Shaders",
    "text": "C.3 Notes on Using These Shaders\n\nGetting Started\n\nGo to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\nModifying Parameters\nEuclidean Tilings: - Adjust fold iteration count (20 is conservative, 10 often sufficient) - Change fundamental domain by modifying half-space parameters - Experiment with different shapes (triangles, pentagons, hexagons) - Try different color palettes\nHyperbolic Tilings: - Mouse interaction in H1/H2 (click and drag to move center) - Adjust the shift in z = uv + vec2(0.0, 1.5) to change visible region - Increase iteration count (50) for more precision near boundaries - Try different triangle configurations (requires computing new geodesics)\n\n\nPerformance Tips\nIf a shader runs slowly: - Reduce iteration count - Lower resolution in Shadertoy settings - Simplify edge/vertex drawing code\n\n\nExploring Further\nEuclidean extensions: - Implement other regular tilings (hexagons, pentagons) - Add animations by making half-spaces time-dependent - Create compound patterns with multiple fundamental domains\nHyperbolic extensions: - Implement (2,3,7) or (2,4,6) triangles - Decorate fundamental domains with patterns (Escher-style) - Explore pentagon tilings - Animate between different models\n\n\nKey Observations\nEuclidean vs Hyperbolic: Compare E7 and H4 - notice how the algorithm structure is identical but the reflection operations differ. This demonstrates the power of mathematical abstraction!\nModel Comparisons: Run H4 (upper half-plane), H7 (Poincaré disk), and H8 (Klein disk) side by side. The same mathematical object looks dramatically different depending on the model, but the underlying hyperbolic geometry is identical.\nEdge Behavior: In H6, notice how triangle edges near the boundary (y → 0) appear more compressed. This visualizes the 1/y² conformal factor in the hyperbolic metric.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 3</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a24.-lemniscate-of-bernoulli-naive-threshold",
    "href": "appendices/day1-shaders.html#a24.-lemniscate-of-bernoulli-naive-threshold",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.24 A24. Lemniscate of Bernoulli (Naive Threshold)",
    "text": "A.24 A24. Lemniscate of Bernoulli (Naive Threshold)\nDrawing a lemniscate using naive |F| &lt; thickness. Notice the non-uniform visual thickness—especially near the origin where the curve self-intersects and the gradient approaches zero.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)\n    float a = 1.0;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n    // Naive threshold - thickness varies!\n    float thickness = 0.15;\n    vec3 color = (abs(F) &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a25.-lemniscate-of-bernoulli-gradient-corrected",
    "href": "appendices/day1-shaders.html#a25.-lemniscate-of-bernoulli-gradient-corrected",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.25 A25. Lemniscate of Bernoulli (Gradient-Corrected)",
    "text": "A.25 A25. Lemniscate of Bernoulli (Gradient-Corrected)\nSame curve, but now we divide by the gradient magnitude to approximate the signed distance function. This gives uniform visual thickness even near the singular point at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)\n    float a = 1.0;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n    // Compute gradient analytically:\n    // ∂F/∂x = 4x(x² + y²) - 2a²x = 2x(2r² - a²)\n    // ∂F/∂y = 4y(x² + y²) + 2a²y = 2y(2r² + a²)\n    vec2 grad = vec2(\n        2.0 * p.x * (2.0 * r2 - a * a),\n        2.0 * p.y * (2.0 * r2 + a * a)\n    );\n\n    // Approximate signed distance: |F| / |∇F|\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);  // avoid division by zero\n\n    // Uniform thickness\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a26.-cassini-ovals-animated",
    "href": "appendices/day1-shaders.html#a26.-cassini-ovals-animated",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.26 A26. Cassini Ovals (Animated)",
    "text": "A.26 A26. Cassini Ovals (Animated)\nCassini ovals are curves defined by the product of distances from two foci being constant. The implicit form is \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). By animating the parameter \\(a\\), we see the phase transition: two separate loops when \\(a &lt; c\\), a lemniscate when \\(a = c\\), and a single oval when \\(a &gt; c\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Cassini oval parameters\n    float c = 1.0;  // half-distance between foci\n    float a = 0.8 + 0.4 * sin(iTime * 0.5);  // animate through phase transition\n\n    // Implicit equation: (x² + y²)² - 2c²(x² - y²) = a⁴ - c⁴\n    float r2 = dot(p, p);\n    float c2 = c * c;\n    float a4 = a * a * a * a;\n    float c4 = c2 * c2;\n    float F = r2 * r2 - 2.0 * c2 * (p.x * p.x - p.y * p.y) - (a4 - c4);\n\n    // Gradient: ∂F/∂x = 4x(r²) - 4c²x = 4x(r² - c²)\n    //           ∂F/∂y = 4y(r²) + 4c²y = 4y(r² + c²)\n    vec2 grad = vec2(\n        4.0 * p.x * (r2 - c2),\n        4.0 * p.y * (r2 + c2)\n    );\n\n    // Approximate signed distance\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);\n\n    // Draw curve with uniform thickness\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  },
  {
    "objectID": "appendices/day1-shaders.html#a27.-elliptic-curves-animated",
    "href": "appendices/day1-shaders.html#a27.-elliptic-curves-animated",
    "title": "Appendix A — Appendix: Complete Shader Code for Day 1",
    "section": "A.27 A27. Elliptic Curves (Animated)",
    "text": "A.27 A27. Elliptic Curves (Animated)\nElliptic curves in Weierstrass form: \\(y^2 = x^3 + ax + b\\). The discriminant \\(\\Delta = 4a^3 + 27b^2\\) determines smoothness. We animate along a circle in \\((a,b)\\) parameter space of radius \\(\\sqrt{13}\\), which passes through the singular points \\((-3, \\pm 2)\\) where the curve develops a node (self-intersection).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Circle in (a,b) parameter space passing through singularities at (-3, ±2)\n    float r = sqrt(13.0);\n    float a = r * cos(iTime * 0.3);\n    float b = r * sin(iTime * 0.3);\n\n    // Elliptic curve: y² = x³ + ax + b\n    // Implicit form: F = y² - x³ - ax - b = 0\n    float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n\n    // Gradient: ∂F/∂x = -3x² - a, ∂F/∂y = 2y\n    vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);\n\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Appendix: Complete Shader Code for Day 1</span>"
    ]
  }
]