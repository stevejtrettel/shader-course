[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPU-Accelerated Mathematical Illustration",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nWe’ll progress from 2D foundations (curves, tilings, fractals) to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to experiment with code through daily homework exercises.",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "outline.html",
    "href": "outline.html",
    "title": "Outline",
    "section": "",
    "text": "Course Overview\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nFormat: Five days, each with one hour of lecture and approximately 1.5 hours of required homework, additional hours of optional homework (for those looking to really develop some of the skills, either during the course or after)\nPrerequisites: Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-1-introduction-to-shader-programming",
    "href": "outline.html#day-1-introduction-to-shader-programming",
    "title": "Outline",
    "section": "Day 1: Introduction to Shader Programming",
    "text": "Day 1: Introduction to Shader Programming\n\nLearning Objectives\n\nUnderstand the mathematical model of shader programming (function from pixels to colors)\nLearn basic GLSL syntax and conventions\nMaster coordinate system setup and distance calculations\nCreate simple geometric shapes and patterns\n\n\n\nIn-Class Content\n\nMathematical Introduction\n\nWhat is a shader? Framing as a function: color = f(x, y, time, ...)\nWhy GPUs? Parallelism means computing ALL pixels simultaneously\nShadertoy overview: available uniforms (iResolution, iTime, iMouse)\n\n\n\nFirst Shader: Solid Colors\n\nBasic shader structure: void mainImage(out vec4 fragColor, in vec2 fragCoord)\nSetting fragColor = vec4(1.0, 0.0, 0.0, 1.0) for a red screen\nGLSL syntax basics: semicolons, vector types, swizzling\nAnimating colors with iTime\n\n\n\nCoordinate System Setup\n\nConverting fragCoord to centered, normalized coordinates\nStandard boilerplate for coordinate transformation\nHandling aspect ratio correctly\n\n\n\nHalf-Plane Coloring\n\nBoolean expressions: x &lt; 0.0\nConditional coloring with ternary operator or step() function\nGeneralizing to arbitrary lines: ax + by &lt; 0\n\n\n\nCircles and Distance Fields\n\nComputing distance to center with length(p)\nFilled circle: length(p) &lt; radius\nCircle outline: abs(length(p) - radius) &lt; thickness\nOptional: Color gradients based on distance\n\n\n\nGrids and Repetition\n\nUsing mod(p, spacing) to create repeating cells\nCreating a grid of circles\nAlternating patterns with mod(floor(p), 2.0)\n\n\n\n\nHomework\n\nRequired: Parabola Graphing Calculator\nCreate a shader that draws a parabola with customizable coefficients: - Draw x and y axes (thick lines at x=0 and y=0) - Define variables: float a = 1.0; float b = 0.0; float c = 0.0; - Plot the curve y = ax² + bx + c as a thick tube - Should handle any hardcoded values of a, b, c\n\n\nOptional #1: Animated Curve Family\n\nUse iTime to vary parameters and animate a family of curves\nSuggestions: elliptic fibration, Lissajous curves, morphing shapes\n\n\n\nOptional #2: Beautiful Tiling Pattern\n\nDesign a pattern within a fundamental square\nUse mod() to tile it across the screen\nFocus on aesthetic appeal and mathematical structure",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "href": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "title": "Outline",
    "section": "Day 2: Complex Dynamics and Euclidean Geometry",
    "text": "Day 2: Complex Dynamics and Euclidean Geometry\n\nLearning Objectives\n\nImplement complex number arithmetic in GLSL\nUnderstand and render the Mandelbrot and Julia sets\nCreate geometric tilings using mathematical transformations\nLearn to use structs for organizing data\nGenerate fractals through iterated folding operations\n\n\n\nIn-Class Content\n\nComplex Numbers in GLSL\n\nRepresenting complex numbers as vec2\nImplementing complex multiplication\nComplex addition, conjugation, and magnitude\n\n\n\nThe Mandelbrot Set\n\nMathematical definition: iterating z → z² + c with z₀ = 0\nEscape-time algorithm\nColoring schemes based on iteration count\nDiscussing convergence and divergence\n\n\n\nJulia Sets\n\nFixing c and varying initial z\nRelationship to Mandelbrot set\nCreating visually interesting Julia sets\n\n\n\nIntroduction to Structs\n\nDefining struct types in GLSL\nUse case: organizing geometric data\nExample: storing triangle vertices or transformation data\n\n\n\nEuclidean Triangle Tiling\n\nFundamental domain for triangular tiling\nReflection across edges to create periodic patterns\nSymmetry groups and transformations\n\n\n\nSierpinski Triangle via Folding\n\nGenerating fractals through iterated reflections\nUsing abs() for geometric folding\nScaling and iteration\nColoring by iteration depth or distance\n\n\n\n\nHomework\n\nRequired: Circle Inversion\n\nImplement circle inversion as an operation on the plane\nFor a circle of radius R centered at origin: p' = R² * p / |p|²\nFor a circle centered at c with radius R: translate, invert, translate back\nVisualize by applying inversion to a grid or pattern\nDemonstrate that circles through the inversion center become lines, and vice versa\n\n\n\nOptional #1: Apollonian Gasket\n\nUse your circle inversion implementation\nStart with three mutually tangent circles\nRepeatedly invert through each circle\nColor by iteration count or which circle was inverted through\nExplore the fractal structure created by nested circles\n\n\n\nOptional #2: Hyperbolic Triangle Tiling (Preview)\n\nAttempt tiling in Poincaré disk or upper half-plane model\nUse circle inversions for reflections across geodesics\nPreview of Day 3 content for those who want to get ahead",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-3-fractals-and-hyperbolic-geometry",
    "href": "outline.html#day-3-fractals-and-hyperbolic-geometry",
    "title": "Outline",
    "section": "Day 3: Fractals and Hyperbolic Geometry",
    "text": "Day 3: Fractals and Hyperbolic Geometry\n\nLearning Objectives\n\nExtend folding techniques to box fractals\nUnderstand hyperbolic geometry models and their properties\nImplement computations in the upper half-plane model\nCreate hyperbolic tilings using inversions and Möbius transformations\nConvert between different models of hyperbolic geometry\n\n\n\nIn-Class Content\n\nSierpinski Carpet\n\nBox folding in 2D using abs() for square symmetry\nRecursive subdivision and removal pattern\nScaling by factor of 3 at each iteration\nConnection to Sierpinski triangle from Day 2\nColoring strategies (iteration depth, distance to removed regions)\n\n\n\nIntroduction to Hyperbolic Geometry\n\nWhy hyperbolic space? Negative curvature vs. Euclidean geometry\nThree primary models: Poincaré disk, upper half-plane, and band model\nHow models are related via Möbius transformations\nProperties: geodesics, distance, angle measurement\n\n\n\nComputations in the Upper Half-Plane Model\n\nDefinition: points {z : Im(z) &gt; 0}\nGeodesics: vertical lines and semicircles perpendicular to real axis\nDistance formula in the upper half-plane\nMöbius transformations as isometries: z → (az + b)/(cz + d) with ad - bc = 1\nMatrix representation of transformations\n\n\n\nHyperbolic Triangle Tiling\n\nSetting up a hyperbolic triangle (angles sum to &lt; π)\nComputing geodesics as circular arcs\nImplementing circle inversion for reflections across geodesics\nFolding points into fundamental domain\nIterating to create the full tiling\nColoring by domain or iteration behavior\n\n\n\nDrawing in Different Models\n\nConverting between Poincaré disk and upper half-plane\nMöbius transformation: w = i(1-z)/(1+z) (disk to half-plane)\nBand model via additional Möbius transformation\nVisualizing the same tiling in multiple models simultaneously\n\n\n\n\nHomework\n\nRequired: Sierpinski Carpet\n\nImplement the 2D Sierpinski carpet using box folding\nUse abs() to create 4-fold symmetry\nScale by 3 at each iteration, removing middle square\nColor by iteration depth or distance\nExperiment with different iteration counts\n\n\n\nRequired: Model Conversion and Möbius Transformation\n\nConvert your hyperbolic tiling from upper half-plane to Poincaré disk (or vice versa)\nApply a Möbius transformation to your tiling (choose your own or use a suggested one)\nRender both the original and transformed tiling\nObserve how the transformation affects the visual appearance\n\n\n\nOptional: Advanced Explorations\n\nAnother Triangle Group: Implement a different hyperbolic triangle group (e.g., (2,3,7), (2,4,6))\nKlein Model: Convert to Klein model via Cayley transform\nConformal Art: Use complex analysis to map to creative domains\nDecorated Tiles: Create Escher-style decorated tiles",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-4-introduction-to-3d-rendering",
    "href": "outline.html#day-4-introduction-to-3d-rendering",
    "title": "Outline",
    "section": "Day 4: Introduction to 3D Rendering",
    "text": "Day 4: Introduction to 3D Rendering\n\nLearning Objectives\n\nUnderstand ray setup and camera models\nImplement analytical ray-object intersection\nLearn the raymarching algorithm and signed distance functions\nApply basic lighting models (diffuse shading)\n\n\n\nIn-Class Content\n\nRay Setup and Camera Model\n\nDefining ray origin and direction from pixel coordinates\nSimple camera model: position, look-at, up vector\nField of view and perspective projection\n\n\n\nAnalytical Ray-Sphere Intersection\n\nDeriving the intersection equation (quadratic)\nSolving for intersection parameter t\nComputing surface normal at intersection point\nRendering the sphere with flat color\n\n\n\nRay-Torus Intersection\n\nImplicit equation for a torus\nComputing gradient for surface normal\nDiscussion: analytical methods become complex quickly\n\n\n\nMotivation for Raymarching\n\nCombining multiple objects is difficult with analytical methods\nBoolean operations (union, intersection) are hard\nArbitrary implicit surfaces require root-finding\n\n\n\nSigned Distance Functions (SDFs)\n\nMathematical definition: minimum distance to surface\nSDFs for basic primitives: sphere, box, plane, torus, cylinder\nProperties: Lipschitz continuity and safe marching\n\n\n\nThe Raymarching Algorithm\n\nSphere tracing: march along ray by the distance to nearest surface\nStopping conditions: hit surface, max iterations, or exit bounds\nEstimating normals via gradient of the SDF\n\n\n\nBasic Lighting\n\nComputing surface normal from SDF gradient\nDiffuse shading: dot product with light direction\nSimple Lambertian lighting model\n\n\n\n\nHomework\n\nRequired: Algebraic Variety Rendering\n\nChoose a polynomial implicit surface (degree 3 or 4)\nImplement root-finding algorithm (bisection, Newton’s method, etc.)\nUse gradient for directional derivative to estimate distance\nOptimization: use sphere bounding box (outside sphere → return sphere SDF, inside → compute polynomial distance)\n\n\n\nOptional: Advanced Lighting and Transformations\n\nSpecular Lighting: Implement Phong or Blinn-Phong model\nTransformations: Use rotation matrices to orient objects in the scene\nComplex Scene: Combine multiple transformed objects with analytical intersections",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-5-choose-your-adventure",
    "href": "outline.html#day-5-choose-your-adventure",
    "title": "Outline",
    "section": "Day 5: Choose Your Adventure",
    "text": "Day 5: Choose Your Adventure\nThe final day will be determined based on pacing, student interest, and energy levels. Two complete lectures are prepared:\n\nOption A: Advanced Raymarching Techniques\n\nLearning Objectives\n\nMaster domain operations for efficient complex scenes\nUnderstand and apply boolean operations on SDFs\nCreate 3D fractals via iterated folding\nBuild sophisticated mathematical visualizations\n\n\n\nIn-Class Content\n\nDomain Operations\n\nRepetition: Using mod(p, spacing) for infinite grids of objects\nSymmetry: Using abs() for mirror planes\nPolar repetition: Radial patterns around an axis\nComputational advantage: Zero cost for infinite complexity\n\n\n\nBoolean Operations on SDFs\n\nUnion: min(d1, d2)\nIntersection: max(d1, d2)\nSubtraction: max(d1, -d2)\nSmooth minimum: smin() for organic blending\nBuilding complex shapes from primitive combinations\n\n\n\nThe Menger Sponge\n\nBox folding in 3D with axis-aligned planes\nIterated subdivision pattern\nScaling and repetition\nConnection to Day 2’s Sierpinski carpet\n\n\n\nAdvanced Examples\n\nArchitectural structures via boolean operations\nInfinite repeated patterns via domain operations\nCombining techniques for rich scenes\n\n\n\n\nHomework\n\nRequired: Creative Scene Building\n\nBuild a complex scene using domain operations and boolean combinations\nExperiment with different SDFs and transformations\nFocus on mathematical or aesthetic interest\n\n\n\nOptional: Sierpinski Tetrahedron\n\nImplement 3D Sierpinski tetrahedron via folding\nReflect across four planes (non-axis-aligned)\nConnection to Day 2’s triangle folding in higher dimension\n\n\n\n\n\n\nOption B: Buffers and Temporal Dynamics\n\nLearning Objectives\n\nUnderstand buffer-based computation in Shadertoy\nImplement differential operators (Laplacian)\nSolve partial differential equations on the GPU\nCreate dynamic, evolving mathematical systems\n\n\n\nIn-Class Content\n\nIntroduction to Buffers\n\nReading from previous frame: texture(iChannel0, uv)\nMulti-pass rendering in Shadertoy\nSimple example: reading buffer and applying conditional coloring (bright → yellow, dark → blue)\n\n\n\nEdge Detection and the Laplacian\n\nDiscrete Laplacian stencil (5-point or 9-point)\nSampling neighboring pixels\nVisualizing edges in imagery\nIntroduction to spatial derivatives on discrete grids\n\n\n\nThe Heat Equation\n\nMathematical formulation: u_t = α∇²u\nApplying the Laplacian stencil for diffusion\nTime-stepping: u_new = u_old + dt * α * laplacian(u_old)\nInitial conditions: heat distribution in a fractal or Julia set\nWatching the pattern blur and diffuse\n\n\n\nBoundary Conditions\n\nZero boundary conditions (edges set to 0)\nAvoiding wrap-around artifacts\nDiscussion of periodic boundaries (if time)\n\n\n\nTimestep Stability\n\nCFL condition (briefly mentioned)\nProviding a stable dt value\nWarning: don’t make timestep too large!\n\n\n\n\nHomework\n\nRequired: Interactive Heat Equation or Reaction-Diffusion\n\nInteractive Heat Source: Add heat at mouse position, watch it diffuse\nGray-Scott Reaction-Diffusion: Implement pattern formation (spots, stripes, etc.) - store U and V in different color channels\n\n\n\nOptional: Wave Equation\n\nRequires two buffers (current and previous state)\nImplement u_tt = c²∇²u\nInitial conditions: pluck a “string” or create a disturbance\nWatch waves propagate and reflect",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "day1.html",
    "href": "day1.html",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "1.1 Overview\nToday we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.\nBy the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#what-is-a-shader",
    "href": "day1.html#what-is-a-shader",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.2 What is a Shader?",
    "text": "1.2 What is a Shader?\n\nMathematical Perspective\nA shader is fundamentally a function \\[f: \\mathbb{R}^2 \\times \\mathbb{R} \\times \\cdots \\to \\mathbb{R}^4\\] that maps pixel coordinates (and potentially time, mouse position, etc.) to color values. For each pixel on the screen, we evaluate this function to determine what color to display.\nThe key insight: modern GPUs can evaluate this function for all pixels simultaneously. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second.\nThis parallelism is what makes shaders extraordinarily fast for mathematical visualization—we’re not looping over pixels sequentially, we’re computing them all at once.\n\n\nWhy Shadertoy?\nShadertoy is a web-based platform that abstracts away the complexities of GPU programming (setting up OpenGL contexts, managing buffers, compiling shaders, etc.). You write a single function, and Shadertoy handles everything else.\nThe platform provides several built-in uniforms (read-only global variables): - iResolution: screen resolution as a vec3 (width, height, pixel aspect ratio) - iTime: elapsed time in seconds - iMouse: mouse position and click state as a vec4\nWe’ll use these throughout the week.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#first-shader-solid-colors",
    "href": "day1.html#first-shader-solid-colors",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.3 First Shader: Solid Colors",
    "text": "1.3 First Shader: Solid Colors\n\nBasic Structure\nEvery Shadertoy shader has the same entry point:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Your code here\n}\nParameters: - fragCoord: the pixel coordinate we’re currently computing, as a vec2 (x, y) - fragColor: the output color we need to set, as a vec4 (red, green, blue, alpha)\nColors are represented in RGBA format with values in \\([0, 1]\\). So vec4(1.0, 0.0, 0.0, 1.0) represents opaque red, while vec4(0.5, 0.5, 0.5, 1.0) is middle gray.\n\n\nExample: Red Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nThis sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on fragCoord, every pixel gets the same value.\n\n\nGLSL Syntax Basics\nA few essential points about the GLSL language:\nSemicolons are required. Every statement must end with a semicolon. This is not Python!\nVector types: GLSL has built-in types vec2, vec3, vec4 for 2D, 3D, and 4D vectors. You can construct them with:\nvec2 v = vec2(1.0, 2.0);\nvec3 w = vec3(1.0, 2.0, 3.0);\nvec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars\nSwizzling: You can access components by name: v.x, v.y or v.r, v.g (same thing, different naming convention). We’ll cover more syntax in the appendix.\nFloating point literals: Write 1.0 not 1 for floating point values. GLSL is picky about types.\n\n\nAnimating with Time\nLet’s make something that changes:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\nHere iTime grows continuously, sin(iTime) oscillates between \\(-1\\) and \\(1\\), and we remap to \\([0, 1]\\) with the affine transformation \\(x \\mapsto \\frac{1}{2}(1 + x)\\). The screen now pulses between black and red.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#coordinate-systems",
    "href": "day1.html#coordinate-systems",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.4 Coordinate Systems",
    "text": "1.4 Coordinate Systems\n\nRaw Coordinates\nBy default, fragCoord gives pixel coordinates with: - Origin \\((0, 0)\\) at the bottom-left - \\(x\\) increases rightward to iResolution.x - \\(y\\) increases upward to iResolution.y\nFor mathematical work, we want: - Origin at the center - Coordinates normalized (not in pixels) - Aspect ratio handled correctly\n\n\nCentered, Normalized Coordinates\nHere’s a standard transformation:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Center at origin: [-0.5, 0.5]\n    uv = uv - 0.5;\n    \n    // Scale to account for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Now uv is centered and aspect-corrected\n    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)\n    vec2 p = uv * 4.0;  // Now p is in [-2, 2] × [-h, h] where h depends on aspect ratio\n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nFrom now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable p for “position.”\n\n\nVisualizing Coordinates\nLet’s color pixels by their position:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup as above, resulting in p]\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\nYou should see a smooth gradient: red increases rightward, green increases upward.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#conditional-coloring-half-planes",
    "href": "day1.html#conditional-coloring-half-planes",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.5 Conditional Coloring: Half-Planes",
    "text": "1.5 Conditional Coloring: Half-Planes\n\nThe Concept\nGiven a linear function \\(L(x, y) = ax + by\\), we want to color pixels differently depending on whether \\(L(p) &lt; 0\\) or \\(L(p) \\geq 0\\). This divides the plane into two half-planes.\n\n\nImplementation\nGLSL provides a conditional operator (ternary operator) just like C:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\nLeft half-plane is red, right half-plane is blue.\n\n\nThe Step Function\nGLSL also provides step(edge, x) which returns 0 if \\(x &lt; \\text{edge}\\) and 1 otherwise. This is useful for smooth code:\nfloat s = step(0.0, p.x);  // 0 on left, 1 on right\nvec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\nHere mix(a, b, t) performs linear interpolation: \\((1-t)a + tb\\).\n\n\nArbitrary Half-Planes\nFor a general line \\(ax + by = 0\\):\nfloat a = 1.0, b = 1.0;\nfloat L = a * p.x + b * p.y;\nvec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\nfragColor = vec4(color, 1.0);\nTry different values of \\(a\\) and \\(b\\) to see different line orientations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#distance-fields-and-circles",
    "href": "day1.html#distance-fields-and-circles",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.6 Distance Fields and Circles",
    "text": "1.6 Distance Fields and Circles\n\nDistance to Center\nThe distance from a point \\(p = (x, y)\\) to the origin is simply \\[d = \\|p\\| = \\sqrt{x^2 + y^2}\\]\nIn GLSL:\nfloat d = length(p);\nThe length() function computes the Euclidean norm of a vector.\n\n\nFilled Circle\nA circle of radius \\(r\\) centered at the origin is the set \\(\\{p : \\|p\\| &lt; r\\}\\). We can color inside vs. outside:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis renders a yellow disk on a dark blue background.\n\n\nDistance-Based Coloring\nWe can create gradients by mapping distance to color:\nfloat d = length(p);\nfloat intensity = 1.0 - d / 2.0;  // Fades out with distance\nintensity = clamp(intensity, 0.0, 1.0);  // Keep in [0, 1]\nvec3 color = vec3(intensity);\nfragColor = vec4(color, 1.0);\n\n\nCircle Outline\nTo draw just the boundary of a circle (an annulus of small thickness), we check if \\(d\\) is approximately equal to \\(r\\):\nfloat d = length(p);\nfloat r = 1.0;\nfloat thickness = 0.05;\n\nfloat circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\nvec3 color = vec3(circle_mask);\nfragColor = vec4(color, 1.0);\nMathematically, we’re coloring the set \\(\\{p : |d(p) - r| &lt; \\epsilon\\}\\) where \\(\\epsilon\\) is our thickness parameter.\nFor a smoother edge, we can use smoothstep:\nfloat circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\nThe smoothstep(a, b, x) function performs smooth Hermite interpolation between \\(a\\) and \\(b\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#grids-and-repetition",
    "href": "day1.html#grids-and-repetition",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.7 Grids and Repetition",
    "text": "1.7 Grids and Repetition\n\nModular Arithmetic\nThe modulo operation creates periodic repetition. For a period \\(T\\), the function \\(p \\mapsto (p \\bmod T) - T/2\\) maps \\(\\mathbb{R}\\) to \\([-T/2, T/2]\\) repeatedly.\nIn GLSL, mod(x, T) computes \\(x \\bmod T\\).\n\n\nCreating a Grid\nTo create a grid of repeated cells:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Now cell_p repeats every spacing units\n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis creates an infinite grid of yellow circles!\n\n\nAlternating Pattern\nWe can create checkerboard-like patterns using the cell index:\nvec2 cell_id = floor(p / spacing);\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\n\nvec3 color_a = vec3(1.0, 0.0, 0.0);\nvec3 color_b = vec3(0.0, 0.0, 1.0);\nvec3 bg_color = mix(color_a, color_b, checker);\nHere floor(p / spacing) gives us integer grid indices, and we alternate colors based on the parity of \\(i + j\\).\n\n\nCombining with Circles\nPut it all together for a grid of circles on an alternating background:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#implicit-curves",
    "href": "day1.html#implicit-curves",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.8 Implicit Curves",
    "text": "1.8 Implicit Curves\n\nGeneral Principle\nAn implicit curve is defined by an equation \\(F(x, y) = 0\\). To render it, we compute \\(F(p)\\) for each pixel and color based on proximity to zero:\nfloat F = [some function of p.x and p.y];\nfloat thickness = 0.05;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nvec3 color = mix(background, curve_color, curve_mask);\n\n\nExample: Parabola\nThe parabola \\(y = x^2\\) can be written implicitly as \\(F(x, y) = y - x^2 = 0\\):\nfloat F = p.y - p.x * p.x;\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n\nvec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\nfragColor = vec4(color, 1.0);\n\n\nExample: Circle (Implicit Form)\nWe’ve been using \\(\\|p\\| &lt; r\\) for filled circles, but we can also write the circle implicitly as \\(x^2 + y^2 - r^2 = 0\\):\nfloat r = 1.0;\nfloat F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nThis is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#summary",
    "href": "day1.html#summary",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.9 Summary",
    "text": "1.9 Summary\nToday we’ve learned:\n\nShaders as parallel functions: Every pixel evaluates \\(f(x, y, t, \\ldots) \\to \\text{color}\\) simultaneously\nGLSL basics: Syntax, vector types, and built-in functions\nCoordinate systems: Centering, normalizing, and scaling for mathematical work\nConditional coloring: Using boolean expressions and step() for discrete color regions\nDistance fields: Using length() to create circles and radial patterns\nModular arithmetic: Creating grids and repeating patterns with mod()\nImplicit curves: Rendering curves defined by \\(F(x, y) = 0\\)\n\nWith these tools, you can already create a wide variety of mathematical visualizations!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#homework",
    "href": "day1.html#homework",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.10 Homework",
    "text": "1.10 Homework\n\nRequired: Parabola Graphing Calculator\nCreate a shader that draws a customizable parabola \\(y = ax^2 + bx + c\\) along with coordinate axes.\nRequirements: - Define variables a, b, c at the top of your shader (hardcoded values are fine) - Draw the \\(x\\)-axis and \\(y\\)-axis as thick lines (use the implicit line technique: \\(|y| &lt; \\epsilon\\) for \\(x\\)-axis, \\(|x| &lt; \\epsilon\\) for \\(y\\)-axis) - Plot the parabola \\(y = ax^2 + bx + c\\) as a thick curve - Use distinct colors for axes and parabola - The visualization should work for any reasonable values of \\(a\\), \\(b\\), \\(c\\)\nSuggested approach:\n// Define parameters\nfloat a = 1.0;\nfloat b = 0.0;\nfloat c = 0.0;\n\n// Axes\nfloat x_axis_mask = abs(p.y) &lt; 0.05 ? 1.0 : 0.0;\nfloat y_axis_mask = abs(p.x) &lt; 0.05 ? 1.0 : 0.0;\n\n// Parabola: F(x,y) = y - (ax² + bx + c) = 0\nfloat F = p.y - (a * p.x * p.x + b * p.x + c);\nfloat parabola_mask = abs(F) &lt; 0.1 ? 1.0 : 0.0;\n\n// Combine\nvec3 color = background;\ncolor = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\ncolor = mix(color, parabola_color, parabola_mask);\nTry different values of \\(a\\), \\(b\\), \\(c\\) and verify your grapher works correctly!\n\n\nOptional #1: Animated Curve Family\nCreate a shader that animates through a family of curves.\nSuggestions: - Elliptic fibration: Fix a cubic polynomial and vary a parameter: \\(y^2 = x^3 + ax + b\\) where \\(a\\) or \\(b\\) varies with iTime - Lissajous curves: \\(x = A\\sin(at + \\delta)\\), \\(y = B\\sin(bt)\\), animate \\(\\delta\\) or the frequency ratio\nUse iTime creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families.\n\n\nOptional #2: Beautiful Tiling Pattern\nDesign an aesthetically pleasing tiling pattern using the mod() technique.\nRequirements: - Create a non-trivial pattern within a fundamental domain (a single tile) - Use mod() to repeat it across the plane - The pattern should tile seamlessly (edges should match up)\nIdeas: - Geometric patterns: nested circles, polygons, stars - Color gradients that vary by tile position - Combinations of implicit curves within each tile - Symmetry: use abs() to create reflections within tiles\nChallenge: Can you create a pattern that has different symmetries in different tiles? (For example, alternating rotational symmetry using the checkerboard cell_id technique.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#looking-ahead",
    "href": "day1.html#looking-ahead",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.11 Looking Ahead",
    "text": "1.11 Looking Ahead\nTomorrow we’ll use these techniques to explore complex dynamics (the Mandelbrot and Julia sets) and geometric tilings (including fractals via iterated folding). The coordinate system and implicit curve techniques you’ve learned today will be the foundation for everything to come.\nMake sure you’re comfortable with: - Setting up coordinates - Computing distances and implicit functions\n- Using mod() for repetition - Conditionally coloring based on mathematical expressions",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day2.html",
    "href": "day2.html",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "",
    "text": "2.1 Overview\nToday we explore the power of iteration and geometric transformations. We’ll implement complex arithmetic in GLSL, use it to render the iconic Mandelbrot and Julia sets, and create geometric tilings through reflection. We conclude by building our first fractal via iterated folding—the Sierpinski triangle.\nBy the end of today, you’ll understand how simple iterative processes can generate intricate mathematical structures, how to organize geometric data using structs, and how folding operations can create self-similar fractals.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#complex-numbers-in-glsl",
    "href": "day2.html#complex-numbers-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.2 Complex Numbers in GLSL",
    "text": "2.2 Complex Numbers in GLSL\n\nRepresentation\nA complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part.\n\n\nComplex Arithmetic\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nThese are the building blocks we need for complex dynamics.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#the-mandelbrot-set",
    "href": "day2.html#the-mandelbrot-set",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.3 The Mandelbrot Set",
    "text": "2.3 The Mandelbrot Set\n\nDefinition\nThe Mandelbrot set \\(\\mathcal{M}\\) is defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nIn practice, we: 1. Start with \\(z_0 = 0\\) 2. Iterate \\(z_{n+1} = z_n^2 + c\\) for a fixed number of iterations (say, 100) 3. Check if \\(|z_n|\\) has escaped some large radius (typically \\(R = 2\\))\nPoints that escape quickly are definitely not in \\(\\mathcal{M}\\). Points that remain bounded after many iterations are likely in \\(\\mathcal{M}\\).\n\n\nImplementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nColoring Schemes\nThe grayscale rendering shows structure but isn’t very exciting. We can create better colormaps:\nSmooth coloring using escape time:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    // Use a color palette (see below)\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nSimple color palette:\nvec3 palette(float t) {\n    // Create a cyclic color palette\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors. Play with the parameters a, b, c, d to get different color schemes!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#julia-sets",
    "href": "day2.html#julia-sets",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.4 Julia Sets",
    "text": "2.4 Julia Sets\n\nDefinition\nFor a fixed complex parameter \\(c\\), the filled Julia set \\(\\mathcal{K}_c\\) consists of points \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded.\nKey difference from Mandelbrot: Here \\(c\\) is fixed and we vary the initial point \\(z_0\\) (which comes from the pixel position). In Mandelbrot, \\(z_0 = 0\\) and \\(c\\) varies with pixel position.\n\n\nRelationship to Mandelbrot\nThere’s a beautiful connection: the Mandelbrot set is essentially a “parameter space” for Julia sets. Each point \\(c\\) in the complex plane has an associated Julia set \\(\\mathcal{K}_c\\): - If \\(c \\in \\mathcal{M}\\), then \\(\\mathcal{K}_c\\) is connected - If \\(c \\notin \\mathcal{M}\\), then \\(\\mathcal{K}_c\\) is a Cantor dust (totally disconnected)\n\n\nImplementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv * 3.0;  // Initial point z_0 comes from pixel position\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // A classic choice\n    // Try: vec2(-0.4, 0.6), vec2(0.285, 0.01), vec2(-0.8, 0.156)\n    \n    // Iterate z_{n+1} = z_n² + c\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color (same as Mandelbrot)\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    if(iter == max_iter) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nTry different values of \\(c\\) to explore the incredible variety of Julia sets! You can even animate \\(c\\) with time:\nvec2 c = vec2(0.7 * cos(iTime * 0.3), 0.7 * sin(iTime * 0.3));",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#structs-in-glsl",
    "href": "day2.html#structs-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.5 Structs in GLSL",
    "text": "2.5 Structs in GLSL\n\nMotivation\nAs we build more complex geometric objects, we need to organize related data. GLSL provides structs (similar to C structs or simple classes without methods).\n\n\nDefining a Struct\nstruct Triangle {\n    vec2 v0;  // First vertex\n    vec2 v1;  // Second vertex\n    vec2 v2;  // Third vertex\n};\n\n\nUsing Structs\nTriangle tri;\ntri.v0 = vec2(0.0, 1.0);\ntri.v1 = vec2(-0.866, -0.5);\ntri.v2 = vec2(0.866, -0.5);\n\n// Access fields with dot notation\nvec2 centroid = (tri.v0 + tri.v1 + tri.v2) / 3.0;\n\n\nWhy Structs?\nFor geometric transformations (reflections, rotations), we’ll need to pass around geometric data. Structs make the code cleaner and more mathematical. For example, we can write:\nvec2 reflect(vec2 p, Triangle tri) {\n    // Reflect point p across an edge of tri\n    // [Implementation details]\n}\nThis is more readable than passing six individual float parameters for the triangle vertices.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#euclidean-triangle-tiling",
    "href": "day2.html#euclidean-triangle-tiling",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.6 Euclidean Triangle Tiling",
    "text": "2.6 Euclidean Triangle Tiling\n\nThe Fundamental Domain\nAn equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can: 1. Reflect across its three edges 2. Repeat this process on the resulting triangles 3. Fill the entire plane with copies of the original triangle\n\n\nSetting Up the Triangle\nLet’s work with an equilateral triangle with vertices at: \\[v_0 = (0, 1), \\quad v_1 = (-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}), \\quad v_2 = (\\frac{\\sqrt{3}}{2}, -\\frac{1}{2})\\]\nThis triangle has side length \\(\\sqrt{3}\\) and is centered at the origin.\n// Define triangle vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866\nvec2 v2 = vec2(0.866, -0.5);\n\n\nReflection Across a Line\nTo reflect a point \\(p\\) across a line through the origin with unit normal \\(\\mathbf{n}\\), we use: \\[p' = p - 2(\\mathbf{n} \\cdot p)\\mathbf{n}\\]\nFor a line through two points (an edge of our triangle), we need to: 1. Compute the perpendicular direction (normal to the edge) 2. Determine which side of the line we’re on 3. Reflect if necessary\nPlaceholder for specific implementation: The exact formulas depend on how we set up our edges. Here’s the structure:\n// Reflect across edge v0-v1\nvec2 edge = v1 - v0;\nvec2 normal = normalize(vec2(-edge.y, edge.x));  // Perpendicular to edge\nfloat dist = dot(p - v0, normal);  // Signed distance to line\nif(dist &lt; 0.0) {\n    p = p - 2.0 * dist * normal;  // Reflect if on wrong side\n}\n\n\nIterative Folding\nThe key insight: we repeatedly reflect \\(p\\) across the three edges of the triangle until it lands inside the fundamental domain.\nvec2 foldToTriangle(vec2 p, int iterations) {\n    // Define the three edges and their normals\n    // [Edge definitions here]\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Reflect across each edge if necessary\n        // [Reflection code for edge 0]\n        // [Reflection code for edge 1]\n        // [Reflection code for edge 2]\n    }\n    \n    return p;\n}\nAfter folding, all points in the plane map to the interior of our triangle. We can then color based on: - The final position within the triangle - The number of reflections needed - Which edge was crossed most recently\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 p = [coordinate setup as usual];\n    \n    // Fold to fundamental domain\n    vec2 p_folded = foldToTriangle(p, 10);\n    \n    // Color based on position in triangle\n    // Could use barycentric coordinates, distance to edges, etc.\n    vec3 color = vec3(p_folded * 0.5 + 0.5, 0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\nNote: The exact implementation requires careful handling of the geometry. The key mathematical ideas are: 1. Reflection formula: \\(p' = p - 2(p \\cdot n)n\\) for a line with normal \\(n\\) through origin 2. Iterative folding brings any point into the fundamental domain 3. Track which reflections occur for interesting coloring",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#sierpinski-triangle-via-folding",
    "href": "day2.html#sierpinski-triangle-via-folding",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.7 Sierpinski Triangle via Folding",
    "text": "2.7 Sierpinski Triangle via Folding\n\nThe Concept\nThe Sierpinski triangle is a fractal that can be generated by: 1. Starting with an equilateral triangle 2. Removing the middle triangle (connecting midpoints) 3. Repeating on each remaining sub-triangle\nEquivalently, we can generate it by iterated folding with scaling.\n\n\nFolding Algorithm\nAt each iteration: 1. Reflect \\(p\\) across the three edges of the triangle (fold it inside) 2. Scale toward the center 3. Repeat\nMathematically, after \\(n\\) iterations, we’ve zoomed in by a factor of \\(2^n\\) and applied \\(n\\) reflections.\n\n\nImplementation Sketch\nvec2 sierpinskiFold(vec2 p, int iterations) {\n    // Triangle vertices (equilateral)\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    float scale = 1.0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Reflect across each edge (fold into triangle)\n        // [Reflection code similar to triangle tiling]\n        \n        // After folding, scale and translate\n        p = p * 2.0;  // Zoom in by factor of 2\n        scale *= 2.0;\n        \n        // [Additional centering/translation may be needed]\n    }\n    \n    return p;\n}\n\n\nColoring by Iteration Depth\nWe can track how many times we hit certain conditions during folding:\nint orbit = 0;  // Track some property during iteration\n\nfor(int i = 0; i &lt; max_iter; i++) {\n    // Folding operations\n    \n    // Track orbit behavior\n    if([some condition]) orbit++;\n}\n\n// Color based on orbit count\nfloat t = float(orbit) / float(max_iter);\nvec3 color = palette(t);\nThe specific conditions to track depend on the geometric setup, but typically we color based on: - Which edge we reflected across most recently - How many reflections were needed - Distance from the center after folding\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    // Apply Sierpinski folding\n    vec2 p_folded = sierpinskiFold(p, 8);\n    \n    // Color based on the folded position\n    float d = length(p_folded);\n    vec3 color = d &lt; 0.1 ? vec3(1.0) : vec3(0.0);\n    \n    // OR: color based on iteration behavior\n    // [More sophisticated coloring]\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Sierpinski triangle should emerge as a self-similar fractal pattern!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#summary",
    "href": "day2.html#summary",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.8 Summary",
    "text": "2.8 Summary\nToday we covered:\n\nComplex arithmetic in GLSL: Representing complex numbers as vec2 and implementing multiplication\nMandelbrot set: Iterating \\(z_{n+1} = z_n^2 + c\\) with \\(z_0 = 0\\), coloring by escape time\nJulia sets: Fixing \\(c\\) and varying initial point \\(z_0\\), exploring the parameter space\nStructs: Organizing geometric data for cleaner code\nTriangle tiling: Using reflection to fold the plane into a fundamental domain\nSierpinski triangle: Generating fractals through iterated folding and scaling\n\nThe key themes: - Simple iterations create complex behavior (chaos and fractals) - Geometric transformations (reflections) can tile or generate fractals - Tracking iteration behavior gives us rich information for coloring - Folding operations create self-similar structures\nTomorrow we’ll extend these ideas: more fractals via folding, then hyperbolic geometry where the same techniques create entirely different tilings.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#homework",
    "href": "day2.html#homework",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.9 Homework",
    "text": "2.9 Homework\n\nRequired: Interactive Julia Sets\nAdd mouse control to the julia sets: take iMouse and read it out as a complex number, then draw the julia set for that number.\n\n\nRequired: Circle Inversion\nCircle inversion is a fundamental transformation in geometry that will be the basis for many interesting visualizations. Your task is to implement it as a general operation on the plane.\nMathematical Background:\nInversion with respect to a circle of radius \\(R\\) centered at the origin maps a point \\(p \\neq 0\\) to: \\[\\text{inv}(p) = R^2 \\frac{p}{|p|^2}\\]\nGeometrically, this maps the inside of the circle to the outside and vice versa, with points on the circle remaining fixed. Key properties: - Circles passing through the center become lines (and vice versa) - Circles not passing through the center remain circles - Angles are preserved (it’s a conformal map)\nFor a circle centered at \\(c\\) with radius \\(R\\), we: 1. Translate to center the circle at origin: \\(p' = p - c\\) 2. Apply inversion: \\(p'' = R^2 \\frac{p'}{|p'|^2}\\) 3. Translate back: \\(\\text{result} = p'' + c\\)\nImplementation Tasks:\n\nBasic inversion centered at origin:\n\nvec2 invert(vec2 p, float R) {\n    float r2 = dot(p, p);\n    return R * R * p / r2;\n}\n\nInversion centered at arbitrary point:\n\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    // Translate, invert, translate back\n    // [Implement this]\n}\n\nVisualization: Create a shader that applies circle inversion to a pattern. Suggestions:\n\nStart with a grid and show its image under inversion\nDraw several circles and show how they transform\nApply inversion to implicit curves from Day 1\nMake the inversion center follow the mouse position using iMouse.xy\n\nDemonstrate properties: Show that:\n\nA line through the inversion center maps to itself\nA line not through the center maps to a circle through the center\nA circle through the center maps to a line\n\n\nExpected Output: A shader that clearly demonstrates circle inversion operating on the plane, with visual evidence of its geometric properties.\n\n\nOptional #1: Apollonian Gasket\nNow that you’ve implemented circle inversion, use it to create the beautiful Apollonian gasket fractal.\nThe Construction:\nStart with three mutually tangent circles. The Apollonian gasket is generated by: 1. Finding the fourth circle tangent to all three (Apollonius’s problem—there are generally two solutions) 2. Recursively filling gaps with new tangent circles 3. Continuing indefinitely\nSimplified Approach via Inversion:\nRather than solving for tangent circles explicitly, we can use inversions: 1. Start with a configuration of circles (e.g., three circles tangent at a point) 2. Define inversions with respect to each circle 3. Apply these inversions repeatedly to generate the fractal pattern 4. Color based on iteration count or which circle was most recently inverted through\nChallenge: Setting up the initial configuration and inversion circles requires working out the tangency conditions. One standard setup: - Three circles of radius 1 centered at the vertices of an equilateral triangle of side length 2 - These are mutually tangent\nVisualization: The resulting fractal should show nested circles filling the gaps in a self-similar pattern, creating a beautiful packing.\n\nOptional: Grid of Julia Sets!\nDivide the plane into a small rectangular grid, inside each grid draw the julia set for the complex number at its center.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#looking-ahead",
    "href": "day2.html#looking-ahead",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.10 Looking Ahead",
    "text": "2.10 Looking Ahead\nTomorrow we’ll continue with fractals and hyperbolic geometry. We’ll start by extending our folding techniques to create the Sierpinski carpet, then dive into hyperbolic space with multiple models (Poincaré disk, upper half-plane, band model) and create beautiful tilings in non-Euclidean geometry.\nMake sure you’re comfortable with: - Complex number iteration and the Mandelbrot/Julia algorithms - Geometric folding operations (reflection via abs(), scaling) - Using iteration count for coloring - Circle inversion (from today’s homework—this will be crucial tomorrow!)\nThe circle inversion you implement today will be the foundation for tomorrow’s hyperbolic tilings, so take your time understanding how it works geometrically.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html",
    "href": "day3.html",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "",
    "text": "3.1 Overview\nToday we complete our exploration of 2D fractals and then venture into hyperbolic space. We’ll extend yesterday’s triangle folding to create the Sierpinski carpet, then implement hyperbolic tilings in the upper half-plane model. Finally, we’ll transform our work into the Poincaré disk model to see the same tiling from a different perspective.\nBy the end of today, you’ll have working implementations of hyperbolic geometry computations and be able to create beautiful tilings in non-Euclidean space.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#sierpinski-carpet-via-box-folding",
    "href": "day3.html#sierpinski-carpet-via-box-folding",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.2 Sierpinski Carpet via Box Folding",
    "text": "3.2 Sierpinski Carpet via Box Folding\n\nFrom Triangle to Square\nYesterday we created the Sierpinski triangle by folding across the edges of an equilateral triangle. The Sierpinski carpet applies the same principle to a square, using axis-aligned reflections.\n\n\nThe Algorithm\nStarting with a square domain (say \\([-1, 1]^2\\)), we: 1. Fold using abs() to create 4-fold symmetry (map all quadrants to first quadrant) 2. Scale by factor of 3 3. Remove the middle square 4. Repeat\nAfter \\(n\\) iterations, we’ve subdivided the square into a \\(3^n \\times 3^n\\) grid and removed all middle squares at every scale.\n\n\nImplementation\nvec2 sierpinskiCarpetFold(vec2 p, int iterations, out int removed) {\n    removed = 0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Scale by 3, shift to center\n        p = p * 3.0 - vec2(1.0);\n        \n        // Check if we're in the middle square (to be removed)\n        // After scaling and shifting, the middle square is roughly centered\n        if(abs(p.x) &lt; 1.0 && abs(p.y) &lt; 1.0) {\n            removed = 1;\n        }\n    }\n    \n    return p;\n}\nNote: The exact check for “removed” regions depends on the coordinate setup. After the transformation p * 3.0 - 1.0, we’re centering each sub-square. The middle third is the region we’re removing.\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    int removed;\n    vec2 p_folded = sierpinskiCarpetFold(p, 6, removed);\n    \n    vec3 color = removed == 1 ? vec3(0.0) : vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nThe characteristic Sierpinski carpet should emerge: a square with self-similar removed regions at all scales.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#hyperbolic-geometry-models-and-metrics",
    "href": "day3.html#hyperbolic-geometry-models-and-metrics",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.3 Hyperbolic Geometry: Models and Metrics",
    "text": "3.3 Hyperbolic Geometry: Models and Metrics\n\nThe Upper Half-Plane Model\nThe upper half-plane model \\(\\mathbb{H}^2\\) consists of complex numbers with positive imaginary part: \\[\\mathbb{H}^2 = \\{z \\in \\mathbb{C} : \\text{Im}(z) &gt; 0\\}\\]\nThe hyperbolic metric is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2} = \\frac{|dz|^2}{(\\text{Im}(z))^2}\\]\nThis metric “blows up” as we approach the real axis (the boundary at infinity), making the geometry shrink near \\(y = 0\\).\n\n\nGeodesics in the Upper Half-Plane\nGeodesics (hyperbolic “straight lines”) in \\(\\mathbb{H}^2\\) are: 1. Vertical lines \\(\\{x = c\\}\\) for constant \\(c\\) 2. Semicircles centered on the real axis, perpendicular to it\nFor a semicircle of radius \\(R\\) centered at \\((c, 0)\\), the equation is: \\[(x - c)^2 + y^2 = R^2, \\quad y &gt; 0\\]\n\n\nHyperbolic Distance\nThe distance between two points \\(z, w \\in \\mathbb{H}^2\\) is: \\[d(z, w) = \\text{arcosh}\\left(1 + \\frac{|z - w|^2}{2 \\cdot \\text{Im}(z) \\cdot \\text{Im}(w)}\\right)\\]\nIn GLSL:\nfloat hyperbolicDistance(vec2 z, vec2 w) {\n    float diff2 = dot(z - w, z - w);  // |z - w|²\n    float denom = 2.0 * z.y * w.y;    // 2·Im(z)·Im(w)\n    return acosh(1.0 + diff2 / denom);\n}\nNote: GLSL may not have acosh built-in. Use: acosh(x) = log(x + sqrt(x*x - 1.0)).\n\n\nThe Poincaré Disk Model\nThe Poincaré disk model consists of the interior of the unit disk: \\[\\mathbb{D}^2 = \\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\]\nThe metric is: \\[ds^2 = \\frac{4(dx^2 + dy^2)}{(1 - |z|^2)^2}\\]\nGeodesics are circular arcs perpendicular to the unit circle (or diameters).\n\n\nConverting Between Models\nThe Cayley transform maps the upper half-plane to the disk: \\[w = \\frac{z - i}{z + i}\\]\nThe inverse is: \\[z = i\\frac{1 + w}{1 - w}\\]\nIn GLSL (using complex arithmetic from Day 2):\nvec2 uhpToDisk(vec2 z) {\n    // w = (z - i) / (z + i)\n    vec2 numerator = z - vec2(0.0, 1.0);      // z - i\n    vec2 denominator = z + vec2(0.0, 1.0);    // z + i\n    return cdiv(numerator, denominator);\n}\n\nvec2 diskToUHP(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 numerator = vec2(0.0, 1.0) + w;      // i(1 + w) = cmul(i, 1+w)\n    numerator = vec2(-numerator.y, numerator.x);  // Multiply by i\n    vec2 denominator = vec2(1.0, 0.0) - w;    // 1 - w\n    return cdiv(numerator, denominator);\n}\nWhere cdiv is complex division (you’ll need to implement this - see homework or use the formula \\(\\frac{a + bi}{c + di} = \\frac{(a + bi)(c - di)}{c^2 + d^2}\\)).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#the-23-triangle",
    "href": "day3.html#the-23-triangle",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.4 The (2,3,∞) Triangle",
    "text": "3.4 The (2,3,∞) Triangle\n\nWhy This Triangle?\nThe \\((2, 3, \\infty)\\) triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (the “ideal vertex” at infinity). In the upper half-plane, this triangle has particularly nice edges: - One edge is the unit semicircle centered at the origin: \\(x^2 + y^2 = 1\\), \\(y &gt; 0\\) - Two edges are vertical lines at \\(x = \\pm c\\) for some constant \\(c\\)\nFor the \\((2,3,\\infty)\\) triangle, with the right angle at the origin and the \\(\\pi/3\\) angles at the two vertical edges, we have \\(c = \\sqrt{3}\\) (this can be derived from hyperbolic trigonometry, but we’ll just use it).\nActually, a cleaner setup: let’s use the triangle with: - Geodesic from \\(-1\\) to \\(1\\) (unit semicircle centered at origin) - Vertical geodesic at \\(x = 1\\) - Vertical geodesic at \\(x = -1\\)\nThis creates a fundamental domain bounded by these three geodesics. The angles where they meet determine the triangle group.\n[Note: Need to work out the exact setup here - which specific triangle gives clean angles? The (2,3,∞) triangle or a different choice like (2,4,∞)? Let me provide the framework and you can adjust the specific parameters.]\n\n\nChecking if a Point is in the Triangle\nFor our triangle with: - Bottom edge: unit semicircle - Left edge: vertical line at \\(x = -1\\) - Right edge: vertical line at \\(x = 1\\)\nbool inTriangle(vec2 p) {\n    // Above the semicircle: x² + y² &gt; 1\n    bool aboveSemicircle = dot(p, p) &gt; 1.0;\n    \n    // Between vertical lines: -1 &lt; x &lt; 1\n    bool betweenLines = (p.x &gt; -1.0) && (p.x &lt; 1.0);\n    \n    return aboveSemicircle && betweenLines;\n}\n\n\nReflection Across Geodesics\nReflection across a vertical line \\(x = c\\): \\[\\text{reflect}(x + iy) = (2c - x) + iy\\]\nvec2 reflectVertical(vec2 p, float c) {\n    return vec2(2.0 * c - p.x, p.y);\n}\nReflection across the unit semicircle (circle inversion from yesterday!): Circle inversion with respect to a circle of radius \\(R\\) centered at \\((c_x, c_y)\\) is: \\[\\text{inv}(p) = c + R^2 \\frac{p - c}{|p - c|^2}\\]\nFor our unit circle centered at origin:\nvec2 reflectCircle(vec2 p) {\n    return p / dot(p, p);  // Inversion through unit circle\n}\n\n\nFolding into the Fundamental Domain\nvec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        bool folded = false;\n        \n        // Reflect across left vertical line if needed\n        if(p.x &lt; -1.0) {\n            p = reflectVertical(p, -1.0);\n            folded = true;\n        }\n        \n        // Reflect across right vertical line if needed\n        if(p.x &gt; 1.0) {\n            p = reflectVertical(p, 1.0);\n            folded = true;\n        }\n        \n        // Reflect across semicircle if needed\n        if(dot(p, p) &lt; 1.0) {\n            p = reflectCircle(p);\n            folded = true;\n        }\n        \n        if(folded) foldCount++;\n        else break;  // In fundamental domain\n    }\n    \n    return p;\n}\n\n\nVisualization: Hyperbolic Tiling\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to upper half-plane\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;  // Scale to see interesting region\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Map to upper half-plane (shift up so y &gt; 0)\n    vec2 p = uv + vec2(0.0, 1.5);  // Ensure we're above real axis\n    \n    // Fold to fundamental domain\n    int foldCount;\n    vec2 p_folded = foldToTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);  // Use palette function from Day 2\n    \n    // If we're in the fundamental triangle, use different color\n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result should be a beautiful hyperbolic tiling - the plane tessellated by copies of our fundamental triangle!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#visualizing-in-the-poincaré-disk",
    "href": "day3.html#visualizing-in-the-poincaré-disk",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.5 Visualizing in the Poincaré Disk",
    "text": "3.5 Visualizing in the Poincaré Disk\nNow we’ll see the same tiling in a different model. The key insight: we can do all our computations in the upper half-plane, then convert the final coordinates to the disk for display.\n\nBy Precomposition\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;  // Map to [-1, 1]\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Only render inside unit disk\n    if(length(uv) &gt;= 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 p = diskToUHP(uv);\n    \n    // Now do all computations in UHP\n    int foldCount;\n    vec2 p_folded = foldToTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);\n    \n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe tiling now appears in the Poincaré disk - the same mathematical object, but displayed in a different model. Notice how the triangles near the boundary appear compressed (they’re the same hyperbolic size, but Euclidean distances shrink near the boundary).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#distance-to-geodesics",
    "href": "day3.html#distance-to-geodesics",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.6 Distance to Geodesics",
    "text": "3.6 Distance to Geodesics\nFor homework, you’ll want to draw geodesic boundaries. Here’s the framework:\n\nDistance to a Vertical Geodesic\nFor a vertical line \\(x = c\\), the hyperbolic distance from a point \\((x, y)\\) to the line is: \\[d = \\text{arcosh}\\left(\\frac{|x - c|}{\\text{some formula involving } y}\\right)\\]\n[Placeholder: exact formula for distance to vertical geodesic]\n\n\nDistance to a Semicircular Geodesic\nFor a semicircle of radius \\(R\\) centered at \\((c, 0)\\), the distance calculation is more involved. One approach: 1. Find the closest point on the semicircle to \\(p\\) 2. Compute hyperbolic distance between \\(p\\) and that closest point\n[Placeholder: geodesic distance formula or algorithm]\nAlternatively, you can find formulas in hyperbolic geometry references, or derive them from the metric.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#summary",
    "href": "day3.html#summary",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.7 Summary",
    "text": "3.7 Summary\nToday we covered:\n\nSierpinski carpet: Box folding with axis-aligned symmetry creates 2D fractals\nHyperbolic geometry models: Upper half-plane and Poincaré disk, with metrics and geodesics\nCoordinate transformations: Cayley transform connecting the two models\nHyperbolic triangle tiling: Using reflections (including circle inversion) to tile hyperbolic space\nMultiple representations: Same tiling visualized in different models\n\nKey insights: - Geometric algorithms transfer to non-Euclidean spaces with the right distance/geodesic formulas - Circle inversion (from Day 2) is fundamental to hyperbolic geometry - The same mathematical object looks different in different models - Folding algorithms work in any geometry with the appropriate reflection operations",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#homework",
    "href": "day3.html#homework",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.8 Homework",
    "text": "3.8 Homework\n\nRequired: Sierpinski Carpet\nImplement the Sierpinski carpet fractal using box folding.\nTask:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    int iterations = 6;\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Scale by 3 and recenter\n        p = p * 3.0 - vec2(1.0);\n    }\n    \n    // Check if p is in a \"removed\" region\n    // [Implement this check]\n    \n    // Color accordingly\n}\nExpected output: The characteristic Sierpinski carpet pattern with removed squares at all scales.\nExperiments: - Different iteration counts (watch detail increase) - Color by iteration depth rather than binary in/out - Animate the zoom level with iTime\n\n\nRequired: Drawing Geodesics and Hyperbolic Disks\nImplement visualization of basic hyperbolic objects to understand the geometry.\nPart 1: Draw several geodesics in the upper half-plane - Vertical lines at various \\(x\\) values (these are easy!) - Semicircles with different centers and radii - Use a thickness threshold on the implicit equation to draw them\nPart 2: Draw hyperbolic disks (circles in hyperbolic metric) - Pick a point \\(z_0 \\in \\mathbb{H}^2\\) - Draw the set \\(\\{z : d_{\\text{hyp}}(z, z_0) &lt; R\\}\\) for some radius \\(R\\) - These appear as Euclidean circles, but positioned/sized according to hyperbolic metric - Draw several disks at different locations\nPart 3: Visualize how geometry changes - Draw a grid of hyperbolic disks of the same hyperbolic radius - Observe how they appear smaller (in Euclidean sense) near the boundary - This demonstrates the “shrinking” effect of the hyperbolic metric\nOptional enhancement: Repeat in Poincaré disk model by precomposition.\n\n\nRequired: Drawing Triangle Edges and Vertices\nEnhance your hyperbolic tiling by drawing the triangle boundaries.\nTask: - Compute the hyperbolic distance from each point to the three geodesics forming your triangle boundary - If distance is less than some threshold, color the point as an edge - Similarly, compute distance to the three vertices and draw them as points\nImplementation hints:\n// Distance to vertical line x = c\nfloat distToVertical(vec2 p, float c) {\n    // [Implement using hyperbolic distance formula]\n}\n\n// Distance to semicircle (center, radius)\nfloat distToSemicircle(vec2 p, float center, float radius) {\n    // [Implement - find closest point on semicircle, compute distance]\n}\n\n// In main shader:\nfloat d1 = distToVertical(p, -1.0);\nfloat d2 = distToVertical(p, 1.0);\nfloat d3 = distToSemicircle(p, 0.0, 1.0);\n\nfloat edgeThickness = 0.05;\nbool onEdge = (d1 &lt; edgeThickness) || (d2 &lt; edgeThickness) || (d3 &lt; edgeThickness);\nExpected output: Your tiling with clearly visible triangle boundaries, making the tessellation structure explicit.\n\n\nRequired: Model Conversion and Möbius Transformation\nWork with different representations of hyperbolic space.\nPart 1: Convert your tiling to Poincaré disk - You already have uhpToDisk() and diskToUHP() functions - Create a shader that displays your (2,3,∞) tiling in the disk model - Compare the visual appearance to the upper half-plane version\nPart 2: Apply a Möbius transformation - A Möbius transformation has the form \\(z \\mapsto \\frac{az + b}{cz + d}\\) with \\(ad - bc = 1\\) - Choose an interesting transformation (or try: \\(z \\mapsto z + 1\\) to translate, or \\(z \\mapsto 2z\\) to scale) - Apply it to your tiling and observe the result - Key insight: Möbius transformations are isometries of hyperbolic space, so they permute the tiles but preserve the geometry\nImplementation:\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    // w = (az + b) / (cz + d)\n    vec2 num = cadd(cmul(a, z), b);\n    vec2 den = cadd(cmul(c, z), d);\n    return cdiv(num, den);\n}\n\n// In shader, before folding:\np = mobius(p, vec2(2.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(1.0, 0.0));  // Scale by 2\n\n\nOptional: Advanced Hyperbolic Explorations\nChoose one or more:\n\nDifferent triangle groups: Implement (2,4,6), (3,3,3), or the famous (2,3,7) triangle. Each creates a different tiling pattern.\nKlein model: The Klein model is another representation where geodesics are straight lines. Convert via the Cayley transform from Poincaré disk: \\(w = \\frac{2z}{1 + |z|^2}\\)\nDecorated tiles: Add patterns inside each triangle (like Escher’s Circle Limit prints). Use the barycentric coordinates within each fundamental domain.\nConformal mapping art: Use complex analysis to map the disk to other regions (strip, annulus, etc.) and visualize hyperbolic geometry in these exotic spaces.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#looking-ahead",
    "href": "day3.html#looking-ahead",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.9 Looking Ahead",
    "text": "3.9 Looking Ahead\nTomorrow we move to 3D! We’ll learn raymarching and signed distance functions to render implicit surfaces. The geometric intuition from folding and distance computations will carry over, but now in three dimensions with lighting and shading.\nMake sure you’re comfortable with: - Distance computations (Euclidean and hyperbolic) - Reflection operations (these generalize to 3D) - Iterative algorithms for geometric structures\nThe 3D rendering techniques we’ll learn are the culmination of everything so far: distance fields, iterative marching, geometric transformations, and real-time GPU computation.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  }
]