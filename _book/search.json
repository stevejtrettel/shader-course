[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPU-Accelerated Mathematical Illustration",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nWe’ll progress from 2D foundations (curves, tilings, fractals) to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to work hard and experiment with code through daily homework exercises. Here are some examples of things we will make:\nThe code\nand the demo\nand a still pic for testing",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "lectures/day1.html",
    "href": "lectures/day1.html",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "1.1 Overview\nBy the end of today, you’ll be able to create this:\nA family of elliptic curves \\(y^2 = x^3 + ax + b\\), drawn for several values of \\(a\\) simultaneously, with \\(b\\) varying across the screen. The curves shift in brightness to show the family structure, and you can watch singularities appear and disappear along the discriminant locus.\nThis image is computed in real time, every pixel evaluated independently on the GPU. To get here, we’ll learn:\nLet’s begin.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#overview",
    "href": "lectures/day1.html#overview",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Missing Demo\n  Shader demo day1/elliptic-family not found.\n\n\n\n\n\nWhat a shader is: a function from coordinates to colors, evaluated in parallel\nHow to set up a coordinate system for mathematical visualization\nHow to draw shapes using distance functions\nHow to render implicit curves \\(F(x,y) = 0\\) with uniform thickness\nHow to add interactivity with mouse input",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#what-is-a-shader",
    "href": "lectures/day1.html#what-is-a-shader",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.2 What is a Shader?",
    "text": "1.2 What is a Shader?\nWe want to draw images on a screen.\nMathematically, an image is a function from a region \\(S \\subset \\mathbb{R}^2\\) to the space of visible colors \\(\\mathcal{C}\\). This color space is three-dimensional, spanned by the responses of the three types of cone cells in our eyes. A convenient basis, roughly aligned with these responses, is red, green, and blue.\nTo realize this on a computer, we discretize. A screen is a grid of pixels: \\(X\\) pixels wide, \\(Y\\) pixels tall. Each pixel is a point in the integer lattice \\[\\{0, 1, \\ldots, X-1\\} \\times \\{0, 1, \\ldots, Y-1\\}.\\]\nColors are represented as RGB triples: red, green, and blue intensities, each in \\([0,1]\\). The constraint to \\([0,1]\\) reflects physical reality—a pixel has a maximum brightness it can display. (We can’t draw the sun.) So an image is a function \\[f\\colon \\{0,\\ldots,X-1\\} \\times \\{0,\\ldots,Y-1\\} \\to [0,1]^3\\] \\[(i,j) \\mapsto (r,g,b).\\]\nIn practice, we add a fourth component: alpha, representing transparency. This matters when compositing multiple layers (we won’t use it in this course, but the machinery expects it). So our shader computes \\[f\\colon (i,j) \\mapsto (r,g,b,1).\\]\nThis is what a shader is. You write a function that takes pixel coordinates and returns an RGBA color. The GPU evaluates your function at every pixel to produce the image.\n\nParallelism\nA 1920×1080 display has over two million pixels. How do we evaluate \\(f\\) at all of them fast enough to animate at 60 frames per second?\nThe answer is parallelism. A GPU contains thousands of cores, and it evaluates \\(f\\) at all pixels simultaneously. There’s no loop over pixels in your code—you write \\(f\\), and the hardware handles the rest.\nThe tradeoff: each pixel’s computation must be independent. Pixel \\((100, 200)\\) cannot ask what color pixel \\((100, 199)\\) received. Every pixel sees the same global inputs—coordinates, time, mouse position—and must determine its color from those alone. Learning to think within this constraint is what shader programming is about.\n\n\n\n\n\n\nNoteWhy “shader”?\n\n\n\nThe name comes from 3D graphics, where these programs computed shading—how light interacts with surfaces. It stuck even though we now use shaders for fractals, simulations, and mathematical visualization.\n\n\n\n\nWhy Shadertoy?\nShader programming normally requires substantial setup: OpenGL contexts, buffer management, compilation, render loops. Shadertoy abstracts all of this—you write one function, press play, and see results. We’ll use it throughout the course.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#first-shaders-colors-and-syntax",
    "href": "lectures/day1.html#first-shaders-colors-and-syntax",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.3 First Shaders: Colors and Syntax",
    "text": "1.3 First Shaders: Colors and Syntax\n\nThe mainImage Function\nIn Shadertoy, your shader is a function called mainImage:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // your code here\n}\nThis function is called once per pixel, every frame. The inputs and outputs:\n\nfragCoord — the pixel coordinates, passed in to your function\nfragColor — the RGBA color, which you write out\n\nThe in and out keywords are explicit about data flow: fragCoord is read-only input, fragColor is where you write your result. The function returns void because the output goes through fragColor, not a return value.\n\n\nHello World: A Solid Color\nThe simplest shader: make every pixel red.\n\n  Missing Demo\n  Shader demo day1/red not found.\n\n\nThe vec4(1.0, 0.0, 0.0, 1.0) constructs a 4-component vector: red=1, green=0, blue=0, alpha=1. Every pixel receives the same color, so the screen fills with red.\n\n\nGLSL Syntax Essentials\nGLSL (OpenGL Shading Language) will feel familiar if you’ve seen C-like syntax, but a few things are worth noting upfront.\nSemicolons are required at the end of each statement.\nFloats must include a decimal point. Write 1.0, not 1. The integer 1 and the float 1.0 are different types, and GLSL is strict about this.\nVector types are built in: vec2, vec3, vec4 for 2, 3, and 4 component vectors. Construct them with:\nvec2 p = vec2(3.0, 4.0);\nvec3 color = vec3(1.0, 0.5, 0.0);\nvec4 rgba = vec4(1.0, 0.0, 0.0, 1.0);\nArithmetic is component-wise. Adding two vectors adds their components:\nvec2(1.0, 2.0) + vec2(3.0, 4.0)  // = vec2(4.0, 6.0)\nScalar-vector operations apply the scalar to each component:\n2.0 * vec2(1.0, 3.0)  // = vec2(2.0, 6.0)\nAccessing components uses .x, .y, .z, .w:\nvec2 p = vec2(3.0, 4.0);\nfloat a = p.x;  // 3.0\nfloat b = p.y;  // 4.0\nFor colors, .r, .g, .b, .a are synonyms—color.r is the same as color.x.\nCommon math functions work as expected: sin, cos, abs, min, max, sqrt, pow. These operate on floats, and apply component-wise to vectors:\nsin(vec2(0.0, 3.14159))  // = vec2(0.0, ~0.0)\nFor loops work as you’d expect:\nfor (int i = 0; i &lt; 5; i++) {\n    // body executes with i = 0, 1, 2, 3, 4\n}\nThe loop variable is an int. Note that some older GPUs require the loop bounds to be constants known at compile time—you can’t always loop up to a variable. We’ll use loops extensively starting tomorrow.\n\n\nUniforms: Global Inputs\nShadertoy provides uniforms—global values that are constant across all pixels. Unlike fragCoord, which takes a different value at each pixel, a uniform has the same value everywhere. They’re how external information (time, screen size, mouse position) gets into your shader.\n\n\n\n\n\n\n\n\nUniform\nType\nDescription\n\n\n\n\niResolution\nvec3\nViewport size: (width, height, pixel_aspect_ratio)\n\n\niTime\nfloat\nSeconds since the shader started\n\n\niMouse\nvec4\nMouse position and click state\n\n\n\nWe’ll use iResolution constantly (for coordinate transforms) and iTime for animation.\n\n\nAnimation: Using iTime\nLet’s make the red channel pulse:\n\n  Missing Demo\n  Shader demo day1/red-pulsing not found.\n\n\nSince sin(iTime) oscillates between -1 and 1, the expression 0.5 + 0.5 * sin(iTime) oscillates between 0 and 1. The screen pulses from black to red.\nThis is our first animated shader—the output depends on time.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#coordinate-systems",
    "href": "lectures/day1.html#coordinate-systems",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.4 Coordinate Systems",
    "text": "1.4 Coordinate Systems\n\nPixel Coordinates\nThe input fragCoord gives the pixel coordinates of the current pixel. The coordinate system:\n\nOrigin at the bottom-left corner\nfragCoord.x increases to the right\nfragCoord.y increases upward\nRanges from \\((0, 0)\\) to \\((X, Y)\\) where \\(X \\times Y\\) is the screen resolution\n\nThis is workable, but inconvenient for mathematics. We’d prefer coordinates centered at the origin with a reasonable scale. Let’s build up a transformation step by step.\n\n\nStep 1: Normalize to \\([0,1]^2\\)\nDivide by the resolution to map pixel coordinates to the unit square:\nvec2 uv = fragCoord / iResolution.xy;\nNow uv ranges from \\((0,0)\\) at bottom-left to \\((1,1)\\) at top-right.\nSince both coordinates are in \\([0,1]\\), we can visualize them directly as color:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n\n  Missing Demo\n  Shader demo day1/coordinates not found.\n\n\nBlack at bottom-left (0,0), red at bottom-right (1,0), green at top-left (0,1), yellow at top-right (1,1).\n\n\nStep 2: Center the Origin\nSubtract \\((0.5, 0.5)\\) to center the origin:\nuv = uv - vec2(0.5, 0.5);\nNow uv ranges from \\((-0.5, -0.5)\\) to \\((0.5, 0.5)\\), with \\((0,0)\\) at the screen center.\n\n\nStep 3: Aspect Ratio Correction\nWe’ve mapped a rectangle of pixels (\\(X \\times Y\\)) to the square \\([-0.5, 0.5]^2\\). This is an affine transformation, not a similarity—it distorts shapes. A circle in our coordinates would render as an ellipse on screen.\nTo fix this, we scale the \\(x\\)-coordinate by the aspect ratio:\nuv.x *= iResolution.x / iResolution.y;\nNow a circle in our coordinates appears as a circle on screen. (When we draw shapes later, try commenting out this line to see the distortion.)\n\n\nStep 4: Scale to a Useful Range\nFinally, scale to a convenient window:\nvec2 p = uv * 4.0;\nWith a scale factor of 4, our coordinates range roughly from \\(-2\\) to \\(2\\)—a good default for visualizing mathematical objects.\n\n\nThe Standard Boilerplate\nPutting it together, here’s the coordinate setup we’ll use throughout the course:\nvec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]\nuv = uv - vec2(0.5, 0.5);               // center origin\nuv.x *= iResolution.x / iResolution.y;  // aspect correction\nvec2 p = uv * 4.0;                      // scale\nFrom here on, p is our mathematical coordinate, centered at the origin, aspect-corrected, with a reasonable range.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#drawing-with-distance",
    "href": "lectures/day1.html#drawing-with-distance",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.5 Drawing with Distance",
    "text": "1.5 Drawing with Distance\nSo far we’ve colored every pixel the same, or colored based on position as a gradient. Now we want to draw: to render a shape on screen.\nWhat does it mean to draw a shape? For a simple filled region, we need a rule that tells us, for each pixel: are you inside the shape or not? When inside, we do one thing (say, color yellow). When outside, we do another (color blue). The boundary of the shape is where we switch.\n\nHalf-Planes\nThe simplest shape is a half-plane. Consider the rule: is the \\(y\\)-coordinate greater than 0? This divides the plane into two regions—above and below the \\(x\\)-axis.\nfloat L = p.y;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red below\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue above\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/half-plane not found.\n\n\nTo color left versus right instead, use p.x in place of p.y.\nMore generally, a line in the plane has the form \\(ax + by + c = 0\\). This divides the plane into two half-planes: where \\(ax + by + c &lt; 0\\) and where \\(ax + by + c &gt; 0\\).\nfloat a = 1.0, b = 1.0, c = 0.0;\nfloat L = a * p.x + b * p.y + c;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue\n}\n\nfragColor = vec4(color, 1.0);\nRecall that \\((a, b)\\) is the normal vector to the line, and \\(c\\) is an offset. Since these are just variables, we can animate them to move the line around:\nfloat a = cos(iTime);\nfloat b = sin(iTime);\nfloat c = 0.5 * sin(iTime * 0.7);\n\n  Missing Demo\n  Shader demo day1/half-plane-animated not found.\n\n\n\n\nCircles\nNow consider the function \\(d(p) = |p|\\), the distance from the origin. Geometrically, the graph of this function is a cone—zero at the origin, increasing linearly in all directions.\nTo draw a filled disk of radius \\(r\\), we could threshold on \\(d &lt; r\\) versus \\(d \\geq r\\). But it’s cleaner to define \\(f(p) = |p| - r\\). This function is negative inside the circle (where \\(d &lt; r\\)) and positive outside (where \\(d &gt; r\\)). The circle itself is the level set \\(f = 0\\).\nfloat d = length(p);\nfloat r = 1.0;\nfloat f = d - r;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow inside\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/circle not found.\n\n\nTry commenting out the aspect ratio correction (uv.x *= ...) to see the distortion—the circle becomes an ellipse.\nTo center the circle at a point \\(c\\) instead of the origin, compute distance from \\(c\\):\nvec2 center = vec2(1.0, 0.5);\nfloat d = length(p - center);\nSince center and r are variables, you can animate them with iTime to create moving, pulsing circles.\n\n\nDrawing a Ring\nOur function \\(f = d - r\\) is negative inside the circle and positive outside. To draw a filled disk, we colored based on the sign of \\(f\\).\nBut what if we want just the boundary—a ring of some thickness? We want to color one way when \\(f\\) is small in absolute value (near the circle), and a different way when \\(|f|\\) is large (far from the circle).\nSo we look at \\(|f| = |d - r|\\) and ask: is this less than some threshold \\(\\varepsilon\\), or greater? Equivalently, is \\(|d - r| - \\varepsilon\\) negative or positive?\nfloat d = length(p);\nfloat r = 1.0;\nfloat eps = 0.1;\nfloat f = abs(d - r) - eps;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 1.0);  // white ring\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/circle-ring not found.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#implicit-curves",
    "href": "lectures/day1.html#implicit-curves",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.6 Implicit Curves",
    "text": "1.6 Implicit Curves\nWe’ve drawn circles using the distance function \\(|p| - r\\). But circles are just one example of curves defined by an equation. Any equation \\(F(x,y) = 0\\) defines a curve—the set of points satisfying that equation. We can draw it the same way: threshold on \\(|F|\\).\n\nA First Example: The Parabola\nConsider \\(F(x,y) = y - x^2\\). The curve \\(F = 0\\) is the parabola \\(y = x^2\\). Points where \\(F &lt; 0\\) lie below the parabola; points where \\(F &gt; 0\\) lie above.\nTo draw the curve itself, we color pixels where \\(|F|\\) is small:\nfloat F = p.y - p.x * p.x;\nfloat eps = 0.1;\n\nvec3 color;\nif (abs(F) &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow curve\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/parabola not found.\n\n\n\n\nMore Examples\nAn ellipse: \\(F(x,y) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1\\)\nfloat a = 2.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) + (p.y*p.y)/(b*b) - 1.0;\nA hyperbola: \\(F(x,y) = \\frac{x^2}{a^2} - \\frac{y^2}{b^2} - 1\\)\nfloat a = 1.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) - (p.y*p.y)/(b*b) - 1.0;\nThe lemniscate of Bernoulli: \\((x^2 + y^2)^2 = a^2(x^2 - y^2)\\), or \\(F = (x^2+y^2)^2 - a^2(x^2 - y^2)\\)\nfloat a = 1.5;\nfloat r2 = dot(p, p);  // x² + y²\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n\nThe Thickness Problem\nLook carefully at the parabola. The rendered thickness isn’t uniform—it’s thinner where the curve is steep, thicker where it’s flat. The problem gets worse with more complicated curves, especially those with singularities. Here’s the lemniscate:\n\n  Missing Demo\n  Shader demo day1/lemniscate-naive not found.\n\n\nNotice how the thickness blows up near the origin, where the curve crosses itself.\nWhy does this happen? The set \\(|F| &lt; \\varepsilon\\) contains all points within \\(\\varepsilon\\) of zero in the \\(F\\) direction. But \\(F\\) doesn’t measure distance to the curve—it’s just some function that happens to be zero on the curve. Where \\(|\\nabla F|\\) is large, \\(F\\) changes rapidly, so the band \\(|F| &lt; \\varepsilon\\) is narrow. Where \\(|\\nabla F|\\) is small, \\(F\\) changes slowly, so the band is wide. At the singular point, \\(\\nabla F = 0\\), and the band becomes infinitely wide.\n\n\nWhy Circles Worked\nFor the circle, we used \\(f(p) = |p| - r\\). This is the signed distance function: it measures actual geometric distance to the curve. The gradient of a distance function has magnitude 1 everywhere (it points toward or away from the curve at unit rate). So \\(|f| &lt; \\varepsilon\\) really does capture points within distance \\(\\varepsilon\\), giving uniform thickness.\nThis is a fact from differential geometry: \\(|\\nabla d| = 1\\) for a distance function \\(d\\). When we use an arbitrary implicit equation \\(F = 0\\), we lose this property.\n\n\nGradient Correction\nWe can fix the non-uniform thickness by dividing by the gradient magnitude. Instead of thresholding \\(|F| &lt; \\varepsilon\\), we threshold \\[\\frac{|F|}{|\\nabla F|} &lt; \\varepsilon.\\]\nThis approximates the signed distance to the curve. The intuition: \\(|F|/|\\nabla F|\\) estimates how far you’d need to travel (in the direction \\(F\\) changes fastest) to reach the curve.\nFor the lemniscate, we compute the gradient analytically: \\[\\nabla F = \\bigl(4x(x^2+y^2) - 2a^2 x,\\; 4y(x^2+y^2) + 2a^2 y\\bigr)\\]\nfloat a = 1.5;\nfloat r2 = dot(p, p);\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\nvec2 grad = vec2(\n    4.0 * p.x * r2 - 2.0 * a * a * p.x,\n    4.0 * p.y * r2 + 2.0 * a * a * p.y\n);\n\nfloat dist = abs(F) / max(length(grad), 0.01);  // avoid division by zero\nfloat eps = 0.05;\n\nvec3 color;\nif (dist &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/lemniscate-gradient not found.\n\n\nCompare with the naive version above to see the difference in thickness uniformity.\n\n\nAnimated Curve Families\nThe lemniscate is part of a one-parameter family called the Cassini ovals, defined by the product of distances from two foci being constant: \\[(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\]\nAs the parameter \\(a\\) varies relative to the fixed focal distance \\(c\\), the topology changes: two separate loops when \\(a &lt; c\\), a lemniscate when \\(a = c\\), a single oval when \\(a &gt; c\\).\n\n  Missing Demo\n  Shader demo day1/lemniscate-animated not found.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#interactivity-and-abstraction",
    "href": "lectures/day1.html#interactivity-and-abstraction",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.7 Interactivity and Abstraction",
    "text": "1.7 Interactivity and Abstraction\nSo far our shaders respond to time (iTime) but not to user input. Shadertoy provides iMouse for mouse interaction.\n\nThe iMouse Uniform\niMouse is a vec4:\n\niMouse.xy — current mouse position (in pixels)\niMouse.zw — position where the mouse was last clicked\n\nFor now we’ll focus on iMouse.xy.\n\n\nDragging a Circle\nLet’s draw a circle centered at the mouse position. Since iMouse.xy is in pixel coordinates, we need to normalize it the same way we normalize fragCoord:\n// Normalize fragment coordinate\nvec2 uv = fragCoord / iResolution.xy;\nuv = uv - vec2(0.5, 0.5);\nuv.x *= iResolution.x / iResolution.y;\nvec2 p = uv * 4.0;\n\n// Normalize mouse coordinate the same way\nvec2 mouse = iMouse.xy / iResolution.xy;\nmouse = mouse - vec2(0.5, 0.5);\nmouse.x *= iResolution.x / iResolution.y;\nmouse = mouse * 4.0;\n\n// Circle centered at mouse\nfloat d = length(p - mouse);\nfloat r = 0.5;\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/circle-mouse not found.\n\n\nClick and drag to move the circle.\n\n\nWriting a Helper Function\nWe just wrote the same four lines of coordinate normalization twice. This is a sign we should write a function.\nA GLSL function declares its return type, then the function name, then its parameters with their types:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\nFunctions must be defined before they’re used, so they go above mainImage. Here’s the overall structure:\nvec2 normalize_coord(vec2 coord) {\n    // normalization logic here\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = normalize_coord(fragCoord);\n    vec2 mouse = normalize_coord(iMouse.xy);\n    \n    // code using p and mouse\n}\nNow our shader is cleaner, and we won’t make mistakes copying the normalization code.\n\n\nCombining iMouse and iTime: Sun and Earth\nLet’s make a circle orbit around the mouse position:\nvec2 p = normalize_coord(fragCoord);\nvec2 sun = normalize_coord(iMouse.xy);\n\n// Earth orbits the sun\nfloat orbit_radius = 0.8;\nvec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n\n// Draw sun (larger, yellow)\nfloat d_sun = length(p - sun);\n// Draw earth (smaller, blue)\nfloat d_earth = length(p - earth);\n\nvec3 color = vec3(0.02, 0.02, 0.05);  // dark background\nif (d_sun &lt; 0.3) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow sun\n}\nif (d_earth &lt; 0.15) {\n    color = vec3(0.2, 0.5, 1.0);  // blue earth\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/sun-earth not found.\n\n\nDrag to move the sun; the earth follows in orbit. (Exercise: add a moon orbiting the earth!)\n\n\nMouse as Parameter\nThe mouse doesn’t have to control position—it can control any parameter. A useful pattern: map iMouse.x to a parameter range and drag across the screen to explore a family of curves.\nThe folium of Descartes is the curve \\(x^3 + y^3 = 3axy\\). We can explore its level sets by drawing \\(x^3 + y^3 - 3axy = c\\) for different values of \\(c\\):\nvec2 p = normalize_coord(fragCoord);\n\n// Fixed parameter a\nfloat a = 1.5;\n\n// Map mouse x to level set value c in [-2, 2]\nfloat c = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n\n// Folium of Descartes: x³ + y³ - 3axy = c\nfloat F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;\n\n// Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)\nvec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);\nfloat dist = abs(F) / max(length(grad), 0.01);\n\nvec3 color;\nif (dist &lt; 0.05) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  Missing Demo\n  Shader demo day1/folium-mouse not found.\n\n\nDrag left and right to sweep through the level sets and watch the curve topology change.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day1.html#exercises",
    "href": "lectures/day1.html#exercises",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.8 Exercises",
    "text": "1.8 Exercises\nHomework is organized into four types:\nCheckpoints — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.\nExplorations — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you’re right on track with the course.\nChallenges — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.\nProject — An extended project for someone familiar with shader basics, to make an artwork.\n\n\nCheckpoints\nC1. Solid Colors. Modify the red screen shader to display: (a) green, (b) cyan, (c) a color of your choice using all three RGB channels.\nC2. Vertical Split. Modify the half-plane shader to divide the screen into left (red) and right (blue) instead of top and bottom.\nC3. Off-Center Circle. Draw a filled circle of radius 0.5 centered at the point \\((1, 1)\\) instead of the origin.\nC4. Pulsing Circle. Make a circle whose radius oscillates between 0.5 and 1.5 over time using iTime.\nC5. Ring Thickness. Draw a ring (circle outline) centered at the origin. Experiment with different values of eps to understand how it controls thickness.\n\n\n\nExplorations\nE1. Concentric Rings. Draw several concentric rings (circles of different radii, all centered at the origin). Can you color alternate rings differently?\nE2. Moon Orbit. Extend the sun-earth shader to add a moon that orbits the earth. The moon should be smaller than the earth and orbit faster.\nE3. Your Favorite Curve. Pick an implicit curve from your mathematical experience (or find one online) and render it. Some suggestions: the cardioid \\((x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)\\), the astroid \\(x^{2/3} + y^{2/3} = a^{2/3}\\), or a rose curve in implicit form. Apply gradient correction for uniform thickness.\nE4. Curve Explorer. Take any one-parameter family of curves and build a mouse-controlled explorer (like the folium example). Map iMouse.x to the parameter and drag to explore the family.\nE5. Two Circles. Draw two filled circles at different positions. What happens when they overlap? Can you make one “in front of” the other? Can you make the intersection a different color, like a Venn diagram?\n\n\n\nChallenges\nH1. Parabola Graphing Calculator. Build an interactive graphing calculator for the parabola \\(y = ax^2 + bx + c\\). Requirements: - Draw coordinate axes (the lines \\(x = 0\\) and \\(y = 0\\)) - Draw the parabola using implicit curve techniques - Find the roots (where \\(y = 0\\)) and draw small circles around them - Use mouse position to control two of the coefficients (e.g., \\(a\\) and \\(b\\), with \\(c\\) fixed, or \\(b\\) and \\(c\\) with \\(a\\) fixed)\nAs you drag the mouse, the parabola should reshape and the root indicators should move (or appear/disappear as roots become real or complex).\nH2. Elliptic Curve Explorer. Elliptic curves in Weierstrass form are \\(y^2 = x^3 + ax + b\\). Build a shader where the mouse position controls \\((a, b)\\). Use gradient correction for uniform thickness. The discriminant \\(\\Delta = 4a^3 + 27b^2\\) determines whether the curve is smooth (\\(\\Delta \\neq 0\\)) or singular (\\(\\Delta = 0\\)). Can you display the current value of \\(\\Delta\\) somehow, or change the curve’s color when it becomes singular?\nH3. Signed Distance Functions. For a filled circle, \\(f(p) = |p| - r\\) is the signed distance function: negative inside, positive outside, with \\(|f|\\) giving the actual distance to the boundary. What is the signed distance function for a half-plane? For an axis-aligned rectangle? Implement both and draw them with uniform-thickness boundaries. Note: when you have the true signed distance function, you don’t need the gradient correction trick—that’s the payoff for computing the right thing from the start!\nH4. Smooth Blending. When two circles overlap, we currently just draw one on top of the other. Research smooth minimum functions (e.g., smin) that blend distance fields smoothly. Draw two circles that “melt together” where they meet.\nH5. Inversion. Circle inversion is the map \\(p \\mapsto p / |p|^2\\). Apply this transformation to your coordinate \\(p\\) before drawing a shape. What happens to a line? What happens to a circle not passing through the origin? Experiment with different shapes.\n\n\n\nProject: Grid Patterns\nThis extended project introduces a powerful technique—using modular arithmetic to repeat patterns across the plane. We’ll build up the machinery carefully, since we’ll use it again in Day 2 to create grids of Julia sets.\n\nPart 1: Setting Up a Grid of Square Cells\nWe want to tile the screen with square cells—say, 4 cells across. The challenge: the screen isn’t square, so we need to handle the aspect ratio.\nLet’s say we want N columns of cells. Each cell has width \\(L = \\text{screen\\_width} / N\\) in pixels, and since cells are square, height \\(L\\) as well. The number of rows depends on the screen’s aspect ratio.\nWorking in our normalized coordinates (after aspect correction), the screen spans roughly \\([-2 \\cdot \\text{aspect}, 2 \\cdot \\text{aspect}]\\) in \\(x\\) and \\([-2, 2]\\) in \\(y\\). If we want cells of side length \\(L\\) in these coordinates:\nfloat aspect = iResolution.x / iResolution.y;\nfloat N = 5.0;  // number of columns\nfloat L = (4.0 * aspect) / N;  // cell size in our coordinate system\nNow each cell is an \\(L \\times L\\) square.\n\n\nPart 2: Cell Coordinates and Identity\nFor each pixel, we want two things:\n\nWhich cell are we in? Integer coordinates \\((i, j)\\) identifying the cell.\nWhere in the cell are we? Local coordinates ranging from \\(-L/2\\) to \\(L/2\\), with \\((0,0)\\) at the cell center.\n\nvec2 cell_id = floor(p / L);\nvec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);\nThe cell_id tells us which cell; the cell_p gives local coordinates within that cell.\nIf we want local coordinates normalized to \\([-1, 1]\\) (useful for drawing things at a standard scale), we can rescale:\nvec2 local = cell_p / (L / 2.0);  // now in [-1, 1] x [-1, 1]\nThis is exactly the setup we’ll need for Day 2, where each cell will contain a Julia set with its own coordinate system.\n\n\nPart 3: Drawing in Each Cell\nNow draw something using the local coordinates. A filled circle at the center of each cell:\nfloat d = length(cell_p);\nfloat r = L * 0.4;  // radius relative to cell size\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nTry changing N to get more or fewer columns. The cells stay square regardless of screen shape.\n\n\nPart 4: Varying by Cell\nThe cell_id lets each cell behave differently. Some ideas:\nCheckerboard background:\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\nvec3 bg = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\nRadius varying by cell:\nfloat r = L * (0.2 + 0.15 * mod(cell_id.x + cell_id.y, 3.0));\nWave animation:\nfloat cell_dist = length(cell_id);\nfloat r = L * (0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5));\n\n\nPart 5: Design Challenge\nDesign a grid-based pattern that you find visually interesting. Some directions:\nConnecting shapes: Draw shapes that connect across cell boundaries. Quarter-circles in each corner create a continuous network. What implicit curves tile seamlessly?\nAlternating motifs: Use cell_id to alternate between different shapes—circles in some cells, rings in others, or different orientations.\nColor fields: Map cell_id to colors using distance from origin, stripes, or a palette.\nPhase shifts: Animate cells with different phase offsets to create waves or ripples.\nUsing local coordinates: Draw something more complex in each cell using the \\([-1,1]\\) local coordinate system—perhaps a small implicit curve, or a pattern that changes based on cell_id.\nThe goal is to produce an image you’d be happy to hang on a wall.\n\n\n\nProject: Fourier Epicycles\nThis project builds a visualization of Fourier series using epicycles—circles whose centers sit on the circumferences of other circles. This is how Ptolemy modeled planetary motion, and it turns out to be exactly how Fourier series work geometrically.\n\nPart 1: The Idea\nAny periodic function can be written as a sum of sines and cosines. Geometrically, \\(\\sin(n\\omega t)\\) and \\(\\cos(n\\omega t)\\) describe a point moving around a circle of frequency \\(n\\omega\\). Adding these components corresponds to stacking circles: each circle’s center rides on the previous circle’s edge.\nFor example, the square wave has Fourier series: \\[f(t) = \\sum_{n=1,3,5,...} \\frac{1}{n} \\sin(n\\omega t)\\]\nThis means circles with: - Radii: \\(1, \\frac{1}{3}, \\frac{1}{5}, \\frac{1}{7}, ...\\) - Frequencies: \\(\\omega, 3\\omega, 5\\omega, 7\\omega, ...\\)\nThe more terms we add, the closer the final point’s \\(y\\)-coordinate approximates a square wave.\n\n\nPart 2: Drawing Circles\nStart by drawing a chain of circles. Each circle is centered at the current position, and the next position is computed by moving along the circle:\nvec2 pos = vec2(0.0, 0.0);  // start at origin\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;  // 1, 3, 5, 7, ...\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    // Draw circle at current position\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // color the circle\n    }\n    \n    // Move to next position\n    pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n}\n\n// Draw final point\nfloat d_point = length(p - pos);\nif (d_point &lt; 0.08) {\n    // bright color\n}\nTry this with N = 1, then N = 3, then N = 7. Watch how more circles create more complex motion.\n\n\nPart 3: The Line Segment SDF\nTo draw the arms connecting circle centers, we need the signed distance function for a line segment. Given endpoints \\(a\\) and \\(b\\), the distance from point \\(p\\) to the segment is:\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\nThe math: we project \\(p - a\\) onto the line direction \\(b - a\\), clamp to \\([0, 1]\\) to stay within the segment, then measure the distance to that closest point.\n\n\nPart 4: Connecting the Arms\nNow modify your loop to also draw line segments:\nvec2 pos = vec2(0.0, 0.0);\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n    \n    // Draw circle\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // faint circle color\n    }\n    \n    // Draw arm from pos to next_pos\n    float d_arm = sd_segment(p, pos, next_pos);\n    if (d_arm &lt; 0.015) {\n        // arm color\n    }\n    \n    pos = next_pos;\n}\n\n\nPart 5: Polish and Explore\nNow make it beautiful:\nFading circles: Later circles are smaller and less important. Fade their brightness:\nfloat fade = 1.0 - float(i) / float(N);\nColor variation: Color circles differently based on their index, or based on their frequency.\nDifferent waves: The square wave uses odd harmonics with \\(1/n\\) coefficients. Try: - Triangle wave: odd harmonics with \\(1/n^2\\) coefficients (alternating signs) - Sawtooth wave: all harmonics with \\(1/n\\) coefficients\nMouse control: Map iMouse.x to the number of terms, so dragging adds or removes circles.\nThe goal: create a mesmerizing animation that reveals the geometry hidden inside Fourier series.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html",
    "href": "lectures/day2.html",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "",
    "text": "2.1 Overview\nBy the end of today, you’ll understand how simple iteration rules generate infinite complexity—and have the tools to render it in real time.\nA zoom into the Mandelbrot set, colored by escape time. The entire structure emerges from iterating one formula: \\(z \\mapsto z^2 + c\\).\nToday we explore two kinds of iterative systems:\nBoth share the same GPU-friendly structure: each pixel asks “what happens when I iterate from here?” No pixel depends on any other—perfect for parallel computation.\nAlong the way, we’ll learn to implement complex arithmetic in GLSL and organize geometric data using structs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#overview",
    "href": "lectures/day2.html#overview",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "",
    "text": "Missing Demo\n  Shader demo day2/mandelbrot-zoom not found.\n\n\n\n\n\nComplex dynamics: Iterating holomorphic maps gives us the Mandelbrot set, Julia sets, and their cousins\nCircle inversion: Iterating geometric transformations gives us the Apollonian gasket",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#complex-numbers-in-glsl",
    "href": "lectures/day2.html#complex-numbers-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "2.2 Complex Numbers in GLSL",
    "text": "2.2 Complex Numbers in GLSL\nThe complex numbers \\(\\mathbb{C}\\) are the plane equipped with a multiplication operation. Today we implement that algebra in GLSL.\n\nRepresentation\nA complex number \\(z = a + bi\\) is naturally represented as a 2D vector:\nvec2 z = vec2(a, b);  // represents a + bi\nWe’ll consistently use the convention that z.x is the real part and z.y is the imaginary part.\n\n\nArithmetic\nAddition of complex numbers is componentwise—exactly what GLSL’s built-in + does for vectors. No helper function needed.\nMultiplication is more interesting. In GLSL, the * operator on vectors is componentwise: vec2(a,b) * vec2(c,d) gives vec2(a*c, b*d). This is not complex multiplication! We need to implement the correct formula ourselves.\nRecall \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\):\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\nThis is the FOIL pattern with \\(i^2 = -1\\) giving the minus sign in the real part.\n\n\nMagnitude\nThe magnitude of \\(z = a + bi\\) is the distance from the origin: \\[|z| = \\sqrt{a^2 + b^2}\\]\nWe can implement this directly:\nfloat cabs(vec2 z) {\n    return sqrt(z.x * z.x + z.y * z.y);\n}\nBut consider: we’ll often have conditions like “is \\(|z|\\) bigger than 2?” rather than needing the actual magnitude. In these cases, we can check \\(|z|^2 &gt; 4\\) instead of \\(|z| &gt; 2\\)—same answer, but no square root. When you’re doing this check millions of times per frame (once per pixel, 60 frames per second), avoiding unnecessary square roots adds up.\nSo we define the squared magnitude:\nfloat cabs2(vec2 z) {\n    return z.x * z.x + z.y * z.y;\n}\nIf we want to be even more efficient, we can use GLSL’s built-in dot product, which computes exactly this sum of products:\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // a² + b²\n}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-mandelbrot-set",
    "href": "lectures/day2.html#the-mandelbrot-set",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "2.3 The Mandelbrot Set",
    "text": "2.3 The Mandelbrot Set\nThe Mandelbrot set is perhaps the most iconic fractal—its shape is instantly recognizable, and its discovery in 1980 helped launch the era of computer-generated mathematical visualization. The definition is remarkably simple.\n\nDefinition\nFix a complex number \\(c\\). Starting from \\(z_0 = 0\\), define a sequence by iterating: \\[z_{n+1} = z_n^2 + c\\]\nFor some values of \\(c\\), this sequence stays bounded forever. For others, it escapes to infinity. The Mandelbrot set \\(\\mathcal{M}\\) is the set of all \\(c\\) for which the sequence remains bounded.\nThat’s it! One quadratic formula, iterated. The intricate structure of the Mandelbrot set emerges entirely from this simple rule.\n\n\nRendering Strategy\nTo draw the Mandelbrot set, we test each pixel: is this value of \\(c\\) in \\(\\mathcal{M}\\) or not?\nThis is exactly the kind of question shaders excel at. Each pixel performs its own independent calculation—no pixel needs information from any other pixel. The entire image can be computed in parallel, with thousands of GPU cores each testing their own value of \\(c\\) simultaneously.\nBut there’s a problem: the definition involves iterating “forever” and checking if the sequence “stays bounded.” We can’t iterate infinitely, and we can’t wait forever to decide. We need a practical criterion for when to stop.\n\n\nThe Escape Radius\nWe need two facts that make efficient rendering possible.\nFact 1. The Mandelbrot set is contained in the disk of radius 2. That is, if \\(|c| &gt; 2\\), then \\(c \\notin \\mathcal{M}\\).\nProof. [TODO] \\(\\square\\)\nThis tells us what region to display: we only need to look at \\(|c| \\leq 2\\).\nFact 2. If \\(|c| \\leq 2\\) and \\(|z_n| &gt; 2\\) for some \\(n\\), then the orbit escapes to infinity (so \\(c \\notin \\mathcal{M}\\)).\nProof. [TODO] \\(\\square\\)\nThis gives us a stopping criterion: once \\(|z_n| &gt; 2\\), we know \\(c\\) is not in the Mandelbrot set. We don’t need to keep iterating.\nTogether, these facts justify the escape-time algorithm: iterate until either \\(|z_n| &gt; 2\\) (escaped, not in \\(\\mathcal{M}\\)) or we hit a maximum iteration count (probably in \\(\\mathcal{M}\\)).\n\n\nThe Escape-Time Algorithm\nThese two facts give us our algorithm:\n\nFor each pixel, let \\(c\\) be the corresponding complex number\nStart with \\(z = 0\\)\nIterate \\(z \\mapsto z^2 + c\\)\nIf \\(|z| &gt; 2\\), stop—this point escapes (not in \\(\\mathcal{M}\\))\nIf we reach a maximum iteration count without escaping, assume bounded (in \\(\\mathcal{M}\\))\n\nThe core of this is a loop:\nvec2 z = vec2(0.0, 0.0);\nint max_iter = 100;\nint iter;\n\nfor (iter = 0; iter &lt; max_iter; iter++) {\n    if (cabs2(z) &gt; 4.0) break;  // |z|² &gt; 4 means |z| &gt; 2\n    z = cmul(z, z) + c;\n}\nAfter this loop, iter tells us what happened: if iter == max_iter, we never escaped (probably in \\(\\mathcal{M}\\)). Otherwise, we escaped on iteration iter.\n\n\nBinary Coloring\nThe simplest approach: color points black if they’re in the set, white if they escaped.\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);  // In the set: black\n} else {\n    color = vec3(1.0);  // Escaped: white\n}\n\n\nFull Implementation\nPutting it together with our coordinate setup:\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale and center to show the Mandelbrot set\n    // By Fact 1, the set lies in |c| ≤ 2\n    vec2 c = uv * 4.0;\n    c.x -= 0.5;  // shift left to center the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Binary coloring\n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);  // In the set: black\n    } else {\n        color = vec3(1.0);  // Escaped: white\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  Missing Demo\n  Shader demo day2/mandelbrot-bw not found.\n\n\nThere it is—the Mandelbrot set in black and white!\n\n\nColoring by Iteration Count\nBlack and white shows the set, but we’re throwing away information. The number of iterations before escape tells us how “close” a point is to the boundary—points that escape after 5 iterations are different from points that escape after 50.\nLet’s use iter to create a gradient:\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);\n} else {\n    float t = float(iter) / float(max_iter);\n    color = vec3(t);\n}\n\n  Missing Demo\n  Shader demo day2/mandelbrot-gray not found.\n\n\nNow we see structure! The boundary reveals intricate detail—tendrils, spirals, bulbs. Points near the boundary take many iterations to escape (bright), while points far away escape quickly (dark).\n\n\nColor Palettes\nGrayscale works, but we can do better. A common technique uses cosines to create smooth, cycling color palettes:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nThe parameters a, b, c, d control the palette’s character. The vector d shifts the phase of each color channel, creating different hues. Try d = vec3(0.00, 0.10, 0.20) for blues and purples, or d = vec3(0.30, 0.20, 0.20) for warmer tones.\n\n  Missing Demo\n  Shader demo day2/mandelbrot-color not found.\n\n\nThe color bands correspond to iteration counts—regions of the same color escaped after the same number of iterations. You’ll notice the bands have sharp edges. In the exercises, we’ll show you a technique called smooth coloring that interpolates between iteration counts, eliminating the banding for even smoother gradients.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#other-escape-time-fractals",
    "href": "lectures/day2.html#other-escape-time-fractals",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "2.4 Other Escape-Time Fractals",
    "text": "2.4 Other Escape-Time Fractals\nThe Mandelbrot set is one example of an escape-time fractal, but the same algorithm works for many other iterated systems. We just swap out the iteration formula (and sometimes the escape condition). Let’s explore a few.\n\nJulia Sets\nThe Mandelbrot set asks: for which values of \\(c\\) does the orbit of \\(0\\) stay bounded? We can ask a different question: for a fixed \\(c\\), which starting points \\(z_0\\) have bounded orbits?\nFix a complex number \\(c\\). The filled Julia set \\(K_c\\) is the set of all starting points \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded.\nSame iteration, different question. For the Mandelbrot set, we vary \\(c\\) and always start at \\(z_0 = 0\\). For a Julia set, we fix \\(c\\) and vary \\(z_0\\).\nThe code change is minimal:\n// Mandelbrot: c varies, z starts at 0\nvec2 c = p;\nvec2 z = vec2(0.0, 0.0);\n\n// Julia: c is fixed, z starts at pixel position\nvec2 c = vec2(-0.7, 0.27015);  // fixed parameter\nvec2 z = p;\n\n  Missing Demo\n  Shader demo day2/julia-static not found.\n\n\nDifferent values of \\(c\\) produce dramatically different Julia sets. In the exercises, you’ll build an interactive explorer that lets you click anywhere on the Mandelbrot set to see the corresponding Julia set:\n\n  Missing Demo\n  Shader demo day2/julia-explorer not found.\n\n\n\n\nThe Burning Ship\nThe Burning Ship fractal modifies the Mandelbrot iteration by taking the absolute value of the imaginary part after each squaring:\n\\[z_{n+1} = (\\text{Re}(z_n^2) + i|\\text{Im}(z_n^2)|) + c\\]\nIn code:\n// Inside the loop:\nz = cmul(z, z);\nz.y = abs(z.y);  // Take absolute value of imaginary part\nz = z + c;\n\n  Missing Demo\n  Shader demo day2/burning-ship not found.\n\n\nThe absolute value breaks the symmetry, creating an asymmetric fractal that (with some imagination) resembles a burning ship.\n\n\nHigher Powers\nThe Mandelbrot set uses \\(z^2 + c\\). What about \\(z^3 + c\\)? Or \\(z^4 + c\\)?\nFor \\(z^3\\), we need to implement cubing:\nvec2 ccube(vec2 z) {\n    // z³ = z · z · z\n    return cmul(cmul(z, z), z);\n}\nOr we can derive it directly: \\((a + bi)^3 = a^3 + 3a^2(bi) + 3a(bi)^2 + (bi)^3 = (a^3 - 3ab^2) + (3a^2b - b^3)i\\)\nvec2 ccube(vec2 z) {\n    float a = z.x, b = z.y;\n    return vec2(\n        a*a*a - 3.0*a*b*b,\n        3.0*a*a*b - b*b*b\n    );\n}\nThen the iteration becomes:\nz = ccube(z) + c;\n\n  Missing Demo\n  Shader demo day2/mandelbrot-cubic not found.\n\n\nHigher powers give higher-order rotational symmetry: \\(z^3 + c\\) has 3-fold symmetry, \\(z^4 + c\\) has 4-fold symmetry, and so on.\n\n\nThe Pattern\nAll these fractals share the same structure:\n\nIterate some function \\(f(z, c)\\)\nCheck escape: has \\(|z|\\) exceeded some threshold?\nColor based on iteration count\n\nChanging the iteration function changes the fractal. The exercises include more variations for you to try.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#circle-inversion",
    "href": "lectures/day2.html#circle-inversion",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "2.5 Circle Inversion",
    "text": "2.5 Circle Inversion\nWe shift gears from complex dynamics to geometric transformations. Circle inversion is a classical operation that turns circles into circles (or lines), preserves angles, and creates beautiful fractal patterns when iterated.\n\nDefinition\nInversion in the unit circle maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\frac{\\mathbf{p}}{|\\mathbf{p}|^2}\\]\nWhat does this do geometrically? The inverted point lies on the same ray from the origin as \\(\\mathbf{p}\\), but at distance \\(1/r\\) instead of \\(r\\).\n\nPoints inside the unit circle map to points outside\nPoints outside map to points inside\n\nPoints on the unit circle stay fixed\nThe origin maps to “infinity”\n\n\n\nImplementation\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\n\nVisualizing Inversion\nTo see what inversion does, let’s draw some shapes and their images. We’ll draw the unit circle (gray), plus a vertical line and a circle (yellow). To make it clearer, we’ll toggle between showing the original shapes and their inversions:\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Compute the inversion of p\n    vec2 p_inv = invert(p);\n    \n    // Toggle between original and inverted every second\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;      // original\n    } else {\n        q = p_inv;  // inverted\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle (the inversion circle)\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a vertical line at x = 2\n    if (abs(q.x - 2.0) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a horizontal line at y = 1.5\n    if (abs(q.y - 1.5) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a circle centered at (2, 0) with radius 0.5\n    float d_circle = abs(length(q - vec2(2.0, 0.0)) - 0.5);\n    if (d_circle &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  Missing Demo\n  Shader demo day2/inversion-toggle not found.\n\n\nWatch the lines become circles! A line not passing through the origin inverts to a circle that does pass through the origin. The circle inverts to another circle (with a different center and radius).\n\n\n\n\n\n\nTipGLSL Shortcuts: mix and step\n\n\n\nThe toggle logic can be written more compactly using built-in functions:\n\nstep(edge, x) returns 0 if x &lt; edge, otherwise 1\nmix(a, b, t) linearly interpolates: returns a when t = 0, b when t = 1\n\nfloat t = step(0.5, fract(iTime * 0.5));\nvec2 q = mix(p, p_inv, t);\nThis is a common pattern for toggling or smoothly transitioning between states.\n\n\n\n\nKey Properties\nCircle inversion maps circles to circles (or to lines, if the circle passes through the center). It’s conformal—it preserves angles between curves. And it’s involutive: applying inversion twice returns to the original point.\n\n\nInverting a Grid\nFor a more dramatic visualization, let’s invert a whole grid of lines. The function mod(q, 0.5) gives the position of q within a repeating \\(0.5 \\times 0.5\\) cell—when either component is near zero, we’re on a grid line:\nvec2 grid = mod(q, 0.5);\nif (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n(If you did the grid project from Day 1, this is familiar!)\nWe can run the same shader as before, just replacing the individual shapes with this grid:\n\n  Missing Demo\n  Shader demo day2/inversion-grid not found.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#structs",
    "href": "lectures/day2.html#structs",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "2.6 Structs",
    "text": "2.6 Structs\nSo far our invert function only works for the unit circle at the origin. What if we want to invert through a different circle?\n\nGeneral Circle Inversion\nFor a circle with center \\(\\mathbf{c}\\) and radius \\(R\\), inversion maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nThe idea is the same as before: the inverted point lies on the ray from \\(\\mathbf{c}\\) through \\(\\mathbf{p}\\), at distance \\(R^2/r\\) from the center (where \\(r = |\\mathbf{p} - \\mathbf{c}|\\)). When \\(\\mathbf{c} = \\mathbf{0}\\) and \\(R = 1\\), this reduces to our earlier formula \\(\\mathbf{p}/|\\mathbf{p}|^2\\).\nIn code:\nvec2 invertInCircle(vec2 p, vec2 center, float radius) {\n    vec2 d = p - center;\n    return center + radius * radius * d / dot(d, d);\n}\nThis works, but notice we need to pass two things (center and radius) to describe one object (a circle). If we’re working with multiple circles, every function call needs center1, radius1, center2, radius2, ...—it gets verbose and error-prone.\n\n\nDefining a Struct\nGLSL lets us bundle related data into a struct:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nNow Circle is a type, just like vec2 or float. We can create circles and access their fields:\nCircle c;\nc.center = vec2(1.0, 0.5);\nc.radius = 0.7;\n\n// Or initialize directly:\nCircle c = Circle(vec2(1.0, 0.5), 0.7);\n\n\nInversion with Structs\nNow our inversion function takes a Circle:\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\nMuch cleaner! And when we’re working with multiple circles, we can pass them around as single objects.\n\n\nDemo: Moving Circle\nLet’s animate a circle moving around and watch how the inversion changes:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Animate the inversion circle\n    Circle inv_circle;\n    inv_circle.center = vec2(sin(iTime) * 0.5, cos(iTime * 0.7) * 0.5);\n    inv_circle.radius = 1.0 + 0.3 * sin(iTime * 1.3);\n    \n    // Compute inversion\n    vec2 p_inv = invert(p, inv_circle);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the inversion circle\n    float d_inv = abs(length(p - inv_circle.center) - inv_circle.radius);\n    if (d_inv &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = mod(p_inv, 0.5);\n    if (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  Missing Demo\n  Shader demo day2/inversion-moving not found.\n\n\nAs the circle moves and breathes, the inverted grid warps and flows.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-apollonian-gasket",
    "href": "lectures/day2.html#the-apollonian-gasket",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "2.7 The Apollonian Gasket",
    "text": "2.7 The Apollonian Gasket\nThe Apollonian gasket is a classical fractal arising from circle packing. It’s named after Apollonius of Perga (~200 BCE), who studied the problem of finding circles tangent to three given circles.\n\n  Missing Demo\n  Shader demo day2/apollonian-final not found.\n\n\n\nThe Setup\nStart with four mutually tangent circles: three “inner” circles that touch each other pairwise, all enclosed by one “outer” circle that touches all three.\nLet’s define these circles using our Circle struct. We’ll place three circles of radius \\(r\\) with centers forming an equilateral triangle, all tangent to each other and to an outer circle:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n// Three inner circles, mutually tangent, plus outer circle\n// For circles of radius r to be mutually tangent, their centers\n// must be 2r apart. This forms an equilateral triangle with side 2r.\nfloat r = 1.0;\nfloat triSide = 2.0 * r;  // distance between inner circle centers\nfloat circumradius = triSide / sqrt(3.0);  // distance from origin to centers\n\nCircle c1 = Circle(vec2(0.0, circumradius), r);\nCircle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\nCircle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\nCircle outer = Circle(vec2(0.0, 0.0), circumradius + r);\nTo draw these circles, we need a distance function:\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\nThis returns the distance from p to the circle’s boundary—zero on the circle, positive elsewhere.\nLet’s draw our starting configuration:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Define circles\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw all four circles\n    if (distToCircle(p, c1) &lt; 0.03) color = vec3(1.0, 0.3, 0.3);\n    if (distToCircle(p, c2) &lt; 0.03) color = vec3(0.3, 1.0, 0.3);\n    if (distToCircle(p, c3) &lt; 0.03) color = vec3(0.3, 0.3, 1.0);\n    if (distToCircle(p, outer) &lt; 0.03) color = vec3(1.0, 1.0, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  Missing Demo\n  Shader demo day2/apollonian-setup not found.\n\n\nThree colored circles inside a white outer circle, all mutually tangent.\n\n\nFrom Drawing to Iteration\nThe gaps between circles are curvilinear triangles. The Apollonian gasket fills each gap with a circle tangent to its three neighbors, then fills the new gaps, and so on forever.\nHere’s the key insight: we can generate this structure by iterating inversions. If a point is inside one of the inner circles, invert through that circle—this “pushes” it out. If a point is outside the outer circle, invert through the outer circle—this “pulls” it in.\nWe need to check: - Is \\(\\mathbf{p}\\) inside circle c1, c2, or c3? (distance from center &lt; radius) - Is \\(\\mathbf{p}\\) outside circle outer? (distance from center &gt; radius)\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nbool isOutside(vec2 p, Circle c) {\n    return length(p - c.center) &gt; c.radius;\n}\nThe iteration: keep inverting until the point lands in a “gap” (inside outer, outside all inner circles) or we hit a maximum iteration count.\n\n\nFull Implementation\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Define circles\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;  // In the gap—done!\n        }\n    }\n    \n    // Color by iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Draw circle boundaries\n    float dMin = min(min(distToCircle(p, c1), distToCircle(p, c2)), \n                     min(distToCircle(p, c3), distToCircle(p, outer)));\n    if (dMin &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  Missing Demo\n  Shader demo day2/apollonian-iterated not found.\n\n\n\n\nVisualizing the Limit Set\nThe limit set of the Apollonian gasket is the fractal boundary—the set of points that never escape to the fundamental domain, no matter how many iterations. Points near the limit set take many iterations before landing in a gap.\nWe can emphasize the limit set by adjusting our coloring. Instead of using a color palette, we use a nonlinear function that suppresses low iteration counts (the “background”) and brightens high iteration counts (near the fractal):\nfloat t = float(iter) / float(max_iter);\nvec3 color = 30.0 * vec3(pow(t, 2.0));\nThe squaring suppresses points that escape quickly, while the factor of 30 boosts the brightness of points near the limit set.\n\n  Missing Demo\n  Shader demo day2/apollonian-final not found.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  },
  {
    "objectID": "lectures/day2.html#exercises",
    "href": "lectures/day2.html#exercises",
    "title": "2  Day 2: Complex Dynamics and Circle Inversion",
    "section": "2.8 Exercises",
    "text": "2.8 Exercises\n\nCheckpoints\nC1. Julia Set. Modify the Mandelbrot shader to render a Julia set. Fix c = vec2(-0.7, 0.27015) and initialize z from the pixel position instead of zero. Verify you get an intricate, connected fractal.\nC2. Cubic Mandelbrot. Change the iteration from \\(z^2 + c\\) to \\(z^3 + c\\). You’ll need to implement complex cubing:\nvec2 ccube(vec2 z) {\n    float a = z.x, b = z.y;\n    return vec2(a*a*a - 3.0*a*b*b, 3.0*a*a*b - b*b*b);\n}\nWhat symmetry do you observe?\nC3. Apollonian Animation. Animate the Apollonian gasket by letting the maximum iteration count grow with time. Use int max_iter = int(mod(iTime * 5.0, 50.0)) + 1; so the fractal “builds up” from the four starting circles to the full gasket, then resets. Watch how each iteration reveals a new layer of circles in the gaps.\nC4. Colorize a Fractal. Take any of the black-and-white fractals from today (Mandelbrot, Julia, Burning Ship, or Apollonian) and add color using the cosine palette:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nExperiment with different values of d to shift the hues.\nC5. Circle Art. Create an image with several circles of different sizes scattered across the screen. Color a pixel based on whether it’s inside zero, one, two, or more circles. (Hint: use isInside and count how many circles contain each point.)\n\n\nExplorations\nE1. Julia Explorer (Mouse). Make the Julia parameter c follow the mouse position. Map iMouse.xy to a reasonable region of the complex plane (say, \\([-2, 2] \\times [-2, 2]\\)). Drag around and watch the Julia set morph!\nE2. Julia Animation. Animate the parameter c along a path in the complex plane. Try a circle:\nfloat angle = iTime * 0.3;\nvec2 c = 0.7885 * vec2(cos(angle), sin(angle));\nOr trace the boundary of the main cardioid of the Mandelbrot set—every point on this curve gives a Julia set with a parabolic fixed point:\nvec2 cardioid(float t) {\n    vec2 eit = vec2(cos(t), sin(t));\n    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;\n    return cmul(eit, z);\n}\n\nvec2 c = cardioid(iTime * 0.5);\nWatch the Julia set continuously transform. What happens when c crosses from inside to outside the Mandelbrot set?\nE3. Other Escape-Time Fractals. Implement one or more of these variations on the Mandelbrot iteration:\n\nBurning Ship: \\(z \\leftarrow z^2\\), then \\(\\text{Im}(z) \\leftarrow |\\text{Im}(z)|\\), then \\(z \\leftarrow z + c\\)\nTricorn (Mandelbar): \\(z_{n+1} = \\bar{z}_n^2 + c\\) where \\(\\bar{z}\\) is the complex conjugate\nCeltic: \\(z_{n+1} = |\\text{Re}(z_n^2)| + i\\,\\text{Im}(z_n^2) + c\\)\n\nFor each, figure out how to translate the mathematical formula into GLSL. The escape condition (\\(|z| &gt; 2\\)) stays the same.\nE4. Smooth Coloring. The iteration count is an integer, so coloring by iteration gives discrete bands. But when a point escapes, it doesn’t land exactly on the escape radius—it overshoots. We can use how much it overshot to interpolate between iteration counts.\nThe idea: if \\(|z_n| &gt; 2\\), the “true” fractional iteration where \\(|z| = 2\\) is approximately: \\[n_{\\text{smooth}} = n - \\frac{\\log(\\log|z_n|/\\log 2)}{\\log 2}\\]\nThis comes from the fact that near escape, \\(|z_{n+1}| \\approx |z_n|^2\\), so \\(\\log|z|\\) roughly doubles each iteration.\nImplement this for the Mandelbrot set:\nif (iter &lt; max_iter) {\n    float log_zn = log(cabs2(z)) / 2.0;  // log|z|\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    t = smooth_iter / float(max_iter);\n}\nThe bands should disappear, replaced by smooth gradients.\nE5. Apollonian Coloring. Modify the Apollonian gasket to color by which circle was last inverted through, instead of iteration count. Use a different color for each of the four circles. What patterns emerge?\nE6. Apollonian Variations. The Apollonian gasket works with any four mutually tangent circles—the symmetric configuration we used is just one example. Descartes’ Circle Theorem tells us: if four circles are mutually tangent with curvatures \\(k_1, k_2, k_3, k_4\\) (where curvature = 1/radius, negative for the outer circle), then: \\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\\] Experiment with different configurations: - Change the radii of the three inner circles (they don’t have to be equal!) - Use Descartes’ theorem to find an outer circle tangent to three given inner circles - What happens if the circles overlap instead of being tangent?\n\n\nChallenges\nH1. Julia Explorer (Full). Build an interactive tool: display the Mandelbrot set, and wherever the user clicks, show the Julia set for that parameter overlaid or side-by-side. This requires: - Rendering Mandelbrot in one region - Reading click position from iMouse - Rendering Julia for that c in another region (or blended on top)\n\n  Missing Demo\n  Shader demo day2/julia-explorer not found.\n\n\nH2. Newton Fractal. The Newton fractal comes from applying Newton’s method to find roots of a polynomial. For \\(f(z) = z^3 - 1\\), Newton’s iteration is: \\[z_{n+1} = z_n - \\frac{f(z_n)}{f'(z_n)} = z_n - \\frac{z_n^3 - 1}{3z_n^2} = \\frac{2z_n^3 + 1}{3z_n^2}\\] Iterate this and color based on which root the orbit converges to (the three cube roots of unity: \\(1\\), \\(e^{2\\pi i/3}\\), \\(e^{4\\pi i/3}\\)). Check convergence by testing if \\(|z^3 - 1| &lt; \\epsilon\\).\nH3. Higher-Power Mandelbrot. Implement \\(z^n + c\\) for general \\(n\\). Use the polar form: if \\(z = re^{i\\theta}\\), then \\(z^n = r^n e^{in\\theta}\\). In code:\nvec2 cpow(vec2 z, float n) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    float rn = pow(r, n);\n    return rn * vec2(cos(n * theta), sin(n * theta));\n}\nTry non-integer values of \\(n\\)! What happens at \\(n = 2.5\\)?\n\n\nProjects\nProject 1: Grid of Julia Sets\nCreate a grid where each cell shows the Julia set for a different value of \\(c\\). The position in the grid determines \\(c\\)—effectively, each cell samples a point in the Mandelbrot parameter space.\nWhen you zoom out, the overall pattern should reveal the Mandelbrot set: cells with connected Julia sets (solid regions) correspond to \\(c \\in \\mathcal{M}\\), while cells with dust-like Julia sets correspond to \\(c \\notin \\mathcal{M}\\).\nUse the grid technique from Day 1:\nfloat grid_size = 8.0;\nvec2 cell_id = floor((p + 2.0) * grid_size / 4.0);\nvec2 cell_p = fract((p + 2.0) * grid_size / 4.0) * 4.0 - 2.0;\n\n// c comes from which cell we're in\nvec2 c = (cell_id / grid_size) * 4.0 - 2.0;\n\n// z starts from position within the cell\nvec2 z = cell_p;\nProject 2: Orbit Visualization\nInstead of just coloring by iteration count, visualize the actual orbit of a point. Make the starting point draggable with the mouse:\n\nLet \\(z_0\\) be the mouse position (normalized to the complex plane)\nFix a parameter \\(c\\) (or let it be controllable too)\nCompute the first \\(N\\) iterates: \\(z_0, z_1, z_2, \\ldots, z_N\\)\nDraw small circles at each iterate position\nConnect consecutive iterates with lines (use the segment SDF from Day 1!)\nColor by iteration index (early iterates one color, later iterates another)\n\nThis reveals the dynamics directly: bounded orbits stay in a region and may converge to a cycle, while escaping orbits spiral outward. Drag the starting point around and watch how the orbit changes—you’ll see the sensitive dependence on initial conditions that makes chaos!\nFor Julia sets, fix c and drag z_0. For the Mandelbrot perspective, fix z_0 = 0 and drag c.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Circle Inversion</span>"
    ]
  }
]