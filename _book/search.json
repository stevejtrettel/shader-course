[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GPU-Accelerated Mathematical Illustration",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nWe’ll progress from 2D foundations (curves, tilings, fractals) to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to work hard and experiment with code through daily homework exercises. Here are some examples of things we will make:",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "outline.html",
    "href": "outline.html",
    "title": "Outline",
    "section": "",
    "text": "Course Overview\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nFormat: Five days, each with one hour of lecture and approximately 1.5 hours of homework\nPrerequisites: Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required\nAudience: Graduate students, postdocs, and faculty in mathematics",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-1-introduction-to-shader-programming",
    "href": "outline.html#day-1-introduction-to-shader-programming",
    "title": "Outline",
    "section": "Day 1: Introduction to Shader Programming",
    "text": "Day 1: Introduction to Shader Programming\n\nLearning Objectives\n\nUnderstand the mathematical model of shader programming (function from pixels to colors)\nLearn basic GLSL syntax and conventions\nMaster coordinate system setup and distance calculations\nCreate simple geometric shapes and implicit curves\n\n\n\nIn-Class Content\n\nMathematical framing: Shaders as parallel functions computing colors for all pixels simultaneously\nGLSL basics: Syntax, vector types, built-in functions\nCoordinate systems: Centering, normalizing, aspect ratio correction\nConditional coloring: Half-planes and regions defined by inequalities\nDistance fields: Circles, filled and outlined\nRepetition: Using mod() for grids and patterns\nImplicit curves: Rendering curves defined by \\(F(x,y) = 0\\)\n\n\n\nHomework\nRequired: Parabola graphing calculator - Draw coordinate axes - Plot \\(y = ax^2 + bx + c\\) with customizable coefficients - Make it robust for various parameter values\nOptional #1: Animated curve family (vary parameters with time)\nOptional #2: Beautiful tiling pattern using mod()",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "href": "outline.html#day-2-complex-dynamics-and-euclidean-geometry",
    "title": "Outline",
    "section": "Day 2: Complex Dynamics and Euclidean Geometry",
    "text": "Day 2: Complex Dynamics and Euclidean Geometry\n\nLearning Objectives\n\nImplement complex number arithmetic in GLSL\nUnderstand and render the Mandelbrot and Julia sets\nCreate geometric tilings using mathematical transformations\nLearn to use structs for organizing data\n\n\n\nIn-Class Content\n\nComplex Numbers in GLSL\n\nRepresenting complex numbers as vec2\nImplementing complex multiplication\nComplex addition, conjugation, and magnitude\n\n\n\nThe Mandelbrot Set\n\nMathematical definition: iterating z → z² + c with z₀ = 0\nEscape-time algorithm\nColoring schemes based on iteration count\nDiscussing convergence and divergence\n\n\n\nJulia Sets\n\nFixing c and varying initial z\nRelationship to Mandelbrot set\nCreating visually interesting Julia sets\n\n\n\nIntroduction to Structs\n\nDefining struct types in GLSL\nUse case: organizing geometric data\nExample: storing triangle vertices or transformation data\n\n\n\nEuclidean Triangle Tiling\n\nFundamental domain for triangular tiling\nReflection across edges to create periodic patterns\nSymmetry groups and transformations\n\n\n\n\nHomework\n\nRequired: Circle Inversion\n\nImplement circle inversion as an operation on the plane\nFor a circle of radius R centered at origin: p' = R² * p / |p|²\nFor a circle centered at c with radius R: translate, invert, translate back\nVisualize by applying inversion to a grid or pattern\nDemonstrate that circles through the inversion center become lines, and vice versa\n\n\n\nOptional #1: Apollonian Gasket\n\nUse your circle inversion implementation\nStart with three mutually tangent circles\nRepeatedly invert through each circle\nColor by iteration count or which circle was inverted through\nExplore the fractal structure created by nested circles",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-3-fractals-and-hyperbolic-geometry",
    "href": "outline.html#day-3-fractals-and-hyperbolic-geometry",
    "title": "Outline",
    "section": "Day 3: Fractals and Hyperbolic Geometry",
    "text": "Day 3: Fractals and Hyperbolic Geometry\n\nLearning Objectives\n\nExtend folding techniques to box fractals\nUnderstand hyperbolic geometry models and their properties\nImplement computations in the upper half-plane model\nCreate hyperbolic tilings using inversions and Möbius transformations\nConvert between different models of hyperbolic geometry\n\n\n\nIn-Class Content\n\nReview: Sierpinski Triangle via Folding\n\nGenerating fractals through iterated reflections\nUsing abs() for geometric folding\nScaling and iteration\nColoring by iteration depth or distance\n\n\n\nIntroduction to Hyperbolic Geometry\n\nWhy hyperbolic space? Negative curvature vs. Euclidean geometry\nThree primary models: Poincaré disk, upper half-plane, and band model\nHow models are related via Möbius transformations\nProperties: geodesics, distance, angle measurement\n\n\n\nComputations in the Upper Half-Plane Model\n\nDefinition: points {z : Im(z) &gt; 0}\nGeodesics: vertical lines and semicircles perpendicular to real axis\nDistance formula in the upper half-plane\nMöbius transformations as isometries: z → (az + b)/(cz + d) with ad - bc = 1\nMatrix representation of transformations\n\n\n\nHyperbolic Triangle Tiling\n\nSetting up a hyperbolic triangle (angles sum to &lt; π)\nComputing geodesics as circular arcs\nImplementing circle inversion for reflections across geodesics\nFolding points into fundamental domain\nIterating to create the full tiling\nColoring by domain or iteration behavior\n\n\n\nDrawing in Different Models\n\nConverting between Poincaré disk and upper half-plane\nMöbius transformation: w = i(1-z)/(1+z) (disk to half-plane)\nBand model via additional Möbius transformation\nVisualizing the same tiling in multiple models simultaneously\n\n\n\n\nHomework\n\nRequired: Sierpinski Carpet\n\nImplement the 2D Sierpinski carpet using box folding\nUse abs() to create 4-fold symmetry\nScale by 3 at each iteration, removing middle square\nColor by iteration depth or distance\nExperiment with different iteration counts\n\n\n\nRequired: Model Conversion and Möbius Transformation\n\nConvert your hyperbolic tiling from upper half-plane to Poincaré disk (or vice versa)\nApply a Möbius transformation to your tiling (choose your own or use a suggested one)\nRender both the original and transformed tiling\nObserve how the transformation affects the visual appearance\n\n\n\nOptional: Advanced Explorations\n\nAnother Triangle Group: Implement a different hyperbolic triangle group (e.g., (2,3,7), (2,4,6))\nKlein Model: Convert to Klein model via Cayley transform\nConformal Art: Use complex analysis to map to creative domains\nDecorated Tiles: Create Escher-style decorated tiles",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-4-introduction-to-3d-rendering",
    "href": "outline.html#day-4-introduction-to-3d-rendering",
    "title": "Outline",
    "section": "Day 4: Introduction to 3D Rendering",
    "text": "Day 4: Introduction to 3D Rendering\n\nLearning Objectives\n\nSet up camera and generate rays from pixels\nImplement analytical ray-object intersection\nLearn the raymarching algorithm and signed distance functions\nApply basic lighting (diffuse shading)\n\n\n\nIn-Class Content\n\nCamera and ray setup:\n\nPinhole camera model\nRay generation from pixel coordinates\nField of view control\n\nAnalytical intersections:\n\nRay-sphere: solve quadratic equation\nCompute surface normals analytically\nRay-torus: implicit equation and gradient\nBisection method for root-finding\n\nLighting introduction:\n\nSurface normals\nDiffuse lighting: dot product with light direction\nSeeing 3D structure through shading\n\nMotivation for raymarching:\n\nAnalytical methods don’t scale\nComplex surfaces need flexible approach\n\nSigned Distance Functions (SDFs):\n\nDefinition and properties\nSDFs for primitives: sphere, box, plane, torus\nDistance as bound for safe marching\n\nRaymarching algorithm:\n\nSphere tracing: march by SDF value\nStopping conditions\nScene composition (minimum distance)\n\nNormal estimation:\n\nGradient via finite differences\nEstimating partial derivatives\nSame lighting applied to raymarched objects\n\nScene progression:\n\nSingle sphere\nTwo spheres\nSphere and torus\n\n\n\n\nHomework\nRequired: Algebraic variety rendering - Choose polynomial implicit surface (degree 3 or 4) - Implement root-finding (bisection or Newton’s method) - Compute gradient for normals - Optional: bounding sphere optimization\nOptional: - Specular lighting (Phong model) - Rotation matrices for object transformation - Complex multi-object scenes",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-5-choose-your-adventure",
    "href": "outline.html#day-5-choose-your-adventure",
    "title": "Outline",
    "section": "Day 5: Choose Your Adventure",
    "text": "Day 5: Choose Your Adventure\nThe final day will be determined based on pacing, student interest, and energy levels. Two complete lectures are prepared:\n\nOption A: Advanced Raymarching Techniques\n\nLearning Objectives\n\nMaster domain operations for efficient complex scenes\nUnderstand and apply boolean operations on SDFs\nCreate 3D fractals via iterated folding (Menger sponge)\nBuild sophisticated scenes from simple primitives\n\n\n\nIn-Class Content\n\nDomain operations:\n\nRepetition: mod() for infinite object grids\nSymmetry: abs() for mirror planes\nPolar repetition for radial patterns\nZero computational cost for infinite complexity\n\nBoolean operations on SDFs:\n\nUnion: min(d1, d2)\nIntersection: max(d1, d2)\nSubtraction: max(d1, -d2)\nSmooth minimum: smin() for organic blending\n\nMenger sponge:\n\nBox folding in 3D\nAxis-aligned operations\nIterated subdivision\nConnection to 2D fractals\n\nScene building:\n\nCombining techniques\nArchitectural structures\nInfinite repeated patterns\n\n\n\n\nHomework\nRequired: Creative scene building - Build complex scene using domain ops and booleans - Experiment with combinations - Focus on mathematical or aesthetic interest\nOptional: Sierpinski tetrahedron - Implement via 3D folding (non-axis-aligned) - Connection to Day 2’s triangle folding in higher dimension\n\n\n\n\nOption B: Buffers and Temporal Dynamics\n\nLearning Objectives\n\nUnderstand buffer-based computation in Shadertoy\nImplement differential operators (Laplacian)\nSolve partial differential equations on the GPU\nCreate dynamic, evolving mathematical systems\n\n\n\nIn-Class Content\n\nIntroduction to buffers:\n\nReading from previous frame\nMulti-pass rendering\nSimple example: conditional coloring based on buffer\n\nEdge detection and the Laplacian:\n\nDiscrete Laplacian stencil (5-point or 9-point)\nSampling neighboring pixels\nSpatial derivatives on grids\n\nThe heat equation:\n\nMathematical formulation: \\(u_t = \\alpha\\nabla^2 u\\)\nApplying Laplacian for diffusion\nTime-stepping: u_new = u_old + dt * α * laplacian(u_old)\nInitial conditions (e.g., heat in a fractal region)\nWatching patterns blur and diffuse\n\nBoundary conditions:\n\nZero boundaries (edges set to 0)\nAvoiding wrap-around\n\nTimestep stability:\n\nCFL condition (briefly mentioned)\nProviding stable dt value\n\n\n\n\nHomework\nRequired: Interactive heat equation or reaction-diffusion - Option 1: Heat source at mouse position, watch it diffuse - Option 2: Gray-Scott reaction-diffusion (pattern formation)\nOptional: Wave equation - Requires two buffers (current and previous state) - Implement \\(u_{tt} = c^2\\nabla^2 u\\) - Watch waves propagate and reflect",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "day1.html",
    "href": "day1.html",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "1.1 Overview\nToday we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.\nBy the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#what-is-a-shader",
    "href": "day1.html#what-is-a-shader",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.2 What is a Shader?",
    "text": "1.2 What is a Shader?\n\nMathematical Perspective\nA shader is fundamentally a function \\[f: \\mathbb{R}^2 \\times \\mathbb{R} \\times \\cdots \\to \\mathbb{R}^4\\] that maps pixel coordinates (and potentially time, mouse position, etc.) to color values. For each pixel on the screen, we evaluate this function to determine what color to display.\nHere’s the magic: modern GPUs can evaluate this function for all pixels simultaneously. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!\nThis is completely different from how you might write mathematical visualization code in, say, Python. There you’d have nested loops:\nfor x in range(width):\n    for y in range(height):\n        color[x,y] = f(x, y)\nWith shaders, there are no loops. You write the function f, and the GPU just does it everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.\n\n\n\n\n\n\nWhy is this called a “shader”?\n\n\n\nHistorically, these programs were used for shading 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!\n\n\n\n\nWhy Shadertoy?\nShadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.\nThe platform provides several built-in uniforms (read-only global variables that are the same for all pixels):\n\niResolution: screen resolution as a vec3 (width, height, pixel aspect ratio)\niTime: elapsed time in seconds since the shader started\niMouse: mouse position and click state as a vec4\n\nWe’ll use these throughout the week to create animated, interactive mathematical visualizations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#first-shader-solid-colors",
    "href": "day1.html#first-shader-solid-colors",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.3 First Shader: Solid Colors",
    "text": "1.3 First Shader: Solid Colors\n\nBasic Structure\nEvery Shadertoy shader has the same entry point:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Your code here\n}\nParameters:\n\nfragCoord: the pixel coordinate we’re currently computing, as a vec2 (x, y)\nfragColor: the output color we need to set, as a vec4 (red, green, blue, alpha)\n\nColors are represented in RGBA format with values in \\([0, 1]\\). So vec4(1.0, 0.0, 0.0, 1.0) represents opaque red, while vec4(0.5, 0.5, 0.5, 1.0) is middle gray.\n\n\nExample: Red Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nThis sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on fragCoord, every pixel gets the same value. Not very exciting—but it’s a start!\n\n\nGLSL Syntax Basics\nBefore we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:\n\n\n\n\n\n\nGLSL Syntax Rules\n\n\n\nSemicolons are required. Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.\nFloating point literals: Write 1.0 not 1 for floating point values. GLSL is very picky about types—if you write 1, it’s an integer, and mixing types causes errors. Get in the habit of always writing the .0.\nVector types: GLSL has built-in types vec2, vec3, vec4 for 2D, 3D, and 4D vectors. You can construct them with:\nvec2 v = vec2(1.0, 2.0);\nvec3 w = vec3(1.0, 2.0, 3.0);\nvec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars\nSwizzling: You can access components by name: v.x, v.y or equivalently v.r, v.g (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: v.yx swaps the coordinates, v.xxx repeats the x-component three times. This is incredibly useful!\n\n\n\n\nAnimating with Time\nLet’s make something that changes:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\nHere iTime grows continuously, sin(iTime) oscillates between \\(-1\\) and \\(1\\), and we remap to \\([0, 1]\\) with the affine transformation \\(x \\mapsto \\frac{1}{2}(1 + x)\\). The screen now pulses between black and red!\nThis pattern—0.5 + 0.5 * sin(...)—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range \\([0,1]\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#coordinate-systems",
    "href": "day1.html#coordinate-systems",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.4 Coordinate Systems",
    "text": "1.4 Coordinate Systems\n\nRaw Coordinates\nBy default, fragCoord gives pixel coordinates with:\n\nOrigin \\((0, 0)\\) at the bottom-left\n\\(x\\) increases rightward to iResolution.x\n\\(y\\) increases upward to iResolution.y\n\nThis is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!\n\n\nCentered, Normalized Coordinates\nHere’s the standard transformation we’ll use in every shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Center at origin: [-0.5, 0.5]\n    uv = uv - 0.5;\n    \n    // Scale to account for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Now uv is centered and aspect-corrected\n    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)\n    vec2 p = uv * 4.0;  // Now p is in [-2, 2] × [-h, h] where h depends on aspect ratio\n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nLet’s break this down step by step:\n\nNormalize: Dividing by iResolution.xy maps from pixel coordinates to \\([0,1] \\times [0,1]\\)\nCenter: Subtracting \\(0.5\\) shifts the origin to the center: \\([-0.5, 0.5] \\times [-0.5, 0.5]\\)\nAspect correction: Multiplying uv.x by the aspect ratio ensures that equal distances in uv.x and uv.y correspond to equal screen distances—this makes circles actually circular!\nScale: Finally, we scale to whatever viewing window we want for our visualization\n\nFrom now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable p for “position.”\n\n\n\n\n\n\nThe coordinate transformation boilerplate\n\n\n\nYou’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit.\n\n\n\n\nVisualizing Coordinates\nLet’s verify our coordinate system is working by coloring pixels according to their position:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup as above, resulting in p]\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\nYou should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#conditional-coloring-half-planes",
    "href": "day1.html#conditional-coloring-half-planes",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.5 Conditional Coloring: Half-Planes",
    "text": "1.5 Conditional Coloring: Half-Planes\n\nThe Concept\nGiven a linear function \\(L(x, y) = ax + by\\), we want to color pixels differently depending on whether \\(L(p) &lt; 0\\) or \\(L(p) \\geq 0\\). This divides the plane into two half-planes—the regions where the function is negative vs. positive.\n\n\nImplementation\nGLSL provides a conditional operator (ternary operator) just like C:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\nLeft half-plane is red, right half-plane is blue. Simple!\n\n\nThe Step Function\nGLSL also provides step(edge, x) which returns \\(0\\) if \\(x &lt; \\text{edge}\\) and \\(1\\) otherwise. This is useful for writing cleaner code without explicit conditionals:\nfloat s = step(0.0, p.x);  // 0 on left, 1 on right\nvec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\nHere mix(a, b, t) performs linear interpolation: \\((1-t)a + tb\\). So when s = 0 we get pure red, when s = 1 we get pure blue.\n\n\n\n\n\n\nWhy use step instead of the ternary operator?\n\n\n\nBoth work fine! The ternary operator ?: is more explicit and familiar if you know C-like languages. But step and mix are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation.\n\n\n\n\nArbitrary Half-Planes\nFor a general line \\(ax + by = 0\\), we just evaluate the corresponding linear function:\nfloat a = 1.0, b = 1.0;\nfloat L = a * p.x + b * p.y;\nvec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\nfragColor = vec4(color, 1.0);\nTry different values of \\(a\\) and \\(b\\) to see different line orientations. The line itself is where \\(L = 0\\), and we’re coloring the two sides differently.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#distance-fields-and-circles",
    "href": "day1.html#distance-fields-and-circles",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.6 Distance Fields and Circles",
    "text": "1.6 Distance Fields and Circles\n\nDistance to Center\nThe distance from a point \\(p = (x, y)\\) to the origin is just the usual Euclidean distance: \\[d = \\|p\\| = \\sqrt{x^2 + y^2}\\]\nIn GLSL this is built-in:\nfloat d = length(p);\nThe length() function computes the Euclidean norm of a vector. It works for vec2, vec3, vec4—whatever you need.\n\n\nFilled Circle\nA circle of radius \\(r\\) centered at the origin is the set \\(\\{p : \\|p\\| &lt; r\\}\\)—just points whose distance from the origin is less than \\(r\\). So to color the inside vs. outside of a circle, we just compare distances:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThat’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle.\n\n\nDistance-Based Coloring\nBut we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:\nfloat d = length(p);\nfloat intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\nintensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\nvec3 color = vec3(intensity);\nfragColor = vec4(color, 1.0);\nThis creates a radial gradient—bright at the center, dark at the edges. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!\n\n\nCircle Outline\nWhat if we want to draw just the boundary of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is approximately equal to the radius. Mathematically, we’re coloring the set \\(\\{p : |d(p) - r| &lt; \\epsilon\\}\\) where \\(\\epsilon\\) is a small thickness parameter:\nfloat d = length(p);\nfloat r = 1.0;\nfloat thickness = 0.05;\n\nfloat circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\nvec3 color = vec3(circle_mask);\nfragColor = vec4(color, 1.0);\nThis draws a thin white annulus around the circle. Play with the thickness parameter to see how it affects the line width!\nFor a smoother, anti-aliased edge, GLSL provides smoothstep:\nfloat circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\nThe smoothstep(a, b, x) function performs smooth Hermite interpolation between \\(a\\) and \\(b\\), transitioning gradually instead of having a hard cutoff. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!\n\n\n\n\n\n\nAnti-aliasing in shaders\n\n\n\nThe harsh cutoffs from using &lt; or the ternary operator create jagged, pixelated edges. Functions like smoothstep give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with smoothstep for smoother results.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#grids-and-repetition",
    "href": "day1.html#grids-and-repetition",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.7 Grids and Repetition",
    "text": "1.7 Grids and Repetition\n\nModular Arithmetic\nThe modulo operation creates periodic repetition. For a period \\(T\\), the function \\(p \\mapsto (p \\bmod T) - T/2\\) maps \\(\\mathbb{R}\\) to \\([-T/2, T/2]\\) repeatedly—it “folds” the entire real line into a finite interval over and over again.\nIn GLSL, mod(x, T) computes \\(x \\bmod T\\). This is one of the most powerful tools in shader programming!\n\n\nCreating a Grid\nTo create a grid of repeated cells, we apply mod to our coordinates:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Now cell_p repeats every spacing units\n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis creates an infinite grid of yellow circles! The coordinate transformation cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0 ensures that cell_p is always in the range \\([-\\text{spacing}/2, \\text{spacing}/2]\\), and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.\n\n\n\n\n\n\nThe power of mod\n\n\n\nThink about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation. This is the kind of efficiency that makes shaders special.\n\n\n\n\nAlternating Pattern\nWe can create checkerboard-like patterns by using the cell index to vary colors. To get the cell index, we divide by the spacing and floor:\nvec2 cell_id = floor(p / spacing);\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\n\nvec3 color_a = vec3(1.0, 0.0, 0.0);\nvec3 color_b = vec3(0.0, 0.0, 1.0);\nvec3 bg_color = mix(color_a, color_b, checker);\nHere floor(p / spacing) gives us integer grid indices \\((i, j)\\), and we alternate colors based on the parity of \\(i + j\\). When \\(i + j\\) is even, checker = 0 (red), when odd, checker = 1 (blue).\n\n\nCombining with Circles\nLet’s put it all together—a grid of circles on an alternating background:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}\nTry varying the spacing and r parameters. What happens if you make the circles larger than the cells? What if you use different spacing values for x and y?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#implicit-curves",
    "href": "day1.html#implicit-curves",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.8 Implicit Curves",
    "text": "1.8 Implicit Curves\n\nGeneral Principle\nAn implicit curve is defined by an equation \\(F(x, y) = 0\\). Points on the curve satisfy the equation exactly, while points off the curve have \\(F(x,y) \\neq 0\\). To render the curve, we compute \\(F(p)\\) for each pixel and color based on proximity to zero:\nfloat F = [some function of p.x and p.y];\nfloat thickness = 0.05;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nvec3 color = mix(background, curve_color, curve_mask);\nThis is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, whatever you want.\n\n\nExample: Parabola\nThe parabola \\(y = x^2\\) can be written implicitly as \\(F(x, y) = y - x^2 = 0\\):\nfloat F = p.y - p.x * p.x;\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n\nvec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\nfragColor = vec4(color, 1.0);\nYou should see a yellow parabola on a dark blue background. The curve appears wherever \\(|F(x,y)| &lt; 0.1\\)—a thin band around the zero set of \\(F\\).\nOne thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker. This is because we’re thresholding on the value of \\(F\\), not the geometric distance to the curve. For perfectly uniform thickness, you’d need to compute the actual signed distance function—something we’ll talk more about on Day 4.\n\n\nExample: Circle (Implicit Form)\nWe’ve been using \\(\\|p\\| &lt; r\\) for filled circles, but we can also write the circle implicitly as \\(x^2 + y^2 - r^2 = 0\\):\nfloat r = 1.0;\nfloat F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nThis is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The dot(p, p) computes \\(x^2 + y^2\\) efficiently.\n\n\n\n\n\n\nImplicit curves in your homework\n\n\n\nWhen you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation \\(F(x,y) = y - (ax^2 + bx + c)\\) and thresholding on \\(|F| &lt; \\epsilon\\). Make sure to test with various values of \\(a\\), \\(b\\), \\(c\\) to ensure your grapher is robust!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#summary",
    "href": "day1.html#summary",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.9 Summary",
    "text": "1.9 Summary\nToday we’ve learned the fundamental tools of shader programming:\n\nShaders as parallel functions: Every pixel evaluates \\(f(x, y, t, \\ldots) \\to \\text{color}\\) simultaneously—no loops required!\nGLSL basics: Syntax, vector types, and built-in functions like length(), step(), and smoothstep()\nCoordinate systems: Centering, normalizing, and scaling for mathematical work\nConditional coloring: Using boolean expressions and step() for discrete color regions\nDistance fields: Using length() to create circles and radial patterns—the foundation for much more complex techniques later\nModular arithmetic: Creating grids and repeating patterns with mod()—infinite complexity with finite computation\nImplicit curves: Rendering curves defined by \\(F(x, y) = 0\\) by thresholding on \\(|F|\\)\n\nWith these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#homework",
    "href": "day1.html#homework",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.10 Homework",
    "text": "1.10 Homework\n\nRequired: Parabola Graphing Calculator\nCreate a shader that draws a customizable parabola \\(y = ax^2 + bx + c\\) along with coordinate axes.\nRequirements:\n\nDefine variables a, b, c at the top of your shader (hardcoded values are fine)\nDraw the \\(x\\)-axis and \\(y\\)-axis as thick lines (use the implicit line technique: \\(|y| &lt; \\epsilon\\) for \\(x\\)-axis, \\(|x| &lt; \\epsilon\\) for \\(y\\)-axis)\nPlot the parabola \\(y = ax^2 + bx + c\\) as a thick curve\nUse distinct colors for axes and parabola\nThe visualization should work for any reasonable values of \\(a\\), \\(b\\), \\(c\\)\n\nSuggested approach:\n// Define parameters\nfloat a = 1.0;\nfloat b = 0.0;\nfloat c = 0.0;\n\n// Axes\nfloat x_axis_mask = abs(p.y) &lt; 0.05 ? 1.0 : 0.0;\nfloat y_axis_mask = abs(p.x) &lt; 0.05 ? 1.0 : 0.0;\n\n// Parabola: F(x,y) = y - (ax² + bx + c) = 0\nfloat F = p.y - (a * p.x * p.x + b * p.x + c);\nfloat parabola_mask = abs(F) &lt; 0.1 ? 1.0 : 0.0;\n\n// Combine\nvec3 color = background;\ncolor = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\ncolor = mix(color, parabola_color, parabola_mask);\nTry different values of \\(a\\), \\(b\\), \\(c\\) and verify your grapher works correctly! What happens with negative \\(a\\)? What about \\(b \\neq 0\\)? Make sure the axes and parabola remain visible for all parameter values you try.\n\n\nOptional #1: Animated Curve Family\nCreate a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build intuition!\nSuggestions:\n\nElliptic fibration: Take a cubic polynomial \\(y^2 = x^3 + ax + b\\) and vary one parameter with iTime. The topology of the curve changes dramatically as you pass through singular values!\nLissajous curves: Parametric curves \\(x = A\\sin(at + \\delta)\\), \\(y = B\\sin(bt)\\). Animate \\(\\delta\\) or the frequency ratio to watch the curve morph through different patterns\nCassini ovals: \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). Vary the parameter and watch the curve transition from two separate loops to a single figure-eight-like shape\n\nUse iTime creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes!\n\n\nOptional #2: Beautiful Tiling Pattern\nDesign an aesthetically pleasing tiling pattern using the mod() technique. This is your chance to be creative!\nRequirements:\n\nCreate a non-trivial pattern within a fundamental domain (a single tile)\nUse mod() to repeat it across the plane\nThe pattern should tile seamlessly (edges should match up)\n\nIdeas:\n\nGeometric patterns: nested circles, polygons, stars\nColor gradients that vary by tile position (using cell_id)\nCombinations of implicit curves within each tile\nSymmetry: use abs() to create reflections within tiles\nDistance-based effects: make circles pulse or fade based on iTime and their position in the grid\n\nChallenge: Can you create a pattern that has different symmetries in different tiles? (For example, alternating rotational symmetry using the checkerboard cell_id technique.) Or a pattern where the colors vary smoothly across the tiling, creating a large-scale gradient effect?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1.html#looking-ahead",
    "href": "day1.html#looking-ahead",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.11 Looking Ahead",
    "text": "1.11 Looking Ahead\nTomorrow we’ll use these techniques to explore complex dynamics (the Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). The coordinate system and implicit curve techniques you’ve learned today will be the foundation for everything to come.\nMake sure you’re comfortable with:\n\nSetting up coordinates (the standard transformation from fragCoord to centered, aspect-corrected p)\nComputing distances and implicit functions\n\nUsing mod() for repetition\nConditionally coloring based on mathematical expressions\n\nIf any of these feel shaky, now is the time to practice! Everything builds on this foundation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day2.html",
    "href": "day2.html",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "2.1 Overview\nToday we explore the power of iteration to generate fractals. We’ll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set. Then we’ll shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We’ll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles, and learn to organize geometric data using structs.\nBy the end of today, you’ll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#complex-numbers-in-glsl",
    "href": "day2.html#complex-numbers-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.2 Complex Numbers in GLSL",
    "text": "2.2 Complex Numbers in GLSL\n\nRepresentation\nA complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). This is actually a completely natural representation—complex numbers are the 2D plane! In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part. This means you can think of complex arithmetic as geometric operations in the plane, which gives great intuition for what’s happening.\n\n\nComplex Arithmetic\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations. Some of these are trivial, others require a bit more work:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nAddition of complex numbers is just vector addition—componentwise! We’re literally adding the real and imaginary parts separately. You might not even need this function since you can just write z + w directly, but it’s here for completeness.\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nThis one requires actually remembering the FOIL pattern and grouping real/imaginary terms. The key is that \\(i^2 = -1\\), which is why we get that minus sign in the real part.\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nThe squared magnitude is just the dot product of the complex number with itself. This is computationally cheaper than taking the square root, so when we just need to check if \\(|z| &gt; 2\\), we’ll check if \\(|z|^2 &gt; 4\\) instead.\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nThe magnitude is the Euclidean distance from the origin—exactly what length() computes!\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nThe conjugate just flips the sign of the imaginary part. Geometrically, this is reflection across the real axis.\nDivision: \\(\\frac{a + bi}{c + di} = \\frac{(a + bi)(c - di)}{c^2 + d^2}\\)\nvec2 cdiv(vec2 z, vec2 w) {\n    float denom = dot(w, w);  // c² + d²\n    return vec2(\n        (z.x * w.x + z.y * w.y) / denom,  // Real part\n        (z.y * w.x - z.x * w.y) / denom   // Imaginary part\n    );\n}\nDivision is the trickiest operation—we multiply numerator and denominator by the conjugate of \\(w\\) to rationalize. The denominator becomes real (\\(c^2 + d^2\\)), and the numerator becomes a new complex number we can compute.\n\n\n\n\n\n\nWhy write helper functions?\n\n\n\nYou might wonder why we’re defining all these functions when we could just inline the formulas. There are a few good reasons:\n\nReadability: cmul(z, z) is much clearer than vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)\nCorrectness: It’s easy to make sign errors in complex arithmetic—writing the function once and testing it is safer\nConsistency: Using the same functions throughout makes the code easier to understand and debug\n\nAs your shaders get more complex, these helper functions will make your life much easier!\n\n\nThese are the building blocks we need for complex dynamics. Let’s put them to work!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#the-mandelbrot-set",
    "href": "day2.html#the-mandelbrot-set",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.3 The Mandelbrot Set",
    "text": "2.3 The Mandelbrot Set\n\nDefinition\nThe Mandelbrot set \\(\\mathcal{M}\\) is one of the most famous objects in mathematics—and for good reason! It’s defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nThat’s it! Just iterate this simple quadratic map starting from \\(z_0 = 0\\), and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.\nIn practice, we can’t iterate to infinity, so we:\n\nStart with \\(z_0 = 0\\)\nIterate \\(z_{n+1} = z_n^2 + c\\) for a fixed number of iterations (say, 100)\nCheck if \\(|z_n|\\) has escaped some large radius (typically \\(R = 2\\))\n\nThere’s a theorem that says if \\(|z_n| &gt; 2\\) for any \\(n\\), then the orbit escapes to infinity. So points that escape quickly are definitely not in \\(\\mathcal{M}\\), while points that remain bounded after many iterations are likely in \\(\\mathcal{M}\\) (or at least, very close to the boundary).\n\n\nBasic Implementation\nLet’s code it up:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\nThat’s the entire Mandelbrot set renderer! Notice how we’re using cabs2 instead of cabs—since we’re just checking if the magnitude exceeds 2, we can check if the squared magnitude exceeds 4, which saves us a square root computation per pixel per iteration.\nThe coordinate scaling is tuned to show the “interesting part” of the Mandelbrot set—the main cardioid and its surrounding bulbs. The set actually extends from about \\(-2.5\\) to \\(0.5\\) on the real axis, so we shift our coordinate system accordingly.\n\n\n\n\n\n\nUnderstanding the iteration\n\n\n\nWhat’s actually happening in that loop? Each pixel represents a complex number \\(c\\), and we’re asking: “If I start at \\(z = 0\\) and repeatedly apply \\(z \\mapsto z^2 + c\\), does the orbit stay bounded?”\nTry adding some debug visualization—color based on the final value of z, or visualize the trajectory somehow. Understanding the dynamics geometrically will help you build intuition for Julia sets (which we’ll do in homework) and other complex dynamical systems.\n\n\n\n\nColoring Schemes\nThe grayscale rendering shows the structure of the set, but it’s not particularly exciting visually. We can do much better! The classic approach is to color based on how quickly points escape:\nSmooth coloring using escape time:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nThis “smooth iteration count” formula eliminates the harsh banding you get from just using integer iteration counts. The math is a bit involved (it comes from the fact that near escape, the magnitude grows roughly exponentially), but the result is smooth, continuous color gradients that look much more professional.\nCreating color palettes:\nNow we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:\nvec3 palette(float t) {\n    // Create a cyclic color palette using cosines\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters a, b, c, d control different aspects of the palette:\n\na and b control the range and center of the colors\nc controls the frequency of color cycling\nd controls the phase offset (shifts the colors)\n\nPlay with these parameters to get different color schemes! Try d = vec3(0.0, 0.1, 0.2) for a more blue-purple palette, or d = vec3(0.3, 0.2, 0.2) for warmer tones.\n\n\n\n\n\n\nThe art of palette design\n\n\n\nCreating good color palettes is part science, part art. The cosine palette is mathematically elegant and gives smooth gradients, but you might want to try other approaches:\n\nHand-picked color stops with interpolation (more control, more work)\nHSV color spaces (easy to create rainbow gradients)\nPerceptually uniform color spaces like LAB (ensures equal perceived color differences)\n\nFor mathematical visualization, the key is that the colors should help reveal structure, not obscure it. High contrast can emphasize boundaries, while smooth gradients show continuous variation in escape time.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#julia-sets",
    "href": "day2.html#julia-sets",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.4 Julia Sets",
    "text": "2.4 Julia Sets\n\nDefinition\nFor a fixed complex parameter \\(c\\), the filled Julia set \\(\\mathcal{K}_c\\) consists of points \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded.\nKey difference from Mandelbrot: Here \\(c\\) is fixed and we vary the initial point \\(z_0\\) (which comes from the pixel position). In Mandelbrot, \\(z_0 = 0\\) and \\(c\\) varies with pixel position.\n\n\nRelationship to Mandelbrot\nThere’s a beautiful connection: the Mandelbrot set is essentially a “parameter space” for Julia sets. Each point \\(c\\) in the complex plane has an associated Julia set \\(\\mathcal{K}_c\\): - If \\(c \\in \\mathcal{M}\\), then \\(\\mathcal{K}_c\\) is connected - If \\(c \\notin \\mathcal{M}\\), then \\(\\mathcal{K}_c\\) is a Cantor dust (totally disconnected)\n\n\nImplementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv * 3.0;  // Initial point z_0 comes from pixel position\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // A classic choice\n    // Try: vec2(-0.4, 0.6), vec2(0.285, 0.01), vec2(-0.8, 0.156)\n    \n    // Iterate z_{n+1} = z_n² + c\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color (same as Mandelbrot)\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    if(iter == max_iter) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nTry different values of \\(c\\) to explore the incredible variety of Julia sets! You can even animate \\(c\\) with time:\nvec2 c = vec2(0.7 * cos(iTime * 0.3), 0.7 * sin(iTime * 0.3));",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#structs-in-glsl",
    "href": "day2.html#structs-in-glsl",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.5 Structs in GLSL",
    "text": "2.5 Structs in GLSL\nBefore we build the Apollonian gasket, we need to talk about organizing our data. We’re about to deal with multiple circles, and passing around center1, radius1, center2, radius2, etc. gets unwieldy fast. GLSL provides structs (just like in C) for grouping related data together.\n\nDefining a Struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nThat’s it! Now Circle is a type we can use just like vec2 or float. Each Circle contains a center position and a radius—exactly the data we need to define a circle.\n\n\nUsing Structs\nCreating and using structs is straightforward:\n// Declare a circle\nCircle c1;\nc1.center = vec2(0.0, 0.0);\nc1.radius = 1.0;\n\n// Or initialize directly\nCircle c2 = Circle(vec2(1.0, 0.5), 0.75);\n\n// Pass to functions\nvec2 invertThroughCircle(vec2 p, Circle circ) {\n    return invertCircle(p, circ.center, circ.radius);\n}\nThe syntax is exactly what you’d expect—use the dot operator to access fields, just like accessing components of a vec2 or vec3.\n\n\nWhy Structs?\nThey make the code dramatically more readable and maintainable. Compare:\n// Without structs - messy!\nvec2 iterateInversions(vec2 p, \n    vec2 c1_center, float c1_radius,\n    vec2 c2_center, float c2_radius,\n    vec2 c3_center, float c3_radius) \n{\n    // ... lots of parameters to keep track of\n}\n\n// With structs - clean!\nvec2 iterateInversions(vec2 p, Circle c1, Circle c2, Circle c3) \n{\n    // Much clearer what we're working with\n}\nFor the Apollonian gasket, we’ll have three circles we need to keep track of and pass around. Structs make this much more manageable!\n\n\n\n\n\n\nStructs vs. arrays\n\n\n\nYou might wonder: why not just use an array of circles? That works too! The choice depends on your needs:\n\nStructs: Better when circles have different roles (like “outer circle” vs “inner circles”)\nArrays: Better when you have many similar circles and want to loop over them\n\nFor the Apollonian gasket, we’ll use individual structs because each circle plays a specific geometric role. In the homework you might try arrays if you’re working with many circles!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#euclidean-triangle-tiling",
    "href": "day2.html#euclidean-triangle-tiling",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.6 Euclidean Triangle Tiling",
    "text": "2.6 Euclidean Triangle Tiling\n\nThe Fundamental Domain\nAn equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can: 1. Reflect across its three edges 2. Repeat this process on the resulting triangles 3. Fill the entire plane with copies of the original triangle\n\n\nSetting Up the Triangle\nLet’s work with an equilateral triangle with vertices at: \\[v_0 = (0, 1), \\quad v_1 = (-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}), \\quad v_2 = (\\frac{\\sqrt{3}}{2}, -\\frac{1}{2})\\]\nThis triangle has side length \\(\\sqrt{3}\\) and is centered at the origin.\n// Define triangle vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866\nvec2 v2 = vec2(0.866, -0.5);\n\n\nReflection Across a Line\nTo reflect a point \\(p\\) across a line through the origin with unit normal \\(\\mathbf{n}\\), we use: \\[p' = p - 2(\\mathbf{n} \\cdot p)\\mathbf{n}\\]\nFor a line through two points (an edge of our triangle), we need to: 1. Compute the perpendicular direction (normal to the edge) 2. Determine which side of the line we’re on 3. Reflect if necessary\nPlaceholder for specific implementation: The exact formulas depend on how we set up our edges. Here’s the structure:\n// Reflect across edge v0-v1\nvec2 edge = v1 - v0;\nvec2 normal = normalize(vec2(-edge.y, edge.x));  // Perpendicular to edge\nfloat dist = dot(p - v0, normal);  // Signed distance to line\nif(dist &lt; 0.0) {\n    p = p - 2.0 * dist * normal;  // Reflect if on wrong side\n}\n\n\nIterative Folding\nThe key insight: we repeatedly reflect \\(p\\) across the three edges of the triangle until it lands inside the fundamental domain.\nvec2 foldToTriangle(vec2 p, int iterations) {\n    // Define the three edges and their normals\n    // [Edge definitions here]\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Reflect across each edge if necessary\n        // [Reflection code for edge 0]\n        // [Reflection code for edge 1]\n        // [Reflection code for edge 2]\n    }\n    \n    return p;\n}\nAfter folding, all points in the plane map to the interior of our triangle. We can then color based on: - The final position within the triangle - The number of reflections needed - Which edge was crossed most recently\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 p = [coordinate setup as usual];\n    \n    // Fold to fundamental domain\n    vec2 p_folded = foldToTriangle(p, 10);\n    \n    // Color based on position in triangle\n    // Could use barycentric coordinates, distance to edges, etc.\n    vec3 color = vec3(p_folded * 0.5 + 0.5, 0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\nNote: The exact implementation requires careful handling of the geometry. The key mathematical ideas are: 1. Reflection formula: \\(p' = p - 2(p \\cdot n)n\\) for a line with normal \\(n\\) through origin 2. Iterative folding brings any point into the fundamental domain 3. Track which reflections occur for interesting coloring",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#sierpinski-triangle-via-folding",
    "href": "day2.html#sierpinski-triangle-via-folding",
    "title": "2  Day 2: Complex Dynamics and Euclidean Geometry",
    "section": "2.7 Sierpinski Triangle via Folding",
    "text": "2.7 Sierpinski Triangle via Folding\n\nThe Concept\nThe Sierpinski triangle is a fractal that can be generated by: 1. Starting with an equilateral triangle 2. Removing the middle triangle (connecting midpoints) 3. Repeating on each remaining sub-triangle\nEquivalently, we can generate it by iterated folding with scaling.\n\n\nFolding Algorithm\nAt each iteration: 1. Reflect \\(p\\) across the three edges of the triangle (fold it inside) 2. Scale toward the center 3. Repeat\nMathematically, after \\(n\\) iterations, we’ve zoomed in by a factor of \\(2^n\\) and applied \\(n\\) reflections.\n\n\nImplementation Sketch\nvec2 sierpinskiFold(vec2 p, int iterations) {\n    // Triangle vertices (equilateral)\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    float scale = 1.0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Reflect across each edge (fold into triangle)\n        // [Reflection code similar to triangle tiling]\n        \n        // After folding, scale and translate\n        p = p * 2.0;  // Zoom in by factor of 2\n        scale *= 2.0;\n        \n        // [Additional centering/translation may be needed]\n    }\n    \n    return p;\n}\n\n\nColoring by Iteration Depth\nWe can track how many times we hit certain conditions during folding:\nint orbit = 0;  // Track some property during iteration\n\nfor(int i = 0; i &lt; max_iter; i++) {\n    // Folding operations\n    \n    // Track orbit behavior\n    if([some condition]) orbit++;\n}\n\n// Color based on orbit count\nfloat t = float(orbit) / float(max_iter);\nvec3 color = palette(t);\nThe specific conditions to track depend on the geometric setup, but typically we color based on: - Which edge we reflected across most recently - How many reflections were needed - Distance from the center after folding\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    // Apply Sierpinski folding\n    vec2 p_folded = sierpinskiFold(p, 8);\n    \n    // Color based on the folded position\n    float d = length(p_folded);\n    vec3 color = d &lt; 0.1 ? vec3(1.0) : vec3(0.0);\n    \n    // OR: color based on iteration behavior\n    // [More sophisticated coloring]\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Sierpinski triangle should emerge as a self-similar fractal pattern!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Euclidean Geometry</span>"
    ]
  },
  {
    "objectID": "day2.html#summary",
    "href": "day2.html#summary",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.7 Summary",
    "text": "2.7 Summary\nToday we’ve explored two powerful iterative processes:\n\nComplex dynamics: The Mandelbrot set emerges from iterating \\(z \\mapsto z^2 + c\\)\n\nImplemented complex arithmetic in GLSL\nEscape-time algorithms and smooth coloring\nThe power of simple quadratic iteration\n\nGeometric dynamics: The Apollonian gasket emerges from iterating circle inversions\n\nCircle inversion as a conformal transformation\nStructs for organizing geometric data\nIterated inversions creating fractal patterns\n\n\nBoth show how incredibly simple rules—a quadratic map, a geometric transformation—can generate infinite complexity through iteration. This is one of the core insights of fractal geometry and dynamical systems!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#homework",
    "href": "day2.html#homework",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.8 Homework",
    "text": "2.8 Homework\n\nRequired: Julia Sets\nThe Julia set is the natural companion to the Mandelbrot set. Instead of varying \\(c\\) and fixing \\(z_0 = 0\\), we fix \\(c\\) and vary \\(z_0\\)!\nThe setup: For a fixed complex number \\(c\\), the Julia set \\(J_c\\) is the set of initial conditions \\(z_0\\) for which the iteration \\(z_{n+1} = z_n^2 + c\\) remains bounded.\nImplementation:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    // The initial z is now the pixel position!\n    vec2 z = p;\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // Classic Julia set parameter\n    \n    // Iterate z_{n+1} = z_n² + c\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on escape time\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    fragColor = vec4(color, 1.0);\n}\nExploration—pick one:\nOption A: Animated parameter space\nAnimate \\(c\\) to explore how the Julia set morphs:\nfloat angle = iTime * 0.3;\nfloat radius = 0.7885;  // Radius in parameter space\nvec2 c = vec2(radius * cos(angle), radius * sin(angle));\nWatch how the Julia set changes as you trace a circle in the complex plane! You’ll see it morph from connected to disconnected, develop tendrils, and create beautiful organic shapes.\nOption B: Mouse-controlled exploration\nTie \\(c\\) to the mouse position:\nvec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;\nmouse_uv.x *= iResolution.x / iResolution.y;\nvec2 c = mouse_uv * 3.0;\nNow you can explore parameter space interactively! Move the mouse around to see different Julia sets. This really helps build intuition for how the Julia set depends on \\(c\\).\nInteresting values to try: - vec2(-0.4, 0.6) - dendrite-like fractal trees - vec2(0.285, 0.01) - beautiful spiral patterns\n- vec2(-0.8, 0.156) - intricate filaments - vec2(-0.7269, 0.1889) - “Douady’s rabbit” (famous Julia set) - vec2(-0.835, -0.2321) - another classic - vec2(-0.70176, -0.3842) - “San Marco dragon”\n\n\nOptional #1: Grid of Julia Sets\nHere’s a beautiful connection: create a grid where each cell shows the Julia set for that value of \\(c\\), and watch the Mandelbrot set emerge!\nThe idea: The Mandelbrot set is a map of Julia set topology—points in \\(\\mathcal{M}\\) have connected Julia sets, points outside have disconnected Julia sets. If we draw a grid of Julia sets, we should see this pattern!\nImplementation strategy:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    // Divide screen into grid cells\n    float grid_size = 8.0;  // 8x8 grid\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;  // Local coordinates within cell\n    \n    // Map cell_id to parameter c\n    vec2 c = (cell_id / grid_size) * 4.0 - vec2(2.5, 2.0);\n    c.x -= 0.5;  // Center on interesting region\n    \n    // Run Julia set iteration with z = cell_p, fixed c\n    vec2 z = cell_p;\n    int max_iter = 50;\n    // [iterate as in Julia set code]\n    \n    // Color\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Optional: draw grid lines\n    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);\n    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a grid of tiny Julia sets, and if you look carefully, you’ll notice that the overall pattern resembles the Mandelbrot set! The cells with connected Julia sets (where you see solid regions) correspond to points in the Mandelbrot set, while cells with disconnected Julia sets (dust-like patterns) are outside.\nThis is one of the most beautiful connections in complex dynamics—the Mandelbrot set is literally a map showing which parameters give connected Julia sets!\n\n\nOptional #2: Other Iterated Inversions\nExplore variations on the Apollonian gasket theme! The key is to set up circles in interesting configurations and iterate inversions.\nSimple variations:\nDifferent circle arrangements: - Four circles in a square configuration - Five circles in a pentagonal arrangement\n- Nested circles (one large, several small inside) - Randomly placed circles (use a hash function to generate positions)\nNon-uniform radii:\n// Make circles pulse\nc1.radius = 0.5 + 0.2 * sin(iTime);\nc2.radius = 0.5 + 0.2 * sin(iTime + 2.0 * 3.14159 / 3.0);\nc3.radius = 0.5 + 0.2 * sin(iTime + 4.0 * 3.14159 / 3.0);\nAlternating inversion patterns:\nInstead of inverting through whichever circle contains the point, try alternating in a fixed pattern:\n// Cycle through circles in order\nint circle_index = i % 3;\nif(circle_index == 0) p = invertCircle(p, c1.center, c1.radius);\nelse if(circle_index == 1) p = invertCircle(p, c2.center, c2.radius);\nelse p = invertCircle(p, c3.center, c3.radius);\nThis creates very different patterns—more regular and less “space-filling” than the gasket, but with interesting self-similarity.\nChallenge: Can you create a configuration that tiles the plane with circular patterns? What about one that creates spiraling structures?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#looking-ahead",
    "href": "day2.html#looking-ahead",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.9 Looking Ahead",
    "text": "2.9 Looking Ahead\nTomorrow we’ll continue with geometric tilings! We’ll start in Euclidean space with triangle tilings using reflections, then move to hyperbolic geometry. The circle inversions you’ve learned today are actually hyperbolic isometries—so we’re already doing non-Euclidean geometry without realizing it!\nWe’ll explore multiple models of the hyperbolic plane (upper half-plane, Poincaré disk) and create beautiful tilings with \\((2,3,\\infty)\\) triangles. The same algorithmic ideas (iterated geometric transformations) work in hyperbolic space, but the results are even more intricate because hyperbolic space has “more room” than Euclidean space.\nMake sure you’re comfortable with: - Iteration and escape-time algorithms (we’ll use similar ideas for tiling) - Circle inversion (this becomes reflection in hyperbolic geodesics!) - Structs for organizing data - Coloring strategies based on orbit behavior\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day3.html",
    "href": "day3.html",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "3.1 Overview\nToday we explore geometric tilings through reflection operations. We’ll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.\nThe key insight: the algorithm stays the same across geometries—only the reflection operations change. This mirrors what we saw yesterday with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region.\nBy the end of today, you’ll understand: - How to construct reflections using linear algebra - The folding algorithm for creating tilings - The structure of hyperbolic geometry in the upper half-plane model - How to implement hyperbolic triangle tilings using the same algorithmic pattern - How to convert between different models of hyperbolic space",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#sierpinski-carpet-via-box-folding",
    "href": "day3.html#sierpinski-carpet-via-box-folding",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.2 Sierpinski Carpet via Box Folding",
    "text": "3.2 Sierpinski Carpet via Box Folding\n\nFrom Triangle to Square\nYesterday we created the Sierpinski triangle by folding across the edges of an equilateral triangle. The Sierpinski carpet applies the same principle to a square, using axis-aligned reflections.\n\n\nThe Algorithm\nStarting with a square domain (say \\([-1, 1]^2\\)), we: 1. Fold using abs() to create 4-fold symmetry (map all quadrants to first quadrant) 2. Scale by factor of 3 3. Remove the middle square 4. Repeat\nAfter \\(n\\) iterations, we’ve subdivided the square into a \\(3^n \\times 3^n\\) grid and removed all middle squares at every scale.\n\n\nImplementation\nvec2 sierpinskiCarpetFold(vec2 p, int iterations, out int removed) {\n    removed = 0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Scale by 3, shift to center\n        p = p * 3.0 - vec2(1.0);\n        \n        // Check if we're in the middle square (to be removed)\n        // After scaling and shifting, the middle square is roughly centered\n        if(abs(p.x) &lt; 1.0 && abs(p.y) &lt; 1.0) {\n            removed = 1;\n        }\n    }\n    \n    return p;\n}\nNote: The exact check for “removed” regions depends on the coordinate setup. After the transformation p * 3.0 - 1.0, we’re centering each sub-square. The middle third is the region we’re removing.\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = [coordinate setup];\n    \n    int removed;\n    vec2 p_folded = sierpinskiCarpetFold(p, 6, removed);\n    \n    vec3 color = removed == 1 ? vec3(0.0) : vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nThe characteristic Sierpinski carpet should emerge: a square with self-similar removed regions at all scales.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#hyperbolic-geometry-models-and-metrics",
    "href": "day3.html#hyperbolic-geometry-models-and-metrics",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.3 Hyperbolic Geometry: Models and Metrics",
    "text": "3.3 Hyperbolic Geometry: Models and Metrics\n\nThe Upper Half-Plane Model\nThe upper half-plane model \\(\\mathbb{H}^2\\) consists of complex numbers with positive imaginary part: \\[\\mathbb{H}^2 = \\{z \\in \\mathbb{C} : \\text{Im}(z) &gt; 0\\}\\]\nThe hyperbolic metric is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2} = \\frac{|dz|^2}{(\\text{Im}(z))^2}\\]\nThis metric “blows up” as we approach the real axis (the boundary at infinity), making the geometry shrink near \\(y = 0\\).\n\n\nGeodesics in the Upper Half-Plane\nGeodesics (hyperbolic “straight lines”) in \\(\\mathbb{H}^2\\) are: 1. Vertical lines \\(\\{x = c\\}\\) for constant \\(c\\) 2. Semicircles centered on the real axis, perpendicular to it\nFor a semicircle of radius \\(R\\) centered at \\((c, 0)\\), the equation is: \\[(x - c)^2 + y^2 = R^2, \\quad y &gt; 0\\]\n\n\nHyperbolic Distance\nThe distance between two points \\(z, w \\in \\mathbb{H}^2\\) is: \\[d(z, w) = \\text{arcosh}\\left(1 + \\frac{|z - w|^2}{2 \\cdot \\text{Im}(z) \\cdot \\text{Im}(w)}\\right)\\]\nIn GLSL:\nfloat hyperbolicDistance(vec2 z, vec2 w) {\n    float diff2 = dot(z - w, z - w);  // |z - w|²\n    float denom = 2.0 * z.y * w.y;    // 2·Im(z)·Im(w)\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // acosh(x) = log(x + sqrt(x²-1))\n}\n\n\nThe Poincaré Disk Model\nThe Poincaré disk model consists of the interior of the unit disk: \\[\\mathbb{D}^2 = \\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\]\nThe metric is: \\[ds^2 = \\frac{4(dx^2 + dy^2)}{(1 - |z|^2)^2}\\]\nGeodesics are circular arcs perpendicular to the unit circle (or diameters).\n\n\nConverting Between Models\nThe Cayley transform maps the upper half-plane to the disk: \\[w = \\frac{z - i}{z + i}\\]\nThe inverse is: \\[z = i\\frac{1 + w}{1 - w}\\]\nIn GLSL (using complex arithmetic from Day 2):\nvec2 uhpToDisk(vec2 z) {\n    // w = (z - i) / (z + i)\n    vec2 numerator = z - vec2(0.0, 1.0);      // z - i\n    vec2 denominator = z + vec2(0.0, 1.0);    // z + i\n    return cdiv(numerator, denominator);\n}\n\nvec2 diskToUHP(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 numerator = vec2(0.0, 1.0) + w;      // i + iw  \n    numerator = vec2(-numerator.y, numerator.x);  // Multiply by i\n    vec2 denominator = vec2(1.0, 0.0) - w;    // 1 - w\n    return cdiv(numerator, denominator);\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#the-23-triangle",
    "href": "day3.html#the-23-triangle",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.4 The (2,3,∞) Triangle",
    "text": "3.4 The (2,3,∞) Triangle\n\nWhy This Triangle?\nThe \\((2, 3, \\infty)\\) triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (the “ideal vertex” at infinity). In the upper half-plane, this triangle has particularly nice edges: - One edge is the unit semicircle centered at the origin: \\(x^2 + y^2 = 1\\), \\(y &gt; 0\\) - Two edges are vertical lines at \\(x = \\pm c\\) for some constant \\(c\\)\nFor the \\((2,3,\\infty)\\) triangle, with the right angle at the origin and the \\(\\pi/3\\) angles at the two vertical edges, we have \\(c = \\sqrt{3}\\) (this can be derived from hyperbolic trigonometry, but we’ll just use it).\nActually, a cleaner setup: let’s use the triangle with: - Geodesic from \\(-1\\) to \\(1\\) (unit semicircle centered at origin) - Vertical geodesic at \\(x = 1\\) - Vertical geodesic at \\(x = -1\\)\nThis creates a fundamental domain bounded by these three geodesics. The angles where they meet determine the triangle group.\n[Note: Need to work out the exact setup here - which specific triangle gives clean angles? The (2,3,∞) triangle or a different choice like (2,4,∞)? Let me provide the framework and you can adjust the specific parameters.]\n\n\nChecking if a Point is in the Triangle\nFor our triangle with: - Bottom edge: unit semicircle - Left edge: vertical line at \\(x = -1\\) - Right edge: vertical line at \\(x = 1\\)\nbool inTriangle(vec2 p) {\n    // Above the semicircle: x² + y² &gt; 1\n    bool aboveSemicircle = dot(p, p) &gt; 1.0;\n    \n    // Between vertical lines: -1 &lt; x &lt; 1\n    bool betweenLines = (p.x &gt; -1.0) && (p.x &lt; 1.0);\n    \n    return aboveSemicircle && betweenLines;\n}\n\n\nReflection Across Geodesics\nReflection across a vertical line \\(x = c\\): \\[\\text{reflect}(x + iy) = (2c - x) + iy\\]\nvec2 reflectVertical(vec2 p, float c) {\n    return vec2(2.0 * c - p.x, p.y);\n}\nReflection across the unit semicircle (circle inversion from yesterday!): Circle inversion with respect to a circle of radius \\(R\\) centered at \\((c_x, c_y)\\) is: \\[\\text{inv}(p) = c + R^2 \\frac{p - c}{|p - c|^2}\\]\nFor our unit circle centered at origin:\nvec2 reflectCircle(vec2 p) {\n    return p / dot(p, p);  // Inversion through unit circle\n}\n\n\nFolding into the Fundamental Domain\nvec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        bool folded = false;\n        \n        // Reflect across left vertical line if needed\n        if(p.x &lt; -1.0) {\n            p = reflectVertical(p, -1.0);\n            folded = true;\n        }\n        \n        // Reflect across right vertical line if needed\n        if(p.x &gt; 1.0) {\n            p = reflectVertical(p, 1.0);\n            folded = true;\n        }\n        \n        // Reflect across semicircle if needed\n        if(dot(p, p) &lt; 1.0) {\n            p = reflectCircle(p);\n            folded = true;\n        }\n        \n        if(folded) foldCount++;\n        else break;  // In fundamental domain\n    }\n    \n    return p;\n}\n\n\nVisualization: Hyperbolic Tiling\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to upper half-plane\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;  // Scale to see interesting region\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Map to upper half-plane (shift up so y &gt; 0)\n    vec2 p = uv + vec2(0.0, 1.5);  // Ensure we're above real axis\n    \n    // Fold to fundamental domain\n    int foldCount;\n    vec2 p_folded = foldToTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);  // Use palette function from Day 2\n    \n    // If we're in the fundamental triangle, use different color\n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result should be a beautiful hyperbolic tiling - the plane tessellated by copies of our fundamental triangle!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#visualizing-in-the-poincaré-disk",
    "href": "day3.html#visualizing-in-the-poincaré-disk",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.5 Visualizing in the Poincaré Disk",
    "text": "3.5 Visualizing in the Poincaré Disk\nNow we’ll see the same tiling in a different model by converting coordinates.\n\nBy Precomposition\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Only render inside unit disk\n    if(length(uv) &gt;= 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 p = diskToUHP(uv);\n    \n    // Now do all computations in UHP\n    int foldCount;\n    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);\n    \n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe tiling now appears in the Poincaré disk—the same mathematical object displayed in a different model!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#distance-to-geodesics",
    "href": "day3.html#distance-to-geodesics",
    "title": "3  Day 3: Fractals and Hyperbolic Geometry",
    "section": "3.6 Distance to Geodesics",
    "text": "3.6 Distance to Geodesics\nFor homework, you’ll want to draw geodesic boundaries. Here’s the framework:\n\nDistance to a Vertical Geodesic\nFor a vertical line \\(x = c\\), the hyperbolic distance from a point \\((x, y)\\) to the line is: \\[d = \\text{arcosh}\\left(\\frac{|x - c|}{\\text{some formula involving } y}\\right)\\]\n[Placeholder: exact formula for distance to vertical geodesic]\n\n\nDistance to a Semicircular Geodesic\nFor a semicircle of radius \\(R\\) centered at \\((c, 0)\\), the distance calculation is more involved. One approach: 1. Find the closest point on the semicircle to \\(p\\) 2. Compute hyperbolic distance between \\(p\\) and that closest point\n[Placeholder: geodesic distance formula or algorithm]\nAlternatively, you can find formulas in hyperbolic geometry references, or derive them from the metric.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Fractals and Hyperbolic Geometry</span>"
    ]
  },
  {
    "objectID": "day3.html#summary",
    "href": "day3.html#summary",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.4 Summary",
    "text": "3.4 Summary\nToday we learned:\n\nThe folding algorithm: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry\nHalf-space structure: Boundary + side gives a unified way to encode regions in Euclidean geometry\nHyperbolic geometry: Negative curvature space with two types of geodesics (vertical lines and semicircles)\nTwo reflection functions: reflectIntoVertical and reflectIntoCircular parallel the Euclidean reflectInto\nConnection to Day 2: Same algorithmic pattern as Apollonian gasket—iterate a transformation to move into desired region\nMultiple models: Converting between upper half-plane and Poincaré disk using the Cayley transform\n\nKey insight: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#homework",
    "href": "day3.html#homework",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.5 Homework",
    "text": "3.5 Homework\n\nRequired #1: Euclidean Triangle Tiling with Edges and Vertices\nGoal: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.\nTasks:\n\nImplement distance to a half-space:\n\n   float distToHalfSpace(vec2 p, HalfSpace hs) {\n       return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n   }\n\nDraw the triangle edges: Use the distance function to draw white lines along the three edges of your triangle.\nDraw the triangle vertices: Compute the vertices of your equilateral triangle and draw small circles at these locations. Use Euclidean distance: length(p - vertex) &lt; 0.05.\nCreate an attractive color scheme: Color tiles based on fold count, parity, or distance to edges. Make it visually appealing!\n\nExpected output: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.\nBonus: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.\n\n\n\nRequired #2: Hyperbolic Triangle Tiling with Edges and Vertices\nGoal: Create a beautiful hyperbolic triangle tiling with visible structure.\nTasks:\n\nImplement hyperbolic distance functions:\nDistance between two points:\nfloat hyperbolicDistance(vec2 z, vec2 w) {\n    float diff2 = dot(z - w, z - w);\n    float denom = 2.0 * z.y * w.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\nDistance to vertical geodesic:\nfloat distToVertical(vec2 z, float c) {\n    z.x -= c;\n    float secTheta = length(z) / abs(z.y);\n    return acosh(secTheta);\n}\nDistance to circular geodesic: Use a Möbius transformation to map the geodesic to a vertical line, then measure distance:\nvec2 applyMobius(vec4 mob, vec2 z) {\n    float a = mob.x, b = mob.y, c = mob.z, d = mob.w;\n    vec2 num = vec2(a, 0.0) * z + vec2(b, 0.0);\n    vec2 den = vec2(c, 0.0) * z + vec2(d, 0.0);\n    return cdiv(num, den);\n}\n\nfloat distToCircularGeodesic(vec2 z, float p, float q) {\n    vec4 mob = vec4(1.0, -p, 1.0, -q);\n    vec2 w = applyMobius(mob, z);\n    return distToVertical(w, 0.0);\n}\nDraw geodesic edges: Use these distance functions to draw the three edges of your (2,3,∞) triangle:\n\n   float d1 = distToVertical(z, -1.0);\n   float d2 = distToVertical(z, 1.0);\n   float d3 = distToCircularGeodesic(z, -1.0, 1.0);\n   float edgeDist = min(d1, min(d2, d3));\n   \n   if(edgeDist &lt; 0.02) {\n       color = vec3(1.0);  // White edges\n   }\n\nDraw vertices: The finite vertices are at approximately \\((-1, 0)\\) and \\((1, 0)\\) on the real axis (actually infinitesimally above). Draw small hyperbolic disks around these points:\n\n   float d1 = hyperbolicDistance(z, vec2(-1.0, 0.01));\n   float d2 = hyperbolicDistance(z, vec2(1.0, 0.01));\n   if(d1 &lt; 0.1 || d2 &lt; 0.1) {\n       color = vec3(1.0, 1.0, 0.0);  // Yellow vertices\n   }\n\nCreate an attractive color scheme: Make it beautiful!\n\nExpected output: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.\nBonus: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.\n\n\n\nRequired #3: Model Conversions\nGoal: See the same tiling in different representations of hyperbolic space.\nTasks:\n\nPoincaré Disk (already provided in lecture): Verify it works with your tiling code.\nKlein Model: Implement the transformation from Poincaré disk: \\[w = \\frac{2z}{1 + |z|^2}\\]\n\n   vec2 diskToKlein(vec2 z) {\n       float denom = 1.0 + dot(z, z);\n       return 2.0 * z / denom;\n   }\nIn the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.\n\nBand Model (Optional): The transformation \\(w = \\tanh(z)\\) from Poincaré disk represents hyperbolic space as an infinite horizontal strip. Implement this and see how your tiling appears.\n\nDeliverable: Show your (2,3,∞) tiling in at least the Poincaré disk and Klein model. Discuss what you observe about how the tiling appears in each model.\n\n\n\nRequired #4: Different Triangle Groups\nGoal: Explore other hyperbolic tilings by implementing different triangle groups.\nThe Challenge: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.\nSuggested triangles to try: - (2, 3, 7): Creates Escher-like tilings with 7-fold symmetry—the most famous hyperbolic tiling - (2, 4, 6): Different symmetry pattern - (3, 3, 3): Equilateral hyperbolic triangle - (2, 5, 10): Pentagonal patterns\nApproach:\nThe notation \\((p, q, r)\\) means angles \\(\\pi/p\\), \\(\\pi/q\\), and \\(\\pi/r\\) at the three vertices.\nStart with two geodesics in nice positions (e.g., a vertical line at \\(x = c\\) and the imaginary axis). Now find the third geodesic such that: - It meets the first at angle \\(\\pi/p\\) - It meets the second at angle \\(\\pi/q\\) - The angle at the third vertex is \\(\\pi/r\\)\nUse the hyperbolic law of cosines for side lengths. If the side opposite angle \\(\\gamma\\) has length \\(s_\\gamma\\): \\[\\cosh(s_\\gamma) = \\frac{\\cos(\\gamma) + \\cos(\\alpha)\\cos(\\beta)}{\\sin(\\alpha)\\sin(\\beta)}\\]\nFor angles \\(\\alpha = \\pi/p\\), \\(\\beta = \\pi/q\\), \\(\\gamma = \\pi/r\\), this gives you the hyperbolic side length. Then translate this into Euclidean coordinates for the third geodesic.\nReference structure:\n// Hyperbolic side length opposite angle r:\nfloat num = cos(PI/r) + cos(PI/p) * cos(PI/q);\nfloat denom = sin(PI/p) * sin(PI/q);\nfloat sr = acosh(num / denom);\n\n// Convert hyperbolic length to Euclidean position\n// (This requires careful geometric work!)\nfloat eucH = sin(PI/p) * exp(sr);\nfloat want = eucH / tan(PI/q);\n// ... compute geodesic endpoints\nDeliverable: Working tilings for at least two different \\((p,q,r)\\) groups. Include screenshots showing the different symmetry structures. Document any interesting observations about how the tilings differ.\n\n\n\nOptional Exercise: Unified Abstractions\nPart 1: Unified HalfSpace Struct\nCreate a struct that handles BOTH Euclidean and hyperbolic half-spaces:\nstruct HalfSpace {\n    int type;  // 0=Euclidean line, 1=vertical hyperbolic, 2=circular hyperbolic\n    // Parameters for all cases\n    float a, b, c, side;  // Euclidean line\n    float x_pos;          // Vertical hyperbolic\n    float p, q;           // Circular hyperbolic\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    if(hs.type == 0) {\n        // Euclidean reflection (your existing code)\n    } else if(hs.type == 1) {\n        // Vertical hyperbolic reflection\n    } else {\n        // Circular hyperbolic reflection\n    }\n}\nPart 2: Triangle Struct\nOnce you have a unified HalfSpace, create:\nstruct Triangle {\n    HalfSpace a, b, c;\n};\n\nvec2 reflectInto(vec2 p, Triangle T) {\n    p = reflectInto(p, T.a);\n    p = reflectInto(p, T.b);\n    p = reflectInto(p, T.c);\n    return p;\n}\nNow your folding loop is just p = reflectInto(p, T) for ANY geometry—Euclidean or hyperbolic!\nGoal: This exercise teaches abstraction and code organization. You’re building a single interface that works across multiple geometries, which is exactly how mathematical software should be structured.\n\n\n\nOptional: Decorated Tiles\nAdd patterns within the fundamental domain (Escher-style):\nIdeas: - Draw curves using distance from edges - Create radial patterns from vertices - Use hyperbolic distance to create concentric patterns - The pattern repeats automatically via reflections!\nChallenge: Create a tessellation that looks like Escher’s Circle Limit prints—fish or angels that tile the hyperbolic plane!\n\n\n\nOptional: Pentagon Tilings\nRight-angled pentagons can tile hyperbolic space (impossible in Euclidean geometry!).\nSetup: Create five geodesics that all meet their neighbors at right angles and enclose a bounded region.\nChallenge: Computing geodesic positions given side lengths is complex. Start with a vertical line and a semicircle at right angles, then add three more geodesics using the constraint that adjacent geodesics meet orthogonally.\nReward: Pentagons give very different aesthetic patterns than triangles!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#looking-ahead",
    "href": "day3.html#looking-ahead",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.8 Looking Ahead",
    "text": "3.8 Looking Ahead\nTomorrow we move to 3D! We’ll learn raymarching and signed distance functions to render implicit surfaces. The geometric intuition from reflections and distance computations will carry over, but now in three dimensions with lighting and shading.\nMake sure you’re comfortable with: - Reflection operations (these generalize to 3D) - Distance computations (both Euclidean and hyperbolic) - Iterative algorithms for geometric structures - Working with different coordinate systems/models\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day4.html",
    "href": "day4.html",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "4.1 Overview\nToday we enter the third dimension! We’ll learn how to cast rays from a camera and test for intersections with 3D objects. We’ll start with analytical methods (solving equations directly) for spheres and tori, then transition to raymarching with signed distance functions—a more flexible approach that enables complex procedural scenes.\nBy the end of today, you’ll understand: - How to set up a camera and generate rays for each pixel - Analytical ray-object intersection for simple surfaces - Why analytical methods become challenging for complex geometry - Signed distance functions as an alternative representation - The raymarching algorithm (sphere tracing) - How to compose multiple objects and assign materials",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#camera-and-ray-setup",
    "href": "day4.html#camera-and-ray-setup",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.2 Camera and Ray Setup",
    "text": "4.2 Camera and Ray Setup\n\nThe Rendering Equation (Simplified)\nFor each pixel, we need to: 1. Determine which ray in 3D space corresponds to that pixel 2. Find where (if anywhere) the ray intersects scene geometry 3. Compute the color based on surface properties and lighting\n\n\nCoordinate System\nWe’ll use the Three.js convention: - Y-axis points up - Z-axis points toward the camera (out of the screen) - X-axis points right - This is a right-handed coordinate system\n\n\nCamera Model\nWe’ll use a simple pinhole camera model: - Camera positioned at the origin (for now) - Looking down the -Z axis - Field of view (FOV) determines the viewing frustum\n\n\nRay Generation\nFor a pixel at normalized coordinates \\((u, v) \\in [-1, 1]^2\\), we generate a ray with: - Origin: \\(\\mathbf{o} = (0, 0, 0)\\) (camera position) - Direction: \\(\\mathbf{d} = \\text{normalize}(u \\cdot \\text{right}, v \\cdot \\text{up}, -\\text{focal length})\\)\nThe focal length relates to field of view: for FOV angle \\(\\theta\\), we have \\(\\text{focal length} = 1 / \\tan(\\theta/2)\\).\n\n\nImplementation\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nRay getRay(vec2 fragCoord, vec2 resolution, float fov) {\n    // Normalize to [-1, 1]\n    vec2 uv = (fragCoord / resolution) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= resolution.x / resolution.y;\n    \n    // Compute focal length from FOV\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    // Ray from origin through pixel\n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.direction = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    return ray;\n}\n\n\nPoints Along a Ray\nA parametric ray can be written as: \\[\\mathbf{L}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(\\mathbf{o}\\) is the origin, \\(\\mathbf{d}\\) is the direction, and \\(t \\geq 0\\) is the parameter.\nvec3 rayPoint(Ray ray, float t) {\n    return ray.origin + t * ray.direction;\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#analytical-ray-sphere-intersection",
    "href": "day4.html#analytical-ray-sphere-intersection",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.3 Analytical Ray-Sphere Intersection",
    "text": "4.3 Analytical Ray-Sphere Intersection\n\nThe Sphere Equation\nA sphere of radius \\(r\\) centered at the origin is defined implicitly by: \\[x^2 + y^2 + z^2 = r^2\\]\nOr more compactly: \\(|\\mathbf{p}|^2 = r^2\\) for points \\(\\mathbf{p}\\) on the surface.\n\n\nSetting Up the Intersection\nWe want to find where the ray \\(\\mathbf{L}(t) = \\mathbf{o} + t\\mathbf{d}\\) intersects the sphere. Substituting the ray equation into the sphere equation: \\[|\\mathbf{o} + t\\mathbf{d}|^2 = r^2\\]\nExpanding: \\[(\\mathbf{o} + t\\mathbf{d}) \\cdot (\\mathbf{o} + t\\mathbf{d}) = r^2\\] \\[|\\mathbf{o}|^2 + 2t(\\mathbf{o} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nThis is a quadratic equation in \\(t\\): \\[at^2 + bt + c = 0\\]\nwhere: - \\(a = |\\mathbf{d}|^2\\) (which is 1 if \\(\\mathbf{d}\\) is normalized) - \\(b = 2(\\mathbf{o} \\cdot \\mathbf{d})\\) - \\(c = |\\mathbf{o}|^2 - r^2\\)\n\n\nSolving the Quadratic\nThe solutions are: \\[t = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\]\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us: - \\(\\Delta &lt; 0\\): no intersection (ray misses sphere) - \\(\\Delta = 0\\): one intersection (ray is tangent) - \\(\\Delta &gt; 0\\): two intersections (ray enters and exits sphere)\nWe want the smaller positive \\(t\\) (the closer intersection point).\n\n\nImplementation\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 oc = ray.origin - center;  // o - c (sphere center)\n    \n    float a = dot(ray.direction, ray.direction);  // Should be 1 if normalized\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc, oc) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    // Return the closer intersection\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    // Return the closest positive t\n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;  // Behind camera\n}\n\n\nRendering the Sphere\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Sphere parameters\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);  // In front of camera\n    float sphereRadius = 1.0;\n    \n    // Test intersection\n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit the sphere!\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    } else {\n        // Background\n        color = vec3(0.1, 0.1, 0.2);  // Dark blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nResult: You should see a red disk on a blue background. But it looks flat—we can’t see that it’s a sphere!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#adding-lighting-the-surface-normal",
    "href": "day4.html#adding-lighting-the-surface-normal",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.4 Adding Lighting: The Surface Normal",
    "text": "4.4 Adding Lighting: The Surface Normal\n\nComputing the Normal\nFor a sphere centered at \\(\\mathbf{c}\\), the outward normal at a point \\(\\mathbf{p}\\) on the surface is: \\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the vector from the center to the surface point, normalized.\nvec3 sphereNormal(vec3 point, vec3 center, float radius) {\n    return (point - center) / radius;\n}\n\n\nDiffuse Lighting\nThe simplest lighting model: Lambertian diffuse shading. The brightness depends on the angle between the surface normal \\(\\mathbf{n}\\) and the light direction \\(\\mathbf{l}\\): \\[\\text{brightness} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max(0, \\cdots)\\) ensures we don’t get negative light (surfaces facing away from the light are dark).\n\n\nImplementation with Lighting\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute intersection point\n        vec3 hitPoint = rayPoint(ray, t);\n        \n        // Compute normal\n        vec3 normal = sphereNormal(hitPoint, sphereCenter, sphereRadius);\n        \n        // Light direction (fixed, from above and to the right)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        \n        // Diffuse lighting\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Color the sphere\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);  // Red\n        color = sphereColor * diffuse;\n        \n        // Add a bit of ambient light so dark side isn't completely black\n        color += sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nResult: Now the sphere looks 3D! The lighting reveals its curvature.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#ray-torus-intersection",
    "href": "day4.html#ray-torus-intersection",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.5 Ray-Torus Intersection",
    "text": "4.5 Ray-Torus Intersection\n\nThe Torus Equation\nA torus with major radius \\(R\\) (center to tube center) and minor radius \\(r\\) (tube radius) centered at the origin with axis along the Y-axis has the implicit equation: \\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nOr equivalently: \\[\\left(|\\mathbf{p}_{xz}| - R\\right)^2 + p_y^2 = r^2\\]\nwhere \\(\\mathbf{p}_{xz} = (p_x, p_z)\\) is the projection onto the XZ-plane.\n\n\nComputing the Gradient (Normal)\nThe gradient of the implicit function \\(F(x, y, z) = \\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 - r^2\\) gives the normal direction.\nLet \\(q = \\sqrt{x^2 + z^2}\\). Then:\n\\[\\frac{\\partial F}{\\partial x} = 2\\left(q - R\\right) \\cdot \\frac{x}{q}\\]\n\\[\\frac{\\partial F}{\\partial y} = 2y\\]\n\\[\\frac{\\partial F}{\\partial z} = 2\\left(q - R\\right) \\cdot \\frac{z}{q}\\]\nThe normal is: \\[\\mathbf{n} = \\nabla F = \\left(\\frac{\\partial F}{\\partial x}, \\frac{\\partial F}{\\partial y}, \\frac{\\partial F}{\\partial z}\\right)\\]\nnormalized to unit length.\n\n\nImplementation\nvec3 torusNormal(vec3 p, float majorRadius, float minorRadius) {\n    // Project to XZ plane\n    vec2 pxz = vec2(p.x, p.z);\n    float q = length(pxz);\n    \n    // Gradient components\n    float factor = q - majorRadius;\n    vec3 grad;\n    grad.x = 2.0 * factor * p.x / q;\n    grad.y = 2.0 * p.y;\n    grad.z = 2.0 * factor * p.z / q;\n    \n    return normalize(grad);\n}\n\n\nFinding the Intersection\nFinding the exact intersection between a ray and a torus requires solving a quartic equation (degree 4 polynomial). This is algebraically messy!\nWe can: 1. Use a numerical root-finding method (Newton’s method, bisection) 2. Or… use a different approach (foreshadowing: raymarching!)\nFor now, let’s implement a simple bisection method to find the intersection:\nfloat torusImplicit(vec3 p, float R, float r) {\n    vec2 pxz = vec2(p.x, p.z);\n    float q = length(pxz) - R;\n    return q * q + p.y * p.y - r * r;\n}\n\nfloat intersectTorus(Ray ray, float majorRadius, float minorRadius) {\n    // Bisection method to find root of F(ray(t)) = 0\n    float tMin = 0.0;\n    float tMax = 10.0;  // Search range\n    \n    // Check if there's a sign change (indicating a root exists)\n    float fMin = torusImplicit(rayPoint(ray, tMin), majorRadius, minorRadius);\n    float fMax = torusImplicit(rayPoint(ray, tMax), majorRadius, minorRadius);\n    \n    if (fMin * fMax &gt; 0.0) {\n        return -1.0;  // No intersection in range\n    }\n    \n    // Bisection\n    for (int i = 0; i &lt; 50; i++) {\n        float tMid = (tMin + tMax) / 2.0;\n        float fMid = torusImplicit(rayPoint(ray, tMid), majorRadius, minorRadius);\n        \n        if (abs(fMid) &lt; 0.001) {\n            return tMid;  // Found intersection\n        }\n        \n        if (fMin * fMid &lt; 0.0) {\n            tMax = tMid;\n            fMax = fMid;\n        } else {\n            tMin = tMid;\n            fMin = fMid;\n        }\n    }\n    \n    return (tMin + tMax) / 2.0;  // Best estimate\n}\n\n\nRendering the Torus\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Torus parameters\n    float majorRadius = 1.5;\n    float minorRadius = 0.5;\n    vec3 torusCenter = vec3(0.0, 0.0, -4.0);\n    \n    // Adjust ray for torus center (translate)\n    Ray torusRay = ray;\n    torusRay.origin = ray.origin - torusCenter;\n    \n    float t = intersectTorus(torusRay, majorRadius, minorRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = rayPoint(torusRay, t);\n        vec3 normal = torusNormal(hitPoint, majorRadius, minorRadius);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = torusColor * diffuse + torusColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nResult: A beautiful cyan torus with proper 3D lighting!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#motivation-for-raymarching",
    "href": "day4.html#motivation-for-raymarching",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.6 Motivation for Raymarching",
    "text": "4.6 Motivation for Raymarching\n\nThe Problem with Analytical Methods\nNotice what we had to do: - Sphere: Solve a quadratic equation (manageable) - Torus: Solve a quartic equation (we used bisection instead) - Arbitrary implicit surface: Could be any degree polynomial, or transcendental!\nMoreover, combining objects is difficult: - How do we render two spheres? Check each separately, take the closer one. - How do we render the union of a sphere and torus? Check both, take closer. - How do we render the intersection (only where both objects exist)? Much harder! - How about smooth blending between objects? Nearly impossible analytically.\nWe need a more flexible approach that works for: - Arbitrary implicit surfaces - Complex compositions of objects - Procedurally defined geometry\nEnter: Raymarching with Signed Distance Functions",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#signed-distance-functions-sdfs",
    "href": "day4.html#signed-distance-functions-sdfs",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.7 Signed Distance Functions (SDFs)",
    "text": "4.7 Signed Distance Functions (SDFs)\n\nDefinition\nA signed distance function \\(d: \\mathbb{R}^3 \\to \\mathbb{R}\\) gives the distance from any point in space to the closest point on a surface: - \\(d(\\mathbf{p}) &gt; 0\\) if \\(\\mathbf{p}\\) is outside the surface - \\(d(\\mathbf{p}) = 0\\) if \\(\\mathbf{p}\\) is on the surface - \\(d(\\mathbf{p}) &lt; 0\\) if \\(\\mathbf{p}\\) is inside the surface\nImportantly, \\(|d(\\mathbf{p})|\\) is the actual Euclidean distance to the surface.\n\n\nWhy SDFs?\nSDFs have a crucial property: if we’re at a point \\(\\mathbf{p}\\) and the nearest surface is distance \\(d\\) away, we can safely move \\(d\\) units along any direction without hitting anything.\nThis enables sphere tracing: we march along the ray, taking steps proportional to the SDF value, guaranteed not to overshoot the surface.\n\n\nSDF for a Sphere\nFor a sphere of radius \\(r\\) centered at \\(\\mathbf{c}\\): \\[d(\\mathbf{p}) = |\\mathbf{p} - \\mathbf{c}| - r\\]\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n\nSDF for a Box\nFor an axis-aligned box centered at the origin with half-extents \\(\\mathbf{b} = (b_x, b_y, b_z)\\):\nfloat sdBox(vec3 p, vec3 center, vec3 halfExtents) {\n    vec3 q = abs(p - center) - halfExtents;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n(This formula handles both inside and outside the box correctly.)\n\n\nSDF for a Plane\nFor an infinite plane with normal \\(\\mathbf{n}\\) (unit vector) passing through point \\(\\mathbf{p}_0\\): \\[d(\\mathbf{p}) = (\\mathbf{p} - \\mathbf{p}_0) \\cdot \\mathbf{n}\\]\nfloat sdPlane(vec3 p, vec3 planePoint, vec3 normal) {\n    return dot(p - planePoint, normal);\n}\nFor the XZ-plane (Y = 0):\nfloat sdPlaneY(vec3 p, float height) {\n    return p.y - height;\n}\n\n\nSDF for a Torus\nFor a torus with major radius \\(R\\) and minor radius \\(r\\), axis along Y:\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\n\nOther Primitives\nMany more SDFs exist! Cylinders, capsules, cones, ellipsoids, etc. See resources like Inigo Quilez’s SDF functions.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#the-raymarching-algorithm",
    "href": "day4.html#the-raymarching-algorithm",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.8 The Raymarching Algorithm",
    "text": "4.8 The Raymarching Algorithm\n\nSphere Tracing\nThe algorithm: 1. Start at the ray origin 2. Evaluate the SDF at the current point 3. March forward along the ray by that distance 4. Repeat until: - We’re very close to the surface (SDF ≈ 0) → hit! - We’ve marched too far → miss - We’ve taken too many steps → give up\nstruct HitInfo {\n    bool hit;\n    float t;        // Distance along ray\n    vec3 position;  // Hit position\n};\n\nHitInfo raymarch(Ray ray, float maxDist, int maxSteps) {\n    HitInfo info;\n    info.hit = false;\n    \n    float t = 0.0;\n    \n    for (int i = 0; i &lt; maxSteps; i++) {\n        vec3 pos = rayPoint(ray, t);\n        \n        // Evaluate scene SDF (define this based on your scene)\n        float d = sceneSDF(pos);\n        \n        // Close enough to surface?\n        if (abs(d) &lt; 0.001) {\n            info.hit = true;\n            info.t = t;\n            info.position = pos;\n            return info;\n        }\n        \n        // March forward\n        t += d;\n        \n        // Too far?\n        if (t &gt; maxDist) {\n            break;\n        }\n    }\n    \n    return info;\n}\n\n\nScene SDF\nFor a scene with multiple objects, we take the minimum distance to any object:\nfloat sceneSDF(vec3 p) {\n    // Sphere at (0, 0, -3)\n    float sphere = sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n    \n    // Ground plane\n    float ground = sdPlaneY(p, -1.0);\n    \n    // Return minimum distance\n    return min(sphere, ground);\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#normal-estimation-via-gradient",
    "href": "day4.html#normal-estimation-via-gradient",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.9 Normal Estimation via Gradient",
    "text": "4.9 Normal Estimation via Gradient\n\nThe Gradient as Normal\nFor an implicit surface \\(F(\\mathbf{p}) = 0\\), the gradient \\(\\nabla F\\) is perpendicular to the surface (it’s the normal direction).\nFor an SDF \\(d(\\mathbf{p})\\), the gradient points away from the surface: \\[\\mathbf{n} = \\nabla d = \\left(\\frac{\\partial d}{\\partial x}, \\frac{\\partial d}{\\partial y}, \\frac{\\partial d}{\\partial z}\\right)\\]\n\n\nFinite Difference Approximation\nWe estimate each partial derivative using finite differences: \\[\\frac{\\partial d}{\\partial x} \\approx \\frac{d(x + \\epsilon, y, z) - d(x - \\epsilon, y, z)}{2\\epsilon}\\]\nand similarly for \\(y\\) and \\(z\\).\n\n\nImplementation\nvec3 estimateNormal(vec3 p, float epsilon) {\n    // Sample SDF at nearby points\n    float dx = sceneSDF(p + vec3(epsilon, 0.0, 0.0)) - sceneSDF(p - vec3(epsilon, 0.0, 0.0));\n    float dy = sceneSDF(p + vec3(0.0, epsilon, 0.0)) - sceneSDF(p - vec3(0.0, epsilon, 0.0));\n    float dz = sceneSDF(p + vec3(0.0, 0.0, epsilon)) - sceneSDF(p - vec3(0.0, 0.0, epsilon));\n    \n    return normalize(vec3(dx, dy, dz));\n}\nTypical choice: \\(\\epsilon \\approx 0.001\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#putting-it-all-together-raymarched-scenes",
    "href": "day4.html#putting-it-all-together-raymarched-scenes",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.10 Putting It All Together: Raymarched Scenes",
    "text": "4.10 Putting It All Together: Raymarched Scenes\n\nScene 1: Single Sphere\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    HitInfo hit = raymarch(ray, 100.0, 100);\n    \n    vec3 color;\n    if (hit.hit) {\n        vec3 normal = estimateNormal(hit.position, 0.001);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = vec3(1.0, 0.0, 0.0);\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nScene 2: Two Spheres\nfloat sceneSDF(vec3 p) {\n    float sphere1 = sdSphere(p, vec3(-1.2, 0.0, -3.0), 1.0);\n    float sphere2 = sdSphere(p, vec3(1.2, 0.0, -3.0), 0.8);\n    \n    return min(sphere1, sphere2);\n}\nJust change the scene SDF! The raymarching and lighting code stays the same.\n\n\nScene 3: Sphere and Torus\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(0.0, 1.0, -4.0), 1.0);\n    float torus = sdTorus(p, vec3(0.0, -0.5, -4.0), 1.5, 0.4);\n    \n    return min(sphere, torus);\n}\nDifferent object colors: To color objects differently, we need to track which object was hit. One approach:\n// Return both distance and object ID\nvec2 sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(0.0, 1.0, -4.0), 1.0);\n    float torus = sdTorus(p, vec3(0.0, -0.5, -4.0), 1.5, 0.4);\n    \n    if (sphere &lt; torus) {\n        return vec2(sphere, 1.0);  // ID = 1 for sphere\n    } else {\n        return vec2(torus, 2.0);   // ID = 2 for torus\n    }\n}\n\n// Then in main shader, use the ID to choose color",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#summary",
    "href": "day4.html#summary",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.4 Summary",
    "text": "4.4 Summary\nToday we learned two approaches to 3D rendering:\nAnalytical Ray Tracing: - Solve equations directly for ray-surface intersection - Exact solutions, very efficient for simple geometry - Sphere: straightforward quadratic equation - Torus: complex quartic equation requiring sophisticated algebra - Becomes increasingly difficult for complex surfaces - Standard in production ray tracers for well-defined geometry\nSDF-Based Raymarching: - Represent surfaces as distance fields - March along rays using sphere tracing - Simple, uniform code for any geometry - Easy composition: just take minimum distance - Flexible—works for procedural, implicit, or arbitrary surfaces - Slightly slower than analytical, but much more versatile\nKey Concepts: - Camera setup and ray generation - Parametric ray equation: \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) - Surface normals for lighting - Diffuse (Lambertian) shading - Signed distance functions (SDFs) - Sphere tracing algorithm - Normal estimation via gradient (finite differences) - Material tracking for multiple objects\nTomorrow we’ll explore advanced raymarching: domain operations for infinite repetition, boolean operations for smooth blending, and 3D fractals!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#homework",
    "href": "day4.html#homework",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.5 Homework",
    "text": "4.5 Homework\n\nRequired: Algebraic Variety Rendering\nImplement analytical ray tracing for an interesting polynomial implicit surface.\nGoal: Experience the challenges of analytical methods firsthand, then appreciate SDFs even more!\nSuggested surfaces: - Degree 3: Saddle surfaces, cubic varieties - Degree 4: Klein bottle projections, quartic surfaces with interesting topology - Cassini ovals in 3D: \\((x^2 + y^2 + z^2)^2 - 2a^2(x^2 - y^2) = b^4 - a^4\\)\nImplementation steps:\n\nDefine your implicit function \\(F(x,y,z) = 0\\)\n\nExample—a quartic surface:\nfloat implicitFunction(vec3 p) {\n    float r2 = dot(p, p);\n    return r2 * r2 - (p.x*p.x + p.y*p.y - 2.0*p.z*p.z);\n}\n\nImplement root finding (bisection method)\n\nfloat intersectImplicit(vec3 rayOrigin, vec3 rayDir) {\n    float tMin = 0.0;\n    float tMax = 10.0;\n    \n    // Check for sign change\n    float fMin = implicitFunction(rayOrigin + tMin * rayDir);\n    float fMax = implicitFunction(rayOrigin + tMax * rayDir);\n    \n    if(fMin * fMax &gt; 0.0) return -1.0;  // No root\n    \n    // Bisection\n    for(int i = 0; i &lt; 50; i++) {\n        float tMid = (tMin + tMax) / 2.0;\n        float fMid = implicitFunction(rayOrigin + tMid * rayDir);\n        \n        if(abs(fMid) &lt; 0.001) return tMid;\n        \n        if(fMin * fMid &lt; 0.0) {\n            tMax = tMid;\n            fMax = fMid;\n        } else {\n            tMin = tMid;\n            fMin = fMid;\n        }\n    }\n    \n    return (tMin + tMax) / 2.0;\n}\n\nCompute normal via gradient\n\nvec3 implicitNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = implicitFunction(p + vec3(eps, 0, 0)) - implicitFunction(p - vec3(eps, 0, 0));\n    float dy = implicitFunction(p + vec3(0, eps, 0)) - implicitFunction(p - vec3(0, eps, 0));\n    float dz = implicitFunction(p + vec3(0, 0, eps)) - implicitFunction(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nOptimization: Bounding volume (optional but recommended)\n\nUse a bounding sphere to avoid checking the entire ray:\n// First check if ray intersects bounding sphere\n// Only compute implicit function if inside bounds\nExpected output: A rendered algebraic surface with proper lighting showing its geometric features.\nReflection question: After implementing this, compare the effort to using SDFs. Which approach would you prefer for a complex scene with many objects?\n\n\n\nOptional Exercises\n\n1. Specular Lighting (Phong Model)\nAdd shiny highlights using the Phong reflection model:\n\\[\\text{specular} = (R \\cdot V)^n\\]\nwhere \\(R\\) is reflected light direction, \\(V\\) is view direction, \\(n\\) is shininess.\nvec3 R = reflect(-lightDir, normal);  // Reflected light\nvec3 V = -rayDir;                      // View direction\nfloat spec = pow(max(0.0, dot(R, V)), 32.0);\ncolor += vec3(1.0) * spec * 0.5;  // White specular highlight\nTry different shininess values (8, 16, 32, 64, 128) to see the effect!\n\n\n2. Camera Movement\nImplement an orbiting camera using time:\nfloat angle = iTime * 0.5;\nvec3 rayOrigin = vec3(3.0 * cos(angle), 1.0, 3.0 * sin(angle));\n\n// Look-at matrix\nvec3 target = vec3(0.0, 0.0, -3.0);\nvec3 forward = normalize(target - rayOrigin);\nvec3 right = normalize(cross(vec3(0, 1, 0), forward));\nvec3 up = cross(forward, right);\n\n// Transform ray direction\nvec3 rd = normalize(uv.x * right + uv.y * up + focalLength * forward);\n\n\n3. Complex SDF Scene\nCreate a scene with 5+ objects using different SDFs from Quilez’s library: - Mix primitives: spheres, boxes, cylinders, tori, cones - Position them creatively - Use different materials - Add interesting lighting\n\n\n4. Soft Shadows (Preview of Day 5)\nCast rays from the surface toward the light to check for occlusion:\nfloat softShadow(vec3 pos, vec3 lightDir) {\n    float t = 0.01;  // Start slightly above surface\n    float shadow = 1.0;\n    \n    for(int i = 0; i &lt; 50; i++) {\n        float d = sceneSDF(pos + lightDir * t);\n        shadow = min(shadow, 8.0 * d / t);  // Penumbra factor\n        t += d;\n        if(t &gt; 10.0 || d &lt; 0.001) break;\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\nApply this to your diffuse lighting for more realistic shadows!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#looking-ahead",
    "href": "day4.html#looking-ahead",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.13 Looking Ahead",
    "text": "4.13 Looking Ahead\nTomorrow (Day 5) we’ll explore advanced raymarching techniques: - Domain operations (repetition, symmetry) for creating infinite patterns - Boolean operations (union, intersection, smooth blending) - 3D fractals via iterated folding (Menger sponge) - Creating complex scenes from simple primitives\nYou’ll leave with a toolkit for rendering virtually any geometry you can imagine!\nMake sure you’re comfortable with: - The raymarching algorithm (it’s the foundation for Day 5) - SDF composition (taking min/max for combinations) - Normal estimation via gradients - Basic lighting (diffuse shading)\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day2.html#circle-inversion",
    "href": "day2.html#circle-inversion",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.4 Circle Inversion",
    "text": "2.4 Circle Inversion\nNow we shift from algebraic dynamics (iterating polynomials) to geometric dynamics (iterating transformations). Circle inversion is a beautiful geometric operation that will be the foundation for everything we do for the rest of the week!\n\nMathematical Definition\nCircle inversion is a transformation of the plane with respect to a circle. For a circle of radius \\(R\\) centered at a point \\(\\mathbf{c}\\), inversion maps a point \\(\\mathbf{p} \\neq \\mathbf{c}\\) to: \\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nLet’s understand this formula geometrically. The vector \\(\\mathbf{p} - \\mathbf{c}\\) points from the center to \\(\\mathbf{p}\\). We normalize this direction by dividing by its squared length, then scale by \\(R^2\\), and finally translate back by the center. The result?\n\nPoints inside the circle map to points outside (and vice versa)\nPoints on the circle are fixed (they map to themselves)\nThe closer you are to the center, the farther away you go (and vice versa)\nThe center itself maps to infinity, and infinity maps to the center\n\nHere’s another way to think about it: draw a ray from the center through \\(\\mathbf{p}\\). The inversion of \\(\\mathbf{p}\\) is the unique point on this ray such that the product of distances from the center is \\(R^2\\). If \\(\\mathbf{p}\\) is at distance \\(r\\) from the center, its image is at distance \\(R^2/r\\).\n\n\nKey Properties\nCircle inversion has some remarkable geometric properties that make it incredibly useful:\n\nLines through the center remain lines through the center (they’re just “flipped inside out” along the ray)\nLines not through the center become circles through the center\nCircles through the center become lines (not through the center)\nCircles not through the center remain circles (but with different center and radius)\nAngles are preserved (it’s a conformal map—it preserves angles between curves)\n\nThese properties mean that circle inversion turns geometric complexity into more geometric complexity in very controlled ways. When we iterate inversions through multiple circles, we’ll see beautiful fractal patterns emerge!\n\n\nImplementation\nThe formula translates directly to GLSL:\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);  // squared distance from center\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);  // Map to \"infinity\"\n    \n    return center + (radius * radius) * diff / r2;\n}\nThe only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it’s effectively off-screen.\n\n\nVisualizing Circle Inversion\nLet’s see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Standard coordinate setup, resulting in p]\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);  // Create repeating cells\n    float gridLine = step(0.95, max(grid.x, grid.y));  // Draw grid lines\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle itself (for reference)\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou’ll see straight grid lines transform into beautiful circular arcs! The lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.\nTry animating the circle position or radius to see how the grid deforms. This really helps build intuition for how inversion works!\n\n\n\n\n\n\nExploring circle inversion\n\n\n\nHere are some experiments to try:\n\nMultiple circles: Invert through a grid of circles instead of just one—create cell_p using mod() like in Day 1, then invert each cell independently\nAnimated radius: Make circleRadius = 1.0 + 0.5 * sin(iTime) to watch the grid breathe in and out\nDifferent patterns: Instead of a grid, try drawing circles or other shapes in the inverted space\n\nEach of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#the-apollonian-gasket",
    "href": "day2.html#the-apollonian-gasket",
    "title": "2  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "2.6 The Apollonian Gasket",
    "text": "2.6 The Apollonian Gasket\nNow for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It’s named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles.\n\nSetup: Three Mutually Tangent Circles\nWe start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For simplicity, we’ll use a nice symmetric configuration:\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3) {\n    // A nice symmetric configuration\n    float R = 2.0;  // Outer radius\n    float r = 0.5;  // Inner radius\n    \n    // Three circles arranged in a triangle\n    c1 = Circle(vec2(0.0, R - r), r);\n    c2 = Circle(vec2(-(R - r) * 0.866, -(R - r) * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2((R - r) * 0.866, -(R - r) * 0.5), r);\n}\nThese three circles are positioned at the vertices of an equilateral triangle, all tangent to each other and to a large outer circle (which we could add if we wanted).\n\n\nThe Iteration Algorithm\nThe algorithm is beautifully simple:\n\nStart with a point \\(p\\)\nFor each iteration:\n\nCheck which circles contain \\(p\\)\nIf \\(p\\) is inside a circle, invert through that circle\nRepeat\n\nColor based on the iteration behavior\n\nHere’s the code:\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, \n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check each circle\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        \n        // If we didn't move, we're done\n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\nWe also track which circle we last inverted through (stored in lastCircle) and how many iterations we performed (stored in finalIter). These will be useful for coloring!\n\n\nColoring Strategies\nThere are several interesting ways to color the Apollonian gasket:\nBy iteration count (like the Mandelbrot set):\nfloat t = float(finalIter) / float(maxIter);\nvec3 color = palette(t);\nBy last circle hit:\nvec3 colors[3] = vec3[3](\n    vec3(1.0, 0.0, 0.0),  // Circle 1: red\n    vec3(0.0, 1.0, 0.0),  // Circle 2: green\n    vec3(0.0, 0.0, 1.0)   // Circle 3: blue\n);\nvec3 color = colors[lastCircle];\nBy final distance from circles:\nfloat d1 = abs(length(p - c1.center) - c1.radius);\nfloat d2 = abs(length(p - c2.center) - c2.radius);\nfloat d3 = abs(length(p - c3.center) - c3.radius);\nfloat d = min(d1, min(d2, d3));\nvec3 color = vec3(smoothstep(0.0, 0.05, d));\nEach gives a different view of the fractal structure. The iteration count shows the “depth” of the orbit, the last circle shows the basin of attraction, and the distance shows the geometric structure of the nested circles.\n\n\nPutting It All Together\nHere’s a complete Apollonian gasket renderer:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    // Setup the three circles\n    Circle c1, c2, c3;\n    setupApollonianCircles(c1, c2, c3);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, maxIter, finalIter, lastCircle);\n    \n    // Color by iteration count with palette\n    float t = float(finalIter) / float(maxIter);\n    vec3 color = palette(t);\n    \n    // Draw the three circles themselves for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d = min(d1, min(d2, d3));\n    \n    if(d &lt; 0.02) color = vec3(1.0);  // White circles\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful nested pattern of circles! Zoom in (by scaling p differently) to see the fractal self-similarity—no matter how far you zoom, you’ll keep finding more nested circles.\n\n\n\n\n\n\nThe mathematics of Apollonian gaskets\n\n\n\nThe Apollonian gasket has deep connections to number theory and hyperbolic geometry. If you choose the initial circles carefully (with integer curvatures), all the nested circles will also have integer curvatures—this is the content of the “Descartes Circle Theorem.”\nThe pattern is also related to hyperbolic tilings, which we’ll explore tomorrow. The inversions we’re doing here are actually isometries (distance-preserving maps) of hyperbolic space! So in some sense, we’re already working in non-Euclidean geometry without realizing it.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#complex-numbers-in-glsl-1",
    "href": "day2.html#complex-numbers-in-glsl-1",
    "title": "4  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "4.10 Complex Numbers in GLSL",
    "text": "4.10 Complex Numbers in GLSL\n\nRepresentation\nA complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part.\n\n\nComplex Arithmetic\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nThese are the building blocks we need for complex dynamics.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#the-mandelbrot-set-1",
    "href": "day2.html#the-mandelbrot-set-1",
    "title": "4  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "4.11 The Mandelbrot Set",
    "text": "4.11 The Mandelbrot Set\n\nDefinition\nThe Mandelbrot set \\(\\mathcal{M}\\) is defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nIn practice, we: 1. Start with \\(z_0 = 0\\) 2. Iterate \\(z_{n+1} = z_n^2 + c\\) for a fixed number of iterations (say, 100) 3. Check if \\(|z_n|\\) has escaped some large radius (typically \\(R = 2\\))\nPoints that escape quickly are definitely not in \\(\\mathcal{M}\\). Points that remain bounded after many iterations are likely in \\(\\mathcal{M}\\).\n\n\nImplementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nColoring Schemes\nThe grayscale rendering shows structure but isn’t very exciting. We can create better colormaps:\nSmooth coloring using escape time:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    // Use a color palette (see below)\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nSimple color palette:\nvec3 palette(float t) {\n    // Create a cyclic color palette\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors. Play with the parameters a, b, c, d to get different color schemes!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day2.html#looking-ahead-1",
    "href": "day2.html#looking-ahead-1",
    "title": "4  Day 2: Complex Dynamics and Iterated Inversions",
    "section": "4.12 Looking Ahead",
    "text": "4.12 Looking Ahead\nTomorrow we’ll continue with fractals and hyperbolic geometry. We’ll start by extending our folding techniques to create the Sierpinski carpet, then dive into hyperbolic space with multiple models (Poincaré disk, upper half-plane, band model) and create beautiful tilings in non-Euclidean geometry.\nMake sure you’re comfortable with: - Complex number iteration and the Mandelbrot/Julia algorithms - Geometric folding operations (reflection via abs(), scaling) - Using iteration count for coloring - Circle inversion (from today’s homework—this will be crucial tomorrow!)\nThe circle inversion you implement today will be the foundation for tomorrow’s hyperbolic tilings, so take your time understanding how it works geometrically.\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 2: Complex Dynamics and Iterated Inversions</span>"
    ]
  },
  {
    "objectID": "day3.html#euclidean-triangle-tiling",
    "href": "day3.html#euclidean-triangle-tiling",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.2 Euclidean Triangle Tiling",
    "text": "3.2 Euclidean Triangle Tiling\n\nThe Fundamental Domain\nAn equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can: 1. Reflect across its three edges 2. Repeat this process on the resulting triangles 3. Fill the entire plane with copies of the original triangle\nThis is a tiling by reflection: the entire plane is covered by reflected copies of our fundamental domain.\n\n\nSetting Up the Triangle\nLet’s work with an equilateral triangle with vertices at: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nThis triangle has side length \\(\\sqrt{3}\\) and is centered at the origin.\n// Define triangle vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866\nvec2 v2 = vec2(0.866, -0.5);\n\n\nReflection Across a Line\nTo reflect a point \\(p\\) across a line through the origin with unit normal \\(\\mathbf{n}\\), we use: \\[p' = p - 2(\\mathbf{n} \\cdot p)\\mathbf{n}\\]\nFor a line through two points (an edge of our triangle), we: 1. Compute the edge direction 2. Find the perpendicular (normal to the edge) 3. Check which side of the line we’re on 4. Reflect if necessary\nImplementation for one edge:\nvec2 reflectAcrossEdge(vec2 p, vec2 v0, vec2 v1) {\n    // Edge direction\n    vec2 edge = v1 - v0;\n    \n    // Normal to edge (perpendicular, pointing outward)\n    vec2 normal = normalize(vec2(-edge.y, edge.x));\n    \n    // Signed distance to line\n    float dist = dot(p - v0, normal);\n    \n    // Reflect if on the wrong side (dist &lt; 0)\n    if(dist &lt; 0.0) {\n        p = p - 2.0 * dist * normal;\n    }\n    \n    return p;\n}\n\n\nIterative Folding into the Triangle\nWe repeatedly reflect \\(p\\) across the three edges until it lands inside the fundamental domain:\nvec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        vec2 p_old = p;\n        \n        // Reflect across each edge if necessary\n        p = reflectAcrossEdge(p, v0, v1);\n        p = reflectAcrossEdge(p, v1, v2);\n        p = reflectAcrossEdge(p, v2, v0);\n        \n        // Check if we're done (no more reflections)\n        if(length(p - p_old) &lt; 0.0001) break;\n        \n        foldCount++;\n    }\n    \n    return p;\n}\n\n\nVisualization: Euclidean Tiling\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold to fundamental domain\n    int foldCount;\n    vec2 p_folded = foldToTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);  // Use palette function from Day 2\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result: a beautiful triangular tiling of the plane, colored by how many reflections were needed to reach the fundamental domain!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#the-23-triangle-in-the-upper-half-plane",
    "href": "day3.html#the-23-triangle-in-the-upper-half-plane",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.4 The (2,3,∞) Triangle in the Upper Half-Plane",
    "text": "3.4 The (2,3,∞) Triangle in the Upper Half-Plane\n\nTriangle Setup\nFor our first hyperbolic tiling, we’ll use a triangle with particularly nice edges in the upper half-plane: - Bottom edge: Unit semicircle centered at origin (equation: \\(x^2 + y^2 = 1\\), \\(y &gt; 0\\)) - Left edge: Vertical geodesic at \\(x = -1\\) - Right edge: Vertical geodesic at \\(x = 1\\)\nThis creates a hyperbolic triangle with one ideal vertex (at infinity on the \\(y\\)-axis) and two finite vertices.\nstruct Geodesic {\n    int type;  // 0 = vertical line, 1 = semicircle\n    vec2 data;  // For vertical: (x_pos, unused), for semicircle: (center_x, radius)\n};\n\nvoid setupTriangle(out Geodesic g1, out Geodesic g2, out Geodesic g3) {\n    g1.type = 1;  // Semicircle\n    g1.data = vec2(0.0, 1.0);  // Center at origin, radius 1\n    \n    g2.type = 0;  // Vertical line\n    g2.data = vec2(-1.0, 0.0);  // At x = -1\n    \n    g3.type = 0;  // Vertical line\n    g3.data = vec2(1.0, 0.0);  // At x = 1\n}\n\n\nChecking if a Point is in the Triangle\nbool inTriangle(vec2 p) {\n    // Above the semicircle: x² + y² &gt; 1\n    bool aboveSemicircle = dot(p, p) &gt; 1.0;\n    \n    // Between vertical lines: -1 &lt; x &lt; 1\n    bool betweenLines = (p.x &gt; -1.0) && (p.x &lt; 1.0);\n    \n    return aboveSemicircle && betweenLines;\n}\n\n\nReflection Across Geodesics\nReflection across a vertical line \\(x = c\\): \\[\\text{reflect}(x + iy) = (2c - x) + iy\\]\nvec2 reflectVertical(vec2 p, float c) {\n    return vec2(2.0 * c - p.x, p.y);\n}\nReflection across a semicircle (circle inversion from yesterday!): For a circle of radius \\(R\\) centered at \\((c_x, 0)\\):\nvec2 reflectCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    return center + (radius * radius) * diff / r2;\n}\n\n\nFolding into the Fundamental Domain\nvec2 foldToHyperbolicTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        bool folded = false;\n        \n        // Reflect across left vertical line if needed\n        if(p.x &lt; -1.0) {\n            p = reflectVertical(p, -1.0);\n            folded = true;\n        }\n        \n        // Reflect across right vertical line if needed\n        if(p.x &gt; 1.0) {\n            p = reflectVertical(p, 1.0);\n            folded = true;\n        }\n        \n        // Reflect across semicircle if needed\n        if(dot(p, p) &lt; 1.0) {\n            p = reflectCircle(p, vec2(0.0, 0.0), 1.0);\n            folded = true;\n        }\n        \n        if(folded) foldCount++;\n        else break;  // In fundamental domain\n    }\n    \n    return p;\n}\n\n\nVisualization: Hyperbolic Tiling\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup - map to upper half-plane\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift up so y &gt; 0\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Fold to fundamental domain\n    int foldCount;\n    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = palette(t);\n    \n    // Highlight fundamental domain\n    if(inTriangle(p_folded)) {\n        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result: a beautiful hyperbolic tiling! Notice how the triangles appear to shrink near the real axis—they’re all the same hyperbolic size, but Euclidean distances compress.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "href": "outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "title": "Outline",
    "section": "Day 2: Complex Dynamics and Iterated Inversions",
    "text": "Day 2: Complex Dynamics and Iterated Inversions\n\nLearning Objectives\n\nImplement complex number arithmetic in GLSL\nRender the Mandelbrot set through escape-time iteration\nMaster circle inversion as a conformal transformation\nUse structs to organize geometric data\nGenerate the Apollonian gasket through iterated inversions\n\n\n\nIn-Class Content\n\nComplex arithmetic: Addition, multiplication, division, conjugation\nMandelbrot set:\n\nIteration \\(z_{n+1} = z_n^2 + c\\) with \\(z_0 = 0\\)\nEscape-time algorithm\nSmooth coloring and palettes\n\nCircle inversion:\n\nMathematical definition and properties\nConformal mapping (preserves angles, maps circles to circles/lines)\nImplementation and visualization\n\nStructs in GLSL: Organizing circle data (center, radius)\nApollonian gasket:\n\nThree mutually tangent circles\nIterated inversions generate fractal structure\nColoring by escape time or basin of attraction\n\n\n\n\nHomework\nRequired: Julia sets - Implement for fixed \\(c\\), varying initial \\(z_0\\) - Explore parameter space (try different values of \\(c\\)) - Optional: animate \\(c\\) to watch morphing\nOptional: Schottky groups - Four or more disjoint circles - Alternating inversion patterns - Create intricate nested structures",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "href": "outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "title": "Outline",
    "section": "Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "text": "Day 3: Geometric Tilings in Euclidean and Hyperbolic Space\n\nLearning Objectives\n\nCreate Euclidean triangle tilings through reflection\nUnderstand hyperbolic geometry models (upper half-plane, Poincaré disk)\nImplement hyperbolic triangle tilings using circle inversion\nConvert between different hyperbolic models\n\n\n\nIn-Class Content\n\nEuclidean triangle tiling:\n\nFundamental domain (equilateral triangle)\nReflection across edges\nIterative folding algorithm\nColoring by reflection count\n\nHyperbolic geometry introduction:\n\nUpper half-plane model: \\(\\mathbb{H}^2 = \\{z : \\text{Im}(z) &gt; 0\\}\\)\nHyperbolic metric: \\(ds^2 = \\frac{dx^2 + dy^2}{y^2}\\)\nGeodesics: vertical lines and semicircles\nHyperbolic distance formula\n\nPoincaré disk model:\n\nUnit disk representation\nCayley transform between models\n\nHyperbolic triangle tiling:\n\n\\((2,3,\\infty)\\) triangle with nice edges\nReflection across vertical geodesics (simple)\nReflection across circular geodesics (circle inversion!)\nFolding algorithm\nVisualization in both models\n\n\n\n\nHomework\nRequired #1: Draw geodesics and hyperbolic disks - Visualize geodesics in upper half-plane - Draw hyperbolic disks (constant hyperbolic distance) - Observe metric distortion\nRequired #2: Draw triangle edges and vertices - Compute distance to geodesics - Render triangle boundaries explicitly - Mark vertices\nRequired #3: Model conversion and Möbius transformations - Convert tiling to Poincaré disk - Apply Möbius transformations (isometries) - Observe how tiling transforms\nOptional: - Different triangle groups (e.g., \\((2,3,7)\\) for Escher-like tilings) - Klein model (geodesics become straight lines) - Decorated tiles (Escher-style patterns)",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#resources-and-further-exploration",
    "href": "outline.html#resources-and-further-exploration",
    "title": "Outline",
    "section": "Resources and Further Exploration",
    "text": "Resources and Further Exploration\n\nShadertoy\n\nMain site: https://www.shadertoy.com\nCommunity examples and tutorials\nGLSL documentation\n\n\n\nReferences\n\nComplex dynamics and fractals\nHyperbolic geometry and tilings\nSigned distance functions (Inigo Quilez: https://iquilezles.org/articles/distfunctions/)\nGPU computing for scientific visualization\n\n\n\nAdvanced Topics\n\nPath tracing and global illumination\nNon-Euclidean ray tracing\nReal-time denoising\nMore complex PDEs and simulations",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#assessment-philosophy",
    "href": "outline.html#assessment-philosophy",
    "title": "Outline",
    "section": "Assessment Philosophy",
    "text": "Assessment Philosophy\nThis is a workshop-style course focused on skill development. Success means: - Completing required homework to keep pace - Experimenting with optional problems based on interest - Developing intuition for when shader programming is appropriate - Leaving with working code templates for future projects\nPhilosophy: Getting something working and understanding it is more valuable than perfect, polished results. The goal is to build practical skills and mathematical intuition, not to create production-quality graphics.",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "outline.html#schedule-summary",
    "href": "outline.html#schedule-summary",
    "title": "Outline",
    "section": "Schedule Summary",
    "text": "Schedule Summary\n\n\n\n\n\n\n\n\nDay\nTopic\nKey Concepts\n\n\n\n\n1\nShader Basics\nCoordinates, distance fields, implicit curves\n\n\n2\nComplex Dynamics\nMandelbrot, circle inversion, Apollonian gasket\n\n\n3\nGeometric Tilings\nEuclidean and hyperbolic tilings, models\n\n\n4\n3D Rendering\nRaymarching, SDFs, lighting\n\n\n5\nAdvanced (flexible)\nDomain ops + fractals OR buffers + PDEs\n\n\n\nEach day: 1 hour lecture + ~1.5 hours homework Total: 5 lectures, 10-12 programming assignments (5 required, 5-7 optional)",
    "crumbs": [
      "Outline"
    ]
  },
  {
    "objectID": "folding-fractals.html",
    "href": "folding-fractals.html",
    "title": "Appendix C — Folding Fractals",
    "section": "",
    "text": "C.1 Overview\nThis appendix explores a fascinating technique for generating fractals: iterated folding with scaling. While reflection-based tiling (Days 2-3) fills space with copies of a fundamental domain, folding fractals add scaling at each iteration, creating self-similar structures that exhibit fractal geometry.\nWe’ll explore three classic examples: 1. Sierpinski Triangle (2D, triangle-based) 2. Sierpinski Carpet (2D, square-based) 3. Menger Sponge (3D, cube-based)\nThese connect naturally to course content: the folding operations use techniques from Day 2-3 (reflection, abs()), and the Menger sponge extends to 3D using Day 4’s coordinate systems.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#fundamental-concept-folding-scaling-fractals",
    "href": "folding-fractals.html#fundamental-concept-folding-scaling-fractals",
    "title": "Appendix C — Folding Fractals",
    "section": "C.2 Fundamental Concept: Folding + Scaling = Fractals",
    "text": "C.2 Fundamental Concept: Folding + Scaling = Fractals\n\nThe General Pattern\nAll folding fractals follow this pattern:\n\nFold: Use geometric operations (reflection, abs()) to bring the point into a fundamental region\nScale: Zoom in by some factor (typically 2 or 3)\nRepeat: Iterate this process\nClassify: After \\(n\\) iterations, check if the point is in a “removed” region or “kept” region\n\nAfter \\(n\\) iterations: - We’ve zoomed in by factor \\(s^n\\) (where \\(s\\) is the scale factor) - The fractal structure emerges from the removal pattern - The result is self-similar: zooming in reveals the same pattern\n\n\nConnection to Tilings\nRecall from Day 3: - Tiling: Fold → repeat (fills space with copies) - Fractal: Fold → scale → repeat (creates self-similar structure with removed regions)\nThe key difference is the scaling step!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#sierpinski-triangle",
    "href": "folding-fractals.html#sierpinski-triangle",
    "title": "Appendix C — Folding Fractals",
    "section": "C.3 Sierpinski Triangle",
    "text": "C.3 Sierpinski Triangle\n\nMathematical Description\nThe Sierpinski triangle is constructed by: 1. Start with an equilateral triangle 2. Remove the middle triangle (formed by connecting edge midpoints) 3. Recursively repeat on each remaining sub-triangle\nEquivalently: iteratively fold into the triangle and scale by 2.\n\n\nMathematical Foundation: Reflection Across a Line\nBefore implementing the fractal, we need the correct reflection formula.\nA line in the plane can be written as \\(ax + by = c\\), with normal vector \\(\\mathbf{n} = (a, b)\\).\nReflection formula: For a point \\(\\mathbf{p} = (x, y)\\), the reflection \\(\\mathbf{p}'\\) across the line is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere: - \\(d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\) is the signed distance to the line - \\(\\hat{\\mathbf{n}} = \\frac{(a,b)}{\\sqrt{a^2 + b^2}}\\) is the unit normal\nCombining these: \\[\\mathbf{p}' = \\mathbf{p} - \\frac{2(ax + by - c)}{a^2 + b^2}(a, b)\\]\n\n\nLine Struct\nLet’s organize line data properly:\nstruct Line {\n    float a, b, c;  // Line equation: ax + by = c\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    // Signed distance from point to line (unnormalized)\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    \n    // Normal vector squared length\n    float normSq = line.a * line.a + line.b * line.b;\n    \n    // Reflection formula\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\n\nSetting Up the Triangle\nFor an equilateral triangle with vertices: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nWe need the three edge lines:\nEdge from \\(v_0\\) to \\(v_1\\): Direction vector: \\(v_1 - v_0 = (-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2})\\) Normal (perpendicular): \\((\\frac{3}{2}, -\\frac{\\sqrt{3}}{2})\\) or simplified: \\((3, -\\sqrt{3})\\) Line equation: \\(3x - \\sqrt{3}y = c\\), passing through \\(v_0 = (0,1)\\): \\(c = -\\sqrt{3}\\)\nEdge from \\(v_1\\) to \\(v_2\\): This is horizontal: \\(y = -\\frac{1}{2}\\) Line equation: \\(0x + 1y = -\\frac{1}{2}\\) or \\((0, 1, -0.5)\\)\nEdge from \\(v_2\\) to \\(v_0\\): By symmetry: \\(-3x - \\sqrt{3}y = -\\sqrt{3}\\)\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    \n    // Edge v0 to v1\n    e1.a = 3.0;\n    e1.b = -sqrt3;\n    e1.c = -sqrt3;\n    \n    // Edge v1 to v2 (horizontal)\n    e2.a = 0.0;\n    e2.b = 1.0;\n    e2.c = -0.5;\n    \n    // Edge v2 to v0\n    e3.a = -3.0;\n    e3.b = -sqrt3;\n    e3.c = -sqrt3;\n}\n\n\nThe Folding Algorithm\nNow we can properly fold into the triangle:\n\n\nThe Folding Algorithm\nNow we can properly fold into the triangle:\nvec2 foldIntoTriangle(vec2 p, Line e1, Line e2, Line e3, int maxIter) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        vec2 p_old = p;\n        \n        // Reflect across each edge if we're on the wrong side\n        // Check sign of distance: if negative, we're on wrong side\n        float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n        if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n        \n        float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n        if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n        \n        float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n        if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        \n        // Converged? (no more reflections)\n        if(length(p - p_old) &lt; 0.0001) break;\n    }\n    \n    return p;\n}\n\n\nAdding the Scaling Step\nFor the Sierpinski fractal, we fold and then scale:\nvec2 sierpinskiTriangle(vec2 p, int iterations, out int depth) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    depth = 0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into fundamental triangle\n        p = foldIntoTriangle(p, e1, e2, e3, 10);\n        \n        // Scale by 2 toward center\n        vec2 center = vec2(0.0, 0.0);  // Approximate center\n        p = (p - center) * 2.0 + center;\n        \n        depth++;\n        \n        // Optional: early exit if escaped\n        if(length(p) &gt; 100.0) break;\n    }\n    \n    return p;\n}\n\n\nDetermining if Point is in Fractal\nAfter folding, we need to check if we’re in the “removed” middle triangle. Using barycentric coordinates:\n\n### Determining if Point is in Fractal\n\nAfter folding, we need to check if we're in the \"removed\" middle triangle. The middle triangle has vertices at the midpoints of the original triangle's edges.\n\nFor an equilateral triangle with vertices $v_0, v_1, v_2$, the midpoints are:\n$$m_{01} = \\frac{v_0 + v_1}{2}, \\quad m_{12} = \\frac{v_1 + v_2}{2}, \\quad m_{20} = \\frac{v_2 + v_0}{2}$$\n\nWe can check if point $p$ is inside this middle triangle using barycentric coordinates:\n\n```glsl\nbool inMiddleTriangle(vec2 p) {\n    // Vertices of original triangle\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    // Midpoints (vertices of removed triangle)\n    vec2 m01 = (v0 + v1) * 0.5;\n    vec2 m12 = (v1 + v2) * 0.5;\n    vec2 m20 = (v2 + v0) * 0.5;\n    \n    // Check if p is inside triangle m01-m12-m20\n    // Using sign of cross products\n    vec2 e0 = m12 - m01;\n    vec2 e1 = m20 - m12;\n    vec2 e2 = m01 - m20;\n    \n    vec2 p0 = p - m01;\n    vec2 p1 = p - m12;\n    vec2 p2 = p - m20;\n    \n    float s0 = e0.x * p0.y - e0.y * p0.x;\n    float s1 = e1.x * p1.y - e1.y * p1.x;\n    float s2 = e2.x * p2.y - e2.y * p2.x;\n    \n    // All same sign means inside\n    return (s0 &gt;= 0.0 && s1 &gt;= 0.0 && s2 &gt;= 0.0) || \n           (s0 &lt;= 0.0 && s1 &lt;= 0.0 && s2 &lt;= 0.0);\n}\n\n\nComplete Implementation\nstruct Line {\n    float a, b, c;\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    float normSq = line.a * line.a + line.b * line.b;\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    e1 = Line(3.0, -sqrt3, -sqrt3);\n    e2 = Line(0.0, 1.0, -0.5);\n    e3 = Line(-3.0, -sqrt3, -sqrt3);\n}\n\nvec2 sierpinskiTriangle(vec2 p, int iterations, out bool inFractal) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into triangle\n        for(int j = 0; j &lt; 10; j++) {\n            float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n            if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n            \n            float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n            if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n            \n            float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n            if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        }\n        \n        // Check if in removed region\n        if(inMiddleTriangle(p)) {\n            inFractal = false;\n        }\n        \n        // Scale by 2\n        p = p * 2.0;\n    }\n    \n    return p;\n}\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 3.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal;\n    vec2 p_final = sierpinskiTriangle(uv, 6, inFractal);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color by final position\n        float t = length(p_final) * 0.1;\n        color = palette(t);\n    } else {\n        // Removed region\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Sierpinski triangle should now render with mathematically correct reflections!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#sierpinski-carpet",
    "href": "folding-fractals.html#sierpinski-carpet",
    "title": "Appendix C — Folding Fractals",
    "section": "C.4 Sierpinski Carpet",
    "text": "C.4 Sierpinski Carpet\n\nMathematical Description\nThe Sierpinski carpet is the square analog: 1. Start with a square 2. Divide into a 3×3 grid of sub-squares 3. Remove the central sub-square 4. Recursively repeat on each remaining sub-square\nNote: Unlike the triangle, the carpet uses axis-aligned divisions, so the implementation is both simpler AND mathematically exact—no approximations needed!\n\n\nThe Algorithm\nMuch simpler than the triangle because we can use axis-aligned operations!\nAt each iteration: 1. Fold using abs() to create 4-fold symmetry (all quadrants map to first quadrant) 2. Scale by factor of 3 3. Check if we’re in the removed middle region\n\n\nImplementation\nbool sierpinskiCarpet(vec2 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant (creates 4-fold symmetry)\n        p = abs(p);\n        \n        // Scale by 3 and recenter\n        p = p * 3.0 - vec2(1.0);\n        \n        // After this transformation, the \"removed\" region is\n        // approximately where both |p.x| &lt; 1 and |p.y| &lt; 1\n    }\n    \n    // Check if in removed region\n    // After n iterations, if we're in the central square, we're removed\n    return (abs(p.x) &lt; 1.0 && abs(p.y) &lt; 1.0);\n}\n\n\nMore Robust Version\nvec2 carpetFold(vec2 p, int iterations, out bool inFractal) {\n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Check if in middle third in both dimensions\n        // In normalized [0,1] space, middle third is [1/3, 2/3]\n        vec2 normalizedP = fract(p);  // Get fractional part\n        \n        bool inMiddleX = (normalizedP.x &gt; 0.33 && normalizedP.x &lt; 0.67);\n        bool inMiddleY = (normalizedP.y &gt; 0.33 && normalizedP.y &lt; 0.67);\n        \n        if(inMiddleX && inMiddleY) {\n            inFractal = false;\n        }\n        \n        // Scale by 3\n        p = p * 3.0;\n    }\n    \n    return p;\n}\n\n\nClean Implementation\nA cleaner approach using the subdivision pattern:\nbool inSierpinskiCarpet(vec2 p, int iterations) {\n    // Normalize to [0, 1]\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Which cell of 3×3 grid are we in?\n        vec2 cell = floor(p * 3.0);\n        \n        // Middle cell (1,1) is removed\n        if(cell.x == 1.0 && cell.y == 1.0) {\n            return false;  // In removed region\n        }\n        \n        // Zoom into current cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;  // In fractal\n}\n\n\nVisualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal = inSierpinskiCarpet(uv, 6);\n    \n    vec3 color = inFractal ? vec3(1.0, 1.0, 0.8) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#menger-sponge-3d-extension",
    "href": "folding-fractals.html#menger-sponge-3d-extension",
    "title": "Appendix C — Folding Fractals",
    "section": "C.5 Menger Sponge (3D Extension)",
    "text": "C.5 Menger Sponge (3D Extension)\n\nMathematical Description\nThe Menger sponge is the 3D analog of the Sierpinski carpet: 1. Start with a cube 2. Divide into a 3×3×3 grid of sub-cubes (27 total) 3. Remove the central sub-cube and the 6 face-centered sub-cubes (7 removed, 20 remain) 4. Recursively repeat on each remaining sub-cube\nNote: Like the carpet, the sponge uses axis-aligned divisions, giving us an exact, mathematically precise implementation.\n\n\nThe Algorithm\nSame pattern as the carpet, but in 3D!\n\nFold using abs(p) to create octahedral symmetry\nScale by factor of 3\nCheck if we’re in a removed region (middle cross pattern)\n\n\n\nImplementation\nbool inMengerSponge(vec3 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        p = abs(p);\n        \n        // Which cell of 3×3×3 grid?\n        vec3 cell = floor(p * 3.0);\n        \n        // Removed regions: center cube and face centers\n        // Center: (1,1,1)\n        // Face centers: (1,1,0), (1,1,2), (1,0,1), (1,2,1), (0,1,1), (2,1,1)\n        // Pattern: at least 2 coordinates equal to 1\n        \n        float ones = 0.0;\n        if(cell.x == 1.0) ones += 1.0;\n        if(cell.y == 1.0) ones += 1.0;\n        if(cell.z == 1.0) ones += 1.0;\n        \n        if(ones &gt;= 2.0) {\n            return false;  // Removed region\n        }\n        \n        // Zoom into cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;\n}\n\n\nAlternative: Using SDF Approach\nWe can also implement the Menger sponge as a signed distance function for use with Day 4’s raymarching:\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdMengerSponge(vec3 p, int iterations) {\n    float d = sdBox(p, vec3(1.0));  // Start with unit cube\n    \n    float scale = 1.0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        vec3 a = mod(p * scale, 2.0) - 1.0;\n        scale *= 3.0;\n        \n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        \n        // Distance to cross (removed region)\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / scale;\n        \n        d = max(d, c);\n    }\n    \n    return d;\n}\n\n\nRendering with Raymarching\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray (using Day 4 techniques)\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Raymarch\n    float t = 0.0;\n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = ray.origin + t * ray.direction;\n        float d = sdMengerSponge(pos, 4);\n        \n        if(abs(d) &lt; 0.001) {\n            // Hit!\n            vec3 normal = estimateNormal(pos);  // Day 4 technique\n            \n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            float diffuse = max(0.0, dot(normal, lightDir));\n            \n            vec3 color = vec3(1.0, 0.8, 0.6) * diffuse + vec3(0.1);\n            fragColor = vec4(color, 1.0);\n            return;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) break;\n    }\n    \n    // Miss\n    fragColor = vec4(0.1, 0.1, 0.2, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#general-principles-of-folding-fractals",
    "href": "folding-fractals.html#general-principles-of-folding-fractals",
    "title": "Appendix C — Folding Fractals",
    "section": "C.6 General Principles of Folding Fractals",
    "text": "C.6 General Principles of Folding Fractals\n\nKey Ingredients\n\nSymmetry operations:\n\nabs() for axis-aligned symmetry\nReflections for arbitrary symmetry\n\nScaling factor:\n\nFactor of 2: Sierpinski triangle\nFactor of 3: Sierpinski carpet, Menger sponge\nGeneral factor \\(s\\): determines fractal dimension\n\nRemoval pattern:\n\nWhich regions get removed at each level\nDefines the fractal’s structure\n\nIteration:\n\nMore iterations = more detail\nComputational cost grows linearly\nVisual complexity grows exponentially\n\n\n\n\nFractal Dimension\nThe fractal dimension \\(D\\) can be computed from the scaling factor \\(s\\) and the number of remaining pieces \\(N\\):\n\\[D = \\frac{\\log N}{\\log s}\\]\nExamples: - Sierpinski triangle: \\(N = 3\\) pieces, scale factor \\(s = 2\\) \\[D = \\frac{\\log 3}{\\log 2} \\approx 1.585\\]\n\nSierpinski carpet: \\(N = 8\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 8}{\\log 3} \\approx 1.893\\]\nMenger sponge: \\(N = 20\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 20}{\\log 3} \\approx 2.727\\]\n\nThe fractal dimension is between the topological dimension and the embedding dimension, reflecting the fractal’s “in-between” nature!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#coloring-strategies",
    "href": "folding-fractals.html#coloring-strategies",
    "title": "Appendix C — Folding Fractals",
    "section": "C.7 Coloring Strategies",
    "text": "C.7 Coloring Strategies\n\nBy Iteration Depth\nTrack which iteration first identifies a point as removed:\nint firstRemovedIter = -1;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    // [Folding and scaling]\n    \n    if([in removed region] && firstRemovedIter &lt; 0) {\n        firstRemovedIter = i;\n    }\n}\n\nfloat t = float(firstRemovedIter) / float(iterations);\nvec3 color = palette(t);\n\n\nBy Distance After Folding\nvec2 p_final = [after all folding];\nfloat d = length(p_final);\nvec3 color = vec3(d * 0.5);  // Grayscale by distance\n\n\nBy Cell Position\nFor grid-based fractals (carpet, sponge), color by which sub-cell the point lands in:\nvec3 cell = floor(p * 3.0);\nvec3 color = cell / 3.0;  // RGB from cell coordinates\n\n\nHybrid: Distance Field + Fractal\nFor 3D fractals, combine distance estimation with fractal membership:\nfloat d = sdMengerSponge(p, iterations);\nvec3 color;\n\nif(d &lt; 0.0) {\n    // Inside sponge\n    color = vec3(1.0, 0.8, 0.6);\n} else {\n    // Outside, but show distance\n    color = vec3(0.1) + vec3(0.2) / (1.0 + d);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#variations-and-experiments",
    "href": "folding-fractals.html#variations-and-experiments",
    "title": "Appendix C — Folding Fractals",
    "section": "C.8 Variations and Experiments",
    "text": "C.8 Variations and Experiments\n\nDifferent Folding Operations\nTry different symmetry groups: - Hexagonal symmetry (6-fold) - Octahedral symmetry (for 3D) - Custom reflection patterns\n\n\nDifferent Scale Factors\n\nScale by 4: sparser fractal\nScale by 1.5: denser fractal\nNon-integer scales: unusual structures\n\n\n\nAnimated Parameters\nfloat scale = 2.0 + 0.5 * sin(iTime);\np = p * scale;\nWatch the fractal morph as the scale factor changes!\n\n\nColor by Orbit\nTrack the “orbit” of the point through the folding process:\nfloat orbit = 0.0;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    orbit += length(p);  // Accumulate total distance traveled\n    // [Folding operations]\n}\n\nvec3 color = palette(orbit / 10.0);\n\n\n3D Variations\n\nCross-Menger: Different removal pattern (only center)\nJerusalem Cube: Variation with different symmetry\nHybrid fractals: Combine different removal patterns at different scales",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#connection-to-course-topics",
    "href": "folding-fractals.html#connection-to-course-topics",
    "title": "Appendix C — Folding Fractals",
    "section": "C.9 Connection to Course Topics",
    "text": "C.9 Connection to Course Topics\n\nDay 2: Iteration Creates Fractals\nBoth folding fractals and the Mandelbrot set/Apollonian gasket share the principle: simple operations iterated create complex structure.\n\nMandelbrot: \\(z \\to z^2 + c\\) (complex arithmetic iteration)\nApollonian: Repeated circle inversions (geometric iteration)\nSierpinski: Fold + scale (geometric iteration with scaling)\n\n\n\nDay 3: Folding Without Scaling\nEuclidean and hyperbolic tilings use folding without scaling: - Reflection brings points into fundamental domain - No scaling → fills space with copies - With scaling → creates fractal structure\n\n\nDay 4: 3D Rendering\nThe Menger sponge naturally extends to 3D: - Can be rendered as SDF (raymarching) - Can be rendered as boolean test (simple ray casting) - Demonstrates 3D coordinate folding",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#exercises",
    "href": "folding-fractals.html#exercises",
    "title": "Appendix C — Folding Fractals",
    "section": "C.10 Exercises",
    "text": "C.10 Exercises\n\nExercise 1: Hexagonal Sierpinski\nCreate a Sierpinski gasket based on a hexagon instead of a triangle: - Use 6-fold symmetry - Scale by factor of 3 - Remove appropriate regions\n\n\nExercise 2: Animate the Scale Factor\nModify the Sierpinski carpet to have a time-varying scale factor:\nfloat scale = 3.0 + sin(iTime);\nWatch how the fractal structure changes!\n\n\nExercise 3: 3D Cross\nImplement a 3D fractal using only cross-shaped removal (remove only the center cube, not the face centers). Compare to the standard Menger sponge.\n\n\nExercise 4: Hybrid Fractal\nCombine two different fractals: - First 3 iterations: Sierpinski triangle folding - Next 3 iterations: Sierpinski carpet folding - Observe the unusual resulting structure\n\n\nExercise 5: Distance-Colored Sponge\nRender the Menger sponge with colors based on distance from the surface: - Use sdMengerSponge as a distance field - Color by distance for points outside - Different color for points inside",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#further-reading",
    "href": "folding-fractals.html#further-reading",
    "title": "Appendix C — Folding Fractals",
    "section": "C.11 Further Reading",
    "text": "C.11 Further Reading\n\nMathematical Theory\n\nHausdorff dimension and box-counting dimension\nIterated function systems (IFS)\nSelf-similar sets and scaling symmetries\n\n\n\nComputational Techniques\n\nEscape-time algorithms\nDistance estimation for fractals\nEfficient rendering of fractal geometry\n\n\n\nApplications\n\nProcedural generation in games/graphics\nAntenna design (fractal antennas)\nModeling natural phenomena (coastlines, plants)\nCompression algorithms",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#summary",
    "href": "folding-fractals.html#summary",
    "title": "Appendix C — Folding Fractals",
    "section": "C.12 Summary",
    "text": "C.12 Summary\nFolding fractals demonstrate: 1. Iteration + scaling creates self-similar structure 2. Simple operations produce complex results 3. GPU parallelism enables real-time fractal rendering 4. Fractals connect to many course topics (iteration, symmetry, 3D)\nThe techniques here—folding, scaling, iteration—are fundamental to both mathematical fractals and computer graphics. These methods extend naturally from 2D to 3D, and from static to animated, making them powerful tools for mathematical visualization.\nKey takeaway: Fractals aren’t just beautiful—they’re computationally accessible. A few dozen lines of shader code can generate infinite complexity!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "folding-fractals.html#complete-example-animated-sierpinski-carpet",
    "href": "folding-fractals.html#complete-example-animated-sierpinski-carpet",
    "title": "Appendix C — Folding Fractals",
    "section": "C.13 Complete Example: Animated Sierpinski Carpet",
    "text": "C.13 Complete Example: Animated Sierpinski Carpet\nvec3 palette(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nbool inCarpet(vec2 p, int iterations) {\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        vec2 cell = floor(p * 3.0);\n        if(cell.x == 1.0 && cell.y == 1.0) return false;\n        p = fract(p * 3.0);\n    }\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom animation\n    float zoom = exp(sin(iTime * 0.3) * 2.0);\n    uv *= zoom;\n    \n    // Rotation animation\n    float angle = iTime * 0.2;\n    float c = cos(angle), s = sin(angle);\n    uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n    \n    int iterations = 6;\n    bool inFractal = inCarpet(uv, iterations);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color based on distance from center\n        float d = length(uv);\n        color = palette(d * 0.5 + iTime * 0.1);\n    } else {\n        color = vec3(0.05, 0.05, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis creates a beautiful, animated Sierpinski carpet that zooms and rotates, with colors flowing through the fractal structure!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>Folding Fractals</span>"
    ]
  },
  {
    "objectID": "schottky.html",
    "href": "schottky.html",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "D.1 1. Schottky groups in one picture\nA (classical) Schottky group of rank \\(g\\) is built from \\(2g\\) disjoint Jordan curves (we use circles) on the Riemann sphere. We pair them up \\((C_1, C_1'), \\dots, (C_g, C_g')\\), and for each pair we choose a Möbius map that sends the exterior of \\(C_i\\) to the interior of \\(C_i'\\). The group generated by these \\(g\\) maps is free and discrete.\nSo the fundamental move is:\nThat is exactly the move we will encode in GLSL.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#the-möbius-generator-between-two-circles",
    "href": "schottky.html#the-möbius-generator-between-two-circles",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.2 2. The Möbius generator between two circles",
    "text": "D.2 2. The Möbius generator between two circles\nLet two disjoint circles in the complex plane be given:\n\nCircle 1: center \\(c_1 \\in \\mathbb{C}\\), radius \\(r_1 &gt; 0\\)\n\nCircle 2: center \\(c_2 \\in \\mathbb{C}\\), radius \\(r_2 &gt; 0\\)\n\nWe seek a Möbius transformation \\(f\\) that sends the exterior of Circle 1 to the interior of Circle 2.\nThe construction proceeds in three geometrically meaningful steps:\n\nNormalize Circle 1 to the unit circle by translation and scaling: \\[\nT_1(z) = \\frac{z - c_1}{r_1}.\n\\]\nInvert in the unit circle to swap interior and exterior: \\[\nJ(w) = \\frac{1}{w}.\n\\]\nDenormalize to Circle 2: \\[\nT_2^{-1}(w) = c_2 + r_2 w.\n\\]\n\nComposing these steps yields \\[\nf(z) = T_2^{-1}(J(T_1(z))) = c_2 + \\frac{r_1 r_2}{z - c_1}.\n\\]\nThis map identifies the circles by sending the exterior of Circle 1 to the interior of Circle 2.\n\nFigure\n\n\n\nMapping the exterior of Circle 1 to the interior of Circle 2",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#complex-numbers-in-glsl",
    "href": "schottky.html#complex-numbers-in-glsl",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.3 3. Complex numbers in GLSL",
    "text": "D.3 3. Complex numbers in GLSL\nGLSL has no native complex numbers, but vec2 suffices.\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b,b);\n    return vec2((a.x*b.x + a.y*b.y)/d, (a.y*b.x - a.x*b.y)/d);\n}\nvec2 cfloat(float x) { return vec2(x,0.0); }\nA circle is represented by a simple struct:\nstruct Circle {\n    vec2 center;\n    float radius;\n};",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#the-schottky-generator-in-code",
    "href": "schottky.html#the-schottky-generator-in-code",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.4 4. The Schottky generator in code",
    "text": "D.4 4. The Schottky generator in code\nThe geometric recipe translates directly into GLSL:\nvec2 toUnitCircle(vec2 z, Circle c) { return (z - c.center) / c.radius; }\nvec2 fromUnitCircle(vec2 w, Circle c) { return c.radius * w + c.center; }\nvec2 invertUnit(vec2 w) { return cdiv(vec2(1.0,0.0), w); }\n\nvec2 schottkyMap(vec2 z, Circle A, Circle B, float rotation, inout float scale) {\n    vec2 zA = toUnitCircle(z, A);\n    float inversionScale = 1.0 / dot(zA, zA);\n    vec2 inv = invertUnit(zA);\n    vec2 inB = fromUnitCircle(inv, B);\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    // optional rotation in target circle\n    vec2 unitB = (inB - B.center) / B.radius;\n    float c = cos(rotation);\n    float s = sin(rotation);\n    vec2 rotated = vec2(c*unitB.x - s*unitB.y, s*unitB.x + c*unitB.y);\n    return B.center + B.radius * rotated;\n}\nThis schottkyMap sends the exterior of Circle A to the interior of Circle B and applies a rotation by rotation radians inside B.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#fixed-points-and-the-loxodromic-axis",
    "href": "schottky.html#fixed-points-and-the-loxodromic-axis",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.5 5. Fixed points and the loxodromic axis",
    "text": "D.5 5. Fixed points and the loxodromic axis\nGiven \\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\] solve \\(f(z) = z\\):\n[ (z - c_1)(z - c_2) = r_1 r_2] [ z^2 - (c_1 + c_2)z + c_1 c_2 - r_1 r_2 = 0.]\nSo \\[\nz = \\frac{c_1 + c_2 \\pm \\sqrt{(c_1 - c_2)^2 + 4 r_1 r_2}}{2}.\n\\]\nThose two solutions are the endpoints of the axis — in \\(\\widehat{\\mathbb C}\\) these are just two points, but in \\(\\mathbb H^3\\) they determine the unique geodesic the map acts along.\nWe need a complex sqrt:\n// principal complex square root\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float t = sqrt(0.5*(r + z.x));\n    float s = (z.y &gt;= 0.0)\n        ? sqrt(0.5*(r - z.x))\n        : -sqrt(0.5*(r - z.x));\n    return vec2(t, s);\n}\nNow the fixed points:\nvoid schottkyEndpoints(Circle A, Circle B,\n                       out vec2 zPlus, out vec2 zMinus, out vec2 Delta)\n{\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n\n    vec2 sum   = c1 + c2;\n    vec2 diff  = c1 - c2;\n    vec2 diff2 = cmul(diff, diff);\n\n    Delta = csqrt( diff2 + cfloat(4.0 * r1 * r2) );\n\n    zPlus  = 0.5 * (sum + Delta);\n    zMinus = 0.5 * (sum - Delta);\n}\nWe’ll call these pPlus and pMinus or p_+, p_-.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#the-complex-multiplier-and-hyperbolic-translation",
    "href": "schottky.html#the-complex-multiplier-and-hyperbolic-translation",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.6 6. The complex multiplier and hyperbolic translation",
    "text": "D.6 6. The complex multiplier and hyperbolic translation\nConjugating \\(f\\) to fix \\(0\\) and \\(\\infty\\) with \\[\nh(z) = \\frac{z - p_-}{z - p_+},\n\\] we obtain \\[\n(h\\circ f\\circ h^{-1})(w) = \\lambda w, \\quad \\text{where} \\quad\n\\lambda = -\\frac{4r_1r_2}{(c_2 - c_1 - \\Delta)^2}.\n\\]\nThe complex number \\(\\lambda\\) encodes both the hyperbolic translation length \\[\nL = 2\\log|\\lambda|,\n\\] and the rotation angle \\[\n\\theta = \\arg(\\lambda).\n\\]\nHence every loxodromic Möbius transformation corresponds to a screw motion along its geodesic axis in \\(\\mathbb{H}^3\\).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#continuous-deformation-the-one-parameter-family",
    "href": "schottky.html#continuous-deformation-the-one-parameter-family",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.7 7. Continuous deformation: the one-parameter family",
    "text": "D.7 7. Continuous deformation: the one-parameter family\nWe can animate the transformation continuously: \\[\nf_t(z) = h^{-1}(\\lambda^t h(z)), \\quad t \\in [0,1].\n\\]\nThis defines a smooth motion that identifies the circles continuously — ideal for a pedagogical animation.\nvec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) { return cdiv(z - pMinus, z - pPlus); }\nvec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) { return cdiv(cmul(w,pPlus) - pMinus, w - vec2(1.0,0.0)); }\n\nvec2 clogc(vec2 z) { return vec2(log(length(z)), atan(z.y,z.x)); }\nvec2 cexpc(vec2 z) {\n    float e = exp(z.x);\n    return vec2(e*cos(z.y), e*sin(z.y));\n}\n\nvec2 schottkyFlow(vec2 z, vec2 pPlus, vec2 pMinus, vec2 lambda, float t) {\n    vec2 loglam = clogc(lambda);\n    vec2 lam_t = cexpc(t*loglam);\n    vec2 w = hMap(z,pPlus,pMinus);\n    vec2 w2 = cmul(lam_t, w);\n    return hInv(w2,pPlus,pMinus);\n}\n\nFigure\n\n\n\nContinuous loxodromic identification",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#shader-1-animated-single-generator",
    "href": "schottky.html#shader-1-animated-single-generator",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.8 8. Shader 1: Animated single generator",
    "text": "D.8 8. Shader 1: Animated single generator\nThe following shader draws two circles, their fixed points, and animates the identification along \\(f_t\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    Circle A = Circle(vec2(-0.6,0.1),0.35);\n    Circle B = Circle(vec2(0.7,-0.15),0.45);\n\n    vec2 pPlus,pMinus,Delta;\n    schottkyEndpoints(A,B,pPlus,pMinus,Delta);\n    vec2 lambda = -cdiv(vec2(4.0*A.radius*B.radius,0.0), cmul(csub(B.center-A.center,Delta), csub(B.center-A.center,Delta)));\n\n    float t = 0.5 + 0.5*sin(iTime*0.7);\n    vec2 z = uv;\n    vec2 mapped = schottkyFlow(z,pPlus,pMinus,lambda,t);\n\n    float dA = abs(length(z - A.center) - A.radius);\n    float dB = abs(length(z - B.center) - B.radius);\n    vec3 col = vec3(0.95);\n    col = mix(col, vec3(0.1,0.3,0.9), smoothstep(0.005,0.0,dA));\n    col = mix(col, vec3(0.9,0.2,0.2), smoothstep(0.005,0.0,dB));\n\n    col = mix(col, vec3(1.0,0.8,0.0), smoothstep(0.03,0.0,length(z - pPlus)));\n    col = mix(col, vec3(0.0,0.8,0.2), smoothstep(0.03,0.0,length(z - pMinus)));\n\n    float d = length(mapped - z);\n    col *= 1.0 - 0.2*exp(-30.0*d*d);\n    fragColor = vec4(col,1.0);\n}\n\nFigure\n\n\n\nAnimated single Schottky identification",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#extending-to-multiple-generators",
    "href": "schottky.html#extending-to-multiple-generators",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.9 9. Extending to multiple generators",
    "text": "D.9 9. Extending to multiple generators\nA Schottky group of genus \\(g\\) is generated by \\(g\\) such transformations.\nEach generator \\(A_i\\) identifies two disjoint circles \\((C_i,C_i')\\).\nThe group is free, and its limit set — the accumulation set of all group orbits — forms a fractal subset of the sphere.\nThe simplest nontrivial example is \\(g=2\\).\nTwo generators \\(A,B\\) identify two pairs of circles.\nIterating points under both transformations yields a dense web of circles that visually approximates the group’s limit set.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#shader-2-two-generator-schottky-group",
    "href": "schottky.html#shader-2-two-generator-schottky-group",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.10 10. Shader 2: Two-generator Schottky group",
    "text": "D.10 10. Shader 2: Two-generator Schottky group\nThe following shader is a simplified pedagogical version of the full two-generator Schottky program.\nIt iterates points under two circle identifications and colors the plane by iteration depth and generator color.\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3 color;\n};\n\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    vec2 w = (z - gen.interior.center)/gen.interior.radius;\n    float invScale = 1.0/dot(w,w);\n    vec2 v = cdiv(vec2(1.0,0.0), w);\n    float rScale = gen.exterior.radius/gen.interior.radius;\n    scale *= invScale * rScale;\n    float c = cos(gen.rotation), s = sin(gen.rotation);\n    vec2 rotated = vec2(c*v.x - s*v.y, s*v.x + c*v.y);\n    return gen.exterior.center + gen.exterior.radius*rotated;\n}\n\nbool inCircle(vec2 z, Circle c) { return length(z - c.center) &lt; c.radius; }\n\nvec3 iterate(vec2 z, Generator A, Generator B) {\n    vec3 col = vec3(1.0);\n    float scale = 1.0;\n    for(int i=0;i&lt;25;i++){\n        bool moved=false;\n        if(inCircle(z,A.interior)){ z=schottkyMap(z,A,scale); col=mix(col,A.color,0.5); moved=true;}\n        else if(inCircle(z,A.exterior)){ z=schottkyMap(z,A,scale); col=mix(col,A.color,0.5); moved=true;}\n        else if(inCircle(z,B.interior)){ z=schottkyMap(z,B,scale); col=mix(col,B.color,0.5); moved=true;}\n        else if(inCircle(z,B.exterior)){ z=schottkyMap(z,B,scale); col=mix(col,B.color,0.5); moved=true;}\n        if(!moved) break;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    Generator A,B;\n    A.interior=Circle(vec2(0.55,0.55),0.55);\n    A.exterior=Circle(vec2(-0.55,-0.55),0.55);\n    A.rotation=-3.14159/2.0;\n    A.color=vec3(0.95,0.2,0.2);\n    B.interior=Circle(vec2(0.45,-0.45),0.45);\n    B.exterior=Circle(vec2(-0.45,0.45),0.45);\n    B.rotation=3.14159/2.0;\n    B.color=vec3(0.2,0.3,1.0);\n    vec3 color = iterate(uv,A,B);\n    fragColor=vec4(color,1.0);\n}\n\nFigure\n\n\n\nTwo-generator Schottky group limit set",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#the-hyperbolic-viewpoint",
    "href": "schottky.html#the-hyperbolic-viewpoint",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.11 11. The hyperbolic viewpoint",
    "text": "D.11 11. The hyperbolic viewpoint\nIn the upper half-space model of \\(\\mathbb{H}^3\\), each Möbius transformation acts as an isometry.\nA loxodromic element translates along its geodesic axis with endpoints \\(p_\\pm\\) and rotates by \\(\\arg(\\lambda)\\) about that axis.\nIts translation length is \\(L = 2\\log|\\lambda|\\).\nA Schottky group thus corresponds to a collection of disjoint geodesics in \\(\\mathbb{H}^3\\) whose endpoints are the circle pairings.\nThe quotient \\(\\mathbb{H}^3/\\Gamma\\) is a handlebody of genus \\(g\\) — a three-dimensional visualization of the group.\n\nFigure\n\n\n\nGeodesic axes in H3 corresponding to circle identifications",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#further-exploration",
    "href": "schottky.html#further-exploration",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.12 12. Further exploration",
    "text": "D.12 12. Further exploration\n\nExperiment with varying the radii and positions of the circles — watch how the limit set morphs.\n\nAdd transparency and depth shading to suggest the 3D geometry of \\(\\mathbb{H}^3\\).\n\nCompute \\(|\\lambda|\\) and \\(\\arg(\\lambda)\\) for each generator and display the hyperbolic length and twist.\n\nExtend the visualization to stereographic projections or the Poincaré ball model.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#summary",
    "href": "schottky.html#summary",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.13 13. Summary",
    "text": "D.13 13. Summary\nWe have constructed, mathematically and computationally, the core objects of Schottky theory:\n\nMöbius transformations gluing circles,\n\nLoxodromic flows with geodesic axes,\n\nContinuous identifications,\n\nAnd finally, iterated group actions producing fractal limit sets.\n\nThis synthesis of mathematics and GLSL shows that the algebraic, geometric, and analytic views of Möbius transformations coincide beautifully in the language of real-time graphics.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#schottky-groups-in-one-picture",
    "href": "schottky.html#schottky-groups-in-one-picture",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "pick two circles,\nsend exterior of the first to interior of the second,\n(optionally) rotate inside the second.\n\n\n\n\n\nMapping the exterior of one circle to the interior of another",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#the-geometry-from-two-circles-to-a-möbius-map",
    "href": "schottky.html#the-geometry-from-two-circles-to-a-möbius-map",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.2 2. The geometry: from two circles to a Möbius map",
    "text": "D.2 2. The geometry: from two circles to a Möbius map\nLet\n\nCircle 1: center \\(c_1 \\in \\mathbb C\\), radius \\(r_1 &gt; 0\\)\nCircle 2: center \\(c_2 \\in \\mathbb C\\), radius \\(r_2 &gt; 0\\)\n\nWe want a Möbius map \\(f\\) with the property\n\nif \\(|z - c_1| &gt; r_1\\) (outside circle 1) then \\(|f(z) - c_2| &lt; r_2\\) (inside circle 2).\n\nThere is a standard 3-step recipe:\n\nNormalize circle 1 to the unit circle: \\[\nT_1(z) = \\frac{z - c_1}{r_1}.\n\\]\nInvert in the unit circle (this swaps inside and outside): \\[\nJ(w) = \\frac{1}{w}.\n\\]\nDenormalize to circle 2: \\[\nT_2^{-1}(w) = c_2 + r_2 w.\n\\]\n\nSo the Möbius map is \\[\nf(z) = T_2^{-1}( J( T_1(z) ) ) = c_2 + \\frac{r_1 r_2}{z - c_1}.\n\\]\nThis is already in closed form:\n\\[\n\\boxed{ f(z) = c_2 + \\frac{r_1 r_2}{z - c_1} }.\n\\]\nYou can check: if \\(|z - c_1| &gt; r_1\\) then \\(\\left| \\frac{r_1}{z - c_1} \\right| &lt; 1\\) so \\(|f(z) - c_2| = r_2 \\left|\\frac{r_1}{z - c_1}\\right| &lt; r_2\\).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#complex-numbers-and-circles-in-glsl",
    "href": "schottky.html#complex-numbers-and-circles-in-glsl",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.3 3. Complex numbers and circles in GLSL",
    "text": "D.3 3. Complex numbers and circles in GLSL\nGLSL doesn’t have complex numbers, so we’ll use vec2 everywhere. We do want to write things in complex style (multiply, divide, take sqrt), so let’s define those once.\n// -----------------------------------------\n// complex helpers\n// -----------------------------------------\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\n\nvec2 cmul(vec2 a, vec2 b) {\n    // (a.x + i a.y)(b.x + i b.y)\n    return vec2(a.x*b.x - a.y*b.y,\n                a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    // a / b = a * conj(b) / |b|^2\n    float d = dot(b, b);\n    return vec2( (a.x*b.x + a.y*b.y) / d,\n                 (a.y*b.x - a.x*b.y) / d );\n}\n\nvec2 cfloat(float x) {\n    return vec2(x, 0.0);\n}\nLet’s also define a circle struct:\n// -----------------------------------------\n// circle data\n// -----------------------------------------\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nWe will carry this struct through the whole document.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#the-geometric-schottky-map-in-glsl",
    "href": "schottky.html#the-geometric-schottky-map-in-glsl",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.4 4. The geometric Schottky map in GLSL",
    "text": "D.4 4. The geometric Schottky map in GLSL\nLet’s translate the exact 3-step recipe:\n\ncircle → unit circle,\ninvert in unit circle,\nunit circle → circle.\n\nWe also add a rotation at the end (useful in Schottky generators).\n// map arbitrary circle to unit circle\nvec2 toUnitCircle(vec2 z, Circle c) {\n    return (z - c.center) / c.radius;\n}\n\n// map unit circle to arbitrary circle\nvec2 fromUnitCircle(vec2 w, Circle c) {\n    return c.radius * w + c.center;\n}\n\n// inversion in unit circle\nvec2 invertUnit(vec2 w) {\n    return cdiv(vec2(1.0, 0.0), w);\n}\nNow the Schottky generator:\n// schottky-like map: exterior(A) -&gt; interior(B)\n// rotation is angle in radians applied INSIDE B\n// scale is an inout used for distance estimation later\nvec2 schottkyMap(vec2 z, Circle A, Circle B, float rotation, inout float scale) {\n    // step 1: normalize to A\n    vec2 zA = toUnitCircle(z, A);\n\n    // derivative of inversion: |d(1/z)| = 1/|z|^2\n    float inversionScale = 1.0 / dot(zA, zA);\n\n    // step 2: invert\n    vec2 inv = invertUnit(zA);\n\n    // step 3: map to B\n    vec2 inB = fromUnitCircle(inv, B);\n\n    // total radius scale = r2 / r1\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    // step 4: rotate inside B\n    vec2 unitB = (inB - B.center) / B.radius;\n    float c = cos(rotation);\n    float s = sin(rotation);\n    vec2 rotated = vec2(c*unitB.x - s*unitB.y,\n                        s*unitB.x + c*unitB.y);\n\n    return B.center + B.radius * rotated;\n}\nThis is the pedagogical version: each line corresponds to something we can draw on the board.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#conjugation-and-the-1-parameter-flow",
    "href": "schottky.html#conjugation-and-the-1-parameter-flow",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.6 6. Conjugation and the 1-parameter flow",
    "text": "D.6 6. Conjugation and the 1-parameter flow\nEvery loxodromic Möbius transformation with fixed points \\(p_-\\) and \\(p_+\\) can be conjugated to \\(w \\mapsto \\lambda w\\), i.e. a pure dilation/spiral fixing \\(0\\) and \\(\\infty\\).\nDefine \\[\nh(z) = \\frac{z - p_-}{z - p_+}.\n\\]\nThen \\[\ng = h \\circ f \\circ h^{-1}\n\\] fixes \\(0\\) and \\(\\infty\\), so \\(g(w) = \\lambda w\\) for some \\(\\lambda \\in \\mathbb C^\\times\\).\nTo animate, define \\[\ng_t(w) = \\lambda^t w, \\quad f_t = h^{-1} \\circ g_t \\circ h.\n\\]\nSo the movie is \\[\nf_t(z) = h^{-1}( \\lambda^t h(z) ).\n\\]\nWe already wrote csqrt. Now write the conjugators and complex log/exp:\nvec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {\n    return cdiv(z - pMinus, z - pPlus);\n}\n\nvec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {\n    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));\n}\n\n// complex log\nvec2 clogc(vec2 z) {\n    float r = length(z);\n    float th = atan(z.y, z.x);\n    return vec2(log(r), th);\n}\n\n// complex exp\nvec2 cexpc(vec2 z) {\n    float ex = exp(z.x);\n    return vec2(ex * cos(z.y), ex * sin(z.y));\n}\nWe also need the multiplier. From the derivation:\n\\[\n\\lambda = - \\frac{4 r_1 r_2}{(c_2 - c_1 - \\Delta)^2}\n\\]\nso\nvec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n\n    vec2 denom  = (c2 - c1) - Delta;\n    vec2 denom2 = cmul(denom, denom);\n    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);\n    return cdiv(num, denom2);\n}\nFinally the flow:\nvec2 schottkyFlow(vec2 z,\n                  vec2 pPlus, vec2 pMinus,\n                  vec2 lambda,\n                  float t)\n{\n    // lambda^t = exp(t * log(lambda))\n    vec2 loglam = clogc(lambda);\n    vec2 lam_t  = cexpc(t * loglam);\n\n    vec2 w  = hMap(z, pPlus, pMinus);\n    vec2 w2 = cmul(lam_t, w);\n    return hInv(w2, pPlus, pMinus);\n}\nSo now we have every mathematical piece.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#full-shader-1-animated-single-identification",
    "href": "schottky.html#full-shader-1-animated-single-identification",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.7 7. Full shader 1: animated single identification",
    "text": "D.7 7. Full shader 1: animated single identification\nThis is a complete Shadertoy-style fragment shader that:\n\ndefines two circles;\ncomputes their loxodromic map;\nfinds the fixed points;\nanimates the identification by applying \\(f_t\\) to sample points on circle 1;\ndraws the circles and the fixed points.\n\nYou can paste this as-is into Shadertoy.\n// =========================================\n// Shader 1: animated Schottky identification\n// =========================================\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2((a.x*b.x + a.y*b.y)/d,\n                (a.y*b.x - a.x*b.y)/d);\n}\nvec2 cfloat(float x) { return vec2(x,0.0); }\n\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float t = sqrt(0.5*(r + z.x));\n    float s = (z.y &gt;= 0.0) ? sqrt(0.5*(r - z.x)) : -sqrt(0.5*(r - z.x));\n    return vec2(t, s);\n}\n\nvoid schottkyEndpoints(Circle A, Circle B,\n                       out vec2 pPlus, out vec2 pMinus, out vec2 Delta)\n{\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n    vec2 sum   = c1 + c2;\n    vec2 diff  = c1 - c2;\n    vec2 diff2 = cmul(diff, diff);\n    Delta  = csqrt( diff2 + cfloat(4.0 * r1 * r2) );\n    pPlus  = 0.5 * (sum + Delta);\n    pMinus = 0.5 * (sum - Delta);\n}\n\nvec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n    vec2 denom  = (c2 - c1) - Delta;\n    vec2 denom2 = cmul(denom, denom);\n    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);\n    return cdiv(num, denom2);\n}\n\nvec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {\n    return cdiv(z - pMinus, z - pPlus);\n}\nvec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {\n    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));\n}\nvec2 clogc(vec2 z) {\n    float r = length(z);\n    float th = atan(z.y, z.x);\n    return vec2(log(r), th);\n}\nvec2 cexpc(vec2 z) {\n    float ex = exp(z.x);\n    return vec2(ex * cos(z.y), ex * sin(z.y));\n}\nvec2 schottkyFlow(vec2 z, vec2 pPlus, vec2 pMinus, vec2 lambda, float t) {\n    vec2 loglam = clogc(lambda);\n    vec2 lam_t  = cexpc(t * loglam);\n    vec2 w  = hMap(z, pPlus, pMinus);\n    vec2 w2 = cmul(lam_t, w);\n    return hInv(w2, pPlus, pMinus);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // map screen to complex plane\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    float zoom = 1.8;\n    vec2 z = vec2(\n        (uv.x - 0.5) * 2.0 * zoom * aspect,\n        (uv.y - 0.5) * 2.0 * zoom\n    );\n\n    // define two circles\n    Circle A;\n    A.center = vec2(-0.6, 0.1);\n    A.radius = 0.35;\n\n    Circle B;\n    B.center = vec2(0.7, -0.15);\n    B.radius = 0.45;\n\n    // fixed points and lambda\n    vec2 pPlus, pMinus, Delta;\n    schottkyEndpoints(A, B, pPlus, pMinus, Delta);\n    vec2 lambda = schottkyLambda(A, B, Delta);\n\n    // time parameter in [0,1]\n    float t = 0.5 + 0.5 * sin(iTime * 0.7);\n\n    // background\n    vec3 col = vec3(0.95);\n\n    // draw circles\n    float dA = abs(length(z - A.center) - A.radius);\n    float dB = abs(length(z - B.center) - B.radius);\n    col = mix(col, vec3(0.1,0.3,0.9), smoothstep(0.005, 0.0, dA));\n    col = mix(col, vec3(0.9,0.2,0.2), smoothstep(0.005, 0.0, dB));\n\n    // draw fixed points\n    float f1 = smoothstep(0.03, 0.0, length(z - pPlus));\n    float f2 = smoothstep(0.03, 0.0, length(z - pMinus));\n    col = mix(col, vec3(1.0,0.8,0.0), f1);\n    col = mix(col, vec3(0.0,0.8,0.2), f2);\n\n    // draw moving image of circle A as dots\n    float imgMask = 0.0;\n    const int N = 80;\n    for (int i = 0; i &lt; N; i++) {\n        float ang = 6.2831853 * float(i) / float(N);\n        vec2 pt = A.center + A.radius * vec2(cos(ang), sin(ang));\n        vec2 imgPt = schottkyFlow(pt, pPlus, pMinus, lambda, t);\n        float m = smoothstep(0.03, 0.0, length(z - imgPt));\n        imgMask = max(imgMask, m);\n    }\n    col = mix(col, vec3(0.35, 0.05, 0.6), imgMask);\n\n    fragColor = vec4(col, 1.0);\n}\nThat’s a complete first shader.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#from-one-generator-to-two-the-group-picture",
    "href": "schottky.html#from-one-generator-to-two-the-group-picture",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.8 8. From one generator to two: the group picture",
    "text": "D.8 8. From one generator to two: the group picture\nNow let’s get to your uploaded program: we don’t just have one identification, we have two, and we want to keep applying them to bring a point back into a fundamental domain. This is the “practical Schottky renderer”:\n\nwe have two generators genA and genB;\neach generator has two circles (call them “interior” and “exterior” — i.e. the two we pair);\nif the current point is inside one of those circles, we apply the corresponding Schottky map (or the inverse one);\nwe keep track of a scale factor for distance estimation;\nwe stop after some number of iterations and draw boundaries.\n\nWe can reuse the same geometric map, just wrapped in a Generator struct.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#full-shader-2-two-generator-schottky-group",
    "href": "schottky.html#full-shader-2-two-generator-schottky-group",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.18 9. Full shader 2: two-generator Schottky group",
    "text": "D.18 9. Full shader 2: two-generator Schottky group\nThis is a complete, self-contained version of your group renderer, but rewritten in the geometric style we developed:\n// ============================================\n// Shader 2: Schottky group with two generators\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\n// ------------------------------\n// complex helpers\n// ------------------------------\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y,\n                a.y*b.x - a.x*b.y) / d;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2(c*z.x - s*z.y,\n                s*z.x + c*z.y);\n}\n\n// ------------------------------\n// circle + generator structs\n// ------------------------------\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3 color;\n};\n\nbool isInsideCircle(vec2 z, Circle c) {\n    return length(z - c.center) &lt; c.radius;\n}\n\nfloat distanceToCircle(vec2 z, Circle c) {\n    return length(z - c.center) - c.radius;\n}\n\n// ------------------------------\n// geometric schottky map (factored)\n// maps exterior(interiorCircle) -&gt; interior(exteriorCircle)\n// ------------------------------\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    // normalize to A\n    vec2 zA = (z - A.center) / A.radius;\n\n    // inversion derivative\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale    = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    // invert\n    vec2 inv = cdiv(vec2(1.0,0.0), zA);\n\n    // to B\n    vec2 inB = B.center + B.radius * inv;\n\n    // rotate in B\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n    return B.center + B.radius * unitB;\n}\n\n// inverse map: undo rotation, normalize to B, invert, go to A\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    // undo rotation in B\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n\n    // normalize to B\n    vec2 zB = (pre - B.center) / B.radius;\n\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale    = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n\n    // invert and go to A\n    vec2 inv = cdiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\n// ------------------------------\n// iteration\n// ------------------------------\nstruct IterationResult {\n    vec3 color;\n    vec2 finalPosition;\n    float scale;\n};\n\nIterationResult iterateSchottky(vec2 z, Generator genA, Generator genB) {\n    vec3 color = vec3(1.0);\n    float scale = 1.0;\n\n    for (int i = 0; i &lt; MAX_ITERATIONS; i++) {\n        bool moved = false;\n\n        if (isInsideCircle(z, genA.interior)) {\n            z = schottkyMap(z, genA, scale);\n            color = mix(color, genA.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genA.exterior)) {\n            z = inverseSchottkyMap(z, genA, scale);\n            color = mix(color, genA.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genB.interior)) {\n            z = schottkyMap(z, genB, scale);\n            color = mix(color, genB.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genB.exterior)) {\n            z = inverseSchottkyMap(z, genB, scale);\n            color = mix(color, genB.color, 0.5);\n            moved = true;\n        }\n\n        if (!moved) break;\n    }\n\n    IterationResult result;\n    result.color = color;\n    result.finalPosition = z;\n    result.scale = scale;\n    return result;\n}\n\n// ------------------------------\n// distance estimation (same idea as your program)\n// ------------------------------\nfloat distanceToGenerator(vec2 z, Generator gen) {\n    float d1 = abs(distanceToCircle(z, gen.interior));\n    float d2 = abs(distanceToCircle(z, gen.exterior));\n    return min(d1, d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator genA, Generator genB) {\n    return min(distanceToGenerator(z, genA),\n               distanceToGenerator(z, genB));\n}\n\nfloat correctedDistance(IterationResult result, Generator genA, Generator genB) {\n    float d = distanceToSchottkyCircles(result.finalPosition, genA, genB);\n    float positionCorrection = 1.0 / (10.0 + length(result.finalPosition));\n    return d / (result.scale * positionCorrection);\n}\n\n// ------------------------------\n// rendering\n// ------------------------------\nvec3 renderSchottky(IterationResult result, Generator genA, Generator genB) {\n    float d = correctedDistance(result, genA, genB);\n    float pixel = 1.0 / iResolution.y;\n    float thickness = 5.5 * pixel;\n    float boundary = smoothstep(0.0, thickness, abs(d) - thickness);\n    return mix(vec3(0.0), result.color, boundary);\n}\n\n// ------------------------------\n// generator setup\n// ------------------------------\nvoid setupGenerators(out Generator genA, out Generator genB, float time) {\n    float t = 3.0 * time;\n    float s = 1.05 + 0.05 * cos(t);\n\n    genA.interior.center = vec2(0.55, 0.55) * s;\n    genA.interior.radius = 0.55;\n    genA.exterior.center = vec2(-0.55, -0.55) * s;\n    genA.exterior.radius = 0.55;\n    genA.rotation = -PI / 2.0;\n    genA.color = vec3(0.95, 0.2, 0.2);\n\n    genB.interior.center = vec2(0.45, -0.45) * s;\n    genB.interior.radius = 0.45;\n    genB.exterior.center = vec2(-0.45, 0.45) * s;\n    genB.exterior.radius = 0.45;\n    genB.rotation = PI / 2.0;\n    genB.color = vec3(0.2, 0.3, 1.0);\n}\n\n// ------------------------------\n// main\n// ------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Generator genA, genB;\n    setupGenerators(genA, genB, iTime);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n\n    IterationResult result = iterateSchottky(uv, genA, genB);\n    vec3 color = renderSchottky(result, genA, genB);\n\n    fragColor = vec4(color, 1.0);\n}\nThat’s the full group shader, expressed the way we described the geometry.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#hyperbolic-geometry-comments-for-people-in-the-room",
    "href": "schottky.html#hyperbolic-geometry-comments-for-people-in-the-room",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.18 10. Hyperbolic geometry comments (for people in the room)",
    "text": "D.18 10. Hyperbolic geometry comments (for people in the room)\n\nEvery Möbius transformation we wrote acts as an orientation-preserving isometry of \\(\\mathbb H^3\\) (upper half-space model).\nA loxodromic element has two fixed points on the sphere at infinity; in our formulas these are the solutions \\[\nz = \\frac{c_1 + c_2 \\pm \\sqrt{(c_1 - c_2)^2 + 4 r_1 r_2}}{2}.\n\\]\nThe conjugated form \\(w \\mapsto \\lambda w\\) acts by a combined translation and rotation along the geodesic with those endpoints.\nThe hyperbolic translation length of that element is \\[\nL = 2 \\log |\\lambda|.\n\\] So if you want to display the hyperbolic length in the shader (e.g. as text or as a color modulation), just compute lambda, take length(lambda) (its modulus), and apply 2.0 * log(modulus).\n\nThis is the conceptual bridge for the people in your audience who do 3-manifolds and want to see the 2D shader as a genuine boundary-at-infinity dynamical system.\n\nThat’s a full chapter’s worth of math + code, and it ends in two fully runnable shaders. You can now prepend your own YAML/front-matter and slot it into your Quarto book. If you want, I can split it into “Lesson 1: single generator” and “Lesson 2: two generators” for readability.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#drawing-the-limit-set-of-a-schottky-group",
    "href": "schottky.html#drawing-the-limit-set-of-a-schottky-group",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.8 Drawing the Limit Set of a Schottky Group",
    "text": "D.8 Drawing the Limit Set of a Schottky Group\nThese notes continue our exploration of Möbius transformations in GLSL, now focusing on Schottky groups—the simplest discrete groups of Möbius transformations—and how to visualize their limit sets using shader iteration.\nOur audience is assumed to know hyperbolic geometry and group theory but to be new to GPU programming. We’ll therefore explain everything twice: once mathematically, and once as a computational recipe.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#what-we-are-drawing-mathematically",
    "href": "schottky.html#what-we-are-drawing-mathematically",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.9 1. What We Are Drawing, Mathematically",
    "text": "D.9 1. What We Are Drawing, Mathematically\nLet \\(\\Gamma \\subset \\mathrm{PSL}(2,\\mathbb{C})\\) be a finitely generated group of Möbius transformations. For any point \\(z_0 \\in \\widehat{\\mathbb{C}}\\), its orbit under \\(\\Gamma\\) is\n\\[\n\\Gamma z_0 = \\{ g(z_0) : g \\in \\Gamma \\}.\n\\]\nThe limit set of \\(\\Gamma\\) is the closure of this orbit:\n\\[\n\\Lambda(\\Gamma) = \\overline{ \\Gamma z_0 }.\n\\]\nFor a classical Schottky group—generated by finitely many loxodromic Möbius transformations each identifying two disjoint circles—the limit set \\(\\Lambda(\\Gamma)\\) is a Cantor-like subset of the sphere at infinity. The complement \\(\\Omega = \\widehat{\\mathbb{C}} \\setminus \\Lambda(\\Gamma)\\) is the domain of discontinuity, on which \\(\\Gamma\\) acts properly discontinuously.\nWe can visualize \\(\\Lambda(\\Gamma)\\) by testing points in the complex plane: points that escape the system of circles belong to \\(\\Omega\\), while points that never escape approximate the limit set.\n\n\n\nFigure: Two pairs of disjoint circles generate a rank-2 Schottky group. Arrows indicate how each pair is identified by a loxodromic Möbius transformation.\n\n\nFigure D.1",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#thinking-algorithmically",
    "href": "schottky.html#thinking-algorithmically",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.10 2. Thinking Algorithmically",
    "text": "D.10 2. Thinking Algorithmically\nImagine throwing a dart at the complex plane: you hit a point \\(z\\). We now repeatedly apply the Schottky generators to fold the plane back into the fundamental domain.\nIf \\(z\\) lands inside one of the paired circles \\(C_i\\) (say the “interior” circle of generator \\(A_i\\)), we apply the Möbius transformation \\(A_i\\) to move it to the paired exterior circle \\(C_i'\\). If it lands inside \\(C_i'\\), we apply \\(A_i^{-1}\\) instead.\nIf after a few steps the point leaves all circles, we say it escaped (it lies in \\(\\Omega\\)). If it never escapes, it’s likely in or near the limit set.\n\nPseudocode\nfor each pixel z:\n    scale = 1\n    color = white\n    for k = 1..N:\n        if z inside A.interior:   z = A(z)\n        elif z inside A.exterior: z = A^{-1}(z)\n        elif z inside B.interior: z = B(z)\n        elif z inside B.exterior: z = B^{-1}(z)\n        else: break\nThe loop terminates when the point leaves all circles, or after a fixed number of steps.\nThe color records which generator acted last; the scale tracks the cumulative derivative \\(|f'(z)|\\) and will later give us a distance estimate.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#from-mathematics-to-pixels",
    "href": "schottky.html#from-mathematics-to-pixels",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.11 3. From Mathematics to Pixels",
    "text": "D.11 3. From Mathematics to Pixels\nEach pixel on screen represents a complex number \\(z = x + iy\\).\nThe shader’s main loop implements exactly the pseudocode above. It repeatedly applies the Möbius generators and their inverses to test how the orbit of \\(z\\) behaves.\n\nIf \\(z\\) escapes, it belongs to the bright background (domain of discontinuity).\nIf \\(z\\) stays trapped, it’s near the dark filigree of the limit set.\n\n\n\n\nFigure: Each pixel represents a complex point \\(z\\). The shader iterates Möbius generators to decide whether it escapes (white) or remains trapped (black).\n\n\nFigure D.2\n\n\n\nWe color pixels by which generator last acted, creating the characteristic red-blue pattern of a two-generator Schottky group.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#distance-estimation-and-smooth-boundaries",
    "href": "schottky.html#distance-estimation-and-smooth-boundaries",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.12 4. Distance Estimation and Smooth Boundaries",
    "text": "D.12 4. Distance Estimation and Smooth Boundaries\nIf we merely colored points as “in” or “out,” the boundary would look jagged. To smooth it, we use distance estimation.\nFor a Möbius map \\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\] the derivative is \\[\nf'(z) = -\\frac{r_1 r_2}{(z - c_1)^2}, \\qquad |f'(z)| = \\frac{r_1 r_2}{|z - c_1|^2}.\n\\]\nAfter \\(n\\) iterations the total contraction factor is\n\\[\nS_n = \\prod_{k=0}^{n-1} |f'_k(z_k)|.\n\\]\nThis \\(S_n\\) tells us how much a small neighborhood around \\(z\\) has been rescaled by the group action. The smaller \\(S_n\\), the closer we are to the limit set.\nIn practice, we track a variable scale such that scale *= 1/|z|^2 each time we invert a circle, then multiply by the ratio of circle radii. The estimated distance to the limit set is\n\\[\nd \\approx \\frac{ \\text{distance to nearest circle} }{ S_n }.\n\\]\nThis gives a smooth measure of proximity, allowing us to use smoothstep to render crisp boundaries.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#implementing-the-algorithm-step-by-step",
    "href": "schottky.html#implementing-the-algorithm-step-by-step",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.13 5. Implementing the Algorithm Step-by-Step",
    "text": "D.13 5. Implementing the Algorithm Step-by-Step\nWe now translate this logic into GLSL, one piece at a time.\n\n5.1. Circles and Generators\nEach generator pairs two circles—an “interior” and an “exterior”—and carries a rotation angle for the twist in the identification.\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3 color;\n};\n\n\n5.2. Core Geometry Operations\nbool isInsideCircle(vec2 z, Circle c) {\n    return length(z - c.center) &lt; c.radius;\n}\n\nfloat distanceToCircle(vec2 z, Circle c) {\n    return length(z - c.center) - c.radius;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;\n}\n\n\n5.3. The Schottky Map\nWe now implement the map that sends the exterior of one circle to the interior of another.\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    vec2 zA = (z - A.center) / A.radius;\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    vec2 inv = complexDiv(vec2(1.0,0.0), zA);\n    vec2 inB = B.center + B.radius * inv;\n\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n\n    return B.center + B.radius * unitB;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n\n    vec2 zB = (pre - B.center) / B.radius;\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n\n    vec2 inv = complexDiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\n\n5.4. A Few Iterations\nTo start, we perform a few iterations and color by the last generator used.\nvec3 iterateColors(vec2 z, Generator A, Generator B) {\n    vec3 color = vec3(1.0);\n    float scale = 1.0;\n\n    for (int i = 0; i &lt; 12; i++) {\n        bool moved = false;\n\n        if (isInsideCircle(z, A.interior)) {\n            z = schottkyMap(z, A, scale);\n            color = A.color; moved = true;\n        }\n        else if (isInsideCircle(z, A.exterior)) {\n            z = inverseSchottkyMap(z, A, scale);\n            color = A.color; moved = true;\n        }\n        else if (isInsideCircle(z, B.interior)) {\n            z = schottkyMap(z, B, scale);\n            color = B.color; moved = true;\n        }\n        else if (isInsideCircle(z, B.exterior)) {\n            z = inverseSchottkyMap(z, B, scale);\n            color = B.color; moved = true;\n        }\n\n        if (!moved) break;\n    }\n\n    return color;\n}\nThis already shows the rough outline of the limit set.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#adding-distance-estimation",
    "href": "schottky.html#adding-distance-estimation",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.14 6. Adding Distance Estimation",
    "text": "D.14 6. Adding Distance Estimation\nWe now compute the minimal distance to all circles and divide by the accumulated scale factor.\nfloat distanceToGenerator(vec2 z, Generator gen) {\n    float d1 = abs(distanceToCircle(z, gen.interior));\n    float d2 = abs(distanceToCircle(z, gen.exterior));\n    return min(d1, d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator A, Generator B) {\n    return min(distanceToGenerator(z, A), distanceToGenerator(z, B));\n}\n\nfloat correctedDistance(vec2 z, float scale, Generator A, Generator B) {\n    float d = distanceToSchottkyCircles(z, A, B);\n    float positionCorrection = 1.0 / (10.0 + length(z));\n    return d / (scale * positionCorrection);\n}\nThe corrected distance gives a scalar field that is small near the limit set. We convert it to a smooth boundary using smoothstep.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#full-shader-two-generator-schottky-group",
    "href": "schottky.html#full-shader-two-generator-schottky-group",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.15 7. Full Shader: Two-Generator Schottky Group",
    "text": "D.15 7. Full Shader: Two-Generator Schottky Group\nThis final program combines everything above into a complete, runnable shader that draws the limit set dynamically.\n// ============================================\n// Schottky Group Renderer (Two Generators)\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\nstruct Circle { vec2 center; float radius; };\nstruct Generator { Circle interior; Circle exterior; float rotation; vec3 color; };\n\nbool isInsideCircle(vec2 z, Circle c) { return length(z - c.center) &lt; c.radius; }\nfloat distanceToCircle(vec2 z, Circle c) { return length(z - c.center) - c.radius; }\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta); float s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;\n}\n\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior; Circle B = gen.exterior;\n    vec2 zA = (z - A.center) / A.radius;\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n    vec2 inv = complexDiv(vec2(1.0,0.0), zA);\n    vec2 inB = B.center + B.radius * inv;\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n    return B.center + B.radius * unitB;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior; Circle B = gen.exterior;\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n    vec2 zB = (pre - B.center) / B.radius;\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n    vec2 inv = complexDiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\nvec3 renderSchottky(vec2 z, Generator A, Generator B) {\n    vec3 color = vec3(1.0); float scale = 1.0;\n    for (int i=0;i&lt;MAX_ITERATIONS;i++) {\n        bool moved=false;\n        if (isInsideCircle(z,A.interior)) { z=schottkyMap(z,A,scale); color=A.color; moved=true; }\n        else if (isInsideCircle(z,A.exterior)) { z=inverseSchottkyMap(z,A,scale); color=A.color; moved=true; }\n        else if (isInsideCircle(z,B.interior)) { z=schottkyMap(z,B,scale); color=B.color; moved=true; }\n        else if (isInsideCircle(z,B.exterior)) { z=inverseSchottkyMap(z,B,scale); color=B.color; moved=true; }\n        if (!moved) break;\n    }\n    float d = distanceToCircle(z, A.interior);\n    d = min(d, distanceToCircle(z, A.exterior));\n    d = min(d, distanceToCircle(z, B.interior));\n    d = min(d, distanceToCircle(z, B.exterior));\n    float pixel = 1.0 / iResolution.y;\n    float boundary = smoothstep(0.0, 5.5*pixel, abs(d) - 5.5*pixel);\n    return mix(vec3(0.0), color, boundary);\n}\n\nvoid setupGenerators(out Generator A, out Generator B, float time) {\n    float t = 3.0 * time; float s = 1.05 + 0.05 * cos(t);\n    A.interior.center = vec2(0.55, 0.55) * s;\n    A.interior.radius = 0.55;\n    A.exterior.center = vec2(-0.55, -0.55) * s;\n    A.exterior.radius = 0.55;\n    A.rotation = -PI/2.0; A.color = vec3(0.95,0.2,0.2);\n    B.interior.center = vec2(0.45,-0.45) * s;\n    B.interior.radius = 0.45;\n    B.exterior.center = vec2(-0.45, 0.45) * s;\n    B.exterior.radius = 0.45;\n    B.rotation = PI/2.0; B.color = vec3(0.2,0.3,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Generator A,B; setupGenerators(A,B,iTime);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n    vec3 col = renderSchottky(uv,A,B);\n    fragColor = vec4(col,1.0);\n}",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#mathematical-commentary",
    "href": "schottky.html#mathematical-commentary",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.16 8. Mathematical Commentary",
    "text": "D.16 8. Mathematical Commentary\nEvery pixel corresponds to a point on the Riemann sphere, and each iteration applies one of the generators of \\(\\Gamma\\). Points that forever remain in the union of fundamental disks approximate the limit set \\(\\Lambda(\\Gamma)\\).\nIn hyperbolic terms, each generator corresponds to a loxodromic isometry of \\(\\mathbb{H}^3\\), acting by a translation and rotation along its geodesic axis. The limit set we see on the screen is the ideal boundary of the handlebody \\(\\mathbb{H}^3 / \\Gamma\\).\nThe parameter \\(\\lambda\\) of each loxodromic element encodes both the translation length \\(L = 2\\log|\\lambda|\\) and the rotation angle \\(\\arg(\\lambda)\\), which together determine how the paired circles are glued in 3D.\n\n\n\nFigure: The Schottky group defines a handlebody in \\(\\mathbb{H}^3\\). Its limit set is the fractal boundary seen in the shader.\n\n\nFigure D.3\n\n\n\n\nPerfect — here’s the final optional section written in Quarto-ready Markdown style (no YAML front matter, standard LaTeX math, fenced GLSL code). You can paste it directly at the end of your existing .qmd file.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "schottky.html#optional-making-the-limit-set-look-good",
    "href": "schottky.html#optional-making-the-limit-set-look-good",
    "title": "Appendix D — Schottky Groups, Möbius Maps, and GLSL",
    "section": "D.17 Optional: Making the Limit Set Look Good",
    "text": "D.17 Optional: Making the Limit Set Look Good\nUp to now, our emphasis has been on getting the geometry right: the correct Möbius transformations, iteration rules, and distance estimators that reveal the limit set of a Schottky group. But if you’ve ever run the simple version of the shader, you may have noticed that the picture looks fuzzy: the black circle boundaries are uneven, and their thickness changes with screen resolution.\nTo produce publication-quality limit sets, we must teach the shader to think like a cartographer — to measure in screen space, not world space, and to correct for the distortions of the Möbius maps. This section develops the refined version of the renderer that does just that.\n\n\n1. The Problem: Thickness and Scale\nIn the mathematical world, our circles are perfect. But on a screen, a “circle” is made of pixels. When you zoom or change resolution, the physical thickness of the black border changes unless we explicitly tell the shader what a pixel means in world coordinates.\nThe base shader also ignored how much each Möbius map contracts or expands space. If a point has been contracted by a factor of 10⁶ after several iterations, its Euclidean distance to a circle means something very different than it did at the start. We need to correct by the product of derivative magnitudes — that’s our scale variable.\n\n\n\n2. The Mathematical Correction\nFor the Schottky map\n\\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\]\nwe know\n\\[\nf'(z) = -\\frac{r_1 r_2}{(z - c_1)^2}, \\qquad |f'(z)| = \\frac{r_1 r_2}{|z - c_1|^2}.\n\\]\nSo each time we apply a generator, we update\nscale *= (r1 * r2) / dot(z - c1, z - c1);\nAt the end of the iteration, dividing by this scale converts the raw circle distance into a true hyperbolic-style distance that measures how close we are to the limit set.\n\n\n\n3. Measuring Thickness in Screen Space\nA pixel on the screen has a definite height in normalized coordinates:\nfloat pixelSize = 1.0 / iResolution.y;\nTo make the black borders a consistent width across displays, we choose a fixed multiple:\nfloat boundaryThickness = 5.5 * pixelSize;\nThat means “make the border about five pixels thick,” regardless of zoom or monitor size. Using smoothstep with that value ensures an anti-aliased transition rather than a hard cutoff.\n\n\n\n4. Stabilizing the Far Corners\nPoints far from the origin tend to have large coordinate values. Without correction, their distances become exaggerated, and black borders vanish in those regions. A simple damping factor\nfloat positionCorrection = 1.0 / (10.0 + length(result.finalPosition));\ntames this effect by decreasing the apparent distance when the point is far away.\n\n\n\n5. The Final “Production” Shader\nPutting these refinements together gives the version below, which produces smooth, consistent outlines and a crisp fractal limit set.\n// ============================================\n// SCHOTTKY GROUP RENDERER - With Distance Estimation\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\n// ---------- Complex arithmetic ----------\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y,\n                a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta), s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\n\n// ---------- Circles ----------\nstruct Circle { vec2 center; float radius; };\nbool  isInsideCircle(vec2 z, Circle c){return length(z-c.center)&lt;c.radius;}\nfloat distanceToCircle(vec2 z, Circle c){return length(z-c.center)-c.radius;}\n\n// ---------- Generator ----------\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3  color;\n};\n\n// ---------- Möbius and inverse ----------\nvec2 schottkyMap(vec2 z, Generator g, inout float scale){\n    vec2 c1=g.interior.center, c2=g.exterior.center;\n    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;\n    float denom=max(dot(z-c1,z-c1),1e-6);\n    scale*=(k/denom);\n    vec2 base=c2+complexDiv(vec2(k,0.0),z-c1);\n    vec2 unit=(base-c2)/r2;\n    unit=complexRotate(unit,g.rotation);\n    return c2+r2*unit;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator g, inout float scale){\n    vec2 c1=g.interior.center, c2=g.exterior.center;\n    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;\n    float denom=max(dot(z-c2,z-c2),1e-6);\n    scale*=(k/denom);\n    vec2 unit=(z-c2)/r2;\n    unit=complexRotate(unit,-g.rotation);\n    vec2 baseOut=c2+r2*unit;\n    return c1+complexDiv(vec2(k,0.0),baseOut-c2);\n}\n\n// ---------- Iteration ----------\nstruct IterationResult{vec3 color; vec2 finalPosition; float scale;};\n\nIterationResult iterateSchottky(vec2 z, Generator A, Generator B){\n    vec3 color=vec3(1.0); float scale=1.0;\n    for(int i=0;i&lt;MAX_ITERATIONS;i++){\n        bool moved=false;\n        if(isInsideCircle(z,A.interior)){z=schottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}\n        else if(isInsideCircle(z,A.exterior)){z=inverseSchottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}\n        else if(isInsideCircle(z,B.interior)){z=schottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}\n        else if(isInsideCircle(z,B.exterior)){z=inverseSchottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}\n        if(!moved)break;\n    }\n    return IterationResult(color,z,scale);\n}\n\n// ---------- Distance estimation ----------\nfloat distanceToGenerator(vec2 z, Generator g){\n    float d1=abs(distanceToCircle(z,g.interior));\n    float d2=abs(distanceToCircle(z,g.exterior));\n    return min(d1,d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator A, Generator B){\n    return min(distanceToGenerator(z,A),distanceToGenerator(z,B));\n}\n\nfloat correctedDistance(IterationResult r, Generator A, Generator B){\n    float d=distanceToSchottkyCircles(r.finalPosition,A,B);\n    float positionCorrection=1.0/(10.0+length(r.finalPosition));\n    return d/(r.scale*positionCorrection);\n}\n\n// ---------- Rendering ----------\nvec3 renderSchottky(IterationResult r, Generator A, Generator B){\n    float d=correctedDistance(r,A,B);\n    float pixelSize=1.0/iResolution.y;\n    float boundaryThickness=5.5*pixelSize;\n    float boundary=smoothstep(0.0,boundaryThickness,abs(d)-boundaryThickness);\n    return mix(vec3(0.0),r.color,boundary);\n}\n\n// ---------- Scene setup ----------\nvoid setupGenerators(out Generator A,out Generator B,float time){\n    float t=3.0*time, s=1.05+0.05*cos(t);\n    A.interior.center=vec2(0.55,0.55)*s; A.interior.radius=0.55;\n    A.exterior.center=vec2(-0.55,-0.55)*s; A.exterior.radius=0.55;\n    A.rotation=-PI/2.0; A.color=vec3(0.95,0.2,0.2);\n    B.interior.center=vec2(0.45,-0.45)*s; B.interior.radius=0.45;\n    B.exterior.center=vec2(-0.45,0.45)*s; B.exterior.radius=0.45;\n    B.rotation=PI/2.0; B.color=vec3(0.2,0.3,1.0);\n}\n\n// ---------- Main ----------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    Generator A,B; setupGenerators(A,B,iTime);\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*=2.0;\n    IterationResult r=iterateSchottky(uv,A,B);\n    vec3 color=renderSchottky(r,A,B);\n    fragColor=vec4(color,1.0);\n}\nThis shader is functionally identical to the simpler pedagogical one but with:\n\nMöbius-formula correctness rather than a three-step normalize/invert/denormalize approach.\nDerivative-based scaling for accurate distance estimation.\nScreen-space boundary control (5.5 * pixelSize) for consistent black borders.\nStabilized far-field correction so the picture remains uniform everywhere.\n\nThe result is a crisp, visually stable limit set—mathematically faithful and aesthetically satisfying.\n\n\n\n6. What to Experiment With\n\nChange boundaryThickness from 5.5 to 3.0 or 8.0 to feel how border width changes.\nTry different radii or centers for the generators to see how the limit set morphs.\nReplace smoothstep with a hard threshold to understand aliasing artifacts.\nAnimate the rotations genA.rotation and genB.rotation to see how the twists deform the pattern.\n\n\nThis “advanced” version closes the loop between mathematical fidelity and graphical clarity. Students who have followed the whole derivation will now appreciate that the small extra factors—scale, pixelSize, and positionCorrection—are what make a shader image mathematically precise and visually beautiful at the same time.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Schottky Groups, Möbius Maps, and GLSL</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html",
    "href": "day1-rewrite.html",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "1.1 Overview\nToday we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.\nBy the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#what-is-a-shader",
    "href": "day1-rewrite.html#what-is-a-shader",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.2 What is a Shader?",
    "text": "1.2 What is a Shader?\n\nMathematical Perspective\nA shader is fundamentally a function \\[f: \\mathbb{R}^2 \\times \\mathbb{R} \\times \\cdots \\to \\mathbb{R}^4\\] that maps pixel coordinates (and potentially time, mouse position, etc.) to color values. For each pixel on the screen, we evaluate this function to determine what color to display.\nHere’s the magic: modern GPUs can evaluate this function for all pixels simultaneously. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!\nThis is completely different from how you might write mathematical visualization code in, say, Python. There you’d have nested loops:\nfor x in range(width):\n    for y in range(height):\n        color[x,y] = f(x, y)\nWith shaders, there are no loops. You write the function f, and the GPU just does it everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.\n\n\n\n\n\n\nWhy is this called a “shader”?\n\n\n\nHistorically, these programs were used for shading 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!\n\n\n\n\nWhy Shadertoy?\nShadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.\nThe platform provides several built-in uniforms (read-only global variables that are the same for all pixels):\n\niResolution: screen resolution as a vec3 (width, height, pixel aspect ratio)\niTime: elapsed time in seconds since the shader started\niMouse: mouse position and click state as a vec4\n\nWe’ll use these throughout the week to create animated, interactive mathematical visualizations.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#first-shader-solid-colors",
    "href": "day1-rewrite.html#first-shader-solid-colors",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.3 First Shader: Solid Colors",
    "text": "1.3 First Shader: Solid Colors\n\nBasic Structure\nEvery Shadertoy shader has the same entry point:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Your code here\n}\nParameters:\n\nfragCoord: the pixel coordinate we’re currently computing, as a vec2 (x, y)\nfragColor: the output color we need to set, as a vec4 (red, green, blue, alpha)\n\nColors are represented in RGBA format with values in \\([0, 1]\\). So vec4(1.0, 0.0, 0.0, 1.0) represents opaque red, while vec4(0.5, 0.5, 0.5, 1.0) is middle gray.\n\n\nExample: Red Screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nThis sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on fragCoord, every pixel gets the same value. Not very exciting—but it’s a start!\n\n\nGLSL Syntax Basics\nBefore we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:\n\n\n\n\n\n\nGLSL Syntax Rules\n\n\n\nSemicolons are required. Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.\nFloating point literals: Write 1.0 not 1 for floating point values. GLSL is very picky about types—if you write 1, it’s an integer, and mixing types causes errors. Get in the habit of always writing the .0.\nVector types: GLSL has built-in types vec2, vec3, vec4 for 2D, 3D, and 4D vectors. You can construct them with:\nvec2 v = vec2(1.0, 2.0);\nvec3 w = vec3(1.0, 2.0, 3.0);\nvec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars\nSwizzling: You can access components by name: v.x, v.y or equivalently v.r, v.g (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: v.yx swaps the coordinates, v.xxx repeats the x-component three times. This is incredibly useful!\n\n\n\n\nAnimating with Time\nLet’s make something that changes:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\nHere iTime grows continuously, sin(iTime) oscillates between \\(-1\\) and \\(1\\), and we remap to \\([0, 1]\\) with the affine transformation \\(x \\mapsto \\frac{1}{2}(1 + x)\\). The screen now pulses between black and red!\nThis pattern—0.5 + 0.5 * sin(...)—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range \\([0,1]\\).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#coordinate-systems",
    "href": "day1-rewrite.html#coordinate-systems",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.4 Coordinate Systems",
    "text": "1.4 Coordinate Systems\n\nRaw Coordinates\nBy default, fragCoord gives pixel coordinates with:\n\nOrigin \\((0, 0)\\) at the bottom-left\n\\(x\\) increases rightward to iResolution.x\n\\(y\\) increases upward to iResolution.y\n\nThis is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!\n\n\nCentered, Normalized Coordinates\nHere’s the standard transformation we’ll use in every shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Center at origin: [-0.5, 0.5]\n    uv = uv - 0.5;\n    \n    // Scale to account for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Now uv is centered and aspect-corrected\n    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)\n    vec2 p = uv * 4.0;  // Now p is in [-2, 2] × [-h, h] where h depends on aspect ratio\n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nLet’s break this down step by step:\n\nNormalize: Dividing by iResolution.xy maps from pixel coordinates to \\([0,1] \\times [0,1]\\)\nCenter: Subtracting \\(0.5\\) shifts the origin to the center: \\([-0.5, 0.5] \\times [-0.5, 0.5]\\)\nAspect correction: Multiplying uv.x by the aspect ratio ensures that equal distances in uv.x and uv.y correspond to equal screen distances—this makes circles actually circular!\nScale: Finally, we scale to whatever viewing window we want for our visualization\n\nFrom now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable p for “position.”\n\n\n\n\n\n\nThe coordinate transformation boilerplate\n\n\n\nYou’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit.\n\n\n\n\nVisualizing Coordinates\nLet’s verify our coordinate system is working by coloring pixels according to their position:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup as above, resulting in p]\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\nYou should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#conditional-coloring-half-planes",
    "href": "day1-rewrite.html#conditional-coloring-half-planes",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.5 Conditional Coloring: Half-Planes",
    "text": "1.5 Conditional Coloring: Half-Planes\n\nThe Concept\nGiven a linear function \\(L(x, y) = ax + by\\), we want to color pixels differently depending on whether \\(L(p) &lt; 0\\) or \\(L(p) \\geq 0\\). This divides the plane into two half-planes—the regions where the function is negative vs. positive.\n\n\nImplementation\nGLSL provides a conditional operator (ternary operator) just like C:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\nLeft half-plane is red, right half-plane is blue. Simple!\n\n\nThe Step Function\nGLSL also provides step(edge, x) which returns \\(0\\) if \\(x &lt; \\text{edge}\\) and \\(1\\) otherwise. This is useful for writing cleaner code without explicit conditionals:\nfloat s = step(0.0, p.x);  // 0 on left, 1 on right\nvec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\nHere mix(a, b, t) performs linear interpolation: \\((1-t)a + tb\\). So when s = 0 we get pure red, when s = 1 we get pure blue.\n\n\n\n\n\n\nWhy use step instead of the ternary operator?\n\n\n\nBoth work fine! The ternary operator ?: is more explicit and familiar if you know C-like languages. But step and mix are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation.\n\n\n\n\nArbitrary Half-Planes\nFor a general line \\(ax + by = 0\\), we just evaluate the corresponding linear function:\nfloat a = 1.0, b = 1.0;\nfloat L = a * p.x + b * p.y;\nvec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\nfragColor = vec4(color, 1.0);\nTry different values of \\(a\\) and \\(b\\) to see different line orientations. The line itself is where \\(L = 0\\), and we’re coloring the two sides differently.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#distance-fields-and-circles",
    "href": "day1-rewrite.html#distance-fields-and-circles",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.6 Distance Fields and Circles",
    "text": "1.6 Distance Fields and Circles\n\nDistance to Center\nThe distance from a point \\(p = (x, y)\\) to the origin is just the usual Euclidean distance: \\[d = \\|p\\| = \\sqrt{x^2 + y^2}\\]\nIn GLSL this is built-in:\nfloat d = length(p);\nThe length() function computes the Euclidean norm of a vector. It works for vec2, vec3, vec4—whatever you need.\n\n\nFilled Circle\nA circle of radius \\(r\\) centered at the origin is the set \\(\\{p : \\|p\\| &lt; r\\}\\)—just points whose distance from the origin is less than \\(r\\). So to color the inside vs. outside of a circle, we just compare distances:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThat’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle.\n\n\nDistance-Based Coloring\nBut we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:\nfloat d = length(p);\nfloat intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\nintensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\nvec3 color = vec3(intensity);\nfragColor = vec4(color, 1.0);\nThis creates a radial gradient—bright at the center, dark at the edges. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!\n\n\nCircle Outline\nWhat if we want to draw just the boundary of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is approximately equal to the radius. Mathematically, we’re coloring the set \\(\\{p : |d(p) - r| &lt; \\epsilon\\}\\) where \\(\\epsilon\\) is a small thickness parameter:\nfloat d = length(p);\nfloat r = 1.0;\nfloat thickness = 0.05;\n\nfloat circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\nvec3 color = vec3(circle_mask);\nfragColor = vec4(color, 1.0);\nThis draws a thin white annulus around the circle. Play with the thickness parameter to see how it affects the line width!\nFor a smoother, anti-aliased edge, GLSL provides smoothstep:\nfloat circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\nThe smoothstep(a, b, x) function performs smooth Hermite interpolation between \\(a\\) and \\(b\\), transitioning gradually instead of having a hard cutoff. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!\n\n\n\n\n\n\nAnti-aliasing in shaders\n\n\n\nThe harsh cutoffs from using &lt; or the ternary operator create jagged, pixelated edges. Functions like smoothstep give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with smoothstep for smoother results.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#grids-and-repetition",
    "href": "day1-rewrite.html#grids-and-repetition",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.7 Grids and Repetition",
    "text": "1.7 Grids and Repetition\n\nModular Arithmetic\nThe modulo operation creates periodic repetition. For a period \\(T\\), the function \\(p \\mapsto (p \\bmod T) - T/2\\) maps \\(\\mathbb{R}\\) to \\([-T/2, T/2]\\) repeatedly—it “folds” the entire real line into a finite interval over and over again.\nIn GLSL, mod(x, T) computes \\(x \\bmod T\\). This is one of the most powerful tools in shader programming!\n\n\nCreating a Grid\nTo create a grid of repeated cells, we apply mod to our coordinates:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup, resulting in p]\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Now cell_p repeats every spacing units\n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis creates an infinite grid of yellow circles! The coordinate transformation cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0 ensures that cell_p is always in the range \\([-\\text{spacing}/2, \\text{spacing}/2]\\), and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.\n\n\n\n\n\n\nThe power of mod\n\n\n\nThink about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation. This is the kind of efficiency that makes shaders special.\n\n\n\n\nAlternating Pattern\nWe can create checkerboard-like patterns by using the cell index to vary colors. To get the cell index, we divide by the spacing and floor:\nvec2 cell_id = floor(p / spacing);\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\n\nvec3 color_a = vec3(1.0, 0.0, 0.0);\nvec3 color_b = vec3(0.0, 0.0, 1.0);\nvec3 bg_color = mix(color_a, color_b, checker);\nHere floor(p / spacing) gives us integer grid indices \\((i, j)\\), and we alternate colors based on the parity of \\(i + j\\). When \\(i + j\\) is even, checker = 0 (red), when odd, checker = 1 (blue).\n\n\nCombining with Circles\nLet’s put it all together—a grid of circles on an alternating background:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // [Coordinate setup]\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}\nTry varying the spacing and r parameters. What happens if you make the circles larger than the cells? What if you use different spacing values for x and y?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#implicit-curves",
    "href": "day1-rewrite.html#implicit-curves",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.8 Implicit Curves",
    "text": "1.8 Implicit Curves\n\nGeneral Principle\nAn implicit curve is defined by an equation \\(F(x, y) = 0\\). Points on the curve satisfy the equation exactly, while points off the curve have \\(F(x,y) \\neq 0\\). To render the curve, we compute \\(F(p)\\) for each pixel and color based on proximity to zero:\nfloat F = [some function of p.x and p.y];\nfloat thickness = 0.05;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nvec3 color = mix(background, curve_color, curve_mask);\nThis is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, whatever you want.\n\n\nExample: Parabola\nThe parabola \\(y = x^2\\) can be written implicitly as \\(F(x, y) = y - x^2 = 0\\):\nfloat F = p.y - p.x * p.x;\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n\nvec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\nfragColor = vec4(color, 1.0);\nYou should see a yellow parabola on a dark blue background. The curve appears wherever \\(|F(x,y)| &lt; 0.1\\)—a thin band around the zero set of \\(F\\).\nOne thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker. This is because we’re thresholding on the value of \\(F\\), not the geometric distance to the curve. For perfectly uniform thickness, you’d need to compute the actual signed distance function—something we’ll talk more about on Day 4.\n\n\nExample: Circle (Implicit Form)\nWe’ve been using \\(\\|p\\| &lt; r\\) for filled circles, but we can also write the circle implicitly as \\(x^2 + y^2 - r^2 = 0\\):\nfloat r = 1.0;\nfloat F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nThis is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The dot(p, p) computes \\(x^2 + y^2\\) efficiently.\n\n\n\n\n\n\nImplicit curves in your homework\n\n\n\nWhen you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation \\(F(x,y) = y - (ax^2 + bx + c)\\) and thresholding on \\(|F| &lt; \\epsilon\\). Make sure to test with various values of \\(a\\), \\(b\\), \\(c\\) to ensure your grapher is robust!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#summary",
    "href": "day1-rewrite.html#summary",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.9 Summary",
    "text": "1.9 Summary\nToday we’ve learned the fundamental tools of shader programming:\n\nShaders as parallel functions: Every pixel evaluates \\(f(x, y, t, \\ldots) \\to \\text{color}\\) simultaneously—no loops required!\nGLSL basics: Syntax, vector types, and built-in functions like length(), step(), and smoothstep()\nCoordinate systems: Centering, normalizing, and scaling for mathematical work\nConditional coloring: Using boolean expressions and step() for discrete color regions\nDistance fields: Using length() to create circles and radial patterns—the foundation for much more complex techniques later\nModular arithmetic: Creating grids and repeating patterns with mod()—infinite complexity with finite computation\nImplicit curves: Rendering curves defined by \\(F(x, y) = 0\\) by thresholding on \\(|F|\\)\n\nWith these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#homework",
    "href": "day1-rewrite.html#homework",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.10 Homework",
    "text": "1.10 Homework\n\nRequired: Parabola Graphing Calculator\nCreate a shader that draws a customizable parabola \\(y = ax^2 + bx + c\\) along with coordinate axes.\nRequirements:\n\nDefine variables a, b, c at the top of your shader (hardcoded values are fine)\nDraw the \\(x\\)-axis and \\(y\\)-axis as thick lines (use the implicit line technique: \\(|y| &lt; \\epsilon\\) for \\(x\\)-axis, \\(|x| &lt; \\epsilon\\) for \\(y\\)-axis)\nPlot the parabola \\(y = ax^2 + bx + c\\) as a thick curve\nUse distinct colors for axes and parabola\nThe visualization should work for any reasonable values of \\(a\\), \\(b\\), \\(c\\)\n\nSuggested approach:\n// Define parameters\nfloat a = 1.0;\nfloat b = 0.0;\nfloat c = 0.0;\n\n// Axes\nfloat x_axis_mask = abs(p.y) &lt; 0.05 ? 1.0 : 0.0;\nfloat y_axis_mask = abs(p.x) &lt; 0.05 ? 1.0 : 0.0;\n\n// Parabola: F(x,y) = y - (ax² + bx + c) = 0\nfloat F = p.y - (a * p.x * p.x + b * p.x + c);\nfloat parabola_mask = abs(F) &lt; 0.1 ? 1.0 : 0.0;\n\n// Combine\nvec3 color = background;\ncolor = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\ncolor = mix(color, parabola_color, parabola_mask);\nTry different values of \\(a\\), \\(b\\), \\(c\\) and verify your grapher works correctly! What happens with negative \\(a\\)? What about \\(b \\neq 0\\)? Make sure the axes and parabola remain visible for all parameter values you try.\n\n\nOptional #1: Animated Curve Family\nCreate a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build intuition!\nSuggestions:\n\nElliptic fibration: Take a cubic polynomial \\(y^2 = x^3 + ax + b\\) and vary one parameter with iTime. The topology of the curve changes dramatically as you pass through singular values!\nLissajous curves: Parametric curves \\(x = A\\sin(at + \\delta)\\), \\(y = B\\sin(bt)\\). Animate \\(\\delta\\) or the frequency ratio to watch the curve morph through different patterns\nCassini ovals: \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). Vary the parameter and watch the curve transition from two separate loops to a single figure-eight-like shape\n\nUse iTime creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes!\n\n\nOptional #2: Beautiful Tiling Pattern\nDesign an aesthetically pleasing tiling pattern using the mod() technique. This is your chance to be creative!\nRequirements:\n\nCreate a non-trivial pattern within a fundamental domain (a single tile)\nUse mod() to repeat it across the plane\nThe pattern should tile seamlessly (edges should match up)\n\nIdeas:\n\nGeometric patterns: nested circles, polygons, stars\nColor gradients that vary by tile position (using cell_id)\nCombinations of implicit curves within each tile\nSymmetry: use abs() to create reflections within tiles\nDistance-based effects: make circles pulse or fade based on iTime and their position in the grid\n\nChallenge: Can you create a pattern that has different symmetries in different tiles? (For example, alternating rotational symmetry using the checkerboard cell_id technique.) Or a pattern where the colors vary smoothly across the tiling, creating a large-scale gradient effect?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day1-rewrite.html#looking-ahead",
    "href": "day1-rewrite.html#looking-ahead",
    "title": "1  Day 1: Introduction to Shader Programming",
    "section": "1.11 Looking Ahead",
    "text": "1.11 Looking Ahead\nTomorrow we’ll use these techniques to explore complex dynamics (the Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). The coordinate system and implicit curve techniques you’ve learned today will be the foundation for everything to come.\nMake sure you’re comfortable with:\n\nSetting up coordinates (the standard transformation from fragCoord to centered, aspect-corrected p)\nComputing distances and implicit functions\n\nUsing mod() for repetition\nConditionally coloring based on mathematical expressions\n\nIf any of these feel shaky, now is the time to practice! Everything builds on this foundation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Day 1: Introduction to Shader Programming</span>"
    ]
  },
  {
    "objectID": "day3.html#part-1-reflection-and-half-spaces-in-euclidean-geometry",
    "href": "day3.html#part-1-reflection-and-half-spaces-in-euclidean-geometry",
    "title": "5  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "5.2 Part 1: Reflection and Half-Spaces in Euclidean Geometry",
    "text": "5.2 Part 1: Reflection and Half-Spaces in Euclidean Geometry\n\nHalf-Spaces and the Reflection Formula\nA half-space is one side of a line. Given a line defined by \\(ax + by = c\\), the half-space is the set of all points satisfying: \\[\\{(x,y) : ax + by &lt; c\\}\\]\nThe complementary half-space is \\(\\{(x,y) : ax + by &gt; c\\}\\). Together, these two regions partition the plane, with the line \\(ax + by = c\\) as their shared boundary.\n\n\n\n\n\n\nHalf-Space Structure\n\n\n\nA half-space has two components: 1. A boundary (the line \\(ax + by = c\\)) 2. A side (the inequality \\(&lt;\\) or \\(&gt;\\))\nWe’ll encode this as: boundary parameters + which side we want. This structure will appear in every geometry we work in today!\n\n\n\n\nDeriving the Reflection Formula\nTo reflect a point \\(\\mathbf{p} = (x, y)\\) across the line \\(ax + by = c\\), we use linear algebra. The normal vector to the line is \\(\\mathbf{n} = (a, b)\\). After normalizing to get \\(\\hat{\\mathbf{n}} = \\mathbf{n}/|\\mathbf{n}|\\), the reflection formula is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere \\(d\\) is the signed distance from \\(\\mathbf{p}\\) to the line: \\[d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\]\nThis is a standard formula from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.\n\n\nImplementation\nLet’s translate this to GLSL:\nvec2 reflectAcrossLine(vec2 p, float a, float b, float c) {\n    // Normal vector to the line\n    vec2 normal = vec2(a, b);\n    float norm = length(normal);\n    normal = normal / norm;  // Normalize to unit vector\n    \n    // Signed distance from point to line\n    float signedDist = (a * p.x + b * p.y - c) / norm;\n    \n    // Reflect: move twice the distance in the normal direction\n    return p - 2.0 * signedDist * normal;\n}\nWe also need to check which side of the line a point is on:\nbool insideHalfSpace(vec2 p, float a, float b, float c) {\n    return a * p.x + b * p.y &lt; c;\n}\nIf the point is on the “wrong” side (outside our desired half-space), we reflect it. If it’s already inside, we do nothing.\n\n\n\nTiling a Strip\nLet’s start with the simplest example: creating a repeating strip pattern. We’ll use two parallel vertical lines at \\(x = 0\\) and \\(x = 1\\) to define our fundamental domain: the strip \\(0 &lt; x &lt; 1\\).\nFor a vertical line at \\(x = c\\), the line equation is \\(x = c\\), which we can write as \\(1 \\cdot x + 0 \\cdot y = c\\). So our parameters are \\(a = 1\\), \\(b = 0\\), \\(c = c\\).\nThe reflection formula simplifies beautifully for vertical lines: \\[\\text{reflect}(x, y) = (2c - x, y)\\]\nWe just flip the \\(x\\)-coordinate around the line position!\nvec2 foldToStrip(vec2 p, int maxIter) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // If left of x = 0, reflect\n        if(p.x &lt; 0.0) {\n            p.x = -p.x;  // Simplified: 2*0 - p.x = -p.x\n            moved = true;\n        }\n        \n        // If right of x = 1, reflect\n        if(p.x &gt; 1.0) {\n            p.x = 2.0 - p.x;  // Simplified: 2*1 - p.x\n            moved = true;\n        }\n        \n        if(!moved) break;  // Inside the strip, done!\n    }\n    return p;\n}\nLet’s see this in action! Here’s a complete shader that draws a simple pattern in the fundamental domain and watches it tile:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // Draw a circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    // Draw the boundary lines\n    if(abs(p.x - 0.0) &lt; 0.02 || abs(p.x - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);  // White boundaries\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a yellow circle repeated horizontally across the screen! The circle is only defined once (in the strip \\(0 &lt; x &lt; 1\\)), but the folding algorithm makes it tile infinitely.\n\n\n\nSquare Tiling\nNow let’s extend to two dimensions. A square fundamental domain has four boundaries: \\(x = 0\\), \\(x = 1\\), \\(y = 0\\), and \\(y = 1\\). We need to check all four and reflect whenever we’re outside.\nThe algorithm structure is exactly the same as the strip—just more boundaries to check:\nvec2 foldToSquare(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check all four boundaries\n        if(p.x &lt; 0.0) {\n            p.x = -p.x;\n            moved = true;\n        }\n        if(p.x &gt; 1.0) {\n            p.x = 2.0 - p.x;\n            moved = true;\n        }\n        if(p.y &lt; 0.0) {\n            p.y = -p.y;\n            moved = true;\n        }\n        if(p.y &gt; 1.0) {\n            p.y = 2.0 - p.y;\n            moved = true;\n        }\n        \n        if(moved) foldCount++;\n        else break;\n    }\n    \n    return p;\n}\nNotice we’re now tracking foldCount—the number of reflections needed to reach the fundamental domain. This will be useful for coloring!\nHere’s a complete shader with the square tiling:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        bool moved = false;\n        \n        if(p.x &lt; 0.0) { p.x = -p.x; moved = true; }\n        if(p.x &gt; 1.0) { p.x = 2.0 - p.x; moved = true; }\n        if(p.y &lt; 0.0) { p.y = -p.y; moved = true; }\n        if(p.y &gt; 1.0) { p.y = 2.0 - p.y; moved = true; }\n        \n        if(moved) foldCount++;\n        else break;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    // Draw boundaries\n    float border = min(min(p.x, 1.0 - p.x), min(p.y, 1.0 - p.y));\n    if(border &lt; 0.02) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow we have a full 2D tiling! The color gradient shows how many reflections were needed—notice the pattern of colors reveals the structure of the tiling.\n\n\n\nTriangle Tiling\nNow for the main event: tiling with triangles. This is where we need the general reflection formula since triangle edges aren’t axis-aligned.\nWe’ll use an equilateral triangle centered at the origin with vertices: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nThis triangle has side length \\(\\sqrt{3}\\) and is nicely positioned for viewing.\n\n\nComputing Edge Equations\nFor each edge, we need to determine the parameters \\(a\\), \\(b\\), \\(c\\) of the line. Given two vertices \\(\\mathbf{v}_0 = (x_0, y_0)\\) and \\(\\mathbf{v}_1 = (x_1, y_1)\\):\n\nEdge direction: \\(\\mathbf{d} = \\mathbf{v}_1 - \\mathbf{v}_0 = (x_1 - x_0, y_1 - y_0)\\)\nOutward normal (perpendicular): \\(\\mathbf{n} = (-d_y, d_x)\\)\nThe line through these points satisfies: \\(\\mathbf{n} \\cdot (\\mathbf{p} - \\mathbf{v}_0) = 0\\)\n\nExpanding: \\(n_x(x - x_0) + n_y(y - y_0) = 0\\), which gives us: \\[n_x \\cdot x + n_y \\cdot y = n_x x_0 + n_y y_0\\]\nSo: \\(a = n_x\\), \\(b = n_y\\), \\(c = \\mathbf{n} \\cdot \\mathbf{v}_0\\).\nThe sign of the normal determines which side of the line is “inside” the triangle—we want the outward-pointing normal so that the half-space contains the triangle’s interior.\n// Reflect across the edge from v0 to v1\nvec2 reflectAcrossEdge(vec2 p, vec2 v0, vec2 v1) {\n    // Edge direction\n    vec2 edge = v1 - v0;\n    \n    // Outward normal (perpendicular to edge)\n    vec2 normal = vec2(-edge.y, edge.x);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    // Signed distance to line through v0 with this normal\n    float signedDist = dot(p - v0, normal);\n    \n    // Only reflect if on wrong side (outside triangle)\n    if(signedDist &lt; 0.0) {\n        p = p - 2.0 * signedDist * normal;\n    }\n    \n    return p;\n}\n\n\nThe Folding Algorithm for Triangles\nNow we repeatedly reflect across all three edges until the point lands inside the triangle:\nvec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {\n    foldCount = 0;\n    \n    // Triangle vertices\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866\n    vec2 v2 = vec2(0.866, -0.5);   //  sqrt(3)/2 ≈  0.866\n    \n    for(int i = 0; i &lt; maxIter; i++) {\n        vec2 p_old = p;\n        \n        // Reflect across each edge if necessary\n        p = reflectAcrossEdge(p, v0, v1);\n        p = reflectAcrossEdge(p, v1, v2);\n        p = reflectAcrossEdge(p, v2, v0);\n        \n        // Check if we moved (if not, we're inside)\n        if(length(p - p_old) &lt; 0.0001) break;\n        \n        foldCount++;\n    }\n    \n    return p;\n}\n\n\n\n\n\n\nThe Power of Reflection\n\n\n\nWe’re generating an infinite tiling with just a few lines of code! Each pixel finds its way into the fundamental domain by reflecting across edges. No explicit loop over tiles needed—the geometry does the work for us.\n\n\nHere’s the complete Euclidean triangle tiling shader:\n// Reflect a point across the line from v0 to v1\nvec2 reflectAcrossEdge(vec2 p, vec2 v0, vec2 v1) {\n    vec2 edge = v1 - v0;\n    vec2 normal = normalize(vec2(-edge.y, edge.x));\n    float dist = dot(p - v0, normal);\n    if(dist &lt; 0.0) {\n        p = p - 2.0 * dist * normal;\n    }\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Triangle vertices (equilateral, centered at origin)\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    // Fold into fundamental domain\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectAcrossEdge(p, v0, v1);\n        p = reflectAcrossEdge(p, v1, v2);\n        p = reflectAcrossEdge(p, v2, v0);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw triangle edges for reference\n    vec2 e0 = v1 - v0; vec2 n0 = normalize(vec2(-e0.y, e0.x));\n    vec2 e1 = v2 - v1; vec2 n1 = normalize(vec2(-e1.y, e1.x));\n    vec2 e2 = v0 - v2; vec2 n2 = normalize(vec2(-e2.y, e2.x));\n    \n    float d0 = abs(dot(p - v0, n0));\n    float d1 = abs(dot(p - v1, n1));\n    float d2 = abs(dot(p - v2, n2));\n    float edgeDist = min(d0, min(d1, d2));\n    \n    if(edgeDist &lt; 0.03) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! You should see an infinite tiling of equilateral triangles, colored by how many reflections were needed. The white edges show the fundamental domain boundaries.\n\n\n\n\n\n\nThe Folding Algorithm Pattern\n\n\n\nNotice the structure we’ve built: 1. Define fundamental domain as intersection of half-spaces 2. For each boundary: if outside, reflect 3. Repeat until inside 4. Color based on iteration count or parity\nThis algorithm is geometry-independent! It works anywhere we can define half-spaces and reflections. We’re about to see it work in hyperbolic geometry with exactly the same structure.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#part-2-introduction-to-hyperbolic-geometry",
    "href": "day3.html#part-2-introduction-to-hyperbolic-geometry",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "4.3 Part 2: Introduction to Hyperbolic Geometry",
    "text": "4.3 Part 2: Introduction to Hyperbolic Geometry\n\nWhat is Hyperbolic Geometry?\nHyperbolic geometry is one of the three classical geometries, characterized by constant negative curvature. It was discovered independently in the early 1800s by János Bolyai, Nikolai Lobachevsky, and Carl Friedrich Gauss, resolving centuries of attempts to prove Euclid’s parallel postulate.\nHyperbolic geometry appears throughout modern mathematics: - Moduli spaces and Teichmüller theory - Kleinian groups and complex dynamics\n- Low-dimensional topology (3-manifolds, knot theory) - Number theory (modular forms and the upper half-plane) - General relativity (negative curvature spacetimes)\nSome key properties that distinguish hyperbolic geometry: - Triangle angles sum to less than \\(\\pi\\) (not exactly \\(\\pi\\) as in Euclidean geometry) - Area of a triangle with angles \\(\\alpha, \\beta, \\gamma\\) is \\(\\pi - \\alpha - \\beta - \\gamma\\) (the angle deficit!) - Exponential growth: The circumference of a circle grows exponentially with its radius - Given a line and a point not on it, there are infinitely many lines through the point parallel to the given line\nThis “extra room” in hyperbolic space is what allows us to fit more than 6 equilateral triangles around a vertex—something impossible in Euclidean geometry.\n\n\n\nThe Upper Half-Plane Model\nWe’ll work primarily in the upper half-plane model of hyperbolic geometry, denoted \\(\\mathbb{H}^2\\):\n\\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThis is just complex numbers with positive imaginary part. The real axis \\(\\{y = 0\\}\\) forms the boundary “at infinity”—it’s not actually part of the hyperbolic plane, but represents points infinitely far away.\nThe hyperbolic metric (which measures distances and angles) is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\nThis makes \\(\\mathbb{H}^2\\) a complete Riemannian manifold with constant curvature \\(-1\\).\n\n\n\n\n\n\nUnderstanding the Metric\n\n\n\nThe factor \\(1/y^2\\) means Euclidean distances are scaled by \\(1/y\\). As \\(y \\to 0\\) (approaching the real axis), this scaling factor blows up—the boundary is infinitely far away in hyperbolic distance.\nThink of it this way: An ant at height \\(y = 1\\) that walks down to height \\(y = 0.01\\) travels a huge hyperbolic distance, even though the Euclidean distance is small. This “compression” near the boundary creates the extra “room” that makes hyperbolic geometry so different from Euclidean geometry.\nThe metric is conformal to the Euclidean metric—it preserves angles but not lengths. A triangle that looks like it has the right angles when you draw it actually does have those angles hyperbolically!\n\n\n\n\nHyperbolic Distance\nThe distance between two points \\(z, w \\in \\mathbb{H}^2\\) can be computed using:\n\\[d_{\\text{hyp}}(z, w) = \\operatorname{acosh}\\left(1 + \\frac{|z - w|^2}{2 \\operatorname{Im}(z) \\operatorname{Im}(w)}\\right)\\]\nwhere \\(\\operatorname{acosh}(x) = \\ln(x + \\sqrt{x^2 - 1})\\) is the inverse hyperbolic cosine.\nIn GLSL:\nfloat hyperbolicDistance(vec2 z, vec2 w) {\n    float diff2 = dot(z - w, z - w);  // |z - w|²\n    float denom = 2.0 * z.y * w.y;    // 2·Im(z)·Im(w)\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // acosh formula\n}\nYou’ll need this for homework exercises, but not for the tiling algorithm itself—we’ll work directly with reflections rather than distances.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#part-3-hyperbolic-geodesics-and-half-spaces",
    "href": "day3.html#part-3-hyperbolic-geodesics-and-half-spaces",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "4.4 Part 3: Hyperbolic Geodesics and Half-Spaces",
    "text": "4.4 Part 3: Hyperbolic Geodesics and Half-Spaces\n\nGeodesics in the Upper Half-Plane\nGeodesics are the “straight lines” of hyperbolic geometry—curves that locally minimize distance between points. In the upper half-plane model, geodesics have a beautiful characterization: they’re curves that meet the boundary at right angles.\nThis gives us exactly two types:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c \\in \\mathbb{R}\\)\nSemicircles: Centered on the real axis, perpendicular to it\n\nEvery geodesic is completely determined by where it intersects the boundary (the real axis). A geodesic has two endpoints: both real numbers, or one real number and \\(\\infty\\).\n\n\nEncoding Geodesics\nWe’ll represent geodesics by their boundary points:\nstruct Geodesic {\n    float p;  // First endpoint on real axis\n    float q;  // Second endpoint (may be infinity)\n};\nExamples: - Vertical line at \\(x = 2\\): Geodesic(2.0, infty) (one endpoint at 2, one at \\(\\infty\\)) - Semicircle from \\(-1\\) to \\(3\\): `Geodesic(-1.0, 3.0)$ - Center: \\((p + q)/2 = 1\\) - Radius: \\(|p - q|/2 = 2\\)\n\n\n\n\n\n\nInfinity in GLSL\n\n\n\nGLSL supports IEEE floating-point infinity, which we can use elegantly:\nfloat infty = 1.0 / 0.0;\nbool isInfinite = isinf(someValue);\nThis is good practice! It lets us handle vertical lines and semicircles uniformly in one data structure. The function isinf() lets us distinguish which case we’re in. This is much cleaner than using special flag values like -1.0 or creating separate types.\nSome might worry this is “insane,” but it’s actually the mathematically natural representation: geodesics really do have endpoints on \\(\\mathbb{R} \\cup \\{\\infty\\}\\), and GLSL’s infinity support lets us express this directly in code!\n\n\nLet’s write a helper function to check if a geodesic is a vertical line:\nbool isLine(Geodesic geo, out float endpt) {\n    // If p is infinity, return q as the endpoint\n    if(isinf(geo.p)) {\n        endpt = geo.q;\n        return true;\n    }\n    // If q is infinity, return p as the endpoint\n    if(isinf(geo.q)) {\n        endpt = geo.p;\n        return true;\n    }\n    // Neither is infinity - it's a semicircle\n    return false;\n}\n\n\n\nReflection in Geodesics\nNow we need to implement reflection across these geodesic boundaries. This is the key operation that makes everything work!\nFor vertical lines at \\(x = c\\), reflection is simple—just flip the \\(x\\)-coordinate: \\[\\text{reflect}_{x=c}(x + iy) = (2c - x) + iy\\]\nFor semicircular geodesics with endpoints \\(p\\) and \\(q\\), we need to perform circle inversion. The semicircle has: - Center: \\(c = (p + q)/2\\) - Radius: \\(R = |p - q|/2\\)\nThe inversion formula (which we learned on Day 2!) is: \\[z \\mapsto c + R^2 \\frac{z - c}{|z - c|^2}\\]\nHere’s where yesterday’s work pays off: circle inversion from the Apollonian gasket is exactly what we need for hyperbolic reflection! The code is nearly identical—same geometric operation, new mathematical interpretation.\nvec2 reflectIn(vec2 z, Geodesic geo) {\n    float endpt;\n    \n    // Check if it's a vertical line\n    if(isLine(geo, endpt)) {\n        z.x = 2.0 * endpt - z.x;\n        return z;\n    }\n    \n    // Otherwise it's a semicircle - use circle inversion\n    float center = (geo.p + geo.q) / 2.0;\n    float radius = abs(geo.p - geo.q) / 2.0;\n    \n    // Circle inversion (same as Day 2!)\n    z.x -= center;\n    z /= radius;\n    z /= dot(z, z);    // This is the inversion step\n    z *= radius;\n    z.x += center;\n    \n    return z;\n}\nThe semicircle case is exactly the circle inversion we implemented yesterday—we can reuse that code directly! This is one of the beautiful connections in mathematics: the same geometric operation appears in multiple contexts.\n\n\n\nHyperbolic Half-Spaces\nJust as in Euclidean geometry, a geodesic divides the hyperbolic plane into two half-spaces. We need to specify which side we want.\nConvention: - For vertical line \\(x = c\\): side \\(+1\\) means \\(x &gt; c\\), side \\(-1\\) means \\(x &lt; c\\) - For semicircle: side \\(+1\\) means outside the circle, side \\(-1\\) means inside\nstruct HalfSpace {\n    Geodesic bdy;  // The boundary geodesic\n    float side;    // +1 or -1\n};\nNow we can check if a point is in a half-space:\nbool inside(vec2 z, HalfSpace hs) {\n    float endpt;\n    \n    // Vertical line case\n    if(isLine(hs.bdy, endpt)) {\n        float side = sign(z.x - endpt);\n        return side * hs.side &gt; 0.0;\n    }\n    \n    // Semicircle case\n    float center = (hs.bdy.p + hs.bdy.q) / 2.0;\n    float radius = abs(hs.bdy.p - hs.bdy.q) / 2.0;\n    \n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    float side = sign(dist2 - radius * radius);\n    \n    return side * hs.side &gt; 0.0;\n}\nAnd reflect into a half-space (reflecting only if we’re outside):\nvec2 reflectIn(vec2 z, HalfSpace hs, inout float parity) {\n    if(!inside(z, hs)) {\n        z = reflectIn(z, hs.bdy);\n        parity *= -1.0;\n    }\n    return z;\n}\nThe parity variable tracks whether we’ve done an odd or even number of reflections—useful for coloring!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#part-4-hyperbolic-triangle-tilings",
    "href": "day3.html#part-4-hyperbolic-triangle-tilings",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "4.5 Part 4: Hyperbolic Triangle Tilings",
    "text": "4.5 Part 4: Hyperbolic Triangle Tilings\n\nTriangle Structure\nA hyperbolic triangle is the intersection of three half-spaces, exactly like in Euclidean geometry:\nstruct Triangle {\n    HalfSpace a;\n    HalfSpace b;\n    HalfSpace c;\n};\nChecking if a point is inside the triangle:\nbool inside(vec2 z, Triangle T) {\n    return inside(z, T.a) && inside(z, T.b) && inside(z, T.c);\n}\nReflecting across all three boundaries:\nvec2 reflectIn(vec2 z, Triangle T, inout float parity) {\n    z = reflectIn(z, T.a, parity);\n    z = reflectIn(z, T.b, parity);\n    z = reflectIn(z, T.c, parity);\n    return z;\n}\nNotice anything? This is exactly the same structure as the Euclidean triangle code! The only difference is what reflectIn() does internally.\n\n\n\nThe Folding Algorithm\nHere’s where everything comes together:\nvec2 moveInto(vec2 z, Triangle T, out float parity) {\n    parity = 1.0;\n    \n    for(int i = 0; i &lt; 50; i++) {\n        z = reflectIn(z, T, parity);\n        if(inside(z, T)) break;\n    }\n    \n    return z;\n}\n\n\n\n\n\n\nThe Algorithmic Connection to Day 2\n\n\n\nThis should look very familiar! This is exactly the algorithm from the Apollonian gasket:\nDay 2 (Apollonian gasket): - Setup: Three circles defining regions - Algorithm: If outside a region, invert through its boundary circle - Iterate until stable - Result: Fractal pattern from iteration\nToday (Hyperbolic tiling): - Setup: Three geodesics defining triangle - Algorithm: If outside the triangle, reflect through the boundary geodesic - Iterate until inside - Result: Tiling pattern from iteration\nThe pattern is universal: iteratively apply a geometric transformation to move into a desired region. The specific transformation (circle inversion, reflection in lines, reflection in hyperbolic geodesics) and the specific region change, but the algorithmic idea stays the same.\nThis is the power of recognizing patterns across mathematics!\n\n\n\n\n\nThe (2,3,∞) Triangle\nLet’s build our first concrete example. The notation \\((2,3,\\infty)\\) means the triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an angle at infinity—the vertex never actually “closes”).\nWe’ll use a particularly nice configuration in the upper half-plane: - Left boundary: Vertical line at \\(x = -1\\) - Right boundary: Vertical line at \\(x = 1\\) - Bottom boundary: Unit semicircle from \\(-1\\) to \\(1\\)\nThis creates a triangle with two finite vertices (where the vertical lines meet the semicircle) and one ideal vertex at \\(\\infty\\) (straight up the \\(y\\)-axis).\nTriangle setupTriangle_23inf() {\n    float infty = 1.0 / 0.0;\n    \n    // Three geodesics\n    Geodesic left = Geodesic(-1.0, infty);   // Vertical line at x = -1\n    Geodesic right = Geodesic(1.0, infty);   // Vertical line at x = 1\n    Geodesic bottom = Geodesic(-1.0, 1.0);   // Semicircle from -1 to 1\n    \n    // Three half-spaces (defining the interior of the triangle)\n    HalfSpace a = HalfSpace(left, 1.0);      // Right of x = -1\n    HalfSpace b = HalfSpace(right, -1.0);    // Left of x = 1\n    HalfSpace c = HalfSpace(bottom, 1.0);    // Above the semicircle\n    \n    return Triangle(a, b, c);\n}\nThe finite vertices of this triangle are at \\((-1, 0) + i\\epsilon\\) and \\((1, 0) + i\\epsilon\\) for small \\(\\epsilon\\) (infinitesimally above the real axis where the geodesics meet).\n\n\n\nComplete Hyperbolic Tiling Shader\nNow let’s put it all together into a working shader. This is the main result—a complete implementation of hyperbolic triangle tiling:\nfloat infty = 1.0 / 0.0;\n\nstruct Geodesic {\n    float p;\n    float q;\n};\n\nstruct HalfSpace {\n    Geodesic bdy;\n    float side;\n};\n\nstruct Triangle {\n    HalfSpace a;\n    HalfSpace b;\n    HalfSpace c;\n};\n\nbool isLine(Geodesic geo, out float endpt) {\n    if(isinf(geo.p)) {\n        endpt = geo.q;\n        return true;\n    }\n    if(isinf(geo.q)) {\n        endpt = geo.p;\n        return true;\n    }\n    return false;\n}\n\nvec2 reflectIn(vec2 z, Geodesic geo) {\n    float endpt;\n    \n    if(isLine(geo, endpt)) {\n        z.x = 2.0 * endpt - z.x;\n        return z;\n    }\n    \n    float center = (geo.p + geo.q) / 2.0;\n    float radius = abs(geo.p - geo.q) / 2.0;\n    \n    z.x -= center;\n    z /= radius;\n    z /= dot(z, z);\n    z *= radius;\n    z.x += center;\n    \n    return z;\n}\n\nbool inside(vec2 z, HalfSpace hs) {\n    float endpt;\n    \n    if(isLine(hs.bdy, endpt)) {\n        float side = sign(z.x - endpt);\n        return side * hs.side &gt; 0.0;\n    }\n    \n    float center = (hs.bdy.p + hs.bdy.q) / 2.0;\n    float radius = abs(hs.bdy.p - hs.bdy.q) / 2.0;\n    \n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    float side = sign(dist2 - radius * radius);\n    \n    return side * hs.side &gt; 0.0;\n}\n\nvec2 reflectIn(vec2 z, HalfSpace hs, inout float parity) {\n    if(!inside(z, hs)) {\n        z = reflectIn(z, hs.bdy);\n        parity *= -1.0;\n    }\n    return z;\n}\n\nbool inside(vec2 z, Triangle T) {\n    return inside(z, T.a) && inside(z, T.b) && inside(z, T.c);\n}\n\nvec2 reflectIn(vec2 z, Triangle T, inout float parity) {\n    z = reflectIn(z, T.a, parity);\n    z = reflectIn(z, T.b, parity);\n    z = reflectIn(z, T.c, parity);\n    return z;\n}\n\nvec2 moveInto(vec2 z, Triangle T, out float parity) {\n    parity = 1.0;\n    \n    for(int i = 0; i &lt; 50; i++) {\n        z = reflectIn(z, T, parity);\n        if(inside(z, T)) break;\n    }\n    \n    return z;\n}\n\nTriangle setupTriangle_23inf() {\n    Geodesic left = Geodesic(-1.0, infty);\n    Geodesic right = Geodesic(1.0, infty);\n    Geodesic bottom = Geodesic(-1.0, 1.0);\n    \n    HalfSpace a = HalfSpace(left, 1.0);\n    HalfSpace b = HalfSpace(right, -1.0);\n    HalfSpace c = HalfSpace(bottom, 1.0);\n    \n    return Triangle(a, b, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Setup triangle\n    Triangle T = setupTriangle_23inf();\n    \n    // Fold into fundamental domain\n    float parity;\n    vec2 w = moveInto(z, T, parity);\n    \n    // Color by parity (odd/even reflections)\n    vec3 color;\n    if(parity &gt; 0.0) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Optional: highlight if we're below y = 0 (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis \\(y = 0\\))—they’re all the same hyperbolic size, but Euclidean distances compress due to the metric.\nThe alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain. You can see the recursive structure of the tiling, with triangles subdividing infinitely.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#part-5-the-poincaré-disk-model",
    "href": "day3.html#part-5-the-poincaré-disk-model",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "4.6 Part 5: The Poincaré Disk Model",
    "text": "4.6 Part 5: The Poincaré Disk Model\n\nA Bounded Model\nThe upper half-plane model is unbounded—it extends infinitely upward. This can make visualization tricky. The Poincaré disk model solves this by fitting all of hyperbolic space inside the unit disk.\nDefinition: \\(\\mathbb{D}^2 = \\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\)\nThe interior of the unit disk represents all of hyperbolic space, and the boundary circle \\(|z| = 1\\) represents points at infinity. The metric in this model is: \\[ds^2 = \\frac{4(dx^2 + dy^2)}{(1 - |z|^2)^2}\\]\nGeodesics in the disk model are circular arcs that meet the boundary at right angles (or diameters, which are the limiting case).\n\n\n\nThe Cayley Transform\nThe Cayley transform is a Möbius transformation that maps between these two models. It’s a conformal map (preserves angles) and takes geodesics to geodesics.\nFrom upper half-plane to disk: \\[w = \\frac{z - i}{z + i}\\]\nFrom disk to upper half-plane: \\[z = i\\frac{1 + w}{1 - w}\\]\nThese formulas use complex arithmetic, which we implemented on Day 2! Let’s write them in GLSL:\n// Complex arithmetic helper functions (from Day 2)\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 uhpToDisk(vec2 z) {\n    vec2 num = z - vec2(0.0, 1.0);    // z - i\n    vec2 den = z + vec2(0.0, 1.0);    // z + i\n    return cdiv(num, den);\n}\n\nvec2 diskToUHP(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 num = cmul(vec2(0.0, 1.0), vec2(1.0, 0.0) + w);  // i(1 + w)\n    vec2 den = vec2(1.0, 0.0) - w;                        // 1 - w\n    return cdiv(num, den);\n}\n\n\n\nVisualization by Precomposition\nHere’s a powerful technique: we can do all our computations in the upper half-plane model, but view the result in the disk model. We just convert coordinates at the start:\n\nPixel coordinates → Disk coordinates\nDisk → Upper half-plane (using diskToUHP)\nCompute tiling in UHP\nDisplay result\n\nThis is called precomposition—we’re composing our tiling function with a coordinate change.\nHere’s the complete shader for viewing the tiling in the Poincaré disk:\n// [Include all the struct definitions and functions from the previous shader]\n// [Geodesic, HalfSpace, Triangle, isLine, reflectIn, inside, moveInto, setupTriangle_23inf]\n// [Plus the complex arithmetic functions cmul, cdiv]\n\nfloat infty = 1.0 / 0.0;\n\nstruct Geodesic {\n    float p;\n    float q;\n};\n\nstruct HalfSpace {\n    Geodesic bdy;\n    float side;\n};\n\nstruct Triangle {\n    HalfSpace a;\n    HalfSpace b;\n    HalfSpace c;\n};\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / denom;\n}\n\nbool isLine(Geodesic geo, out float endpt) {\n    if(isinf(geo.p)) {\n        endpt = geo.q;\n        return true;\n    }\n    if(isinf(geo.q)) {\n        endpt = geo.p;\n        return true;\n    }\n    return false;\n}\n\nvec2 reflectIn(vec2 z, Geodesic geo) {\n    float endpt;\n    \n    if(isLine(geo, endpt)) {\n        z.x = 2.0 * endpt - z.x;\n        return z;\n    }\n    \n    float center = (geo.p + geo.q) / 2.0;\n    float radius = abs(geo.p - geo.q) / 2.0;\n    \n    z.x -= center;\n    z /= radius;\n    z /= dot(z, z);\n    z *= radius;\n    z.x += center;\n    \n    return z;\n}\n\nbool inside(vec2 z, HalfSpace hs) {\n    float endpt;\n    \n    if(isLine(hs.bdy, endpt)) {\n        float side = sign(z.x - endpt);\n        return side * hs.side &gt; 0.0;\n    }\n    \n    float center = (hs.bdy.p + hs.bdy.q) / 2.0;\n    float radius = abs(hs.bdy.p - hs.bdy.q) / 2.0;\n    \n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    float side = sign(dist2 - radius * radius);\n    \n    return side * hs.side &gt; 0.0;\n}\n\nvec2 reflectIn(vec2 z, HalfSpace hs, inout float parity) {\n    if(!inside(z, hs)) {\n        z = reflectIn(z, hs.bdy);\n        parity *= -1.0;\n    }\n    return z;\n}\n\nbool inside(vec2 z, Triangle T) {\n    return inside(z, T.a) && inside(z, T.b) && inside(z, T.c);\n}\n\nvec2 reflectIn(vec2 z, Triangle T, inout float parity) {\n    z = reflectIn(z, T.a, parity);\n    z = reflectIn(z, T.b, parity);\n    z = reflectIn(z, T.c, parity);\n    return z;\n}\n\nvec2 moveInto(vec2 z, Triangle T, out float parity) {\n    parity = 1.0;\n    \n    for(int i = 0; i &lt; 50; i++) {\n        z = reflectIn(z, T, parity);\n        if(inside(z, T)) break;\n    }\n    \n    return z;\n}\n\nTriangle setupTriangle_23inf() {\n    Geodesic left = Geodesic(-1.0, infty);\n    Geodesic right = Geodesic(1.0, infty);\n    Geodesic bottom = Geodesic(-1.0, 1.0);\n    \n    HalfSpace a = HalfSpace(left, 1.0);\n    HalfSpace b = HalfSpace(right, -1.0);\n    HalfSpace c = HalfSpace(bottom, 1.0);\n    \n    return Triangle(a, b, c);\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 num = cmul(vec2(0.0, 1.0), vec2(1.0, 0.0) + w);\n    vec2 den = vec2(1.0, 0.0) - w;\n    return cdiv(num, den);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup for disk viewing\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Only render inside unit disk\n    if(length(uv) &gt;= 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 z = diskToUHP(uv);\n    \n    // Now do all computations in UHP\n    Triangle T = setupTriangle_23inf();\n    float parity;\n    vec2 w = moveInto(z, T, parity);\n    \n    // Color by parity\n    vec3 color;\n    if(parity &gt; 0.0) {\n        color = vec3(0.7, 0.8, 0.9);\n    } else {\n        color = vec3(0.5, 0.6, 0.8);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe tiling now appears in a bounded disk! All of hyperbolic space fits in this circle. Compare it to the upper half-plane view—it’s the same mathematical tiling, just displayed in a different coordinate system.\nNotice how triangles near the boundary of the disk look very small—they’re approaching infinity in hyperbolic terms, and the compression becomes extreme.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#part-6-distance-computations",
    "href": "day3.html#part-6-distance-computations",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "4.7 Part 6: Distance Computations",
    "text": "4.7 Part 6: Distance Computations\nFor homework and more advanced visualizations, you’ll want to compute distances to geodesics. This lets you draw edges, create distance-based effects, and understand the geometry better.\n\nDistance to a Vertical Geodesic\nFor a vertical line at \\(x = c\\), the hyperbolic distance from a point \\(z = x + iy\\) to the line can be computed using:\nfloat distToVertical(vec2 z, float c) {\n    z.x -= c;  // Translate so line is at x = 0\n    float secTheta = length(z) / abs(z.y);\n    return acosh(secTheta);\n}\nThe geometric idea: we measure the angle that the geodesic from \\(z\\) to the line makes with the vertical. The hyperbolic distance is related to this angle by \\(d = \\operatorname{acosh}(\\sec\\theta)\\).\n\n\nDistance to a Circular Geodesic\nFor a semicircular geodesic, we use a trick: apply a Möbius transformation that moves the geodesic to the imaginary axis, then measure distance to that vertical line.\nvec2 applyMobius(vec4 mob, vec2 z) {\n    float a = mob.x, b = mob.y, c = mob.z, d = mob.w;\n    vec2 num = vec2(a, 0.0) * z + vec2(b, 0.0);\n    vec2 den = vec2(c, 0.0) * z + vec2(d, 0.0);\n    return cdiv(num, den);\n}\n\nfloat distToGeodesic(vec2 z, Geodesic geo) {\n    float endpt;\n    \n    // Vertical line case\n    if(isLine(geo, endpt)) {\n        return distToVertical(z, endpt);\n    }\n    \n    // Semicircle case: transform to vertical line\n    vec4 mob = vec4(1.0, -geo.p, 1.0, -geo.q);\n    vec2 w = applyMobius(mob, z);\n    return distToVertical(w, 0.0);\n}\nUsage: You can use these functions to draw geodesic edges in your tilings:\nfloat d = distToGeodesic(w, T.a.bdy);\nd = min(d, distToGeodesic(w, T.b.bdy));\nd = min(d, distToGeodesic(w, T.c.bdy));\n\nif(d &lt; 0.02) {\n    color = vec3(1.0);  // Draw white edges\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#starting-simple-the-folding-algorithm",
    "href": "day3.html#starting-simple-the-folding-algorithm",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "4.1 Starting Simple: The Folding Algorithm",
    "text": "4.1 Starting Simple: The Folding Algorithm\nBefore we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.\n\nTiling a Strip\nImagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip \\(0 &lt; x &lt; 1\\)—and reflect any point outside this strip back inside.\nThe algorithm is remarkably simple: - If \\(x &lt; 0\\), reflect across \\(x = 0\\) - If \\(x &gt; 1\\), reflect across \\(x = 1\\)\n- Repeat until the point stops moving\nFor a vertical line at \\(x = c\\), reflection just flips the \\(x\\)-coordinate: \\((x, y) \\mapsto (2c - x, y)\\).\nHere’s a complete shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    // Draw the boundary lines\n    if(abs(p.x) &lt; 0.02 || abs(p.x - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.\n\n\n\nSquare Tiling\nLet’s extend to two dimensions. Now we have four boundaries: \\(x = 0\\), \\(x = 1\\), \\(y = 0\\), and \\(y = 1\\). Same algorithm, just more boundaries to check:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    // Draw boundaries\n    float border = min(min(p.x, 1.0 - p.x), min(p.y, 1.0 - p.y));\n    if(border &lt; 0.02) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nPerfect! A full 2D tiling. The color gradient shows how many reflections were needed.\nNotice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#abstracting-half-spaces",
    "href": "day3.html#abstracting-half-spaces",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "4.2 Abstracting: Half-Spaces",
    "text": "4.2 Abstracting: Half-Spaces\nLooking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.\n\nWhat is a Half-Space?\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions: - Points where \\(ax + by &lt; c\\) - Points where \\(ax + by &gt; c\\)\nWe’ll encode a half-space by storing the line parameters and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line parameters: ax + by = c\n    float side;     // +1 or -1 for which side\n};\n\n\n\n\n\n\nA Note on Redundancy\n\n\n\nThis representation is actually redundant: we could fix the convention to always use \\(ax + by &lt; c\\) (side implicit) and just flip signs of \\(a\\), \\(b\\), \\(c\\) to get the other side. For example, \\(x &lt; 1\\) is the same as \\(-x &gt; -1\\).\nBut having an explicit side parameter is convenient for clarity, and will be essential when we move to hyperbolic geometry where the sign-flipping doesn’t work as cleanly. The small redundancy is worth the flexibility!\n\n\n\n\nThe Reflection Formula\nTo reflect a point \\(\\mathbf{p} = (x, y)\\) across the line \\(ax + by = c\\), we use linear algebra. The normal vector to the line is \\(\\mathbf{n} = (a, b)\\). After normalizing to \\(\\hat{\\mathbf{n}} = \\mathbf{n}/|\\mathbf{n}|\\), the reflection formula is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere \\(d\\) is the signed distance from \\(\\mathbf{p}\\) to the line: \\[d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\]\nThis is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.\n\n\nImplementation\nLet’s write a function that reflects into a half-space—checking if we’re on the right side, and only reflecting if necessary:\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    // Compute which side of the line we're on\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    // Check if we're already on the correct side\n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;  // Already inside, nothing to do\n    }\n    \n    // We're on the wrong side - reflect across the boundary line\n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\nThis function encapsulates the entire pattern: check if we’re on the correct side, and only reflect if we’re not. This is exactly what we did in the concrete examples, now abstracted to work for any line!\n\n\n\nSquare Tiling with Half-Spaces\nLet’s rewrite our square tiling using this abstraction. For the square \\([0, 1] \\times [0, 1]\\), we need four half-spaces:\n\nLeft edge (\\(x = 0\\)): We want \\(x &gt; 0\\)\n\nLine: \\(x = 0\\) means \\(1 \\cdot x + 0 \\cdot y = 0\\)\nFor points with \\(x &gt; 0\\): \\((x - 0) \\cdot (-1) &lt; 0\\) ✓\nSo: HalfSpace(1.0, 0.0, 0.0, -1.0)\n\nRight edge (\\(x = 1\\)): We want \\(x &lt; 1\\)\n\nLine: \\(1 \\cdot x + 0 \\cdot y = 1\\)\nFor points with \\(x &lt; 1\\): \\((x - 1) \\cdot (1) &lt; 0\\) ✓\nSo: HalfSpace(1.0, 0.0, 1.0, 1.0)\n\nBottom edge (\\(y = 0\\)): We want \\(y &gt; 0\\)\n\nSo: HalfSpace(0.0, 1.0, 0.0, -1.0)\n\nTop edge (\\(y = 1\\)): We want \\(y &lt; 1\\)\n\nSo: HalfSpace(0.0, 1.0, 1.0, 1.0)\n\n\nHere’s the complete shader:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for our square [0,1]×[0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Fold into the square\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, left);\n        p = reflectInto(p, right);\n        p = reflectInto(p, bottom);\n        p = reflectInto(p, top);\n        \n        // If point didn't move, we're inside\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    // Draw boundaries\n    float border = min(min(p.x, 1.0 - p.x), min(p.y, 1.0 - p.y));\n    if(border &lt; 0.02) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis should give exactly the same result as before! The tiling looks identical, but now our code is much more flexible. Notice how clean the folding loop is—we just call reflectInto for each boundary and check for convergence.\nThe beauty of this abstraction: changing from a square to a triangle only requires changing the half-space definitions!\n\n\n\nTriangle Tiling\nNow we’re ready for triangles. We’ll use an equilateral triangle with vertices: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\n\nComputing Half-Spaces from Edges\nFor each edge of the triangle, we need to find the line parameters \\(a, b, c\\) and determine which side is “inside.”\nEdge from \\(v_0 = (0, 1)\\) to \\(v_1 = (-\\sqrt{3}/2, -1/2)\\): - Edge direction: \\(\\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\\) - Perpendicular (90° CCW): \\(\\mathbf{n} = (-d_y, d_x) = (1.5, -0.866)\\) - Line equation: \\(1.5x - 0.866y = c\\) where \\(c = \\mathbf{n} \\cdot v_0 = 1.5(0) - 0.866(1) = -0.866\\) - For the origin (inside): \\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\\) - We want inside when \\((ax + by - c) &lt; 0\\), so need side = -1.0 - Result: HalfSpace(1.5, -0.866, -0.866, -1.0)\nEdge from \\(v_1 = (-0.866, -0.5)\\) to \\(v_2 = (0.866, -0.5)\\): - Edge direction: \\((1.732, 0)\\) - Perpendicular: \\((0, 1.732)\\) - Line: \\(0 \\cdot x + 1.732 \\cdot y = 1.732(-0.5) = -0.866\\) - For the origin: \\(1.732(0) - (-0.866) = 0.866 &gt; 0\\) - So: HalfSpace(0.0, 1.732, -0.866, -1.0)\nEdge from \\(v_2 = (0.866, -0.5)\\) to \\(v_0 = (0, 1)\\): - Edge direction: \\((-0.866, 1.5)\\) - Perpendicular: \\((-1.5, -0.866)\\) - Line: \\(-1.5x - 0.866y = -1.5(0.866) - 0.866(-0.5) = -0.866\\) - For the origin: \\(-1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\\) - So: HalfSpace(-1.5, -0.866, -0.866, -1.0)\nHere’s the complete triangle tiling shader:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Triangle vertices\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    // Define three half-spaces for the triangle edges\n    // (Computed from edge normals as shown above)\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into the triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        // If point didn't move, we're inside\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw triangle edges\n    float d1 = abs(hs1.a * p.x + hs1.b * p.y - hs1.c) / length(vec2(hs1.a, hs1.b));\n    float d2 = abs(hs2.a * p.x + hs2.b * p.y - hs2.c) / length(vec2(hs2.a, hs2.b));\n    float d3 = abs(hs3.a * p.x + hs3.b * p.y - hs3.c) / length(vec2(hs3.a, hs3.b));\n    float edgeDist = min(d1, min(d2, d3));\n    \n    if(edgeDist &lt; 0.03) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! You should see an infinite tiling of equilateral triangles. Notice how minimal the change was from squares to triangles—just three different half-space definitions!\n\n\n\n\n\n\nThe Power of Abstraction\n\n\n\nCompare this triangle shader to our original square shader. The algorithm is identical: 1. Define boundaries as half-spaces 2. Repeatedly reflect into each half-space\n3. Check for convergence (point stops moving) 4. Color based on iteration count\nWe went from axis-aligned squares to arbitrary triangles by just changing how we define the half-spaces. This is the power of mathematical abstraction: write the algorithm once, apply it everywhere!\n\n\n\n\n\n\nA Cleaner Structure: The Triangle Struct\nThe triangle tiling works, but we have three separate hs1, hs2, hs3 variables floating around. We can make this much cleaner by grouping them into a single structure:\nstruct Triangle {\n    HalfSpace a, b, c;\n};\nNow we can write a helper function that operates on triangles:\nvec2 reflectInto(vec2 p, Triangle T) {\n    p = reflectInto(p, T.a);\n    p = reflectInto(p, T.b);\n    p = reflectInto(p, T.c);\n    return p;\n}\nHere’s the triangle tiling rewritten with this cleaner structure:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nstruct Triangle {\n    HalfSpace a, b, c;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvec2 reflectInto(vec2 p, Triangle T) {\n    p = reflectInto(p, T.a);\n    p = reflectInto(p, T.b);\n    p = reflectInto(p, T.c);\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Create the triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    Triangle T = Triangle(hs1, hs2, hs3);\n    \n    // Fold into the triangle - look how clean this is!\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, T);\n        \n        // If point didn't move, we're inside\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw triangle edges\n    float d1 = abs(T.a.a * p.x + T.a.b * p.y - T.a.c) / length(vec2(T.a.a, T.a.b));\n    float d2 = abs(T.b.a * p.x + T.b.b * p.y - T.b.c) / length(vec2(T.b.a, T.b.b));\n    float d3 = abs(T.c.a * p.x + T.c.b * p.y - T.c.c) / length(vec2(T.c.a, T.c.b));\n    float edgeDist = min(d1, min(d2, d3));\n    \n    if(edgeDist &lt; 0.03) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nMuch nicer! The folding loop is now just p = reflectInto(p, T)—beautifully concise. This structure will serve us perfectly when we move to hyperbolic geometry, where the pattern is identical but the reflection operations are different.\n\nThis completes our Euclidean foundation. We’ve seen: 1. The folding algorithm in concrete examples (strip, square) 2. The abstraction (half-spaces) that makes it general 3. Clean code structure (Triangle struct) that makes it maintainable 4. Convergence checking: iterate until the point stops moving\nNext, we’ll take this exact same algorithmic structure into hyperbolic geometry!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#part-1-reflection-and-tilings-in-euclidean-geometry",
    "href": "day3.html#part-1-reflection-and-tilings-in-euclidean-geometry",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.2 Part 1: Reflection and Tilings in Euclidean Geometry",
    "text": "3.2 Part 1: Reflection and Tilings in Euclidean Geometry\n\nStarting Simple: The Folding Algorithm\nBefore we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.\n\nTiling a Strip\nImagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip \\(0 &lt; x &lt; 1\\)—and reflect any point outside this strip back inside.\nThe algorithm is remarkably simple: - If \\(x &lt; 0\\), reflect across \\(x = 0\\) - If \\(x &gt; 1\\), reflect across \\(x = 1\\)\n- Repeat until the point stops moving\nFor a vertical line at \\(x = c\\), reflection just flips the \\(x\\)-coordinate: \\((x, y) \\mapsto (2c - x, y)\\).\nHere’s a complete shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    // Draw the boundary lines\n    if(abs(p.x) &lt; 0.02 || abs(p.x - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.\n\n\n\nSquare Tiling\nLet’s extend to two dimensions. Now we have four boundaries: \\(x = 0\\), \\(x = 1\\), \\(y = 0\\), and \\(y = 1\\). Same algorithm, just more boundaries to check:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    // Draw boundaries\n    float border = min(min(p.x, 1.0 - p.x), min(p.y, 1.0 - p.y));\n    if(border &lt; 0.02) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nPerfect! A full 2D tiling. The color gradient shows how many reflections were needed.\nNotice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain.\n\n\n\n\nAbstracting: Half-Spaces\nLooking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.\n\nWhat is a Half-Space?\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions: - Points where \\(ax + by &lt; c\\) - Points where \\(ax + by &gt; c\\)\nWe’ll encode a half-space by storing the line parameters and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line parameters: ax + by = c\n    float side;     // +1 or -1 for which side\n};\n\n\n\n\n\n\nA Note on Redundancy\n\n\n\nThis representation is actually redundant: we could fix the convention to always use \\(ax + by &lt; c\\) (side implicit) and just flip signs of \\(a\\), \\(b\\), \\(c\\) to get the other side. For example, \\(x &lt; 1\\) is the same as \\(-x &gt; -1\\).\nBut having an explicit side parameter is convenient for clarity, and will be essential when we move to hyperbolic geometry where the sign-flipping doesn’t work as cleanly. The small redundancy is worth the flexibility!\n\n\n\n\nThe Reflection Formula\nTo reflect a point \\(\\mathbf{p} = (x, y)\\) across the line \\(ax + by = c\\), we use linear algebra. The normal vector to the line is \\(\\mathbf{n} = (a, b)\\). After normalizing to \\(\\hat{\\mathbf{n}} = \\mathbf{n}/|\\mathbf{n}|\\), the reflection formula is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere \\(d\\) is the signed distance from \\(\\mathbf{p}\\) to the line: \\[d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\]\nThis is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.\n\n\nImplementation\nLet’s write a function that reflects into a half-space—checking if we’re on the right side, and only reflecting if necessary:\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    // Compute which side of the line we're on\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    // Check if we're already on the correct side\n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;  // Already inside, nothing to do\n    }\n    \n    // We're on the wrong side - reflect across the boundary line\n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\nThis function encapsulates the entire pattern: check if we’re on the correct side, and only reflect if we’re not.\n\n\n\n\nSquare Tiling with Half-Spaces\nLet’s rewrite our square tiling using this abstraction. For the square \\([0, 1] \\times [0, 1]\\), we need four half-spaces:\n\nLeft edge (\\(x = 0\\)): We want \\(x &gt; 0\\)\nLine: \\(x = 0\\) means \\(1 \\cdot x + 0 \\cdot y = 0\\)\nFor \\(x &gt; 0\\): \\((x - 0) \\cdot (-1) &lt; 0\\) ✓\nSo: HalfSpace(1.0, 0.0, 0.0, -1.0)\nRight edge (\\(x = 1\\)): We want \\(x &lt; 1\\)\nSo: HalfSpace(1.0, 0.0, 1.0, 1.0)\nBottom and top: Similarly for \\(y\\)\n\nComplete shader:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for our square [0,1]×[0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Fold into the square\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, left);\n        p = reflectInto(p, right);\n        p = reflectInto(p, bottom);\n        p = reflectInto(p, top);\n        \n        // If point didn't move, we're inside\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    // Draw boundaries\n    float border = min(min(p.x, 1.0 - p.x), min(p.y, 1.0 - p.y));\n    if(border &lt; 0.02) {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis looks identical to before, but now our code is flexible. The beauty: changing from a square to a triangle only requires changing the half-space definitions!\n\n\n\nTriangle Tiling\nNow we’re ready for triangles. We’ll use an equilateral triangle with vertices: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\n\nComputing Half-Spaces from Edges\nFor each edge, we compute the line parameters. The math (shown in the callout below) gives us:\nEdge from \\(v_0\\) to \\(v_1\\): HalfSpace(1.5, -0.866, -0.866, -1.0)\nEdge from \\(v_1\\) to \\(v_2\\): HalfSpace(0.0, 1.732, -0.866, -1.0)\nEdge from \\(v_2\\) to \\(v_0\\): HalfSpace(-1.5, -0.866, -0.866, -1.0)\n\n\n\n\n\n\nDerivation of Half-Space Parameters\n\n\n\n\n\nFor edge from \\(v_0 = (0, 1)\\) to \\(v_1 = (-0.866, -0.5)\\): - Edge direction: \\(\\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\\) - Perpendicular (90° CCW): \\(\\mathbf{n} = (-d_y, d_x) = (1.5, -0.866)\\) - Line: \\(1.5x - 0.866y = c\\) where \\(c = \\mathbf{n} \\cdot v_0 = -0.866\\) - For origin (inside): \\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\\) - Want inside when \\((ax + by - c) &lt; 0\\), so side = -1.0\nSimilar calculations for the other two edges.\n\n\n\nHere’s the complete triangle tiling shader:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for the triangle edges\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into the triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        // If point didn't move, we're inside\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! An infinite tiling of equilateral triangles.\n\n\n\n\n\n\nThe Power of Abstraction\n\n\n\nCompare this to our square shader. The algorithm is identical: 1. Define boundaries as half-spaces 2. Repeatedly reflect into each half-space\n3. Check for convergence 4. Color based on iteration count\nWe changed from squares to triangles by just changing the half-space definitions. This is mathematical abstraction at work!\n\n\nThis completes our Euclidean foundation. We’ve seen: 1. The folding algorithm in concrete examples 2. The half-space abstraction that makes it general 3. Convergence checking by detecting when points stop moving\nNext, we’ll take this exact algorithmic structure into hyperbolic geometry!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day3.html#part-2-hyperbolic-geometry",
    "href": "day3.html#part-2-hyperbolic-geometry",
    "title": "3  Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "3.3 Part 2: Hyperbolic Geometry",
    "text": "3.3 Part 2: Hyperbolic Geometry\n\nIntroduction to Hyperbolic Geometry\nHyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant negative curvature. It was discovered independently in the early 1800s by János Bolyai, Nikolai Lobachevsky, and Carl Friedrich Gauss.\nHyperbolic geometry appears throughout modern mathematics: - Moduli spaces and Teichmüller theory - Kleinian groups and complex dynamics\n- Low-dimensional topology (3-manifolds, knot theory) - Number theory (modular forms and the upper half-plane) - General relativity (negative curvature spacetimes)\nKey properties that distinguish hyperbolic geometry: - Triangle angles sum to less than \\(\\pi\\) (not exactly \\(\\pi\\) as in Euclidean) - Exponential growth: The circumference of a circle grows exponentially with its radius - Given a line and a point not on it, there are infinitely many lines through the point parallel to the given line\nThis “extra room” in hyperbolic space allows for richer tiling structures than Euclidean geometry.\n\n\n\nThe Upper Half-Plane Model\nWe’ll work in the upper half-plane model of hyperbolic geometry, denoted \\(\\mathbb{H}^2\\):\n\\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThis is just complex numbers with positive imaginary part. The real axis \\(\\{y = 0\\}\\) forms the boundary “at infinity”—it’s not actually part of the hyperbolic plane, but represents points infinitely far away.\nThe hyperbolic metric (which measures distances and angles) is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\nThis makes \\(\\mathbb{H}^2\\) a complete Riemannian manifold with constant curvature \\(-1\\).\n\n\n\n\n\n\nUnderstanding the Metric\n\n\n\nThe factor \\(1/y^2\\) means Euclidean distances are scaled by \\(1/y\\). As \\(y \\to 0\\) (approaching the real axis), this scaling factor blows up—the boundary is infinitely far away in hyperbolic distance.\nThink of it this way: An ant at height \\(y = 1\\) that walks down to height \\(y = 0.01\\) travels a huge hyperbolic distance, even though the Euclidean distance is small. This “compression” near the boundary creates the extra “room” that makes hyperbolic geometry so different from Euclidean geometry.\nThe metric is conformal to the Euclidean metric—it preserves angles but not lengths. A triangle that looks like it has the right angles when you draw it actually does have those angles hyperbolically!\n\n\n\n\n\nGeodesics and Reflections\n\nGeodesics in the Upper Half-Plane\nGeodesics (the “straight lines” of hyperbolic geometry—curves that locally minimize distance) in \\(\\mathbb{H}^2\\) have exactly two forms:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c \\in \\mathbb{R}\\)\nSemicircles: Centered on the real axis, perpendicular to it\n\nThese are curves that meet the boundary at right angles. Every geodesic is determined by where it intersects the boundary (the real axis).\n\n\nReflection Across Vertical Lines\nFor a vertical geodesic at \\(x = c\\), reflection is simple—just flip the \\(x\\)-coordinate: \\[\\text{reflect}_{x=c}(x + iy) = (2c - x) + iy\\]\nThis is exactly what we had in Euclidean geometry! Now we implement it with our half-space convention:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    // Check if we're on the correct side\n    if((z.x - x_pos) * side &lt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Reflect across the vertical line\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\nThe side parameter works the same way: side = -1.0 means we want \\(x &gt; x_{\\text{pos}}\\), and side = 1.0 means \\(x &lt; x_{\\text{pos}}\\).\n\n\nReflection Across Semicircles\nFor a semicircular geodesic with endpoints \\(p\\) and \\(q\\) on the real axis, we use circle inversion from Day 2!\nThe semicircle has: - Center: \\(c = (p + q)/2\\) - Radius: \\(R = |p - q|/2\\)\nThe inversion formula is: \\[z \\mapsto c + R^2 \\frac{z - c}{|z - c|^2}\\]\nThis is exactly the same as yesterday’s Apollonian gasket! The code is nearly identical:\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    // Semicircle from p to q on real axis\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    \n    // Check which side we're on\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    // side = 1.0 means outside circle, side = -1.0 means inside\n    if((dist2 - radius * radius) * side &gt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Circle inversion (from Day 2!)\n    z.x -= center;\n    z /= radius;\n    z /= dot(z, z);    // The inversion step\n    z *= radius;\n    z.x += center;\n    \n    return z;\n}\nThe semicircle case uses the same circle inversion we implemented yesterday—same formula, new geometric interpretation!\n\n\n\n\n\n\nThe Algorithmic Connection to Day 2\n\n\n\nNotice the pattern across all three days:\nDay 2 (Apollonian gasket): - Setup: Three circles defining regions - Algorithm: If outside a region, invert through its boundary circle - Iterate until stable\nDay 3, Euclidean: - Setup: Half-spaces (lines) defining a region\n- Algorithm: If outside the region, reflect across the boundary - Iterate until point stops moving\nDay 3, Hyperbolic: - Setup: Half-spaces (vertical lines and semicircles) defining a region - Algorithm: If outside the region, reflect across the boundary (using line reflection OR circle inversion) - Iterate until point stops moving\nThe pattern is universal: iteratively apply a geometric transformation to move into a desired region. The specific transformations change (circle inversion, line reflection, hyperbolic reflection), but the algorithmic structure remains the same!\n\n\n\n\n\n\nThe (2,3,∞) Triangle\nLet’s build our first hyperbolic triangle tiling. The notation \\((2,3,\\infty)\\) means the triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an ideal vertex at infinity).\nWe’ll use a particularly nice configuration in the upper half-plane: - Left boundary: Vertical line at \\(x = -1\\) - Right boundary: Vertical line at \\(x = 1\\)\n- Bottom boundary: Unit semicircle from \\(-1\\) to \\(1\\)\nThis creates a triangle with two finite vertices (where the vertical lines meet the semicircle) and one ideal vertex at \\(\\infty\\) (straight up the \\(y\\)-axis).\nHere’s the complete shader:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    z.x -= center;\n    z /= radius;\n    z /= dot(z, z);\n    z *= radius;\n    z.x += center;\n    return z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis \\(y = 0\\))—they’re all the same hyperbolic size, but Euclidean distances compress due to the metric.\nThe alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.\n\n\n\n\n\n\nCompare to Euclidean\n\n\n\nLook at the structure of this shader compared to the Euclidean triangle tiling:\nEuclidean:\np = reflectInto(p, hs1);\np = reflectInto(p, hs2);\np = reflectInto(p, hs3);\nHyperbolic:\nz = reflectIntoVertical(z, -1.0, -1.0);\nz = reflectIntoVertical(z, 1.0, 1.0);\nz = reflectIntoCircular(z, -1.0, 1.0, 1.0);\nThe algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.\n\n\n\n\n\nThe Poincaré Disk Model\nThe upper half-plane model is unbounded—it extends infinitely upward. The Poincaré disk model solves this by fitting all of hyperbolic space inside the unit disk.\nDefinition: \\(\\mathbb{D}^2 = \\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\)\nThe interior of the unit disk represents all of hyperbolic space, and the boundary circle \\(|z| = 1\\) represents points at infinity.\n\nThe Cayley Transform\nThe Cayley transform is a Möbius transformation that maps between these two models:\nFrom upper half-plane to disk: \\[w = \\frac{z - i}{z + i}\\]\nFrom disk to upper half-plane: \\[z = i\\frac{1 + w}{1 - w}\\]\nThese formulas use complex arithmetic, which we implemented on Day 2:\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 diskToUHP(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 num = cmul(vec2(0.0, 1.0), vec2(1.0, 0.0) + w);\n    vec2 den = vec2(1.0, 0.0) - w;\n    return cdiv(num, den);\n}\n\n\nVisualization in the Disk\nHere’s a powerful technique: we can do all our computations in the upper half-plane model, but view the result in the disk model. We just convert coordinates at the start:\n\nPixel coordinates → Disk coordinates\nDisk → Upper half-plane (using diskToUHP)\nCompute tiling in UHP\nDisplay result\n\nHere’s the complete shader for viewing the tiling in the Poincaré disk:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    z.x -= center;\n    z /= radius;\n    z /= dot(z, z);\n    z *= radius;\n    z.x += center;\n    return z;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 num = cmul(vec2(0.0, 1.0), vec2(1.0, 0.0) + w);\n    vec2 den = vec2(1.0, 0.0) - w;\n    return cdiv(num, den);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup for disk viewing\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Only render inside unit disk\n    if(length(uv) &gt;= 1.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 z = diskToUHP(uv);\n    \n    // Now do all computations in UHP\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.7, 0.8, 0.9) : vec3(0.5, 0.6, 0.8);\n    \n    fragColor = vec4(color, 1.0);\n}\nThe tiling now appears in a bounded disk! All of hyperbolic space fits in this circle. Compare it to the upper half-plane view—it’s the same mathematical tiling, just displayed in a different coordinate system.\nNotice how triangles near the boundary of the disk look very small—they’re approaching infinity in hyperbolic terms, and the compression becomes extreme.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Day 3: Geometric Tilings in Euclidean and Hyperbolic Space</span>"
    ]
  },
  {
    "objectID": "day4.html#part-1-analytical-ray-tracing",
    "href": "day4.html#part-1-analytical-ray-tracing",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.2 Part 1: Analytical Ray Tracing",
    "text": "4.2 Part 1: Analytical Ray Tracing\n\nCamera and Ray Setup\n\nThe Rendering Pipeline\nFor each pixel, we need to: 1. Generate a ray from the camera through that pixel 2. Find where (if anywhere) the ray intersects scene geometry 3. Compute color based on surface properties and lighting\n\n\nCoordinate System\nWe’ll use the standard graphics convention: - Y-axis points up - Z-axis points toward the camera (out of the screen) - X-axis points right - Right-handed coordinate system\n\n\nPinhole Camera Model\nOur camera sits at the origin looking down the negative Z-axis. For a pixel at normalized coordinates \\((u, v) \\in [-1, 1]^2\\), we generate a ray:\nRay origin: \\(\\mathbf{o} = (0, 0, 0)\\) (camera position)\nRay direction: \\(\\mathbf{d} = \\text{normalize}(u, v, -f)\\)\nwhere \\(f\\) is the focal length, related to field of view by: \\(f = 1/\\tan(\\text{FOV}/2)\\).\n\n\nParametric Ray Equation\nA ray can be written as: \\[\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(t \\geq 0\\) is the parameter. Points along the ray correspond to different values of \\(t\\).\n\n\nImplementation\nLet’s start by visualizing our rays without any intersections:\nShader 1: Ray Visualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates to [-1, 1]\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Field of view\n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    // Ray direction (camera at origin, looking down -Z)\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Color based on ray direction (visualize the rays)\n    vec3 color = rayDir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a colorful gradient showing the direction of each ray. This confirms our camera setup is working!\n\n\n\n\nRay-Sphere Intersection\n\nThe Sphere Equation\nA sphere of radius \\(r\\) centered at position \\(\\mathbf{c}\\) is defined by: \\[|\\mathbf{p} - \\mathbf{c}|^2 = r^2\\]\nAll points \\(\\mathbf{p}\\) satisfying this equation lie on the sphere’s surface.\n\n\nFinding the Intersection\nWe want to find where our ray \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) intersects the sphere. Substituting the ray equation into the sphere equation: \\[|\\mathbf{o} + t\\mathbf{d} - \\mathbf{c}|^2 = r^2\\]\nLet \\(\\mathbf{oc} = \\mathbf{o} - \\mathbf{c}\\) (vector from sphere center to ray origin). Expanding: \\[|\\mathbf{oc} + t\\mathbf{d}|^2 = r^2\\] \\[|\\mathbf{oc}|^2 + 2t(\\mathbf{oc} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nThis is a quadratic equation in \\(t\\): \\[at^2 + bt + c = 0\\]\nwhere: - \\(a = |\\mathbf{d}|^2\\) (equals 1 if direction is normalized) - \\(b = 2(\\mathbf{oc} \\cdot \\mathbf{d})\\) - \\(c = |\\mathbf{oc}|^2 - r^2\\)\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us: - \\(\\Delta &lt; 0\\): no intersection (ray misses sphere) - \\(\\Delta = 0\\): one intersection (ray grazes sphere) - \\(\\Delta &gt; 0\\): two intersections (ray enters and exits)\nWe want the smaller positive \\(t\\) (the entry point).\n\n\nImplementation\nShader 2: Basic Sphere\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);  // Should be 1.0 if rayDir is normalized\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    // Return the closer intersection\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    // Return closest positive t\n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;  // Both behind camera\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere parameters\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    // Test intersection\n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit the sphere\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    } else {\n        // Background\n        color = vec3(0.1, 0.1, 0.2);  // Dark blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a flat red disk! It looks 2D because we don’t have lighting yet—we can’t see the sphere’s curvature.\n\n\n\n\nAdding Lighting\nTo see the 3D structure, we need to compute lighting based on the surface normal.\n\nSurface Normal\nFor a sphere centered at \\(\\mathbf{c}\\), the outward normal at surface point \\(\\mathbf{p}\\) is: \\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the vector from center to surface, normalized.\n\n\nDiffuse Lighting\nThe simplest lighting model: Lambertian diffuse shading. Surface brightness depends on the angle between the normal \\(\\mathbf{n}\\) and light direction \\(\\mathbf{l}\\): \\[\\text{brightness} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max(0, \\cdots)\\) ensures surfaces facing away from the light remain dark.\nShader 3: Sphere with Lighting\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) return -1.0;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvec3 sphereNormal(vec3 hitPoint, vec3 sphereCenter, float radius) {\n    return (hitPoint - sphereCenter) / radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit point\n        vec3 hitPoint = rayOrigin + t * rayDir;\n        \n        // Surface normal\n        vec3 normal = sphereNormal(hitPoint, sphereCenter, sphereRadius);\n        \n        // Light direction (from above and to the right)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        \n        // Diffuse lighting\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Sphere color\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);  // Red\n        color = sphereColor * diffuse;\n        \n        // Add ambient light so dark side isn't completely black\n        color += sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow the sphere looks 3D! The lighting reveals its curvature. Beautiful!\n\n\n\n\nRay-Torus Intersection: Where Analytical Gets Complex\n\nThe Torus Equation\nA torus with major radius \\(R\\) (distance from center to tube center) and minor radius \\(r\\) (tube thickness) has the implicit equation: \\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nOr in vector form: \\[\\left(|\\mathbf{p}_{xz}| - R\\right)^2 + p_y^2 = r^2\\]\nwhere \\(\\mathbf{p}_{xz} = (p_x, p_z)\\) is the projection onto the XZ-plane.\n\n\nThe Challenge\nSubstituting our ray equation into this gives a quartic polynomial (degree 4): \\[at^4 + bt^3 + ct^2 + dt + e = 0\\]\nUnlike quadratics (which have a simple formula), quartic equations require sophisticated algebraic methods. Here’s what solving it actually looks like:\nShader 4: Analytical Torus\n// From Inigo Quilez - https://www.shadertoy.com/view/XdSGWy\n// Analytical quartic solver for torus intersection\nfloat intersectTorus(vec3 ro, vec3 rd, vec2 tor)\n{\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01)\n    {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0)\n    {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4)\n    {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    return result;\n}\n\nvec3 torusNormal(vec3 pos, vec2 tor)\n{\n    return normalize(pos * (dot(pos,pos) - tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Torus parameters\n    vec2 torus = vec2(1.0, 0.4);  // (major radius, minor radius)\n    vec3 torusCenter = vec3(0.0, 0.0, -3.5);\n    \n    // Adjust ray for torus position\n    vec3 ro = rayOrigin - torusCenter;\n    \n    float t = intersectTorus(ro, rayDir, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ro + t * rayDir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = torusColor * diffuse + torusColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nLook at that intersection code! Over 80 lines of complex algebra just to render one torus. And this is still a relatively simple surface—imagine arbitrary algebraic varieties, or trying to combine multiple objects with boolean operations.\nAnalytical methods work beautifully for simple geometry, but we need a more flexible approach for complex scenes.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#part-2-signed-distance-functions-and-raymarching",
    "href": "day4.html#part-2-signed-distance-functions-and-raymarching",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.3 Part 2: Signed Distance Functions and Raymarching",
    "text": "4.3 Part 2: Signed Distance Functions and Raymarching\n\nIntroduction to SDFs\nA signed distance function (SDF) gives the distance from any point in space to the nearest surface:\n\\[d(\\mathbf{p}) = \\begin{cases}\n&gt; 0 & \\text{outside surface} \\\\\n= 0 & \\text{on surface} \\\\\n&lt; 0 & \\text{inside surface}\n\\end{cases}\\]\nCrucially, \\(|d(\\mathbf{p})|\\) is the actual Euclidean distance to the surface.\n\nWhy SDFs?\nSDFs have a powerful property: if we’re at point \\(\\mathbf{p}\\) and the surface is distance \\(d\\) away, we can safely move \\(d\\) units in any direction without hitting anything. This enables sphere tracing—we march along the ray taking steps proportional to the SDF value.\n\n\nSDF Examples\nLet’s see SDFs for shapes we’ve already rendered analytically:\nSphere:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nCompare this to our 30+ line analytical intersection! Much simpler.\nTorus:\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\nAgain, dramatically simpler than the quartic solver!\nOther Primitives\nMany more SDFs exist: boxes, cylinders, capsules, cones, pyramids, etc. See Inigo Quilez’s comprehensive library for a complete reference. Each SDF is typically just a few lines of code.\n\n\n\n\nThe Raymarching Algorithm\nSphere tracing works like this:\n\nStart at the ray origin\nEvaluate the SDF at current position\nMarch forward along the ray by that distance (safe step!)\nRepeat until:\n\nVery close to surface (SDF ≈ 0) → hit!\nToo far away → miss\nToo many steps → give up\n\n\nHere’s the algorithm:\nfloat sceneSDF(vec3 p) {\n    // Define scene geometry (we'll implement this)\n    return 0.0;\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out float hitDist, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        // Close enough to surface?\n        if(abs(d) &lt; 0.001) {\n            hitDist = t;\n            hitPos = pos;\n            return true;\n        }\n        \n        // March forward\n        t += d;\n        \n        // Too far?\n        if(t &gt; 100.0) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\nNormal Estimation via Gradient\nFor an SDF \\(d(\\mathbf{p})\\), the gradient \\(\\nabla d\\) points perpendicular to the surface (it’s the normal direction). We estimate it using finite differences:\n\\[\\frac{\\partial d}{\\partial x} \\approx \\frac{d(x + \\epsilon, y, z) - d(x - \\epsilon, y, z)}{2\\epsilon}\\]\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\n\nFirst Raymarch Shader\nShader 5: Single Sphere with Raymarching\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        \n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Raymarch\n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        color = sphereColor * diffuse + sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nSame result as the analytical sphere, but now we have a flexible framework!\n\n\n\n\nThe Power of SDFs: Instant Shape Swapping\nHere’s where SDFs shine: changing shapes is trivial. Just swap out one SDF for another!\nShader 6: Shapeshifting\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdBox(vec3 p, vec3 center, vec3 halfExtents) {\n    vec3 q = abs(p - center) - halfExtents;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    // Uncomment ONE of these to see different shapes!\n    // Everything else stays the same - same raymarch, same lighting, same normal calculation\n    \n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n    //return sdTorus(p, vec3(0.0, 0.0, -3.0), 1.0, 0.4);\n    //return sdBox(p, vec3(0.0, 0.0, -3.0), vec3(0.8, 0.8, 0.8));\n    \n    // Try any SDF from https://iquilezles.org/articles/distfunctions/\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nComment/uncomment different SDFs in sceneSDF() to instantly see different shapes! Try adding more from Quilez’s library. The raymarching algorithm doesn’t care what shape you use—it just follows the distance field.\n\n\n\nComposing Multiple Objects\nTo combine multiple objects, we simply take the minimum distance to any object. The closest surface wins!\nShader 7: Multiple Objects with Materials\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Global variable to track which object we hit\nfloat gMaterialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;  // Start with very large distance\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.2, 0.0, -3.5), 0.8);\n    if(sphere &lt; d) {\n        d = sphere;\n        gMaterialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p, vec3(1.2, 0.0, -3.5), 1.0, 0.3);\n    if(torus &lt; d) {\n        d = torus;\n        gMaterialID = 2.0;\n    }\n    \n    // Ground plane\n    float plane = sdPlane(p, -1.0);\n    if(plane &lt; d) {\n        d = plane;\n        gMaterialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float matID) {\n    if(matID &lt; 1.5) return vec3(1.0, 0.0, 0.0);      // Sphere: red\n    if(matID &lt; 2.5) return vec3(0.0, 0.7, 1.0);      // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                       // Plane: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos, out float matID) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            matID = gMaterialID;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    float matID;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos, matID);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = getMaterialColor(matID);\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThree objects with different colors! Adding more objects is trivial—just add another SDF check in sceneSDF(). Compare this to analytical methods where combining objects requires sophisticated CSG (constructive solid geometry) techniques.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  },
  {
    "objectID": "day4.html#looking-ahead-to-day-5",
    "href": "day4.html#looking-ahead-to-day-5",
    "title": "4  Day 4: Introduction to 3D Rendering",
    "section": "4.6 Looking Ahead to Day 5",
    "text": "4.6 Looking Ahead to Day 5\nTomorrow we’ll explore advanced raymarching techniques that would be nearly impossible with analytical methods:\n\nDomain operations: Infinite repetition, symmetry, twisting\nBoolean operations: Union, intersection, smooth blending\n3D fractals: Menger sponge, Mandelbulb via iterated transformations\nAdvanced lighting: Ambient occlusion, global illumination\n\nMake sure you’re comfortable with: - The raymarching algorithm (it’s the foundation) - How SDFs compose (taking minimum/maximum) - Normal estimation via gradients - The material tracking pattern we developed\nSee you tomorrow!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Day 4: Introduction to 3D Rendering</span>"
    ]
  }
]