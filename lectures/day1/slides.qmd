---
title: "Day 1: Introduction"
subtitle: "Shaders for Mathematical Visualization"
format:
  revealjs:
    theme: [default, ../../styles/slides.scss]
metadata-files:
  - ../../_slides-metadata.yml
---

##

{{< shader-slide day1/elliptic-family >}}

## What is a Shader?

A **shader** is a function from coordinates to colors.

- Takes a point $(x, y)$, returns RGB
- GPU runs it for every pixel, in parallel
- Result: an image, 60 times per second

Each pixel computes independently.

## mainImage {.smaller}

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

- `fragCoord`: pixel coordinates (input)
- `fragColor`: RGBA color (output)
- `vec4(r, g, b, a)`: each in $[0, 1]$
- Floats need decimals: `1.0` not `1`

##

{{< shader-slide day1/red >}}

## Uniforms and Conditionals

```glsl
iResolution.xy    // screen size in pixels
```

```glsl
if (fragCoord.x < iResolution.x / 2.0) {
    color = vec3(1.0, 0.0, 0.0);  // red
} else {
    color = vec3(0.0, 0.0, 1.0);  // blue
}
```

##

{{< shader-slide day1/half-plane-pixels >}}

## We Need Better Coordinates

`fragCoord.x < iResolution.x / 2.0` is awkward.

We want: origin at center, $x \in [-2, 2]$, circles look circular.

## The Transformation

```glsl
vec2 uv = fragCoord / iResolution.xy;   // [0,1]
uv = uv - vec2(0.5, 0.5);               // center
uv.x *= iResolution.x / iResolution.y;  // aspect
vec2 p = uv * 4.0;                      // scale
```

Now `p.x < 0.0` means "left half."

##

{{< shader-slide day1/coordinates >}}

## Drawing with Distance

**Key idea:** compute distance, then threshold.

```glsl
float d = length(p);    // distance from origin
float r = 1.0;
```

- Inside circle: `d < r`
- Outside circle: `d > r`

## Circle Code {.smaller}

```glsl
float d = length(p);
float r = 1.0;
float f = d - r;    // negative inside, positive outside

vec3 color;
if (f < 0.0) {
    color = vec3(1.0, 1.0, 0.0);  // yellow
} else {
    color = vec3(0.1, 0.1, 0.3);  // blue
}
```

##

{{< shader-slide day1/circle >}}

## From Filled to Outline

For just the boundary:

```glsl
float f = abs(d - r) - 0.1;
```

Small when $d \approx r$ (near the circle).

##

{{< shader-slide day1/circle-ring >}}

## Animation with iTime

`iTime` = seconds elapsed. `sin(iTime)` oscillates $-1$ to $1$.

```glsl
float r = 1.0 + 0.5 * sin(iTime);
```

Radius oscillates between $0.5$ and $1.5$.

##

{{< shader-slide day1/circle-pulsing >}}

## Implicit Curves

Any equation $F(x,y) = 0$ defines a curve.

Same pattern: color where $|F|$ is small.

```glsl
float F = p.y - p.x * p.x;    // parabola: y = x²

if (abs(F) < 0.1) {
    color = yellow;
}
```

##

{{< shader-slide day1/parabola >}}

## The Thickness Problem

{{< shader-slide day1/lemniscate-naive >}}

## Why?

$|F| < \varepsilon$ isn't distance to the curve.

- Where $|\nabla F|$ large → curve looks thin
- Where $|\nabla F|$ small → curve looks thick
- Where $\nabla F = 0$ → blows up

## Gradient Correction

$$\text{dist} \approx \frac{|F|}{|\nabla F|}$$

```glsl
vec2 grad = vec2(dF/dx, dF/dy);  // compute by hand
float dist = abs(F) / max(length(grad), 0.01);
```

##

{{< shader-slide day1/lemniscate-gradient >}}

## Mouse Input

`iMouse.xy` = mouse position in pixels.

Normalize it the same way as `fragCoord`:

```glsl
vec2 mouse = iMouse.xy / iResolution.xy;
mouse = mouse - vec2(0.5, 0.5);
mouse.x *= iResolution.x / iResolution.y;
mouse = mouse * 4.0;
```

## Circle at Mouse

```glsl
float d = length(p - mouse);
```

##

{{< shader-slide day1/circle-mouse >}}

## Mouse as Parameter

Map mouse position to parameter range:

```glsl
float a = mix(-2.0, 1.0, iMouse.x / iResolution.x);
float b = mix(-2.0, 2.0, iMouse.y / iResolution.y);
```

`mix(a, b, t)` interpolates: $a$ when $t=0$, $b$ when $t=1$.

## Elliptic Curves

$y^2 = x^3 + ax + b$ → $F = y^2 - x^3 - ax - b$

$\nabla F = (-3x^2 - a, \; 2y)$

Discriminant $\Delta = 4a^3 + 27b^2$:

- $\Delta > 0$: one component (gold)
- $\Delta < 0$: two components (blue)  
- $\Delta = 0$: singular (red)

##

{{< shader-slide day1/elliptic-curve >}}

## Now You Can Build This

{{< shader-slide day1/elliptic-family >}}

## Summary

- Shaders: coordinates → colors, parallel
- Coordinate transformation: pixels → math
- Distance fields: threshold for shapes
- Implicit curves: $|F|/|\nabla F| < \varepsilon$
- Animation: `iTime`
- Interaction: `iMouse`