---
title: "Day 1: Pixels"
subtitle: "Shaders for Mathematical Visualization"
format:
  revealjs:
    theme: [default, ../../styles/slides.scss]
metadata-files:
  - ../../_slides-metadata.yml
---

##

{{< shader-slide day1/elliptic-family >}}

## What is a Shader?

A **shader** is a function from coordinates to colors.

- You write code that takes a point $(x, y)$
- It returns an RGB color
- The GPU runs it for every pixel, in parallel
- Result: an image, recomputed 60 times per second

Each pixel computes independently—no peeking at neighbors.

# First Shader

## The Basics {.smaller}

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // fragCoord: pixel coordinates (input)
    // fragColor: RGBA color (output)
}
```

- `vec4(r, g, b, a)` holds four floats, each in $[0, 1]$
- Floats need decimals: `1.0` not `1`

**Hello World!**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

Every pixel outputs red.

##

{{< shader-slide day1/red >}}

# Dividing the Screen

## Uniforms and Vectors {.smaller}

Shadertoy provides **uniforms**—same value for every pixel:

| Uniform | Type | Description |
|---------|------|-------------|
| `iResolution` | `vec3` | `(width, height, 1)` in pixels |
| `iTime` | `float` | Seconds since start |
| `iMouse` | `vec4` | Mouse position and click |

Access components with `.x`, `.y`, `.z`:

```glsl
iResolution.x    // screen width
fragCoord.y      // pixel's y coordinate
```

## Left vs Right {.smaller}

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec3 color;
    if (fragCoord.x < iResolution.x / 2.0) {
        color = vec3(1.0, 0.0, 0.0);  // red on left
    } else {
        color = vec3(0.0, 0.0, 1.0);  // blue on right
    }
    
    fragColor = vec4(color, 1.0);
}
```

##

{{< shader-slide day1/half-plane-pixels >}}

# Coordinate Systems

`fragCoord.x < iResolution.x / 2.0` works, but...

What if we want a circle? A diagonal? Any mathematical shape?

We need a proper coordinate system.

**The Problem**

`fragCoord` gives pixel coordinates: origin at bottom-left, values like $(0,0)$ to $(1920, 1080)$.

We want: origin at center, scale $-2$ to $2$, circles that look circular.

## The Transformation {.smaller}

```glsl
vec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]
uv = uv - vec2(0.5, 0.5);               // center origin
uv.x *= iResolution.x / iResolution.y;  // aspect correction
vec2 p = uv * 4.0;                      // scale to [-2, 2]
```

Vector arithmetic is component-wise: `vec2(6,8) / vec2(2,4)` = `vec2(3,2)`.

This is our **standard boilerplate**. From now on, `p` is our math coordinate.

##

{{< shader-slide day1/coordinates >}}


# Drawing with Distance

## The Key Idea

**Compute a distance, then threshold it.**

```glsl
length(p)           // distance from origin
length(p - center)  // distance from any point
```

Filled circle: `length(p) < r`



**Example: Circle**

```glsl
float d = length(p);    // distance from origin
float r = 1.0;          // radius
float f = d - r;        // negative inside, positive outside

vec3 color;
if (f < 0.0) {
    color = vec3(1.0, 1.0, 0.0);  // yellow inside
} else {
    color = vec3(0.1, 0.1, 0.3);  // blue outside
}
```

##

{{< shader-slide day1/circle >}}

## Ring: Distance to Boundary

For a ring, we want pixels where $d \approx r$. Use `abs()`:

```glsl
float f = abs(d - r) - 0.1;  // small when d is near r
```

$|d - r|$ is distance to the circle. Subtract thickness, threshold on sign.

##

{{< shader-slide day1/circle-ring >}}

# Animation

## iTime and sin()

`iTime` = seconds since start. `sin(iTime)` oscillates $-1$ to $1$.

```glsl
float r = 1.0 + 0.5 * sin(iTime);  // radius pulses 0.5 to 1.5
```

Period is $2\pi \approx 6.28$ seconds.

##

{{< shader-slide day1/circle-pulsing >}}

# Implicit Curves

## Any Equation $F(x,y) = 0$

The circle was $F = |p| - r$. But we can draw **any** implicit curve:

```glsl
float F = p.y - p.x * p.x;  // parabola: y = x²

if (abs(F) < 0.1) {
    color = yellow;  // on the curve
}
```

##

{{< shader-slide day1/parabola >}}

## The Thickness Problem

What happens with a more complex curve?

##

{{< shader-slide day1/lemniscate-naive >}}

## Why It Blows Up

$|F| < \varepsilon$ captures points where $F$ is small—but $F$ isn't distance.

- Where $|\nabla F|$ is large: $F$ changes fast → thin
- Where $|\nabla F|$ is small: $F$ changes slow → thick
- Where $\nabla F = 0$: infinite thickness

**Fix:** divide by gradient magnitude: $\text{dist} \approx |F|/|\nabla F|$

## Lemniscate with Gradient {.smaller}

$F = (x^2 + y^2)^2 - (x^2 - y^2)$, so $\nabla F = (4x(x^2+y^2) - 2x, \, 4y(x^2+y^2) + 2y)$

```glsl
float r2 = p.x*p.x + p.y*p.y;
float F = r2*r2 - (p.x*p.x - p.y*p.y);

vec2 grad = vec2(4.0*p.x*r2 - 2.0*p.x, 4.0*p.y*r2 + 2.0*p.y);
float dist = abs(F) / max(length(grad), 0.01);
```

Use `max(..., 0.01)` to avoid division by zero.

##

{{< shader-slide day1/lemniscate-gradient >}}

## Animating Curve Families

Any parameter can depend on `iTime`. Cassini ovals sweep through a family as $c$ varies:

##

{{< shader-slide day1/lemniscate-animated >}}

# Mouse Input

## iMouse and Helper Functions {.smaller}

`iMouse.xy` = mouse position in pixels. Normalize it the same way as `fragCoord`:

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}
```

Define functions **above** `mainImage`.

## Circle Following Mouse {.smaller}

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    vec2 mouse = normalize_coord(iMouse.xy);
    
    float d = length(p - mouse);
    
    vec3 color = vec3(0.1, 0.1, 0.3);
    if (d < 0.5) {
        color = vec3(1.0, 0.9, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

##

{{< shader-slide day1/circle-mouse >}}

## Mouse as Parameter

Mouse can control any parameter, not just position. `mix(a, b, t)` interpolates:

```glsl
float param = mix(-2.0, 2.0, iMouse.x / iResolution.x);
```

As mouse moves left→right, `param` goes $-2 \to 2$.

# Coming Full Circle

## Elliptic Curves

$y^2 = x^3 + ax + b$ → $F = y^2 - x^3 - ax - b$, $\nabla F = (-3x^2 - a, \, 2y)$

The discriminant $\Delta = 4a^3 + 27b^2$ determines topology:

- $\Delta > 0$: one component
- $\Delta < 0$: two components
- $\Delta = 0$: singular

## Elliptic Curve Code {.smaller}

```glsl
float a = mix(-2.0, 1.0, iMouse.x / iResolution.x);
float b = mix(-2.0, 2.0, iMouse.y / iResolution.y);

float disc = 4.0*a*a*a + 27.0*b*b;

float F = p.y*p.y - p.x*p.x*p.x - a*p.x - b;
vec2 grad = vec2(-3.0*p.x*p.x - a, 2.0*p.y);
float dist = abs(F) / max(length(grad), 0.01);

if (dist < 0.05) {
    if (abs(disc) < 0.3) color = red;
    else if (disc > 0.0) color = gold;
    else color = blue;
}
```

##

{{< shader-slide day1/elliptic-curve >}}

## You Can Now Build This

{{< shader-slide day1/elliptic-family >}}

# Summary

## What We Learned

- Shaders: coordinates → colors, massively parallel
- Coordinate transformation: pixel space → math space
- Distance fields: threshold distance for shapes
- Implicit curves: $F(x,y) = 0$ with gradient correction
- Animation: parameters depending on `iTime`
- Interaction: parameters depending on `iMouse`