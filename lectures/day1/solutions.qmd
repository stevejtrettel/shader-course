# Day 1 Homework Solutions

---

## Checkpoints

### C1. Solid Colors

**(a) Green:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(0.0, 1.0, 0.0, 1.0);
}
```

**(b) Cyan:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(0.0, 1.0, 1.0, 1.0);
}
```

**(c) Custom color (example: orange):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
```

---

### C2. Vertical Split

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float L = p.x;  // test x-coordinate for left/right split
    
    vec3 color;
    if (L < 0.0) {
        color = vec3(1.0, 0.0, 0.0);  // red on left
    } else {
        color = vec3(0.0, 0.0, 1.0);  // blue on right
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C3. Off-Center Circle

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    vec2 center = vec2(1.0, 1.0);
    float d = length(p - center);
    float r = 0.5;
    
    vec3 color;
    if (d < r) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C4. Pulsing Circle

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0 + 0.5 * sin(iTime);  // oscillates between 0.5 and 1.5
    
    vec3 color;
    if (d < r) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C5. Ring Thickness

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float eps = 0.1;  // try 0.02, 0.05, 0.1, 0.2, 0.5
    
    vec3 color;
    if (abs(d - r) < eps) {
        color = vec3(1.0, 1.0, 0.0);  // yellow ring
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** Students should observe that `eps` controls the visual thickness of the ring. Smaller values give thinner rings; larger values give thicker rings. The ring has total width $2\varepsilon$.

---

## Explorations

### E1. Concentric Rings

**Step 1: Draw a few rings manually**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float eps = 0.05;
    
    vec3 color = vec3(0.1, 0.1, 0.3);  // background
    
    // Draw rings at r = 0.5, 1.0, 1.5, 2.0
    if (abs(d - 0.5) < eps) color = vec3(1.0, 1.0, 0.0);
    if (abs(d - 1.0) < eps) color = vec3(1.0, 1.0, 0.0);
    if (abs(d - 1.5) < eps) color = vec3(1.0, 1.0, 0.0);
    if (abs(d - 2.0) < eps) color = vec3(1.0, 1.0, 0.0);
    
    fragColor = vec4(color, 1.0);
}
```

**Step 2: Use a for loop**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float eps = 0.05;
    
    vec3 color = vec3(0.1, 0.1, 0.3);  // background
    
    // Draw rings at r = 0.5, 1.0, 1.5, 2.0
    for (float r = 0.5; r <= 2.0; r += 0.5) {
        if (abs(d - r) < eps) {
            color = vec3(1.0, 1.0, 0.0);
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Step 3: Alternating colors with mod**

The `mod(x, y)` function returns the remainder when `x` is divided by `y`. So `mod(i, 2.0)` alternates between 0 and 1 as `i` increases. We can use this to alternate colors:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float eps = 0.05;
    
    vec3 color = vec3(0.1, 0.1, 0.3);  // background
    
    float i = 0.0;
    for (float r = 0.5; r <= 2.0; r += 0.5) {
        if (abs(d - r) < eps) {
            if (mod(i, 2.0) < 1.0) {
                color = vec3(1.0, 1.0, 0.0);  // yellow
            } else {
                color = vec3(0.0, 1.0, 1.0);  // cyan
            }
        }
        i += 1.0;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E2. Moon Orbit

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    vec2 sun = normalize_coord(iMouse.xy);
    
    // Earth orbits the sun
    float earth_orbit = 1.2;
    float earth_speed = 1.0;
    vec2 earth = sun + earth_orbit * vec2(cos(iTime * earth_speed), sin(iTime * earth_speed));
    
    // Moon orbits the earth (smaller orbit, faster speed)
    float moon_orbit = 0.25;
    float moon_speed = 3.0;
    vec2 moon = earth + moon_orbit * vec2(cos(iTime * moon_speed), sin(iTime * moon_speed));
    
    // Distances
    float d_sun = length(p - sun);
    float d_earth = length(p - earth);
    float d_moon = length(p - moon);
    
    // Draw (back to front: sun, earth, moon)
    vec3 color = vec3(0.02, 0.02, 0.05);
    
    if (d_sun < 0.3) {
        color = vec3(1.0, 0.9, 0.2);  // yellow sun
    }
    if (d_earth < 0.15) {
        color = vec3(0.2, 0.5, 1.0);  // blue earth
    }
    if (d_moon < 0.08) {
        color = vec3(0.8, 0.8, 0.8);  // gray moon
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Extension: Solar system with more planets**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    vec2 sun = vec2(0.0, 0.0);  // sun at center
    
    // Planet parameters: orbit radius, speed, size, color
    vec3 color = vec3(0.02, 0.02, 0.05);
    
    // Sun
    if (length(p - sun) < 0.25) {
        color = vec3(1.0, 0.9, 0.2);
    }
    
    // Mercury
    vec2 mercury = sun + 0.5 * vec2(cos(iTime * 4.0), sin(iTime * 4.0));
    if (length(p - mercury) < 0.05) {
        color = vec3(0.7, 0.7, 0.7);
    }
    
    // Venus
    vec2 venus = sun + 0.8 * vec2(cos(iTime * 2.5), sin(iTime * 2.5));
    if (length(p - venus) < 0.08) {
        color = vec3(0.9, 0.7, 0.4);
    }
    
    // Earth with moon
    vec2 earth = sun + 1.2 * vec2(cos(iTime * 1.5), sin(iTime * 1.5));
    vec2 moon = earth + 0.15 * vec2(cos(iTime * 5.0), sin(iTime * 5.0));
    if (length(p - earth) < 0.1) {
        color = vec3(0.2, 0.5, 1.0);
    }
    if (length(p - moon) < 0.04) {
        color = vec3(0.8, 0.8, 0.8);
    }
    
    // Mars
    vec2 mars = sun + 1.6 * vec2(cos(iTime * 1.0), sin(iTime * 1.0));
    if (length(p - mars) < 0.07) {
        color = vec3(0.9, 0.4, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E3. Your Favorite Curve

**Example: Cardioid** $(x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)$

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float a = 1.0;
    float r2 = dot(p, p);
    
    // (x² + y² - ax)² = a²(x² + y²)
    // F = (r² - ax)² - a²r²
    float lhs = r2 - a * p.x;
    float F = lhs * lhs - a * a * r2;
    
    // Gradient (computed analytically)
    // dF/dx = 2(r² - ax)(2x - a) - 2a²x
    // dF/dy = 2(r² - ax)(2y) - 2a²y
    vec2 grad = vec2(
        2.0 * lhs * (2.0 * p.x - a) - 2.0 * a * a * p.x,
        2.0 * lhs * (2.0 * p.y) - 2.0 * a * a * p.y
    );
    
    float dist = abs(F) / max(length(grad), 0.01);
    
    vec3 color;
    if (dist < 0.05) {
        color = vec3(1.0, 0.5, 0.5);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E4. Curve Explorer

**Example: Superellipse** $|x/a|^n + |y/b|^n = 1$, with exponent $n$ controlled by mouse.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Map mouse x to exponent n in [0.5, 4.0]
    // n < 1: star shape, n = 1: diamond, n = 2: ellipse, n > 2: rounded rectangle
    float n = mix(0.5, 4.0, iMouse.x / iResolution.x);
    
    float a = 1.5;
    float b = 1.0;
    
    // Superellipse: |x/a|^n + |y/b|^n = 1
    // F = |x/a|^n + |y/b|^n - 1
    float F = pow(abs(p.x / a), n) + pow(abs(p.y / b), n) - 1.0;
    
    // Numerical gradient (analytical is messy for arbitrary n)
    float eps_grad = 0.01;
    float Fx = pow(abs((p.x + eps_grad) / a), n) + pow(abs(p.y / b), n) - 1.0;
    float Fy = pow(abs(p.x / a), n) + pow(abs((p.y + eps_grad) / b), n) - 1.0;
    vec2 grad = vec2(Fx - F, Fy - F) / eps_grad;
    
    float dist = abs(F) / max(length(grad), 0.01);
    
    vec3 color;
    if (dist < 0.05) {
        color = vec3(0.5, 1.0, 0.5);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** Dragging from left to right morphs the shape from a 4-pointed star ($n < 1$) through a diamond ($n = 1$), circle ($n = 2$), to a rounded rectangle ($n > 2$). This family is called the Lamé curves.

---

### E5. Two Circles (Venn Diagram)

**Version 1: One circle in front of the other**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Two circles
    vec2 c1 = vec2(-0.6, 0.0);
    vec2 c2 = vec2(0.6, 0.0);
    float r = 1.0;
    
    float d1 = length(p - c1);
    float d2 = length(p - c2);
    
    // Draw back to front: circle 1 first, then circle 2 on top
    vec3 color = vec3(0.1, 0.1, 0.2);  // background
    
    if (d1 < r) {
        color = vec3(1.0, 0.3, 0.3);  // red circle 1
    }
    if (d2 < r) {
        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 (drawn on top)
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Version 2: Venn diagram with three colors**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Two circles
    vec2 c1 = vec2(-0.6, 0.0);
    vec2 c2 = vec2(0.6, 0.0);
    float r = 1.0;
    
    float d1 = length(p - c1);
    float d2 = length(p - c2);
    
    bool in1 = d1 < r;
    bool in2 = d2 < r;
    
    vec3 color;
    if (in1 && in2) {
        color = vec3(1.0, 1.0, 0.0);  // yellow intersection
    } else if (in1) {
        color = vec3(1.0, 0.3, 0.3);  // red circle 1 only
    } else if (in2) {
        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 only
    } else {
        color = vec3(0.1, 0.1, 0.2);  // background
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E6. Soft Circles

**Basic anti-aliased circle:**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float f = d - r;
    
    // smoothstep creates a soft transition
    float t = smoothstep(-0.05, 0.05, f);
    vec3 color = mix(vec3(1.0, 1.0, 0.0), vec3(0.1, 0.1, 0.3), t);
    
    fragColor = vec4(color, 1.0);
}
```

**Circle with glow effect:**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float f = d - r;
    
    vec3 bg = vec3(0.05, 0.05, 0.1);
    vec3 circle_color = vec3(1.0, 0.8, 0.2);
    vec3 glow_color = vec3(1.0, 0.5, 0.1);
    
    vec3 color = bg;
    
    // Outer glow: fades from glow_color to background
    float glow_width = 0.5;
    if (f > 0.0 && f < glow_width) {
        float glow_t = f / glow_width;
        float glow_intensity = 1.0 - glow_t * glow_t;  // quadratic falloff
        color = mix(glow_color, bg, 1.0 - glow_intensity * 0.6);
    }
    
    // Circle itself with soft edge
    float t = smoothstep(-0.05, 0.05, f);
    color = mix(circle_color, color, t);
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** The glow effect uses distance beyond the circle boundary to create a fade. The quadratic falloff (`1.0 - t*t`) gives a more natural-looking glow than linear falloff. Students can experiment with different falloff functions and glow widths.

---

### E7. HSV Experiments

**HSV conversion function (from Color Appendix—copy into your shader):**

```glsl
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.xxx + vec3(1.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0, 1.0, 1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}
```

**Color wheel (hue varies with angle):**

```glsl
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.xxx + vec3(1.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0, 1.0, 1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float angle = atan(p.y, p.x);
    float hue = angle / 6.28318 + 0.5;
    
    vec3 color;
    if (d < 1.5) {
        color = hsv2rgb(vec3(hue, 1.0, 1.0));
    } else {
        color = vec3(0.1, 0.1, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Rainbow rings (hue varies with distance):**

```glsl
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.xxx + vec3(1.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0, 1.0, 1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float hue = fract(d * 0.5);  // repeating rainbow bands
    
    vec3 color = hsv2rgb(vec3(hue, 0.8, 0.9));
    
    fragColor = vec4(color, 1.0);
}
```

**Animated cycling colors:**

```glsl
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.xxx + vec3(1.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0, 1.0, 1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    
    // Hue cycles over time, with spatial variation
    float hue = fract(iTime * 0.1 + d * 0.2);
    
    vec3 color = hsv2rgb(vec3(hue, 0.7, 0.9));
    
    fragColor = vec4(color, 1.0);
}
```

**Colored implicit curve:**

```glsl
vec3 hsv2rgb(vec3 c) {
    vec3 p = abs(fract(c.xxx + vec3(1.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0, 1.0, 1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Lemniscate
    float a = 1.5;
    float r2 = dot(p, p);
    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);
    
    vec2 grad = vec2(
        4.0 * p.x * r2 - 2.0 * a * a * p.x,
        4.0 * p.y * r2 + 2.0 * a * a * p.y
    );
    
    float dist = abs(F) / max(length(grad), 0.01);
    
    // Hue varies with angle
    float angle = atan(p.y, p.x);
    float hue = angle / 6.28318 + 0.5;
    
    vec3 curve_color = hsv2rgb(vec3(hue, 1.0, 1.0));
    vec3 bg = vec3(0.1, 0.1, 0.2);
    
    float t = smoothstep(0.0, 0.08, dist);
    vec3 color = mix(curve_color, bg, t);
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** HSV is invaluable for shader art. The key insight is that hue is cyclic (0 and 1 are the same color), so `fract()` naturally creates smooth color cycles. Using angle for hue creates radial color patterns; using distance creates concentric patterns; using time creates animation.

---

## Challenges

### H1. Parabola Graphing Calculator

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Map mouse to coefficients
    // a in [-2, 2], b in [-3, 3], c fixed at -1
    float a = mix(-2.0, 2.0, iMouse.x / iResolution.x);
    float b = mix(-3.0, 3.0, iMouse.y / iResolution.y);
    float c = -1.0;
    
    vec3 color = vec3(0.1, 0.1, 0.15);  // background
    
    // Draw axes
    float axis_thickness = 0.03;
    if (abs(p.x) < axis_thickness) {
        color = vec3(0.3, 0.3, 0.3);  // y-axis
    }
    if (abs(p.y) < axis_thickness) {
        color = vec3(0.3, 0.3, 0.3);  // x-axis
    }
    
    // Draw parabola: y = ax² + bx + c
    // Implicit: F = y - ax² - bx - c
    float F = p.y - a * p.x * p.x - b * p.x - c;
    vec2 grad = vec2(-2.0 * a * p.x - b, 1.0);
    float dist = abs(F) / length(grad);
    
    if (dist < 0.05) {
        color = vec3(1.0, 1.0, 0.0);  // yellow parabola
    }
    
    // Find and draw roots
    // ax² + bx + c = 0
    // x = (-b ± sqrt(b² - 4ac)) / 2a
    float discriminant = b * b - 4.0 * a * c;
    
    if (discriminant >= 0.0 && abs(a) > 0.01) {
        float sqrt_disc = sqrt(discriminant);
        float x1 = (-b + sqrt_disc) / (2.0 * a);
        float x2 = (-b - sqrt_disc) / (2.0 * a);
        
        // Draw circles around roots
        float root_radius = 0.15;
        float root_thickness = 0.03;
        
        float d1 = abs(length(p - vec2(x1, 0.0)) - root_radius);
        float d2 = abs(length(p - vec2(x2, 0.0)) - root_radius);
        
        if (d1 < root_thickness) {
            color = vec3(1.0, 0.3, 0.3);  // red circle at root 1
        }
        if (d2 < root_thickness) {
            color = vec3(0.3, 1.0, 0.3);  // green circle at root 2
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### H2. Signed Distance Functions

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Signed distance to half-plane x > 1
    // SDF: distance is negative when inside (x > 1), positive outside
    float sdf_halfplane = 1.0 - p.x;  // negative when x > 1
    
    // Signed distance to rectangle [-1, 1] x [-0.5, 0.5]
    // SDF for axis-aligned box
    vec2 box_size = vec2(1.0, 0.5);
    vec2 d = abs(p) - box_size;
    float sdf_rect = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    
    // Choose which to display (toggle by uncommenting)
    float sdf = sdf_rect;
    // float sdf = sdf_halfplane;
    
    // Draw with uniform thickness boundary
    float eps = 0.05;
    
    vec3 color;
    if (sdf < -eps) {
        color = vec3(0.3, 0.3, 0.6);  // inside
    } else if (sdf < eps) {
        color = vec3(1.0, 1.0, 0.0);  // boundary
    } else {
        color = vec3(0.1, 0.1, 0.2);  // outside
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** The key insight is that for the rectangle SDF:
- `max(d, 0.0)` handles points outside the box
- `min(max(d.x, d.y), 0.0)` handles points inside the box
- No gradient correction needed because it's a true distance function!

---

### H3. Smooth Blending

```glsl
// Smooth minimum function
float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Two circles that orbit each other
    float angle = iTime * 0.5;
    vec2 c1 = 0.8 * vec2(cos(angle), sin(angle));
    vec2 c2 = 0.8 * vec2(cos(angle + 3.14159), sin(angle + 3.14159));
    float r = 0.8;
    
    float d1 = length(p - c1) - r;
    float d2 = length(p - c2) - r;
    
    // Smooth blend parameter (try 0.1 to 1.0)
    float k = 0.5;
    float d = smin(d1, d2, k);
    
    vec3 color;
    if (d < 0.0) {
        color = vec3(1.0, 0.8, 0.2);
    } else {
        color = vec3(0.1, 0.1, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** The `smin` function smoothly blends two distance fields. The parameter `k` controls how "soft" the blend is—larger values create more melting together. Watch the two blobs merge and separate as they orbit.

---

### H4. Inversion

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Mouse controls the line position
    float line_x = mix(0.5, 2.0, iMouse.x / iResolution.x);
    
    // Apply circle inversion: p -> p / |p|²
    float r2 = dot(p, p);
    vec2 p_inv = p / max(r2, 0.01);  // avoid division by zero
    
    vec3 color = vec3(0.1, 0.1, 0.2);
    
    // Draw unit circle (the circle of inversion)
    if (abs(length(p) - 1.0) < 0.02) {
        color = vec3(0.3, 0.3, 0.4);
    }
    
    // Draw the original line x = line_x (in cyan)
    if (abs(p.x - line_x) < 0.03) {
        color = vec3(0.0, 0.8, 0.8);
    }
    
    // Draw the inverted line (becomes a circle through origin!) in yellow
    // The line x = a inverts to a circle with center (1/(2a), 0) and radius 1/(2a)
    float inv_radius = 1.0 / (2.0 * line_x);
    vec2 inv_center = vec2(inv_radius, 0.0);
    if (abs(length(p - inv_center) - inv_radius) < 0.03) {
        color = vec3(1.0, 1.0, 0.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** Key observations:
- Lines through origin map to themselves
- Lines not through origin map to circles through origin (shown here)
- Circles through origin map to lines
- Circles not through origin map to circles
- The unit circle (gray) is the "mirror" of the inversion

Drag the mouse to move the original line (cyan) and watch its inverted image (yellow circle) change.

---

### H5. Fourier Epicycles

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float omega = 1.0;
    int N = 7;
    float scale = 1.2;
    
    vec3 color = vec3(0.02, 0.02, 0.05);
    
    vec2 pos = vec2(0.0, 0.0);
    
    for (int i = 0; i < 20; i++) {
        if (i >= N) break;
        
        int n = 2 * i + 1;  // odd harmonics: 1, 3, 5, ...
        float r = scale / float(n);
        float freq = float(n) * omega;
        
        vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));
        
        // Draw circle
        float d_circle = abs(length(p - pos) - r);
        if (d_circle < 0.02) {
            color = vec3(0.2, 0.2, 0.4);
        }
        
        pos = next_pos;
    }
    
    // Final point (bright)
    float d_point = length(p - pos);
    if (d_point < 0.08) {
        color = vec3(1.0, 1.0, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** Each circle represents a term in the Fourier series. The square wave uses odd harmonics with 1/n coefficients. More circles = better approximation. The final point traces out a path that approximates a square wave in the y-coordinate.

---

## Project: Grid Patterns

**Example solution: Truchet-style pattern**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Normalized coordinates centered at origin
    vec2 uv = fragCoord / iResolution.xy - 0.5;
    float aspect = iResolution.x / iResolution.y;
    uv.x *= aspect;
    vec2 p = uv * 4.0;
    
    // Grid setup
    float N = 8.0;
    float L = (4.0 * aspect) / N;
    
    // Grid formula
    vec2 cell_id = floor(p / L + 0.5);
    vec2 cell_center = cell_id * L;
    vec2 local = p - cell_center;
    
    // Pseudo-random per cell (determines arc orientation)
    float rand = fract(sin(dot(cell_id, vec2(12.9898, 78.233))) * 43758.5453);
    
    // Quarter circles centered at corners
    float r = L / 2.0;
    float thickness = 0.05;
    
    // Corner positions relative to cell center
    vec2 TL = vec2(-L/2.0,  L/2.0);   // top-left
    vec2 TR = vec2( L/2.0,  L/2.0);   // top-right
    vec2 BL = vec2(-L/2.0, -L/2.0);   // bottom-left
    vec2 BR = vec2( L/2.0, -L/2.0);   // bottom-right
    
    float d;
    if (rand > 0.5) {
        // Arcs from top-left and bottom-right corners
        float d1 = abs(length(local - TL) - r);
        float d2 = abs(length(local - BR) - r);
        d = min(d1, d2);
    } else {
        // Arcs from top-right and bottom-left corners
        float d1 = abs(length(local - TR) - r);
        float d2 = abs(length(local - BL) - r);
        d = min(d1, d2);
    }
    
    vec3 color;
    if (d < thickness) {
        color = vec3(1.0, 0.9, 0.7);
    } else {
        // Subtle gradient background
        float t = 0.5 + 0.5 * sin(length(cell_id) * 0.5 + iTime * 0.5);
        color = mix(vec3(0.1, 0.15, 0.25), vec3(0.2, 0.1, 0.2), t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** This creates the classic Truchet tile pattern where quarter-circle arcs connect across cell boundaries to form continuous meandering paths. The pseudo-random function determines each cell's orientation. Notice how naming the corner positions (`TL`, `TR`, `BL`, `BR`) makes the geometry self-documenting.

---

## Project: Elliptic Curve Family

**Full solution:**

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Mouse picks (a, b) in parameter space
    float a = mix(-2.0, 1.0, iMouse.x / iResolution.x);
    float b_center = mix(-2.0, 2.0, iMouse.y / iResolution.y);
    
    vec3 color = vec3(0.05, 0.05, 0.1);
    
    vec3 oneComponent = vec3(1.0, 0.85, 0.3);   // gold
    vec3 twoComponent = vec3(0.3, 0.5, 0.8);    // blue
    vec3 singularColor = vec3(1.0, 0.2, 0.2);   // red
    
    for (int j = -15; j <= 15; j++) {
        float b = b_center + float(j) * 0.15;
        
        float dist_from_center = abs(float(j));
        
        // Discriminant: 4a³ + 27b²
        float disc = 4.0 * a * a * a + 27.0 * b * b;
        
        float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;
        vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);
        float dist = abs(F) / max(length(grad), 0.01);
        
        float thickness = 0.05 / (1.0 + dist_from_center * 0.8);
        
        // Color by topology
        vec3 curveColor;
        if (abs(disc) < 0.3) {
            curveColor = singularColor;
        } else if (disc > 0.0) {
            curveColor = oneComponent;
        } else {
            curveColor = twoComponent;
        }
        
        float brightness = 1.0 / (1.0 + dist_from_center * 0.4);
        curveColor *= brightness;
        
        if (dist < thickness) {
            color = curveColor;
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** The discriminant $\Delta = 4a^3 + 27b^2$ determines curve topology. When $\Delta > 0$, the curve has one component (gold). When $\Delta < 0$, it splits into two components — the "egg" and the infinite piece (blue). When $\Delta = 0$, the curve is singular — it has a self-intersection or cusp (red). The singular locus forms a cusp curve in the $(a, b)$ parameter space.