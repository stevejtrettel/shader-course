# Day 1 Exercises

Homework is organized into four types:

**Checkpoints** — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.

**Explorations** — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you're on track with the course.

**Challenges** — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.

**Projects** — Extended projects to make a shader you'd be proud to show someone.

---

## Checkpoints

**C1. Solid Colors.** Modify the red screen shader to display: (a) green, (b) cyan, (c) a color of your choice using all three RGB channels.

**C2. Vertical Split.** Using the standard coordinate setup, divide the screen into left (red) and right (blue) by testing `p.x < 0.0`.

**C3. Off-Center Circle.** Draw a filled circle of radius 0.5 centered at the point $(1, 1)$ instead of the origin.

**C4. Pulsing Circle.** Make a circle whose radius oscillates between 0.5 and 1.5 over time using `iTime`.

**C5. Ring Thickness.** Draw a ring (circle outline) centered at the origin. Experiment with different values of `eps` to understand how it controls thickness.

---

## Explorations

**E1. Concentric Rings.** Draw several concentric rings (circles of different radii, all centered at the origin). Can you color alternate rings differently?

**E2. Moon Orbit.** Extend the sun-earth shader to add a moon that orbits the earth. The moon should be smaller than the earth and orbit faster.

**E3. Your Favorite Curve.** Pick an implicit curve and render it with gradient correction for uniform thickness. Some suggestions:

- **Cardioid**: $(x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)$. Heart-shaped with one cusp.
- **Folium of Descartes**: $x^3 + y^3 = 3axy$. Has a loop and an asymptote.
- **Lemniscate of Gerono**: $x^4 = x^2 - y^2$. A figure-eight, simpler than Bernoulli's.
- **Astroid**: $x^{2/3} + y^{2/3} = a^{2/3}$. Four cusps. (Be careful with the fractional powers—you'll need to handle signs.)
- **Tricuspoid (deltoid)**: $(x^2 + y^2 + 12ax + 9a^2)^2 = 4a(2x + 3a)^3$. Three cusps, looks like a curved triangle.

**E4. Curve Explorer.** Take any one-parameter family of curves and build a mouse-controlled explorer (like the folium example). Map `iMouse.x` to the parameter and drag to explore the family.

**E5. Two Circles.** Draw two filled circles at different positions. What happens when they overlap? Can you make one "in front of" the other? Can you make the intersection a different color, like a Venn diagram?

**E6. Soft Circles.** Use `smoothstep` and `mix` to draw a circle with anti-aliased edges. Then try adding a glow effect: instead of a hard edge, make the color fade gradually as you move away from the boundary.

**E7. HSV Experiments.** Use the `hsv2rgb` function from the Color Appendix to create colorful effects:
- Color a filled circle so that hue varies with angle (a color wheel).
- Color based on distance from origin: hue increasing as you move outward, creating rainbow rings.
- Animate: make hue depend on `iTime` so colors cycle smoothly.
- Color an implicit curve so that hue varies along the curve (hint: use `atan(p.y, p.x)` even for non-circular curves).

---

## Challenges

**H1. Parabola Graphing Calculator.** Build an interactive graphing calculator for the parabola $y = ax^2 + bx + c$. Requirements:

- Draw coordinate axes (the lines $x = 0$ and $y = 0$)
- Draw the parabola using implicit curve techniques
- Find the roots (where $y = 0$) and draw small circles around them
- Use mouse position to control two of the coefficients (e.g., $a$ and $b$, with $c$ fixed, or $b$ and $c$ with $a$ fixed)

As you drag the mouse, the parabola should reshape and the root indicators should move (or appear/disappear as roots become real or complex).

**H2. Signed Distance Functions.** For a filled circle, $f(p) = |p| - r$ is the *signed* distance function: negative inside, positive outside, with $|f|$ giving the actual distance to the boundary. What is the signed distance function for a half-plane? For an axis-aligned rectangle? Implement both and draw them with uniform-thickness boundaries. Note: when you have the true signed distance function, you don't need the gradient correction trick—that's the payoff for computing the right thing from the start.

**H3. Smooth Blending.** When two circles overlap, we currently just draw one on top of the other. Research *smooth minimum* functions (e.g., `smin`) that blend distance fields smoothly. Draw two circles that "melt together" where they meet.

**H4. Inversion.** Circle inversion is the map $p \mapsto p / |p|^2$. Apply this transformation to your coordinate $p$ before drawing a shape. What happens to a line? What happens to a circle not passing through the origin? Experiment with different shapes.

**H5. Fourier Epicycles.** Build an animation of Fourier series using epicycles—circles whose centers ride on the edges of other circles. For the square wave, the Fourier series uses odd harmonics: frequencies $\omega, 3\omega, 5\omega, \ldots$ with radii $1, 1/3, 1/5, \ldots$ Stack N circles, each rotating at its frequency, and draw a bright dot at the final position. Bonus: draw the arms connecting circle centers, fade the outer circles, or let the mouse control the number of terms.

---

## Project: Grid Patterns

This extended project introduces a powerful technique—using modular arithmetic to repeat patterns across the plane. We'll build up the machinery carefully, since we'll use it again in Day 2 to create grids of Julia sets.

### Part 1: Setting Up a Grid of Square Cells

We want to tile the screen with square cells—say, 4 cells across. The challenge: the screen isn't square, so we need to handle the aspect ratio.

Let's say we want `N` columns of cells. Each cell has width $L = \text{screen\_width} / N$ in pixels, and since cells are square, height $L$ as well. The number of rows depends on the screen's aspect ratio.

Working in our normalized coordinates (after aspect correction), the screen spans roughly $[-2 \cdot \text{aspect}, 2 \cdot \text{aspect}]$ in $x$ and $[-2, 2]$ in $y$. If we want cells of side length $L$ in these coordinates:

```glsl
float aspect = iResolution.x / iResolution.y;
float N = 5.0;  // number of columns
float L = (4.0 * aspect) / N;  // cell size in our coordinate system
```

Now each cell is an $L \times L$ square.

### Part 2: Cell Coordinates and Identity

For each pixel, we want two things:

1. **Which cell are we in?** Integer coordinates $(i, j)$ identifying the cell.
2. **Where in the cell are we?** Local coordinates ranging from $-L/2$ to $L/2$, with $(0,0)$ at the cell center.

```glsl
vec2 cell_id = floor(p / L);
vec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);
```

The `cell_id` tells us which cell; the `cell_p` gives local coordinates within that cell.

If we want local coordinates normalized to $[-1, 1]$ (useful for drawing things at a standard scale), we can rescale:

```glsl
vec2 local = cell_p / (L / 2.0);  // now in [-1, 1] x [-1, 1]
```

This is exactly the setup we'll need for Day 2, where each cell will contain a Julia set with its own coordinate system.

### Part 3: Drawing in Each Cell

Now draw something using the local coordinates. A filled circle at the center of each cell:

```glsl
float d = length(cell_p);
float r = L * 0.4;  // radius relative to cell size

vec3 color;
if (d < r) {
    color = vec3(1.0, 1.0, 0.0);
} else {
    color = vec3(0.1, 0.1, 0.3);
}
```

{{< shader-demo day1/grid-circles >}}

Try changing `N` to get more or fewer columns. The cells stay square regardless of screen shape.

### Part 4: Varying by Cell

The `cell_id` lets each cell behave differently. Some ideas:

**Checkerboard background:**

```glsl
float checker = mod(cell_id.x + cell_id.y, 2.0);
vec3 bg = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);
```

**Radius varying by cell:**

```glsl
float r = L * (0.2 + 0.15 * mod(cell_id.x + cell_id.y, 3.0));
```

**Wave animation:**

```glsl
float cell_dist = length(cell_id);
float r = L * (0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5));
```

### Part 5: Design Challenge

Design a grid-based pattern that you find visually interesting. Some directions:

**Connecting shapes:** Draw shapes that connect across cell boundaries. Quarter-circles in each corner create a continuous network. What implicit curves tile seamlessly?

**Alternating motifs:** Use `cell_id` to alternate between different shapes—circles in some cells, rings in others, or different orientations.

**Color fields:** Map `cell_id` to colors using distance from origin, stripes, or a palette.

**Phase shifts:** Animate cells with different phase offsets to create waves or ripples.

**Using local coordinates:** Draw something more complex in each cell using the $[-1,1]$ local coordinate system—perhaps a small implicit curve, or a pattern that changes based on `cell_id`.

The goal is to produce an image you'd be happy to hang on a wall.


## Project: Elliptic Curve Family

This project builds a beautiful visualization of elliptic curves—the kind used in cryptography and studied throughout number theory. We'll draw not just one curve, but a family of curves that morph as you drag the mouse.

### Part 1: One Elliptic Curve

An elliptic curve in Weierstrass form is $y^2 = x^3 + ax + b$. As an implicit curve: $F(x, y) = y^2 - x^3 - ax - b = 0$.

Start with fixed parameters, say $a = -1$ and $b = 1$:

```glsl
float a = -1.0;
float b = 1.0;

float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;
vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);
float dist = abs(F) / max(length(grad), 0.01);

if (dist < 0.05) {
    color = vec3(1.0, 0.85, 0.3);  // gold
}
```

Get this working first. You should see a smooth curve.

### Part 2: Mouse Controls a Parameter

Let the mouse $y$-coordinate control $b$:

```glsl
float a = -1.0;
float b = mix(-2.0, 2.0, iMouse.y / iResolution.y);
```

Drag up and down. Notice how the curve changes shape—sometimes it's connected, sometimes it splits into two pieces.

### Part 3: The Discriminant

The discriminant $\Delta = 4a^3 + 27b^2$ determines the curve's topology:

- $\Delta > 0$: one connected component
- $\Delta < 0$: two components (an "egg" and an infinite piece)
- $\Delta = 0$: singular (the curve crosses itself)

Color the curve based on this:

```glsl
float disc = 4.0 * a * a * a + 27.0 * b * b;

vec3 curveColor;
if (abs(disc) < 0.3) {
    curveColor = vec3(1.0, 0.2, 0.2);  // red for singular
} else if (disc > 0.0) {
    curveColor = vec3(1.0, 0.85, 0.3); // gold for one component
} else {
    curveColor = vec3(0.3, 0.5, 0.8);  // blue for two components
}
```

### Part 4: A Family of Curves

Instead of one curve, draw many curves at nearby parameter values. Use a loop to vary $b$ around the mouse position:

```glsl
float b_center = mix(-2.0, 2.0, iMouse.y / iResolution.y);

for (int j = -10; j <= 10; j++) {
    float b = b_center + float(j) * 0.15;
    // ... draw curve with this b
}
```

### Part 5: Fading

The family looks cluttered. Make curves fade as they get further from the center:

- **Thickness**: thinner curves further from center
- **Brightness**: dimmer curves further from center

```glsl
float dist_from_center = abs(float(j));
float thickness = 0.05 / (1.0 + dist_from_center * 0.8);
float brightness = 1.0 / (1.0 + dist_from_center * 0.4);
curveColor *= brightness;
```

### Part 6: Two-Parameter Control

Finally, let the mouse control both parameters: $x$ controls $a$, $y$ controls $b$. The family sweeps through $b$ values around the mouse position, while $a$ is set by mouse $x$.

```glsl
float a = mix(-2.0, 1.0, iMouse.x / iResolution.x);
float b_center = mix(-2.0, 2.0, iMouse.y / iResolution.y);
```

Now you can explore the full parameter space. Find where the singular curves live—they form a cusp in $(a, b)$ space!