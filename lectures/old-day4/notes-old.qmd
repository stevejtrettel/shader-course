# Day 4: Simulation

## Overview

By the end of today, you'll be able to create things like this:

{{< shader-demo day4/wave-star >}}

Waves bouncing inside a star. Click to add ripples — watch them reflect off the points and interfere with each other. The wave equation, running in real time on the GPU.

And this:

{{< shader-demo day4/gray-scott-mandelbrot >}}

Reaction-diffusion chemistry confined to the Mandelbrot set. Two simulated chemicals react and diffuse, creating organic patterns that grow and divide inside a fractal boundary.

These are **simulations**: computations where each frame depends on the previous frame. Unlike our earlier shaders, which could compute any frame directly from `iTime`, simulations must evolve step by step. To make them work, we need a new capability: **memory**.

Today we'll learn:

- How buffers store state between frames
- Cellular automata (Game of Life) as a first simulation
- The heat equation: continuous diffusion
- The wave equation: propagation and reflection
- How to trap simulations inside arbitrary boundaries using SDFs


## Buffers and Persistent State

Every shader we've written so far has a fundamental limitation: no memory. Each frame, `mainImage` runs fresh — it doesn't know what it computed last frame, or the frame before that. The screen is a blank slate, redrawn from scratch sixty times per second.

This is fine for static images and even for animation, where motion comes from `iTime`. But it rules out an entire class of phenomena: **simulations**, where the next state depends on the current state. A cellular automaton needs to know which cells were alive. A heat simulation needs to know the current temperature everywhere. A wave needs to know its current shape and velocity.

Today we add memory.

### What Is a Buffer?

Until now, our shader has been a single function — `mainImage` — that writes directly to the screen. The GPU runs it once per pixel, the results appear, and then they're gone. Next frame, we start over.

A **buffer** is a shader that writes to a *stored image* instead of the screen. That image lives in GPU memory and persists between frames. On the next frame, any shader — including the buffer itself — can read from it.

This changes everything. If a buffer reads from itself, it sees what it wrote last frame. Now computations can accumulate. State can evolve. We can simulate.

### Shadertoy's Buffer System

Shadertoy gives us up to four buffers (Buffer A through Buffer D) plus a final Image shader that draws to the screen. Each buffer is its own shader with its own `mainImage` function.

The key mechanism is **channels**. Each shader has four input channels (`iChannel0` through `iChannel3`) that can be connected to various sources: textures, audio, other buffers, or even the buffer's own output.

Here's the setup we'll use most often:

- **Buffer A** reads from itself via `iChannel0` (this creates persistence)
- **Image** reads from Buffer A via `iChannel0` (this displays the result)

To set this up in Shadertoy:

1. Click the **+** tab next to "Image" and select "Buffer A"
2. In Buffer A, click `iChannel0` at the bottom and select "Buffer A" from the Misc tab
3. In Image, click `iChannel0` and select "Buffer A"

Now Buffer A can see its own previous output, and Image can display whatever Buffer A computed.

### Reading from a Buffer

To sample from a buffer, we use `texelFetch`:

```glsl
vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
```

This reads the pixel at exactly the integer coordinates we specify. The third argument (0) is the mipmap level — always use 0 for buffers.

Why `texelFetch` instead of the `texture` function you might have seen elsewhere? The `texture` function uses normalized coordinates (0 to 1) and can interpolate between pixels. For simulations, we want exact pixel values at exact integer locations. `texelFetch` gives us that precision.

### A Painting Program

Let's build the simplest possible buffer shader: a program that remembers where you've drawn.

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read what was here last frame
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    
    // Keep it
    fragColor = prev;
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Just display whatever Buffer A computed
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

Run this and... nothing happens. The screen is black and stays black. But something important *is* happening: Buffer A is reading its previous output and writing it back. It's maintaining state — there's just nothing interesting in that state yet.

Let's add a brush. When the mouse is pressed, we'll draw a white dot:

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read what was here last frame
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    
    // Check distance to mouse
    float d = length(fragCoord - iMouse.xy);
    
    // If mouse is pressed (z > 0) and we're close, paint white
    if (iMouse.z > 0.0 && d < 10.0) {
        fragColor = vec4(1.0);
    } else {
        fragColor = prev;
    }
}
```

Now click and drag. White dots appear — and they *stay*. Release the mouse, click somewhere else, and the old marks are still there. We have persistence.

{{< shader-demo day4/paint-basic >}}

### Frame by Frame

Let's trace through exactly what happens:

**Frame 0:** Buffer A reads from itself, but there's nothing there yet — we get black (zeros). The mouse isn't pressed, so every pixel writes back black.

**Frame 1:** Same thing. Black in, black out.

**Frame 47:** You click at position (200, 150). Pixels within distance 10 of that point write white. Everything else reads black and writes black.

**Frame 48:** Mouse still pressed at (205, 150) — you're dragging. Buffer A reads from last frame: most pixels see black, but pixels near (200, 150) see white. Pixels near the new mouse position write white. Pixels near the old position read white *and write it back*. The stroke accumulates.

**Frame 200:** You've released the mouse. Every pixel reads its previous value and writes it back unchanged. The drawing persists.

This is the core loop: read previous state, decide what the new state should be, write it out.

### Adding Fade

Permanent marks are nice, but let's add some dynamics. What if the paint slowly fades?

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read and fade
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    prev *= 0.99;
    
    // Paint at mouse
    float d = length(fragCoord - iMouse.xy);
    if (iMouse.z > 0.0 && d < 10.0) {
        fragColor = vec4(1.0);
    } else {
        fragColor = prev;
    }
}
```

Now each frame, every pixel's brightness drops to 99% of what it was. Draw something and watch it slowly disappear. Keep drawing and you get glowing trails — new paint is bright, old paint fades into darkness.

{{< shader-demo day4/paint-fade >}}

That single line — `prev *= 0.99` — transforms our painting program into something dynamic. The state isn't just persisting; it's *evolving*. Each frame's output depends on the previous frame's output.

This is the essence of simulation.

### What We've Learned

- **Buffers** are shaders that write to stored images instead of the screen
- Buffer output **persists** between frames
- A buffer can **read from itself** to see its previous output
- Use `texelFetch(iChannel, ivec2(fragCoord), 0)` to read exact pixel values
- The **Image shader** displays the final result by reading from a buffer

With these tools, we can build systems where state evolves over time. But so far, each pixel only looks at itself — its own previous value. In the next section, we'll read from *neighboring* pixels, and that opens up a whole new world: cellular automata, diffusion, waves. Let's start with the most famous cellular automaton of all.


## Game of Life

Conway's Game of Life is the most famous cellular automaton — a grid of cells that evolve according to simple rules, yet produce astonishingly complex behavior. Gliders, oscillators, and self-replicating patterns emerge from just four rules.

It's also the perfect first simulation: the rules are easy to state, the implementation teaches us how to read neighboring pixels, and the results are immediately satisfying.

### The Rules

The Game of Life plays out on a grid where each cell is either **alive** (1) or **dead** (0). Every step, each cell looks at its eight neighbors and decides its next state:

1. **Underpopulation:** A live cell with fewer than 2 live neighbors dies
2. **Survival:** A live cell with 2 or 3 live neighbors survives
3. **Overpopulation:** A live cell with more than 3 live neighbors dies
4. **Reproduction:** A dead cell with exactly 3 live neighbors becomes alive

That's it. These four rules, applied simultaneously to every cell, generate everything from static "still lifes" to traveling "gliders" to chaotic, unpredictable evolution.

### Reading Neighbors

Until now, each pixel only looked at itself — `texelFetch(iChannel0, ivec2(fragCoord), 0)`. To implement Game of Life, we need to read the eight surrounding pixels.

The key insight: `texelFetch` takes integer coordinates, and we can add offsets:

```glsl
ivec2 p = ivec2(fragCoord);

float self  = texelFetch(iChannel0, p, 0).r;
float north = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
float south = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
float east  = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
float west  = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
float ne    = texelFetch(iChannel0, p + ivec2( 1,  1), 0).r;
float nw    = texelFetch(iChannel0, p + ivec2(-1,  1), 0).r;
float se    = texelFetch(iChannel0, p + ivec2( 1, -1), 0).r;
float sw    = texelFetch(iChannel0, p + ivec2(-1, -1), 0).r;
```

::: {.callout-note}
## GLSL: Integer Vectors

We've been using `vec2` for 2D coordinates — these hold floating-point numbers. GLSL also provides **integer vectors**: `ivec2`, `ivec3`, `ivec4`.

The `texelFetch` function requires integer coordinates (it reads exact pixels, not interpolated positions), so we convert with `ivec2(fragCoord)`. This truncates the fractional part, giving us the pixel's integer position.

Integer vectors support the same operations as float vectors — addition, subtraction, component access with `.x` and `.y` — but with integer arithmetic.
:::

We read from the red channel (`.r`) since we only need one value per cell — alive or dead. Now we can count live neighbors:

```glsl
float neighbors = north + south + east + west + ne + nw + se + sw;
```

### The Update Rule

With the neighbor count in hand, we apply Conway's rules:

```glsl
float alive = 0.0;

if (self == 1.0) {
    // Live cell survives with 2 or 3 neighbors
    if (neighbors == 2.0 || neighbors == 3.0) {
        alive = 1.0;
    }
} else {
    // Dead cell becomes alive with exactly 3 neighbors
    if (neighbors == 3.0) {
        alive = 1.0;
    }
}
```

Since each cell stores exactly `0.0` or `1.0`, the neighbor sum is always exactly `0.0`, `1.0`, `2.0`, etc. Small integers are represented exactly in floating point, so direct comparison works perfectly here.

::: {.callout-note}
## When Can You Compare Floats for Equality?

You may have heard "never compare floats for equality." That's good advice when dealing with *computed* values that might accumulate rounding errors. But here we control the data — cells are always set to exactly `1.0` or `0.0`, never something like `0.9999`. When you're comparing values you explicitly stored, equality is safe.
:::

### Initialization

We need to seed the grid with an initial pattern. If we don't, every cell starts dead and stays dead forever — not very interesting.

This is where `iFrame` comes in. On the first frame, we ignore the buffer (it's empty anyway) and write random initial values:

```glsl
if (iFrame == 0) {
    // Initialize with random cells
    float random = hash(fragCoord);
    fragColor = vec4(step(0.5, random));  // 50% chance alive
    return;
}
```

The `hash` function turns coordinates into pseudorandom numbers. Here's a simple one that works well:

```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}
```

This is a common trick in shader programming: use arithmetic operations that scramble the bits of the input coordinates to produce apparently random output. It's deterministic (same input gives same output) but chaotic enough to look random.

Let's see what it looks like:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float random = hash(fragCoord);
    fragColor = vec4(vec3(random), 1.0);
}
```

{{< shader-demo day4/random-noise >}}

Static noise — every pixel gets a different value, but the pattern is fixed (no animation, since the hash only depends on position). When we threshold this at 0.5, roughly half the pixels will be white and half black — our random initial state for Game of Life.

::: {.callout-note}
## The Initialization Pattern

You'll use this pattern in almost every buffer shader:

```glsl
if (iFrame == 0) {
    // Set up initial conditions
    fragColor = ...;
    return;
}

// Normal simulation
```

On frame 0, we write initial state and skip the simulation logic. Every subsequent frame reads the previous state and evolves it.

If you ever notice your simulation not initializing properly — perhaps after resizing the window or switching tabs — you can broaden the check to `if (iFrame < 5)` to catch edge cases.
:::

::: {.callout-tip}
## The Rewind Button

When working with buffer shaders, the **rewind button** (⏮) is your friend. It resets `iFrame` to 0, which re-runs your initialization code.

If you modify your shader and don't see any change, or if things look wrong, hit rewind. The buffer remembers its previous contents — without rewinding, your `iFrame == 0` initialization won't run again.
:::

### The Complete Shader

Putting it all together:

**Buffer A:**
```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize on first frame
    if (iFrame == 0) {
        float random = hash(fragCoord);
        fragColor = vec4(step(0.5, random));
        return;
    }
    
    // Read self and neighbors
    ivec2 p = ivec2(fragCoord);
    
    float self = texelFetch(iChannel0, p, 0).r;
    float neighbors = 
        texelFetch(iChannel0, p + ivec2(-1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  1), 0).r;
    
    // Apply Conway's rules
    float alive = 0.0;
    
    if (self == 1.0) {
        // Live cell survives with 2 or 3 neighbors
        if (neighbors == 2.0 || neighbors == 3.0) {
            alive = 1.0;
        }
    } else {
        // Dead cell becomes alive with exactly 3 neighbors
        if (neighbors == 3.0) {
            alive = 1.0;
        }
    }
    
    fragColor = vec4(alive, alive, alive, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

{{< shader-demo day4/game-of-life >}}

Watch it run! You'll see:

- **Still lifes:** Stable patterns like blocks and beehives that don't change
- **Oscillators:** Patterns that cycle through a sequence of states (blinkers, toads)
- **Gliders:** Patterns that move across the screen
- **Chaos:** Regions of unpredictable activity that eventually settle down

### The Simulation Loop Pattern

Look at the structure of our Game of Life shader:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // 1. Initialize (first frame only)
    if (iFrame == 0) {
        fragColor = initialState(fragCoord);
        return;
    }
    
    // 2. Read current state and neighbors
    float self = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    float neighbors = /* sum of 8 neighbors */;
    
    // 3. Compute new state
    float newState = updateRule(self, neighbors);
    
    // 4. Write new state
    fragColor = vec4(newState);
}
```

This is the **simulation loop pattern**, and we'll use it for every simulation in this chapter:

1. **Initialize** on the first frame
2. **Read** the current state (self and neighbors)
3. **Compute** the new state based on some rule
4. **Write** the new state

The heat equation and wave equation will follow exactly this structure. Only the update rule changes — everything else stays the same.




## The Heat Equation

The heat equation is one of the fundamental PDEs:

$$\frac{\partial u}{\partial t} = \alpha \Delta u$$

Temperature $u$ evolves over time, driven by the Laplacian $\Delta u$. The constant $\alpha$ controls diffusion speed.

To simulate this, we discretize space (pixel grid), time (frames), and the Laplacian (finite differences). The result has the same structure as Game of Life: an initial state and an update rule applied each frame.

### The Discrete Laplacian

The Laplacian is the sum of second partial derivatives:

$$\Delta u = \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}$$

We discretize each term using finite differences:

$$\frac{\partial^2 u}{\partial x^2} \approx u_{i+1,j} - 2u_{i,j} + u_{i-1,j}$$

$$\frac{\partial^2 u}{\partial y^2} \approx u_{i,j+1} - 2u_{i,j} + u_{i,j-1}$$

(taking grid spacing $h = 1$). Adding these:

$$\Delta u \approx u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}$$

The corresponding stencil:

$$\begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \end{bmatrix}$$

In code, this is the same neighbor-sampling pattern as Game of Life:

```glsl
ivec2 p = ivec2(fragCoord);
float center = texelFetch(iChannel0, p, 0).r;
float north  = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
float south  = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
float east   = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
float west   = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;

float laplacian = north + south + east + west - 4.0 * center;
```

### Time Stepping

The heat equation tells us the rate of change: $\partial u / \partial t = \alpha \Delta u$. We step forward in time using explicit Euler:

$$u^{n+1} = u^n + dt \cdot \alpha \cdot \Delta u^n$$

where the superscript denotes the time step. This is the simplest scheme. More sophisticated methods (implicit Euler, Crank-Nicolson, etc.) have better stability properties, but explicit Euler is easiest to implement and illustrates the core idea.

```glsl
float alpha = 0.5;
float dt = 0.4;
float newTemp = center + dt * alpha * laplacian;
```

### Boundary Conditions

What happens at the edges? When we sample neighbors at the boundary, some fall outside the domain. We need to specify boundary conditions.

The simplest choice is **Dirichlet conditions**: fix the boundary values. We'll hold the edges at zero temperature, as if the boundary is in contact with a cold reservoir.

```glsl
// Dirichlet boundary: edges fixed at zero
if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
    fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
    return;
}
```

Other choices include Neumann conditions (zero flux at boundary) or periodic conditions (wrap around). We'll explore these in the exercises.

### Initial Conditions

Let's start with a hot disk in the center — temperature 1 inside, 0 outside:

```glsl
if (iFrame == 0) {
    vec2 center = iResolution.xy * 0.5;
    float d = length(fragCoord - center);
    float temp = d < 80.0 ? 1.0 : 0.0;
    fragColor = vec4(temp, 0.0, 0.0, 1.0);
    return;
}
```

The sharp edge is deliberate — watch the heat equation smooth it out.

::: {.callout-note}
## A Note on Coordinates

We're working directly in pixel coordinates — the grid spacing is $h = 1$ pixel, and distances like `80.0` are measured in pixels. This keeps the code simple, but it means the simulation's appearance depends on your screen resolution. A proper physical simulation would define a domain (say, $[-1, 1]^2$), map pixels to that domain, and account for the actual grid spacing $h$ in the Laplacian. We'll explore this in the exercises.
:::

### The Complete Shader

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: hot disk in center
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float temp = d < 80.0 ? 1.0 : 0.0;
        fragColor = vec4(temp, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary: edges fixed at zero
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Read neighbors
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    // Laplacian
    float laplacian = n + s + e + w - 4.0 * c;
    
    // Explicit Euler step
    float alpha = 0.5;
    float dt = 0.4;
    float newTemp = c + dt * alpha * laplacian;
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
vec3 heatColor(float t) {
    return mix(vec3(0.0, 0.0, 0.3), vec3(1.0, 0.3, 0.0), t);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float temp = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    fragColor = vec4(heatColor(temp), 1.0);
}
```

{{< shader-demo day4/heat-equation >}}

The sharp boundary of the disk immediately begins to blur. Heat diffuses outward while also draining through the cold boundaries. Eventually everything decays to zero.

::: {.callout-warning}
## Stability

Try changing `dt` to `1.0` and hitting rewind.

The simulation explodes. Instead of smooth diffusion, you get oscillations that grow exponentially.

This is a fundamental limitation of explicit methods. The scheme computes the new value from old values alone, without any implicit coupling to the future state. When $dt$ is too large, errors from one step get amplified in the next.

The problem is most severe for high-frequency components — the checkerboard pattern (alternating hot and cold pixels) is the worst case. The Laplacian of a checkerboard is large, so the update overshoots, creating an inverted checkerboard, which overshoots again, and so on.

The stability condition for explicit Euler on the 2D heat equation is:

$$dt < \frac{h^2}{4\alpha}$$

With grid spacing $h = 1$ and $\alpha = 0.5$, this gives $dt < 0.5$. Our choice `dt = 0.4` is safe; `dt = 1.0` violates the condition and blows up.
:::

### Adding Heat Interactively

We can inject heat with the mouse. After computing `newTemp`, add:

```glsl
if (iMouse.z > 0.0) {
    float d = length(fragCoord - iMouse.xy);
    if (d < 20.0) {
        newTemp = 1.0;
    }
}
```

{{< shader-demo day4/heat-interactive >}}

Click and drag to paint heat; watch it diffuse away. We'll use the same technique for the wave equation, where clicks create ripples instead.


## The Wave Equation

The wave equation describes propagating disturbances:

$$\frac{\partial^2 u}{\partial t^2} = c^2 \Delta u$$

Unlike the heat equation, this is **second-order in time**. Heat diffuses and dissipates; waves propagate and reflect.

### Two Quantities

A second-order equation in time requires two pieces of initial data: the initial displacement *and* the initial velocity. We introduce velocity as a separate variable:

$$v = \frac{\partial u}{\partial t}$$

This converts our second-order equation into two coupled first-order equations:

$$\frac{\partial u}{\partial t} = v$$

$$\frac{\partial v}{\partial t} = c^2 \Delta u$$

The first says displacement changes according to velocity. The second says velocity changes according to the Laplacian of displacement — where the surface is curved, it accelerates.

### Two Buffers

We need to store both $u$ and $v$ at each pixel. The cleanest approach: use two buffers.

- **Buffer A** stores displacement $u$
- **Buffer B** stores velocity $v$

Each buffer needs to read from *both* buffers to compute its update. This is our first multi-buffer shader.

In Shadertoy, set up:
- Buffer A: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Buffer B: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Image: `iChannel0` = Buffer A (we display displacement)

Both buffers read from the previous frame's state of A and B, then write their new values simultaneously.

### The Update Rules

Discretizing with explicit Euler:

$$u^{n+1} = u^n + dt \cdot v^n$$

$$v^{n+1} = v^n + dt \cdot c^2 \cdot \Delta u^n$$

Buffer A computes the new displacement:

```glsl
// Buffer A: update displacement
float u = texelFetch(iChannel0, p, 0).r;  // current displacement
float v = texelFetch(iChannel1, p, 0).r;  // current velocity

float newU = u + dt * v;
```

Buffer B computes the new velocity, which requires the Laplacian of $u$:

```glsl
// Buffer B: update velocity
float u_c = texelFetch(iChannel0, p, 0).r;
float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;

float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;

float v = texelFetch(iChannel1, p, 0).r;
float newV = v + dt * c * c * laplacian;
```

### Initial Conditions

We start with a Gaussian "pluck" — a bump in displacement with zero initial velocity:

```glsl
// In Buffer A (displacement)
if (iFrame == 0) {
    vec2 center = iResolution.xy * 0.5;
    float d = length(fragCoord - center);
    float sigma = 30.0;
    float u = exp(-d * d / (2.0 * sigma * sigma));
    fragColor = vec4(u, 0.0, 0.0, 1.0);
    return;
}

// In Buffer B (velocity)
if (iFrame == 0) {
    fragColor = vec4(0.0);  // zero initial velocity
    return;
}
```

### Boundary Conditions

We use Dirichlet conditions: displacement fixed at zero on the boundary. Waves reflect off the fixed edges.

```glsl
if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
    fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
    fragColor = vec4(0.0);
    return;
}
```

### The Complete Shader

Buffer A updates displacement. It reads the current displacement from Buffer A and current velocity from Buffer B, then steps forward: $u^{n+1} = u^n + dt \cdot v^n$.

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: Gaussian pluck
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float sigma = 30.0;
        float u = exp(-d * d / (2.0 * sigma * sigma));
        fragColor = vec4(u, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

Buffer B updates velocity. It reads displacement from Buffer A (including neighbors, to compute the Laplacian) and current velocity from Buffer B, then steps forward: $v^{n+1} = v^n + dt \cdot c^2 \cdot \Delta u^n$.

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: zero velocity
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    // Laplacian of displacement
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

The Image shader reads displacement from Buffer A and maps it to color. Positive displacement is orange, negative is blue.

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    
    // Amplify for visibility
    u *= 5.0;
    
    // Map displacement to color: negative = blue, zero = black, positive = orange
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

{{< shader-demo day4/wave-equation >}}

Watch the circular wave expand from the initial pluck, hit the boundaries, and reflect back. The reflections interfere with each other, creating complex patterns.

### Stability

As with the heat equation, explicit Euler has a stability condition. For the wave equation it's the CFL condition:

$$dt < \frac{h}{c}$$

With $h = 1$ and $c = 0.5$, we need $dt < 2$. Our choice `dt = 0.5` is safe.

### Interactive Waves

To create ripples with the mouse, we add a velocity kick in Buffer B — a small Gaussian impulse:

```glsl
// In Buffer B, after computing newV:
if (iMouse.z > 0.0) {
    float d = length(fragCoord - iMouse.xy);
    float sigma = 15.0;
    newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
}
```

{{< shader-demo day4/wave-interactive >}}

Click to create ripples. Watch them spread, reflect, and interfere.


## Boundary Geometry

So far our waves have bounced off the edges of a rectangle — the screen boundary. But we can trap waves in any shape. The technique: use a signed distance function to define the domain, and force displacement to zero outside it.

This connects back to Day 1. Any SDF works: circles, polygons, even fractals.

### Circular Boundary

Let's trap waves in a circular domain. We need a function that checks whether a pixel is inside. Since both buffers and the Image shader need this function, we'll use Shadertoy's **Common** tab — code placed there gets prepended to every shader in your project.

**Common:**
```glsl
float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = fragCoord - center;
    return sdCircle(p, scale) < 0.0;
}
```

Now in Buffer A, Buffer B, and Image, we just call `inDomain(fragCoord, iResolution.xy)`. The boundary check forces displacement and velocity to zero outside the circle — a Dirichlet condition on the circular boundary.

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.15, 0.15, 0.15, 1.0);
        return;
    }
    
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

{{< shader-demo day4/wave-circle >}}

Click to create ripples. The circular boundary creates beautiful radial reflections.

### Triangular Boundary

To change the domain, we only modify Common — the buffers and Image shader stay exactly the same:

**Common:**
```glsl
float sdEquilateralTriangle(vec2 p) {
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    if (p.x + k * p.y > 0.0) {
        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;
    }
    p.x -= clamp(p.x, -2.0, 0.0);
    return -length(p) * sign(p.y);
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = (fragCoord - center) / scale;
    p.y += 0.25;  // shift down to center the triangle
    return sdEquilateralTriangle(p) < 0.0;
}
```

{{< shader-demo day4/wave-triangle >}}

The corners create focusing effects — waves reflecting off two edges concentrate toward the opposite vertex.


## Exercises

Homework is organized into four types:

**Checkpoints** — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.

**Explorations** — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you're right on track with the course.

**Challenges** — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.

**Project** — An extended project for someone familiar with shader basics, to make an artwork.

---