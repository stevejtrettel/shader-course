# Day 2: Fractals — Homework

## Checkpoints

These verify you've understood the core material.

**C1. Julia Mouse.** Modify the Mandelbrot shader to render a Julia set controlled by the mouse. Fix `c` to come from `iMouse.xy` (mapped to $[-2, 2] \times [-2, 2]$) and initialize `z` from the pixel position. Drag around and watch the Julia set change—connected structures shatter into dust as you cross outside the Mandelbrot set.

**C2. Higher Powers.** The iteration $z^2 + c$ generalizes to $z^n + c$. For $z^3$, you can use repeated multiplication:
```glsl
vec2 ccube(vec2 z) {
    return cmul(cmul(z, z), z);
}
```

For arbitrary powers, use polar form:
```glsl
vec2 cpow(vec2 z, float n) {
    float r = length(z);
    float theta = atan(z.y, z.x);
    return pow(r, n) * vec2(cos(n * theta), sin(n * theta));
}
```

Try $n = 3, 4, 5$—what rotational symmetry does each have? Why? Try $n = 2.5$ and look for the discontinuity.

**C3. Smooth Coloring.** The discrete iteration count creates visible color bands. This formula gives a fractional escape time that removes them:

```glsl
// After the loop, if escaped:
float log_zn = log(cabs2(z)) / 2.0;
float nu = log(log_zn / log(2.0)) / log(2.0);
float smooth_iter = float(iter) + 1.0 - nu;
```

Apply this to your Mandelbrot or Julia shader. The bands should vanish. For best results, run 2-3 extra iterations after detecting escape before computing `smooth_iter`.

**C4. Apollonian Animation.** Animate the Apollonian gasket by letting the iteration count grow with time:
```glsl
int max_iter = int(mod(iTime * 5.0, 50.0)) + 1;
```
Watch each iteration reveal a new layer of circles.


## Explorations

These extend the day's topics in interesting directions.

**E1. Julia Animation.** Animate `c` along the boundary of the main cardioid:
```glsl
vec2 cardioid(float t) {
    vec2 eit = vec2(cos(t), sin(t));
    return cmul(eit, (vec2(2.0, 0.0) - eit) / 4.0);
}
vec2 c = cardioid(iTime * 0.5);
```
Every point on the cardioid gives a Julia set with a parabolic fixed point—right at the edge of connectivity. What do you observe about the Julia sets as $c$ traces this curve?

**E2. Other Escape-Time Fractals.** The Mandelbrot iteration $z \mapsto z^2 + c$ is one choice among many. Implement these variations:

- **Burning Ship**: $z_{n+1} = (|\text{Re}(z_n)| + i|\text{Im}(z_n)|)^2 + c$ — take absolute values *before* squaring. Center around $(-0.5, -0.5)$ to see the main structure. Then try zooming into the small blob in the lower-left (around $(-1.8, -0.05)$ at 20× zoom) to find a miniature "burning ship."
- **Tricorn**: $z_{n+1} = \bar{z}_n^2 + c$ where $\bar{z} = x - iy$ is the complex conjugate. Also called the "Mandelbar."
- **Celtic**: $z_{n+1} = (|\text{Re}(z_n^2)| + i\,\text{Im}(z_n^2)) + c$ — absolute value of real part *after* squaring.

The escape condition $|z| > 2$ still applies. Use smooth coloring (C3) and experiment with different palette parameters to make these look good—they can be just as beautiful as the Mandelbrot set with the right coloring.

**E3. Sierpinski Carpet.** Render the Sierpinski carpet using the same iterate-and-test approach as the Apollonian gasket.

The carpet lives in the unit square $[0,1]^2$. At each iteration:
1. Scale coordinates by 3 to see which of 9 sub-cells you're in
2. If you're in the center cell, stop (this region is removed)
3. Otherwise, use `fract` to zoom into that cell and repeat

Color the carpet black and removed regions white (or vice versa). The key insight: `floor(p * 3.0)` gives the cell indices (0, 1, or 2 in each dimension), and `fract(p * 3.0)` gives position within that cell, ready for the next iteration.

**E4. Sierpinski Triangle.** Apply the same subdivision technique to the Sierpinski triangle. 

We use a right triangle with vertices at $(0,0)$, $(1,0)$, and $(0,1)$ because the region tests are simple:
- Bottom-left sub-triangle: $x + y < 0.5$
- Bottom-right sub-triangle: $x > 0.5$  
- Top sub-triangle: $y > 0.5$
- Middle (removed): everything else

Each sub-triangle maps back to the full triangle by scaling by 2 and translating. Work out the three transformations and implement the shader.

*Extension:* The right triangle looks tilted. Apply an affine transformation at the end to map it to an equilateral triangle centered at the origin. The transformation is a shear followed by a scale.

**E5. Apollonian Domain Coloring.** Modify the Apollonian gasket to track *which* circle you inverted through most recently. After iteration, color by this: red for c1, green for c2, blue for c3, yellow for outer.

What structure do you see? Where are the boundaries between colored regions? How does this relate to the limit set?


## Challenges

These require ideas beyond the lecture.

**H1. Split-Screen Julia Explorer.** Build a side-by-side display with the Mandelbrot set on the left and a Julia set on the right. The mouse position in the left half selects the parameter $c$, and the Julia set updates in real time.

Requirements:
1. Left half shows Mandelbrot, right half shows Julia—each properly centered and aspect-corrected within its half
2. Mouse position determines $c$, but only when clicking/dragging on the *left* half
3. A small colored dot marks the current $c$ value on the Mandelbrot side
4. Both halves should use the same coloring scheme

The coordinate setup is the tricky part: each half of the screen needs its own independent mapping to $[-2, 2] \times [-2, 2]$ (or similar). Think carefully about aspect ratios for half-width rectangles.

Watch the Julia set transform as you drag across the Mandelbrot boundary—connected sets shatter into dust.

**H2. Newton Fractal.** Newton's method finds roots of $f(z) = 0$ by iterating $z \mapsto z - f(z)/f'(z)$. For $f(z) = z^3 - 1$:
$$z_{n+1} = \frac{2z_n^3 + 1}{3z_n^2}$$

This converges to one of the three cube roots of unity: $1$, $e^{2\pi i/3}$, $e^{4\pi i/3}$. Color each pixel by which root its orbit approaches.

You'll need complex division:
```glsl
vec2 cdiv(vec2 z, vec2 w) {
    float denom = dot(w, w);
    return vec2(z.x*w.x + z.y*w.y, z.y*w.x - z.x*w.y) / denom;
}
```

How do you determine which root the orbit converged to? The basin boundaries form a fractal—every point on the boundary has all three basins arbitrarily close by.

**H3. Escape Radius Proofs.** Prove the facts that justify the escape-time algorithm.

For the Mandelbrot set:
1. If $|c| > 2$, then $c \notin \mathcal{M}$.
2. If $|z_n| > 2$ for some $n$ (with $|c| \leq 2$), the orbit escapes to infinity.

For Julia sets: If $|z| > R$ where $R = \frac{1 + \sqrt{1 + 4|c|}}{2}$, then the orbit escapes.

*Hint:* The key inequality is $|z^2 + c| \geq |z|^2 - |c|$ (triangle inequality). For what values of $|z|$ is $|z|^2 - |c| > |z|$?

**H4. Period Detection.** Some orbits in the Mandelbrot set are periodic—they settle into cycles. A period-1 orbit converges to a fixed point; period-2 alternates between two values ($z_{n+2} = z_n$); and so on.

To detect periodicity, track the last few iterates and check if the current value matches one of them. You'll need separate variables for $z_{n-1}$, $z_{n-2}$, etc. Check for matches only after enough iterations have passed for the orbit to settle (say, $n > 50$).

Implement a shader that colors the Mandelbrot set by period: one color for period-1, another for period-2, another for period-3. Points that escape get colored by iteration count as usual; points that don't converge to a detected period stay black.

What structure do you find?

**H5. Orbit Traps.** The escape-time algorithm colors points by *when* the orbit escapes. An orbit trap colors points by *where* the orbit goes—specifically, how close it passes to a geometric "trap" shape.

During iteration, track the minimum distance from $z$ to your trap. For points *inside* the Mandelbrot set (bounded orbits), color by this minimum distance. For points outside, just color black—the interesting structure is inside, where orbits pass near the trap repeatedly.

Good traps to try:
- **Point trap**: `length(z)` — distance to origin
- **Circle trap**: `abs(length(z) - 1.0)` — distance to unit circle
- **Cross trap**: `min(abs(z.x), abs(z.y))` — distance to axes

Experiment with coloring: `palette(trap_dist * 5.0)` or glow effects like `exp(-trap_dist * 20.0)`.

The results reveal structure invisible in standard escape-time coloring.

**H6. Distance Estimation.** The escape-time algorithm gives blocky boundaries at high zoom. Distance estimation produces smooth, resolution-independent boundaries by tracking the derivative of the orbit.

Let $z'_n = \frac{\partial z_n}{\partial c}$. Starting from $z_0 = 0$ and $z'_0 = 0$, derive the recurrence for $z'_{n+1}$ using the chain rule on $z_{n+1} = z_n^2 + c$.

When the orbit escapes, the distance to the Mandelbrot boundary is approximately:
$$d \approx \frac{|z_n| \log|z_n|}{|z'_n|}$$

Implement distance estimation and use it to visualize the boundary:
- **Sharp boundary**: `d < 0.002 ? white : black`
- **Glow effect**: `exp(-d * 200.0)`
- **Contour lines**: `fract(log(d) * 5.0)`

To see the improvement, zoom into a region of the boundary (say, near $c = -0.75 + 0.1i$ at 100× magnification) and compare escape-time coloring to distance-based rendering. The distance estimator gives crisp edges at any zoom level.


## Projects

**Project 1: Grid of Julia Sets**

Create a grid where each cell shows the Julia set for a different parameter $c$. Use the grid formula from Day 1:

```glsl
// Grid setup
float L = 0.5;                            // cell size

// Grid formula
vec2 cell_id = floor(p / L + 0.5);        // which cell (round to nearest)
vec2 cell_center = cell_id * L;           // center of this cell
vec2 local = p - cell_center;             // offset from center, in [-L/2, L/2]
```

Map `cell_center` to a parameter $c$ in an interesting region of the complex plane (try the window $[-2, 0.5] \times [-1.25, 1.25]$). Use `local` scaled to $[-2, 2]$ as the starting point $z$ for the Julia iteration.

Color the Julia sets dark on a light background (inverted from the usual convention). When you zoom out, the grid reveals the Mandelbrot set: cells with $c \in \mathcal{M}$ show connected Julia sets, cells with $c \notin \mathcal{M}$ show scattered dust. This is the Mandelbrot-Julia correspondence made visible.

**Project 2: Orbit Visualization**

Instead of coloring by iteration count, visualize the actual orbit. Let the mouse control the starting point $z_0$:

- Compute iterates $z_0, z_1, \ldots, z_N$
- Draw a small circle at each iterate
- Connect consecutive iterates with line segments (use the segment SDF from Day 1)
- Color by iteration index—early iterates blue, later iterates red

Start with the Mandelbrot/Julia iteration: for a fixed $c$ inside $\mathcal{M}$, drag $z_0$ around. Bounded orbits spiral toward an attractor; escaping orbits fly outward. You'll see sensitive dependence—nearby starting points can have very different fates.

Once it works for complex dynamics, try the same visualization for the Apollonian gasket or Sierpinski carpet. Watch the point bounce between inversions or zoom into sub-cells. The iteration logic differs but the visualization technique is identical.
