---
title: "Day 2: Fractals"
subtitle: "Shaders for Mathematical Visualization"
format:
  revealjs:
    theme: [default, ../../styles/slides.scss]
metadata-files:
  - ../../_slides-metadata.yml
---

# Fractals

## {background-color="white"}

{{< shader-demo day2/mandelbrot-zoom height="700px" >}}

## What is a Fractal?

Structure at every scale, generated by iteration.

::: {.incremental}
- Repeat a simple rule
- Check a condition
- Color by how long it takes
:::

## Complex Numbers in GLSL

A complex number $z = a + bi$ is a `vec2`:

```glsl
vec2 z = vec2(a, b);  // real part, imaginary part
```

Addition works: `z + w` is componentwise.

Multiplication doesn't—$(a+bi)(c+di) \neq (ac, bd)$.

## Complex Arithmetic

```glsl
// Complex multiplication: (a + bi)(c + di)
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, 
                z.x * w.y + z.y * w.x);
}

// Squared magnitude (avoids sqrt)
float cabs2(vec2 z) {
    return dot(z, z);
}
```

# The Mandelbrot Set

## Definition

Pick a complex number $c$. Iterate:
$$z_0 = 0, \quad z_{n+1} = z_n^2 + c$$

If the orbit stays bounded, $c$ is in the Mandelbrot set.

If $|z_n| > 2$ ever, it escapes to infinity.

## Mandelbrot Code {.smaller}

```glsl
vec2 c = p;  // c from pixel position
c.x -= 0.5;  // shift to center the set

vec2 z = vec2(0.0, 0.0);
int max_iter = 100;
int iter;

for (iter = 0; iter < max_iter; iter++) {
    if (cabs2(z) > 4.0) break;  // escaped
    z = cmul(z, z) + c;
}

vec3 color;
if (iter == max_iter) {
    color = vec3(0.0, 0.0, 0.0);  // in the set: black
} else {
    color = vec3(1.0, 1.0, 1.0);  // escaped: white
}
```

## {background-color="white"}

{{< shader-demo day2/mandelbrot-bw height="700px" >}}

# Julia Sets

## A Different Question

Mandelbrot: fix $z_0 = 0$, vary $c$ (from pixel).

Julia: fix $c$, vary $z_0$ (from pixel).

Same iteration, different role for the pixel coordinate.

## Julia Code {.smaller}

```glsl
// Fixed parameter
vec2 c = vec2(-0.7, 0.27015);

// z starts at pixel position (not zero!)
vec2 z = p;

int max_iter = 100;
int iter;

for (iter = 0; iter < max_iter; iter++) {
    if (cabs2(z) > 4.0) break;
    z = cmul(z, z) + c;
}
```

## {background-color="white"}

{{< shader-demo day2/julia-static height="700px" >}}

## The Correspondence

Each point $c$ in the Mandelbrot set has a Julia set.

- $c$ inside $\mathcal{M}$ → Julia set is connected
- $c$ outside $\mathcal{M}$ → Julia set is dust

## {background-color="white"}

{{< shader-demo day2/julia-explorer height="700px" >}}

Drag to change $c$ and watch the Julia set transform.

# Coloring

## Iteration Count

Black and white throws away information. The iteration count tells us *how fast* a point escapes.

```glsl
if (iter == max_iter) {
    color = vec3(0.0, 0.0, 0.0);  // in the set
} else {
    float t = float(iter) / float(max_iter);
    color = vec3(t, t, t);    // grayscale
}
```

## {background-color="white"}

{{< shader-demo day2/mandelbrot-gray height="700px" >}}

## Cosine Palette

```glsl
vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

float t = float(iter) / float(max_iter);
vec3 color = palette(t);
```

## {background-color="white"}

{{< shader-demo day2/mandelbrot-color height="700px" >}}

## The Pattern

All escape-time fractals share the same structure:

1. **Iterate** a function
2. **Check** an escape condition
3. **Color** by iteration count

Change the function, get a different fractal.

# Circle Inversion

## A Different Kind of Iteration

Polynomials aren't the only thing we can iterate.

**Circle inversion** through the unit circle:
$$\text{inv}(\mathbf{p}) = \frac{\mathbf{p}}{|\mathbf{p}|^2}$$

Points inside ↔ points outside. The circle itself is fixed.

## Inversion Code

```glsl
vec2 invert(vec2 p) {
    return p / dot(p, p);
}
```

That's it. `dot(p, p)` is $|p|^2$.

## {background-color="white"}

{{< shader-demo day2/inversion-toggle height="700px" >}}

Lines become circles. Circles become circles (or lines).

## {background-color="white"}

{{< shader-demo day2/inversion-grid height="700px" >}}

`mod(q, 0.5)` gives position within a repeating cell.

# Structs and General Inversion

## The Circle Struct

To invert through any circle, we need center and radius:

```glsl
struct Circle {
    vec2 center;
    float radius;
};

Circle c = Circle(vec2(1.0, 0.5), 0.8);
```

## General Inversion

```glsl
vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}
```

# The Apollonian Gasket

## Circle Packing

Start with four mutually tangent circles. Fill each gap with a circle tangent to its three neighbors. Repeat forever.

We render it by iterating inversions.

## Setup: Four Circles {.smaller}

```glsl
float r = 1.0;
float circumradius = 2.0 * r / sqrt(3.0);

Circle c1 = Circle(vec2(0.0, circumradius), r);
Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);
Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);
Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
```

## {background-color="white"}

{{< shader-demo day2/apollonian-setup height="700px" >}}

Three inner circles, one outer circle, all tangent.

## Iteration Logic {.smaller}

```glsl
for (iter = 0; iter < max_iter; iter++) {
    if (isInside(p, c1)) {
        p = invert(p, c1);
    } else if (isInside(p, c2)) {
        p = invert(p, c2);
    } else if (isInside(p, c3)) {
        p = invert(p, c3);
    } else if (!isInside(p, outer)) {
        p = invert(p, outer);
    } else {
        break;  // in a gap—done
    }
}
```

## {background-color="white"}

{{< shader-demo day2/apollonian-final height="700px" >}}

Same pattern: iterate, check condition, color by count.

# Wrap Up

## What We Learned

- Complex arithmetic in GLSL: `cmul`, `cabs2`
- Mandelbrot set: iterate $z^2 + c$, escape when $|z| > 2$
- Julia sets: fix $c$, vary starting point
- Coloring by iteration count
- Circle inversion: $p / |p|^2$
- Apollonian gasket: iterate four inversions

## Exercises

**Checkpoints**: Julia set, cubic Mandelbrot, colorize, Apollonian animation

**Explorations**: Julia animation, Burning Ship/Tricorn/Celtic, Sierpinski carpet & triangle

**Challenges**: Newton fractal, higher powers, escape radius proofs

**Projects**: Grid of Julia sets, orbit visualization

See the homework handout!
