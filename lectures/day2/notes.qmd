# Day 2: Fractals

## Overview

A fractal is a shape with structure at every scale—zoom in and you find more detail, forever. Today we make two of them:

{{< shader-demo day2/mandelbrot-zoom >}}

The first is the Mandelbrot set, born from iterating $z \mapsto z^2 + c$ in the complex plane. The second is the Apollonian gasket, born from iterating circle inversions. Different mathematics, same principle: take a simple operation and repeat it.

Both fit naturally into shaders. Each pixel asks "what happens when I iterate from here?"—and since pixels don't depend on each other, the GPU can answer millions of these questions in parallel.

The Mandelbrot set lives in the complex plane, so we start there.


## Complex Numbers in GLSL

The complex numbers $\mathbb{C}$ are the plane $\mathbb{R}^2$ equipped with a multiplication. A point $(a, b)$ represents $a + bi$, and we define
$$(a + bi)(c + di) = (ac - bd) + (ad + bc)i.$$

This makes $\mathbb{C}$ a field, with $i^2 = -1$ encoding the rotation structure of complex multiplication.

### Representation

A complex number $z = a + bi$ is naturally a `vec2`:

```glsl
vec2 z = vec2(a, b);  // represents a + bi
```

We use the convention that `z.x` is the real part and `z.y` is the imaginary part.

### Arithmetic

Addition is componentwise, so GLSL's built-in `+` already does the right thing. No helper function needed.

Multiplication requires care. The `*` operator on vectors is componentwise—`vec2(a,b) * vec2(c,d)` gives `vec2(a*c, b*d)`—which is not complex multiplication. We implement the correct formula:

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(
        z.x * w.x - z.y * w.y,
        z.x * w.y + z.y * w.x
    );
}
```

The minus sign in the real part comes from $i^2 = -1$.

### Magnitude

The magnitude $|z| = \sqrt{a^2 + b^2}$ measures distance from the origin. We could compute it directly:

```glsl
float cabs(vec2 z) {
    return sqrt(z.x * z.x + z.y * z.y);
}
```

But we'll often want to check conditions like "$|z| > 2$" rather than compute the actual magnitude. Since $|z| > 2$ is equivalent to $|z|^2 > 4$, we can avoid the square root:

```glsl
float cabs2(vec2 z) {
    return dot(z, z);  // z.x² + z.y²
}
```

The built-in `dot(z, z)` computes $a^2 + b^2$ efficiently. When you're doing this millions of times per frame, skipping unnecessary square roots matters.


## The Mandelbrot Set

Fix a complex number $c$. Starting from $z_0 = 0$, iterate:
$$z_{n+1} = z_n^2 + c$$

For some values of $c$, this sequence stays bounded. For others, it escapes to infinity. The **Mandelbrot set** $\mathcal{M}$ is the set of all $c$ for which the sequence remains bounded:
$$\mathcal{M} = \{c \in \mathbb{C} : \text{the orbit of } 0 \text{ under } z \mapsto z^2 + c \text{ is bounded}\}$$

The boundary has intricate structure, but we never describe this geometry explicitly. Every pixel runs the same computation, asks "does my orbit escape?", and the structure emerges.

### The Escape Radius

We can't iterate forever, so we need a stopping criterion. Two facts make this practical:

**Fact 1.** If $|c| > 2$, then $c \notin \mathcal{M}$.

**Fact 2.** If $|z_n| > 2$ for some $n$, the orbit escapes to infinity, so $c \notin \mathcal{M}$.

Together, these justify the **escape-time algorithm**: iterate until $|z| > 2$ (the orbit is escaping) or until we hit a maximum iteration count (the orbit is probably bounded). The number 2 here is the *escape radius*.

Proving these facts requires some careful estimates with the triangle inequality; we leave this as Challenge H4.

### Implementation

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    // Map to a region showing the Mandelbrot set
    vec2 c = uv * 4.0;
    c.x -= 0.5;  // shift left—the set isn't centered at the origin
    
    // Iterate
    vec2 z = vec2(0.0, 0.0);
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;  // |z|² > 4 means |z| > 2
        z = cmul(z, z) + c;
    }
    
    // Color: black if we never escaped, white otherwise
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        color = vec3(1.0, 1.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

{{< shader-demo day2/mandelbrot-bw >}}

There's another fractal hiding in the same iteration.


## Julia Sets

The Mandelbrot set asks: for which $c$ does the orbit of $0$ stay bounded? We can ask a different question: for a *fixed* $c$, which starting points $z_0$ have bounded orbits?

Fix $c \in \mathbb{C}$. The **filled Julia set** $K_c$ is
$$K_c = \{z_0 \in \mathbb{C} : \text{the orbit of } z_0 \text{ under } z \mapsto z^2 + c \text{ is bounded}\}$$

Same iteration, different question. For the Mandelbrot set, we vary $c$ and always start at $z_0 = 0$. For a Julia set, we fix $c$ and vary the starting point.

The code change is minimal:

```glsl
// Mandelbrot: c comes from pixel position, z starts at 0
vec2 c = p;
vec2 z = vec2(0.0, 0.0);

// Julia: c is fixed, z comes from pixel position
vec2 c = vec2(-0.7, 0.27015);  // a fixed parameter
vec2 z = p;
```

{{< shader-demo day2/julia-static >}}

### Escape Radius for Julia Sets

**Fact.** For the iteration $z \mapsto z^2 + c$, if $|z_n| > R$ where
$$R = \frac{1 + \sqrt{1 + 4|c|}}{2}$$
then the orbit escapes to infinity, so $z_0 \notin K_c$.

This is the Julia set analog of the Mandelbrot escape facts—once outside this disk, you never come back. In practice, the simpler bound $R = \max(2, |c|)$ is also valid and easier to compute. Proving this is Exercise H5.

Different values of $c$ produce very different Julia sets. Some are connected (one piece), others are totally disconnected (Cantor dust). The relationship is governed by a precise theorem.

### The Mandelbrot-Julia Correspondence

Each point $c$ in the complex plane has an associated Julia set $K_c$, and the Mandelbrot set tells you what kind:

**Theorem (Douady-Hubbard).** The filled Julia set $K_c$ is connected if and only if $c \in \mathcal{M}$.

If $c$ lies inside the Mandelbrot set, the Julia set is a single connected piece—perhaps with a complicated boundary, but topologically one blob. If $c$ lies outside the Mandelbrot set, the Julia set shatters into uncountably many pieces, a Cantor set of dust. The Mandelbrot set is precisely the set of parameters for which the Julia set holds together.

Points on the *boundary* of $\mathcal{M}$ give the most intricate Julia sets—neither solid nor completely fractured, but balanced at the edge of connectivity.

{{< shader-demo day2/julia-explorer >}}

Drag from inside the Mandelbrot set to outside and watch the Julia set transform. Connected structures with complicated boundaries give way to scattered dust as you cross into the exterior.


## Coloring Escape-Time Fractals

Black and white shows the set, but we're throwing away information. The iteration count tells us *how quickly* a point escapes—points that escape after 5 iterations are different from points that escape after 50.

### Grayscale

Map the iteration count to brightness:

```glsl
vec3 color;
if (iter == max_iter) {
    color = vec3(0.0, 0.0, 0.0);  // in the set: black
} else {
    float t = float(iter) / float(max_iter);
    color = vec3(t, t, t);  // escaped: brightness from iteration count
}
```

{{< shader-demo day2/mandelbrot-gray >}}

Structure appears: tendrils, spirals, bulbs around the boundary. Points near the boundary of the Mandelbrot set take many iterations to escape (bright); points far from the set escape quickly (dark).

### Color

Grayscale reveals structure, but color can reveal more. We use a cosine palette (see Appendix: Color) to map iteration counts to smooth color gradients:

```glsl
vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

float t = float(iter) / float(max_iter);
vec3 color = palette(t);
```

{{< shader-demo day2/mandelbrot-color >}}

The color bands correspond to iteration counts.

### The Pattern

The Mandelbrot set and Julia sets share the same structure:

1. **Iterate** a function $f(z, c)$
2. **Check escape**: has $|z|$ exceeded some threshold?
3. **Color** based on iteration count

Changing the iteration function changes the fractal. The exercises include $z^3 + c$, the Burning Ship, and others.


## Circle Inversion

We've been iterating a polynomial. But polynomials aren't the only thing we can iterate.

Circle inversion is to circles what reflection is to lines: it swaps inside and outside, preserves angles, and applying it twice returns you to where you started. We'll build another fractal the same way we built the Mandelbrot set: iterate a map, check a condition on where the point ends up, and color accordingly. For Mandelbrot, we checked whether the orbit escaped past radius 2. For our next fractal, we'll check which region the orbit lands in after bouncing between inversions.

### Definition

Inversion in the unit circle sends a point $\mathbf{p}$ to:
$$\text{inv}(\mathbf{p}) = \frac{\mathbf{p}}{|\mathbf{p}|^2}$$

The inverted point lies on the same ray from the origin, but at reciprocal distance: if $\mathbf{p}$ is at distance $r$, its image is at distance $1/r$. Points inside the circle map outside; points outside map inside; points on the circle stay fixed. (The origin maps to "infinity"—inversion extends naturally to the Riemann sphere.)

```glsl
vec2 invert(vec2 p) {
    return p / dot(p, p);
}
```

### Visualizing Inversion

To see what inversion does, let's draw some shapes and watch them transform. The shader below toggles between original and inverted coordinates:

```glsl
vec2 p_inv = invert(p);

// Toggle every second
vec2 q;
if (fract(iTime * 0.5) < 0.5) {
    q = p;
} else {
    q = p_inv;
}

// Draw shapes using q
```

{{< shader-demo day2/inversion-toggle >}}

Lines not through the origin become circles through the origin. Circles map to circles, or to lines if they pass through the center of inversion.

::: {.callout-tip}
## GLSL Shortcuts: mix and step

The toggle logic can be written more compactly:

- `step(edge, x)` returns 0 if `x < edge`, otherwise 1
- `mix(a, b, t)` linearly interpolates: returns `a` when `t = 0`, `b` when `t = 1`

```glsl
float t = step(0.5, fract(iTime * 0.5));
vec2 q = mix(p, p_inv, t);
```
:::

Invert a grid. The function `mod(q, 0.5)` gives the position of `q` within a repeating $0.5 \times 0.5$ cell. When either component is near zero, we're on a grid line:

```glsl
vec2 grid = mod(q, 0.5);
if (grid.x < 0.02 || grid.y < 0.02) color = vec3(1.0, 1.0, 0.0);
```

{{< shader-demo day2/inversion-grid >}}

The rectilinear grid becomes a web of circles, all passing through the origin.

### General Circle Inversion

So far we've inverted through the unit circle at the origin. For a circle with center $\mathbf{c}$ and radius $R$:
$$\text{inv}(\mathbf{p}) = \mathbf{c} + R^2 \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|^2}$$

The point is reflected through the circle: same ray from the center, reciprocal distance (scaled by $R^2$).


## Structs

To invert through an arbitrary circle, we need to pass both a center and a radius. We could write:

```glsl
vec2 invert(vec2 p, vec2 center, float radius) { ... }
```

But when working with multiple circles, this gets unwieldy. GLSL lets us bundle related data into a **struct**:

```glsl
struct Circle {
    vec2 center;
    float radius;
};
```

Now `Circle` is a type. We can create instances and access their fields:

```glsl
Circle c = Circle(vec2(1.0, 0.5), 0.7);
// c.center is vec2(1.0, 0.5)
// c.radius is 0.7
```

Our inversion function becomes cleaner:

```glsl
vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}
```

And we can write helper functions that take circles as arguments:

```glsl
float distToCircle(vec2 p, Circle c) {
    return abs(length(p - c.center) - c.radius);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}
```

{{< shader-demo day2/inversion-moving >}}


## The Apollonian Gasket

The Apollonian gasket is a fractal circle packing, named for Apollonius of Perga who studied tangent circles in the 3rd century BCE. Start with four mutually tangent circles, three inside one, and fill each curved gap with a circle tangent to its three neighbors. Repeat.

### Setup

Place three circles of radius $r$ with centers at the vertices of an equilateral triangle, all tangent to each other and enclosed by an outer circle tangent to all three:

```glsl
float r = 1.0;
float circumradius = 2.0 * r / sqrt(3.0);  // center-to-vertex distance

Circle c1 = Circle(vec2(0.0, circumradius), r);
Circle c2 = Circle(vec2(-circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
Circle c3 = Circle(vec2(circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
```

{{< shader-demo day2/apollonian-setup >}}

The gaps between circles are curvilinear triangles.

### Iteration

If a point is inside one of the inner circles, invert it through that circle, pushing it out. If it's outside the outer circle, invert through the outer circle—pulling it in. Repeat until the point lands in a gap (inside the outer circle but outside all inner circles) or we hit a maximum iteration count.

```glsl
for (iter = 0; iter < max_iter; iter++) {
    if (isInside(p, c1)) {
        p = invert(p, c1);
    } else if (isInside(p, c2)) {
        p = invert(p, c2);
    } else if (isInside(p, c3)) {
        p = invert(p, c3);
    } else if (!isInside(p, outer)) {
        p = invert(p, outer);
    } else {
        break;  // in a gap—done
    }
}
```

Color by iteration count, just like escape-time fractals:

```glsl
float t = float(iter) / float(max_iter);
vec3 color = palette(t);
```

Each inversion maps the configuration into a smaller copy of itself, creating self-similar structure at every scale.

### Full Implementation

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 6.0;
    
    // Setup circles
    float r = 1.0;
    float circumradius = 2.0 * r / sqrt(3.0);
    
    Circle c1 = Circle(vec2(0.0, circumradius), r);
    Circle c2 = Circle(vec2(-circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
    Circle c3 = Circle(vec2(circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
    
    // Iterate inversions
    int max_iter = 50;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
        } else {
            break;
        }
    }
    
    // Color by iteration count
    float t = float(iter) / float(max_iter);
    vec3 color = palette(t);
    
    fragColor = vec4(color, 1.0);
}
```

{{< shader-demo day2/apollonian-iterated >}}

### The Limit Set

Points that land in a gap quickly are dark. Points near the fractal boundary, the **limit set**, take many iterations to settle and appear bright. We can emphasize the limit set with nonlinear coloring:

```glsl
float t = float(iter) / float(max_iter);
vec3 color = 30.0 * vec3(pow(t, 2.0));
```

The squaring suppresses low iteration counts while the factor of 30 boosts high ones:

{{< shader-demo day2/apollonian-final >}}

All of this from iterating four circle inversions.


## Summary

Today we built fractals from two different iterations: complex quadratic polynomials (Mandelbrot and Julia sets) and circle inversions (Apollonian gasket). Despite their different origins, both share the same algorithmic structure:

1. **Iterate** a transformation
2. **Test** a stopping condition (escape, or landing in a fundamental region)
3. **Color** based on iteration count

This pattern—per-pixel iteration with no communication between pixels—is ideal for GPUs.

### GLSL Skills

- **Complex arithmetic**: Representing $\mathbb{C}$ as `vec2`, implementing `cmul` and `cabs2`
- **Structs**: Bundling related data (`Circle` with center and radius)
- **Control flow**: `for` loops with early `break`, nested `if/else`
- **Built-in functions**: `dot`, `length`, `mod`, `step`, `mix`
- **Cosine palettes**: Mapping scalar values to smooth color gradients

### Key Concepts

- The **escape radius** lets us stop iterating early—once $|z|$ exceeds the threshold, we know the orbit escapes
- The **Mandelbrot set** indexes Julia sets: $c \in \mathcal{M}$ if and only if $K_c$ is connected
- **Circle inversion** generalizes reflection and preserves angles (it's a conformal map)
- **Iteration count** encodes geometric information—how close a point is to the fractal boundary

Tomorrow we move to three dimensions.