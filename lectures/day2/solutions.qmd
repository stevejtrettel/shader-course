# Appendix: Day 2 Exercise Solutions

Complete solutions for the Day 2 exercises. Try the exercises yourself before looking here!


## Checkpoints

### C1. Julia Set

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Fixed parameter
    vec2 c = vec2(-0.7, 0.27015);
    
    // z starts at pixel position (not zero!)
    vec2 z = p;
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        color = vec3(1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### C2. Cubic Mandelbrot

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 ccube(vec2 z) {
    float a = z.x, b = z.y;
    return vec2(a*a*a - 3.0*a*b*b, 3.0*a*a*b - b*b*b);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 c = uv * 3.0;
    vec2 z = vec2(0.0);
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = ccube(z) + c;  // z³ + c instead of z² + c
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        color = vec3(1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The cubic Mandelbrot has **3-fold rotational symmetry** (120° rotation), compared to the 2-fold symmetry of the standard Mandelbrot.


### C3. Apollonian Animation

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

float distToCircle(vec2 p, Circle c) {
    return abs(length(p - c.center) - c.radius);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 6.0;
    
    // Setup circles
    float r = 1.0;
    float triSide = 2.0 * r;
    float circumradius = triSide / sqrt(3.0);
    
    Circle c1 = Circle(vec2(0.0, circumradius), r);
    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);
    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);
    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
    
    // Animate max_iter: grows from 1 to 50, then resets
    int max_iter = int(mod(iTime * 5.0, 50.0)) + 1;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
        } else {
            break;
        }
    }
    
    // Color by iteration
    float t = float(iter) / 50.0;
    vec3 color = 30.0 * vec3(pow(t, 2.0));
    
    fragColor = vec4(color, 1.0);
}
```


### C4. Colorize a Fractal

Adding color to the Julia set:

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);  // Try different values!
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Fixed parameter
    vec2 c = vec2(-0.7, 0.27015);
    
    // z starts at pixel position
    vec2 z = p;
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

Try these palette variations:
- `d = vec3(0.00, 0.10, 0.20)` - cool blues
- `d = vec3(0.30, 0.20, 0.20)` - warm tones
- `d = vec3(0.50, 0.50, 0.50)` - shifted spectrum


### C5. Circle Art

```glsl
struct Circle {
    vec2 center;
    float radius;
};

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Define several circles
    Circle circles[6];
    circles[0] = Circle(vec2(-1.0, 0.5), 0.8);
    circles[1] = Circle(vec2(0.5, 0.3), 0.6);
    circles[2] = Circle(vec2(-0.3, -0.7), 0.9);
    circles[3] = Circle(vec2(1.2, -0.2), 0.5);
    circles[4] = Circle(vec2(0.0, 0.8), 0.4);
    circles[5] = Circle(vec2(-0.8, -0.3), 0.5);
    
    // Count how many circles contain this point
    int count = 0;
    for (int i = 0; i < 6; i++) {
        if (isInside(p, circles[i])) count++;
    }
    
    // Color by count
    vec3 color;
    if (count == 0) color = vec3(0.1, 0.1, 0.15);
    else if (count == 1) color = vec3(0.2, 0.4, 0.8);
    else if (count == 2) color = vec3(0.8, 0.3, 0.5);
    else color = vec3(1.0, 0.9, 0.3);
    
    fragColor = vec4(color, 1.0);
}
```


## Explorations

### E1. Julia Explorer (Mouse)

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Map mouse to [-2, 2] x [-2, 2]
    vec2 mouse_uv = iMouse.xy / iResolution.xy;
    mouse_uv = mouse_uv - vec2(0.5, 0.5);
    mouse_uv.x *= iResolution.x / iResolution.y;
    vec2 c = mouse_uv * 4.0;
    
    // Default if no mouse
    if (iMouse.x < 1.0) {
        c = vec2(-0.7, 0.27015);
    }
    
    vec2 z = p;
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E2. Julia Animation

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

// Main cardioid boundary parameterization
vec2 cardioid(float t) {
    vec2 eit = vec2(cos(t), sin(t));
    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;
    return cmul(eit, z);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Animate c along the cardioid boundary
    vec2 c = cardioid(iTime * 0.5);
    
    // Or try a simple circle:
    // float angle = iTime * 0.3;
    // vec2 c = 0.7885 * vec2(cos(angle), sin(angle));
    
    vec2 z = p;
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E3. Smooth Coloring

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    // Zoom into seahorse valley to see the effect
    vec2 center = vec2(-0.745, 0.186);
    float zoom = 50.0;
    vec2 c = center + uv * 4.0 / zoom;
    
    vec2 z = vec2(0.0);
    int max_iter = 200;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        float t;
        // Toggle between smooth and discrete every 2 seconds
        if (mod(iTime, 4.0) < 2.0) {
            // Discrete coloring - notice the bands
            t = float(iter) / float(max_iter);
        } else {
            // Smooth coloring - bands disappear!
            float log_zn = log(cabs2(z)) / 2.0;
            float nu = log(log_zn / log(2.0)) / log(2.0);
            float smooth_iter = float(iter) + 1.0 - nu;
            t = smooth_iter / float(max_iter);
        }
        color = palette(t * 4.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E4. Other Escape-Time Fractals

#### Burning Ship (with smooth coloring)

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 0.5);
    vec3 d = vec3(0.00, 0.10, 0.20);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 c = 0.1 * fragCoord / iResolution.y + vec2(1.66, -0.02);
    
    vec2 z = vec2(0.0);
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (dot(z, z) > 1000.0) break;
        z = cmul(z, z);
        z.y = abs(z.y);  // abs of imaginary part AFTER squaring
        z = z - c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        // Smooth coloring
        float log_zn = log(dot(z, z)) / 2.0;
        float nu = log(log_zn / log(2.0)) / log(2.0);
        float smooth_iter = float(iter) + 1.0 - nu;
        float t = smooth_iter / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

#### Tricorn (with smooth coloring)

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.30, 0.20, 0.20);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 c = uv * 4.0;
    c.x -= 0.5;
    
    vec2 z = vec2(0.0);
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = vec2(z.x, -z.y);  // conjugate
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        // Smooth coloring
        float log_zn = log(cabs2(z)) / 2.0;
        float nu = log(log_zn / log(2.0)) / log(2.0);
        float smooth_iter = float(iter) + 1.0 - nu;
        float t = smooth_iter / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The Tricorn has **3-fold reflection symmetry** (symmetric about the real axis and two other axes at 60°).

#### Celtic (with smooth coloring)

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 c = uv * 4.0;
    c.x -= 0.5;
    
    vec2 z = vec2(0.0);
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        vec2 z2 = cmul(z, z);
        z = vec2(abs(z2.x), z2.y) + c;  // abs of real part of z²
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        // Smooth coloring
        float log_zn = log(cabs2(z)) / 2.0;
        float nu = log(log_zn / log(2.0)) / log(2.0);
        float smooth_iter = float(iter) + 1.0 - nu;
        float t = smooth_iter / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E5. Apollonian Coloring

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 6.0;
    
    float r = 1.0;
    float triSide = 2.0 * r;
    float circumradius = triSide / sqrt(3.0);
    
    Circle c1 = Circle(vec2(0.0, circumradius), r);
    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);
    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);
    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
    
    int max_iter = 100;
    int iter;
    int lastCircle = -1;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
            lastCircle = 0;
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
            lastCircle = 1;
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
            lastCircle = 2;
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
            lastCircle = 3;
        } else {
            break;
        }
    }
    
    // Color by which circle was last hit
    vec3 color;
    if (lastCircle == 0) color = vec3(1.0, 0.2, 0.2);
    else if (lastCircle == 1) color = vec3(0.2, 1.0, 0.2);
    else if (lastCircle == 2) color = vec3(0.2, 0.2, 1.0);
    else if (lastCircle == 3) color = vec3(1.0, 1.0, 0.2);
    else color = vec3(0.5);
    
    fragColor = vec4(color, 1.0);
}
```


### E6. Apollonian Variations

Example with different-sized inner circles:

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 6.0;
    
    // Three circles with different radii, manually positioned to be tangent
    // Using Descartes theorem: (k1+k2+k3+k4)² = 2(k1²+k2²+k3²+k4²)
    Circle c1 = Circle(vec2(0.0, 1.2), 0.8);
    Circle c2 = Circle(vec2(-1.0, -0.5), 1.0);
    Circle c3 = Circle(vec2(1.1, -0.4), 0.7);
    Circle outer = Circle(vec2(0.0, 0.1), 2.2);
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
        } else {
            break;
        }
    }
    
    float t = float(iter) / float(max_iter);
    vec3 color = 30.0 * vec3(pow(t, 2.0));
    
    fragColor = vec4(color, 1.0);
}
```

Note: Finding four mutually tangent circles with arbitrary radii requires solving Descartes' theorem. Given three tangent circles with curvatures $k_1, k_2, k_3$, the fourth curvature is:
$$k_4 = k_1 + k_2 + k_3 \pm 2\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}$$


## Challenges

### H1. Julia Explorer (Full)

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Get c from mouse position
    vec2 mouse_uv = iMouse.xy / iResolution.xy;
    mouse_uv = mouse_uv - vec2(0.5, 0.5);
    mouse_uv.x *= iResolution.x / iResolution.y;
    vec2 c = mouse_uv * 4.0;
    c.x -= 0.5;
    
    if (iMouse.x < 1.0) {
        c = vec2(-0.7, 0.27015);
    }
    
    // Mandelbrot iteration (background)
    vec2 mc = p;
    mc.x -= 0.5;
    vec2 mz = vec2(0.0);
    int m_iter;
    for (m_iter = 0; m_iter < 100; m_iter++) {
        if (cabs2(mz) > 4.0) break;
        mz = cmul(mz, mz) + mc;
    }
    
    // Julia iteration (foreground)
    vec2 jz = p;
    int j_iter;
    for (j_iter = 0; j_iter < 100; j_iter++) {
        if (cabs2(jz) > 4.0) break;
        jz = cmul(jz, jz) + c;
    }
    
    // Layer: light background, gray Mandelbrot, black Julia
    vec3 color = vec3(0.9);
    if (m_iter == 100) {
        color = vec3(0.6);
    }
    if (j_iter == 100) {
        color = vec3(0.0);
    }
    
    // Red dot at c position
    vec2 c_pos = c;
    c_pos.x += 0.5;
    if (length(p - c_pos) < 0.05) {
        color = vec3(1.0, 0.0, 0.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### H2. Newton Fractal

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 cdiv(vec2 z, vec2 w) {
    float denom = dot(w, w);
    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / denom;
}

vec2 ccube(vec2 z) {
    float a = z.x, b = z.y;
    return vec2(a*a*a - 3.0*a*b*b, 3.0*a*a*b - b*b*b);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 z = uv * 4.0;
    
    // The three cube roots of unity
    vec2 root1 = vec2(1.0, 0.0);
    vec2 root2 = vec2(-0.5, 0.866);
    vec2 root3 = vec2(-0.5, -0.866);
    
    int max_iter = 50;
    int iter;
    float eps = 0.001;
    
    for (iter = 0; iter < max_iter; iter++) {
        // Newton iteration: z = z - (z³-1)/(3z²)
        // Simplified: z = (2z³ + 1) / (3z²)
        vec2 z2 = cmul(z, z);
        vec2 z3 = cmul(z2, z);
        z = cdiv(2.0 * z3 + vec2(1.0, 0.0), 3.0 * z2);
        
        // Check convergence
        if (dot(z3 - vec2(1.0, 0.0), z3 - vec2(1.0, 0.0)) < eps * eps) break;
    }
    
    // Color by which root we converged to
    vec3 color;
    float d1 = length(z - root1);
    float d2 = length(z - root2);
    float d3 = length(z - root3);
    
    float t = float(iter) / float(max_iter);
    
    if (d1 < d2 && d1 < d3) {
        color = vec3(1.0, 0.2, 0.2) * (1.0 - t * 0.5);
    } else if (d2 < d3) {
        color = vec3(0.2, 1.0, 0.2) * (1.0 - t * 0.5);
    } else {
        color = vec3(0.2, 0.2, 1.0) * (1.0 - t * 0.5);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### H3. Higher-Power Mandelbrot

```glsl
float cabs2(vec2 z) {
    return dot(z, z);
}

vec2 cpow(vec2 z, float n) {
    float r = length(z);
    if (r < 0.0001) return vec2(0.0);  // Handle z ≈ 0
    float theta = atan(z.y, z.x);
    float rn = pow(r, n);
    return rn * vec2(cos(n * theta), sin(n * theta));
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 c = uv * 3.0;
    
    // Start with small offset to avoid z=0 singularity
    vec2 z = vec2(0.0001, 0.0);
    
    float n = 2.5;  // Try different values! Integer and non-integer
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cpow(z, n) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

Non-integer powers create interesting branch cut effects!


## Projects

### Project 1: Grid of Julia Sets

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Grid parameters
    float grid_size = 20.0;
    vec2 cell_id = floor(p * grid_size / 4.0);
    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;
    cell_p *= 4.0;
    
    // c from cell position (map to interesting region)
    vec2 c = (cell_id / grid_size) * 3.0 - vec2(2.0, 1.5);
    
    // Julia iteration within this cell
    vec2 z = cell_p;
    int max_iter = 50;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    float t = float(iter) / float(max_iter);
    vec3 color = vec3(t);
    
    fragColor = vec4(color, 1.0);
}
```


### Project 2: Orbit Visualization

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

// Distance to line segment from a to b
float sdSegment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // z0 from mouse, c fixed (or swap roles)
    vec2 mouse_uv = iMouse.xy / iResolution.xy;
    mouse_uv = mouse_uv - vec2(0.5, 0.5);
    mouse_uv.x *= iResolution.x / iResolution.y;
    vec2 z0 = mouse_uv * 4.0;
    
    if (iMouse.x < 1.0) {
        z0 = vec2(0.3, 0.5);
    }
    
    vec2 c = vec2(-0.7, 0.27015);
    
    // Compute orbit
    const int N = 50;
    vec2 orbit[50];
    orbit[0] = z0;
    for (int i = 1; i < N; i++) {
        orbit[i] = cmul(orbit[i-1], orbit[i-1]) + c;
        if (dot(orbit[i], orbit[i]) > 100.0) {
            orbit[i] = orbit[i-1];  // clamp escaped points
        }
    }
    
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    // Draw Julia set faintly in background
    vec2 z = p;
    int iter;
    for (iter = 0; iter < 100; iter++) {
        if (dot(z, z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    if (iter == 100) color = vec3(0.15, 0.15, 0.2);
    
    // Draw orbit lines
    for (int i = 0; i < N - 1; i++) {
        float d = sdSegment(p, orbit[i], orbit[i+1]);
        float t = float(i) / float(N);
        vec3 lineColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.3, 0.1), t);
        if (d < 0.02) color = lineColor;
    }
    
    // Draw orbit points
    for (int i = 0; i < N; i++) {
        float d = length(p - orbit[i]);
        float t = float(i) / float(N);
        float size = mix(0.06, 0.02, t);
        if (d < size) {
            color = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.5, 0.0), t);
        }
    }
    
    // Highlight z0
    if (length(p - z0) < 0.08) {
        color = vec3(1.0, 1.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```