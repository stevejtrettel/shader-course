# Appendix: Day 2 Exercise Solutions

Complete solutions for the Day 2 exercises. Try the exercises yourself before looking here!


## Checkpoints

### C1. Julia Set

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Fixed parameter
    vec2 c = vec2(-0.7, 0.27015);
    
    // z starts at pixel position (not zero!)
    vec2 z = p;
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        color = vec3(1.0, 1.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### C2. Julia Mouse

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    vec2 c = normalize_coord(iMouse.xy);
    
    // Default if no mouse input
    if (iMouse.x < 1.0) {
        c = vec2(-0.7, 0.27015);
    }
    
    vec2 z = p;
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### C3. Cubic Mandelbrot

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 ccube(vec2 z) {
    return cmul(cmul(z, z), z);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 3.0;  // smaller window for cubic
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    vec2 c = p;
    vec2 z = vec2(0.0, 0.0);
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = ccube(z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        color = vec3(1.0, 1.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The cubic Mandelbrot has **3-fold rotational symmetry** because $z^3$ has 3-fold symmetry: rotating $z$ by $120°$ rotates $z^3$ by $360°$, which is no change.


### C4. Colorize a Fractal

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);  // Try different values!
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    vec2 c = vec2(-0.7, 0.27015);
    vec2 z = p;
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

Palette variations to try:
- `d = vec3(0.00, 0.10, 0.20)` — cool blues
- `d = vec3(0.30, 0.20, 0.20)` — warm tones
- `d = vec3(0.50, 0.50, 0.50)` — shifted spectrum


### C5. Apollonian Animation

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 6.0;  // larger window for Apollonian
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    float r = 1.0;
    float circumradius = 2.0 * r / sqrt(3.0);
    
    Circle c1 = Circle(vec2(0.0, circumradius), r);
    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);
    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);
    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
    
    // Animate max_iter
    int max_iter = int(mod(iTime * 5.0, 50.0)) + 1;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
        } else {
            break;
        }
    }
    
    float t = float(iter) / 50.0;
    vec3 color = 30.0 * vec3(pow(t, 2.0));
    
    fragColor = vec4(color, 1.0);
}
```


## Explorations

### E1. Julia Animation

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 cardioid(float t) {
    vec2 eit = vec2(cos(t), sin(t));
    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;
    return cmul(eit, z);
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Animate c along the cardioid boundary
    vec2 c = cardioid(iTime * 0.5);
    
    vec2 z = p;
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

As $c$ traces the cardioid, the Julia sets all have parabolic fixed points and remain connected but change shape continuously.


### E2. Other Escape-Time Fractals

#### Burning Ship

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 0.5);
    vec3 d = vec3(0.00, 0.10, 0.20);
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    vec2 c = p;
    c.x -= 0.5;
    c.y -= 0.5;
    
    vec2 z = vec2(0.0, 0.0);
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (dot(z, z) > 4.0) break;
        z = cmul(z, z);
        z.y = abs(z.y);  // abs of imaginary part AFTER squaring
        z = z + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

#### Tricorn

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.30, 0.20, 0.20);
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    vec2 c = p;
    vec2 z = vec2(0.0, 0.0);
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = vec2(z.x, -z.y);  // conjugate
        z = cmul(z, z) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

#### Celtic

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    vec2 c = p;
    vec2 z = vec2(0.0, 0.0);
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        vec2 z2 = cmul(z, z);
        z = vec2(abs(z2.x), z2.y) + c;  // abs of real part of z²
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E3. Apollonian Variations

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 6.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Three circles with different radii
    Circle c1 = Circle(vec2(0.0, 1.2), 0.8);
    Circle c2 = Circle(vec2(-1.0, -0.5), 1.0);
    Circle c3 = Circle(vec2(1.1, -0.4), 0.7);
    Circle outer = Circle(vec2(0.0, 0.1), 2.2);
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
        } else {
            break;
        }
    }
    
    float t = float(iter) / float(max_iter);
    vec3 color = 30.0 * vec3(pow(t, 2.0));
    
    fragColor = vec4(color, 1.0);
}
```

With non-tangent or differently-sized circles, you still get a fractal, but the symmetry changes. Overlapping circles can create interesting interference patterns.


### E4. Sierpinski Carpet

```glsl
vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv.x *= iResolution.x / iResolution.y;
    
    // Map to unit square region
    vec2 p = uv * 1.5 - vec2(0.25, 0.1);
    
    int max_iter = 20;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        // Check if outside unit square
        if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) {
            break;
        }
        
        // Which cell are we in?
        int ix = int(floor(p.x * 3.0));
        int iy = int(floor(p.y * 3.0));
        
        // Center cell is removed
        if (ix == 1 && iy == 1) {
            break;  // escaped!
        }
        
        // Zoom into this cell
        p = p * 3.0 - vec2(float(ix), float(iy));
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);  // in the carpet
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E5. Sierpinski Triangle

```glsl
vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv.x *= iResolution.x / iResolution.y;
    
    // Map to region containing unit triangle
    vec2 p = uv * 1.5 - vec2(0.25, 0.1);
    
    int max_iter = 20;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        // Check if outside the triangle (vertices at (0,0), (1,0), (0,1))
        if (p.x < 0.0 || p.y < 0.0 || p.x + p.y > 1.0) {
            break;
        }
        
        // Which sub-triangle?
        if (p.x + p.y < 0.5) {
            // Bottom-left corner
            p = p * 2.0;
        } else if (p.x > 0.5) {
            // Bottom-right corner
            p = p * 2.0 - vec2(1.0, 0.0);
        } else if (p.y > 0.5) {
            // Top corner
            p = p * 2.0 - vec2(0.0, 1.0);
        } else {
            // Middle triangle (removed)
            break;  // escaped!
        }
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);  // in the triangle
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```


## Challenges

### H1. Julia Explorer (Full)

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Get c from mouse position
    vec2 c = normalize_coord(iMouse.xy);
    c.x -= 0.5;  // shift for Mandelbrot centering
    
    if (iMouse.x < 1.0) {
        c = vec2(-0.7, 0.27015);
    }
    
    // Mandelbrot iteration (background)
    vec2 mc = p;
    mc.x -= 0.5;
    vec2 mz = vec2(0.0, 0.0);
    int m_iter;
    for (m_iter = 0; m_iter < 100; m_iter++) {
        if (cabs2(mz) > 4.0) break;
        mz = cmul(mz, mz) + mc;
    }
    
    // Julia iteration (foreground)
    vec2 jz = p;
    int j_iter;
    for (j_iter = 0; j_iter < 100; j_iter++) {
        if (cabs2(jz) > 4.0) break;
        jz = cmul(jz, jz) + c;
    }
    
    // Layer: light background, gray Mandelbrot, black Julia
    vec3 color = vec3(0.9, 0.9, 0.9);
    if (m_iter == 100) {
        color = vec3(0.6, 0.6, 0.6);
    }
    if (j_iter == 100) {
        color = vec3(0.0, 0.0, 0.0);
    }
    
    // Red dot at c position
    vec2 c_pos = c;
    c_pos.x += 0.5;
    if (length(p - c_pos) < 0.05) {
        color = vec3(1.0, 0.0, 0.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### H2. Newton Fractal

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 cdiv(vec2 z, vec2 w) {
    float denom = dot(w, w);
    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / denom;
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 z = normalize_coord(fragCoord);
    
    // The three cube roots of unity
    vec2 root1 = vec2(1.0, 0.0);
    vec2 root2 = vec2(-0.5, 0.866);
    vec2 root3 = vec2(-0.5, -0.866);
    
    int max_iter = 50;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        // Newton iteration for z³ - 1 = 0
        // z = z - (z³-1)/(3z²) = (2z³ + 1) / (3z²)
        vec2 z2 = cmul(z, z);
        vec2 z3 = cmul(z2, z);
        z = cdiv(2.0 * z3 + vec2(1.0, 0.0), 3.0 * z2);
        
        // Check convergence
        if (dot(z3 - vec2(1.0, 0.0), z3 - vec2(1.0, 0.0)) < 0.0001) break;
    }
    
    // Color by which root we converged to
    float d1 = length(z - root1);
    float d2 = length(z - root2);
    float d3 = length(z - root3);
    
    float t = float(iter) / float(max_iter);
    vec3 color;
    
    if (d1 < d2 && d1 < d3) {
        color = vec3(1.0, 0.2, 0.2) * (1.0 - t * 0.5);
    } else if (d2 < d3) {
        color = vec3(0.2, 1.0, 0.2) * (1.0 - t * 0.5);
    } else {
        color = vec3(0.2, 0.2, 1.0) * (1.0 - t * 0.5);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### H3. Higher-Power Mandelbrot

```glsl
float cabs2(vec2 z) {
    return dot(z, z);
}

vec2 cpow(vec2 z, float n) {
    float r = length(z);
    if (r < 0.0001) return vec2(0.0, 0.0);
    float theta = atan(z.y, z.x);
    float rn = pow(r, n);
    return rn * vec2(cos(n * theta), sin(n * theta));
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 3.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    vec2 c = p;
    vec2 z = vec2(0.0001, 0.0);  // small offset to avoid z=0 singularity
    
    float n = 2.5;  // Try different values!
    
    int max_iter = 100;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cpow(z, n) + c;
    }
    
    vec3 color;
    if (iter == max_iter) {
        color = vec3(0.0, 0.0, 0.0);
    } else {
        float t = float(iter) / float(max_iter);
        color = palette(t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

Non-integer powers create branch cut discontinuities where `atan` jumps from $\pi$ to $-\pi$.


### H4. Escape Radius Proofs

**Fact 1:** If $|c| > 2$, then $c \notin \mathcal{M}$.

*Proof.* Starting from $z_0 = 0$, we have $z_1 = c$. If $|c| > 2$, then for $n \geq 1$:
$$|z_{n+1}| = |z_n^2 + c| \geq |z_n|^2 - |c|$$
When $|z_n| > |c|$, we have $|z_n|^2 - |c| > |z_n|(|z_n| - 1)$. Since $|z_1| = |c| > 2$, by induction $|z_n| \to \infty$. $\square$

**Fact 2:** If $|z_n| > 2$ for some $n$ (with $|c| \leq 2$), the orbit escapes.

*Proof.* Suppose $|z_n| > 2$ and $|c| \leq 2$. Then $|z_n| > |c|$, so:
$$|z_{n+1}| = |z_n^2 + c| \geq |z_n|^2 - |c| > |z_n|^2 - |z_n| = |z_n|(|z_n| - 1)$$
Since $|z_n| > 2$, we have $|z_n| - 1 > 1$, so $|z_{n+1}| > |z_n|$. The orbit grows without bound. $\square$


## Projects

### Project 1: Grid of Julia Sets

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float cabs2(vec2 z) {
    return dot(z, z);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // For the grid, we use a different coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float grid_size = 20.0;
    vec2 cell_id = floor(p * grid_size / 4.0);
    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;
    cell_p *= 4.0;
    
    // c from cell position
    vec2 c = (cell_id / grid_size) * 3.0 - vec2(2.0, 1.5);
    
    vec2 z = cell_p;
    int max_iter = 50;
    int iter;
    
    for (iter = 0; iter < max_iter; iter++) {
        if (cabs2(z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    
    float t = float(iter) / float(max_iter);
    vec3 color = vec3(t, t, t);
    
    fragColor = vec4(color, 1.0);
}
```


### Project 2: Orbit Visualization

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float sdSegment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h);
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // z0 from mouse
    vec2 z0 = normalize_coord(iMouse.xy);
    
    if (iMouse.x < 1.0) {
        z0 = vec2(0.3, 0.5);
    }
    
    vec2 c = vec2(-0.7, 0.27015);
    
    // Compute orbit
    const int N = 50;
    vec2 orbit[50];
    orbit[0] = z0;
    for (int i = 1; i < N; i++) {
        orbit[i] = cmul(orbit[i-1], orbit[i-1]) + c;
        if (dot(orbit[i], orbit[i]) > 100.0) {
            orbit[i] = orbit[i-1];
        }
    }
    
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    // Julia set in background
    vec2 z = p;
    int iter;
    for (iter = 0; iter < 100; iter++) {
        if (dot(z, z) > 4.0) break;
        z = cmul(z, z) + c;
    }
    if (iter == 100) color = vec3(0.15, 0.15, 0.2);
    
    // Orbit lines
    for (int i = 0; i < N - 1; i++) {
        float d = sdSegment(p, orbit[i], orbit[i+1]);
        float t = float(i) / float(N);
        vec3 lineColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.3, 0.1), t);
        if (d < 0.02) color = lineColor;
    }
    
    // Orbit points
    for (int i = 0; i < N; i++) {
        float d = length(p - orbit[i]);
        float t = float(i) / float(N);
        float size = mix(0.06, 0.02, t);
        if (d < size) {
            color = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.5, 0.0), t);
        }
    }
    
    // Highlight z0
    if (length(p - z0) < 0.08) {
        color = vec3(1.0, 1.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The same visualization technique works for Apollonian (watch the point bounce between inversions) or Sierpinski (watch it zoom into sub-cells). The iteration logic changes but the orbit-drawing code stays the same.