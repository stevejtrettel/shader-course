# Appendix: Day 2 Exercise Solutions

Complete solutions for the Day 2 exercises. Try the exercises yourself before looking here!


## Checkpoints

### C1. Julia Mouse

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 z = normalize_coord(fragCoord);
    vec2 c = normalize_coord(iMouse.xy);
    
    // Default if no mouse input
    if (iMouse.x < 1.0) {
        c = vec2(-0.7, 0.27015);
    }
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    int i;
    for (i = 0; i < 100; i++) {
        if (length(z) > 2.0) break;
        z = cmul(z, z) + c;
    }
    
    if (i < 100) {
        float t = float(i) / 100.0;
        float gray = 1.0 - t;
        color = vec3(gray, gray, gray);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### C2. Higher Powers

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 ccube(vec2 z) {
    return cmul(cmul(z, z), z);
}

vec2 cpow(vec2 z, float n) {
    float r = length(z);
    if (r < 0.0001) return vec2(0.0, 0.0);
    float theta = atan(z.y, z.x);
    return pow(r, n) * vec2(cos(n * theta), sin(n * theta));
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 c = normalize_coord(fragCoord);
    vec2 z = vec2(0.0001, 0.0);  // small offset avoids z=0 singularity
    
    float n = 3.0;  // Try 3.0, 4.0, 5.0, 2.5
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    int i;
    for (i = 0; i < 100; i++) {
        if (length(z) > 2.0) break;
        z = cpow(z, n) + c;
        // For integer n=3, you can use: z = ccube(z) + c;
    }
    
    if (i < 100) {
        float t = float(i) / 100.0;
        float gray = 1.0 - t;
        color = vec3(gray, gray, gray);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Symmetry:** $z^n + c$ has $n$-fold rotational symmetry because rotating $z$ by $2\pi/n$ rotates $z^n$ by $2\pi$, leaving it unchanged. So $n=3$ gives 3-fold symmetry, $n=4$ gives 4-fold, etc.

**Non-integer powers:** Try $n = 2.5$. The discontinuity (branch cut) appears along the negative real axis, where `atan(z.y, z.x)` jumps from $\pi$ to $-\pi$. This is because $z^{2.5}$ is multi-valued.


### C3. Animated Zoom

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    float zoom = pow(2.0, iTime);  // doubles every second
    return uv * 2.5 / zoom;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 center = vec2(-0.745, 0.186);  // seahorse valley
    vec2 c = center + normalize_coord(fragCoord);
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    vec2 z = vec2(0.0, 0.0);
    int i;
    for (i = 0; i < 200; i++) {
        if (length(z) > 2.0) break;
        z = cmul(z, z) + c;
    }
    
    if (i < 200) {
        float t = float(i) / 200.0;
        float gray = 1.0 - t;
        color = vec3(gray, gray, gray);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The exponential zoom $m(t) = 2^t$ satisfies $\frac{dm}{dt} = m \ln 2$, so the rate of magnification is proportional to the current magnification. This produces visually constant zoom speed.

At high magnification ($>10^6\times$), you'll notice the boundary becomes blocky—discrete steps from iteration bands. This motivates distance estimation (Project 2).


### C4. Apollonian Animation

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 6.0;
    
    float r = 1.0;
    float circumradius = 2.0 * r / sqrt(3.0);
    
    Circle c1 = Circle(vec2(0.0, circumradius), r);
    Circle c2 = Circle(vec2(-circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
    Circle c3 = Circle(vec2(circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
    
    // Animate max_iter
    int max_iter = int(mod(iTime * 5.0, 50.0)) + 1;
    int i;
    
    for (i = 0; i < max_iter; i++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
        } else {
            break;
        }
    }
    
    float t = float(i) / 50.0;
    float gray = 1.0 - t;
    vec3 color = vec3(gray, gray, gray);
    
    fragColor = vec4(color, 1.0);
}
```


## Explorations

### E1. Julia Animation

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 cardioid(float t) {
    vec2 eit = vec2(cos(t), sin(t));
    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;
    return cmul(eit, z);
}

vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 z = normalize_coord(fragCoord);
    
    // Animate c along the cardioid boundary
    vec2 c = cardioid(iTime * 0.5);
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    int i;
    for (i = 0; i < 100; i++) {
        if (length(z) > 2.0) break;
        z = cmul(z, z) + c;
    }
    
    if (i < 100) {
        float t = float(i) / 100.0;
        float gray = 1.0 - t;
        color = vec3(gray, gray, gray);
    }
    
    fragColor = vec4(color, 1.0);
}
```

As $c$ traces the cardioid, the Julia sets all have parabolic fixed points and remain connected but continuously deform.


### E2. Other Escape-Time Fractals

#### Burning Ship

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 0.7, 0.4);
    vec3 d = vec3(0.00, 0.15, 0.20);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    // Main view: center on the ship
    vec2 center = vec2(-0.5, -0.5);
    float zoom = 1.0;
    
    // Mini ship zoom: uncomment to see the small ship in lower-left
    // center = vec2(-1.8, -0.05);
    // zoom = 20.0;
    
    vec2 c = center + uv * 2.5 / zoom;
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    vec2 z = vec2(0.0, 0.0);
    int i;
    for (i = 0; i < 200; i++) {
        if (length(z) > 2.0) break;
        z = abs(z);  // Take absolute value BEFORE squaring
        z = cmul(z, z) + c;
    }
    
    float t = float(i) / 200.0;
    color = palette(t * 4.0);
    
    fragColor = vec4(color, 1.0);
}
```

#### Tricorn

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.30, 0.20, 0.20);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 c = uv * 2.5;
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    vec2 z = vec2(0.0, 0.0);
    int i;
    for (i = 0; i < 200; i++) {
        if (length(z) > 2.0) break;
        z = vec2(z.x, -z.y);  // conjugate
        z = cmul(z, z) + c;
    }
    
    float t = float(i) / 200.0;
    color = palette(t * 3.0);
    
    fragColor = vec4(color, 1.0);
}
```

#### Celtic

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 c = uv * 2.5;
    c.x = c.x - 0.5;
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    vec2 z = vec2(0.0, 0.0);
    int i;
    for (i = 0; i < 200; i++) {
        if (length(z) > 2.0) break;
        vec2 z2 = cmul(z, z);
        z = vec2(abs(z2.x), z2.y) + c;  // abs of real part AFTER squaring
    }
    
    float t = float(i) / 200.0;
    color = palette(t * 3.0);
    
    fragColor = vec4(color, 1.0);
}
```


### E3. Sierpinski Carpet

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 p = uv;
    
    int i;
    for (i = 0; i < 6; i++) {
        p = p * 3.0;
        vec2 cell = floor(p);
        
        // Check if in center cell (1,1)
        if (cell.x == 1.0 && cell.y == 1.0) {
            break;  // In a hole
        }
        
        p = fract(p);
    }
    
    vec3 color;
    if (i < 6) {
        color = vec3(1.0, 1.0, 1.0);  // hole: white
    } else {
        color = vec3(0.0, 0.0, 0.0);  // carpet: black
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E4. Sierpinski Triangle

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    
    // Start in [0,1]² right triangle
    vec2 p = uv;
    
    // Only consider points in the triangle x + y < 1
    if (p.x + p.y > 1.0) {
        fragColor = vec4(0.1, 0.1, 0.15, 1.0);
        return;
    }
    
    int i;
    for (i = 0; i < 8; i++) {
        // Scale by 2
        p = p * 2.0;
        
        // Determine which sub-triangle
        if (p.x + p.y < 1.0) {
            // Bottom-left: already in place
        } else if (p.x > 1.0) {
            // Bottom-right
            p.x = p.x - 1.0;
        } else if (p.y > 1.0) {
            // Top
            p.y = p.y - 1.0;
        } else {
            // Middle hole (x + y >= 1, x <= 1, y <= 1)
            break;
        }
    }
    
    vec3 color;
    if (i < 8) {
        color = vec3(1.0, 1.0, 1.0);  // hole
    } else {
        color = vec3(0.0, 0.0, 0.0);  // triangle
    }
    
    fragColor = vec4(color, 1.0);
}
```


### E5. Apollonian Domain Coloring

```glsl
struct Circle {
    vec2 center;
    float radius;
};

vec2 invert(vec2 p, Circle c) {
    vec2 d = p - c.center;
    return c.center + c.radius * c.radius * d / dot(d, d);
}

bool isInside(vec2 p, Circle c) {
    return length(p - c.center) < c.radius;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 6.0;
    
    float r = 1.0;
    float circumradius = 2.0 * r / sqrt(3.0);
    
    Circle c1 = Circle(vec2(0.0, circumradius), r);
    Circle c2 = Circle(vec2(-circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
    Circle c3 = Circle(vec2(circumradius * sqrt(3.0)/2.0, -circumradius * 0.5), r);
    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);
    
    int last_circle = -1;  // Track which circle we inverted through last
    
    int i;
    for (i = 0; i < 50; i++) {
        if (isInside(p, c1)) {
            p = invert(p, c1);
            last_circle = 0;
        } else if (isInside(p, c2)) {
            p = invert(p, c2);
            last_circle = 1;
        } else if (isInside(p, c3)) {
            p = invert(p, c3);
            last_circle = 2;
        } else if (!isInside(p, outer)) {
            p = invert(p, outer);
            last_circle = 3;
        } else {
            break;
        }
    }
    
    vec3 color;
    if (last_circle == 0) {
        color = vec3(1.0, 0.3, 0.3);  // red for c1
    } else if (last_circle == 1) {
        color = vec3(0.3, 1.0, 0.3);  // green for c2
    } else if (last_circle == 2) {
        color = vec3(0.3, 0.3, 1.0);  // blue for c3
    } else if (last_circle == 3) {
        color = vec3(1.0, 1.0, 0.3);  // yellow for outer
    } else {
        color = vec3(0.2, 0.2, 0.2);  // gray for fundamental domain
    }
    
    fragColor = vec4(color, 1.0);
}
```

The colored regions tile the disk, with fractal boundaries meeting at the limit set.


## Challenges

### H1. Split-Screen Julia Explorer

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    float aspect = iResolution.x / iResolution.y;
    
    // Which half?
    bool left_half = uv.x < 0.5;
    
    // Local coordinates within each half, centered
    vec2 local;
    if (left_half) {
        local = (uv - vec2(0.25, 0.5)) * vec2(aspect, 1.0) * 5.0;
    } else {
        local = (uv - vec2(0.75, 0.5)) * vec2(aspect, 1.0) * 5.0;
    }
    
    // Get c from mouse (only if on left half)
    vec2 c;
    vec2 mouse_uv = iMouse.xy / iResolution.xy;
    if (mouse_uv.x < 0.5 && iMouse.x > 1.0) {
        vec2 mouse_local = (mouse_uv - vec2(0.25, 0.5)) * vec2(aspect, 1.0) * 5.0;
        c = mouse_local;
        c.x = c.x - 0.5;
    } else {
        c = vec2(-0.7, 0.27015);
    }
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    if (left_half) {
        // Mandelbrot
        vec2 mc = local;
        mc.x = mc.x - 0.5;
        vec2 z = vec2(0.0, 0.0);
        
        int i;
        for (i = 0; i < 100; i++) {
            if (length(z) > 2.0) break;
            z = cmul(z, z) + mc;
        }
        
        if (i < 100) {
            float t = float(i) / 100.0;
            float gray = 1.0 - t;
            color = vec3(gray, gray, gray);
        }
        
        // Draw dot at c position
        vec2 c_pos = c;
        c_pos.x = c_pos.x + 0.5;
        if (length(local - c_pos) < 0.08) {
            color = vec3(1.0, 0.2, 0.2);
        }
    } else {
        // Julia
        vec2 z = local;
        
        int i;
        for (i = 0; i < 100; i++) {
            if (length(z) > 2.0) break;
            z = cmul(z, z) + c;
        }
        
        if (i < 100) {
            float t = float(i) / 100.0;
            float gray = 1.0 - t;
            color = vec3(gray, gray, gray);
        }
    }
    
    // Dividing line
    if (abs(uv.x - 0.5) < 0.002) {
        color = vec3(0.3, 0.3, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### H2. Newton Fractal

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 cdiv(vec2 z, vec2 w) {
    float denom = dot(w, w);
    return vec2(z.x*w.x + z.y*w.y, z.y*w.x - z.x*w.y) / denom;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 z = uv * 2.5;
    
    // The three cube roots of unity
    vec2 root1 = vec2(1.0, 0.0);
    vec2 root2 = vec2(-0.5, sqrt(3.0)/2.0);
    vec2 root3 = vec2(-0.5, -sqrt(3.0)/2.0);
    
    int which_root = -1;
    int i;
    for (i = 0; i < 50; i++) {
        // Check convergence
        if (length(z - root1) < 0.001) { which_root = 0; break; }
        if (length(z - root2) < 0.001) { which_root = 1; break; }
        if (length(z - root3) < 0.001) { which_root = 2; break; }
        
        // Newton iteration for z³ - 1 = 0
        // z -> z - (z³ - 1)/(3z²) = (2z³ + 1)/(3z²)
        vec2 z2 = cmul(z, z);
        vec2 z3 = cmul(z2, z);
        vec2 numerator = 2.0 * z3 + vec2(1.0, 0.0);
        vec2 denominator = 3.0 * z2;
        z = cdiv(numerator, denominator);
    }
    
    vec3 color;
    float brightness = 1.0 - float(i) / 50.0;
    
    if (which_root == 0) {
        color = vec3(1.0, 0.2, 0.2) * brightness;
    } else if (which_root == 1) {
        color = vec3(0.2, 1.0, 0.2) * brightness;
    } else if (which_root == 2) {
        color = vec3(0.2, 0.2, 1.0) * brightness;
    } else {
        color = vec3(0.0, 0.0, 0.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The basin boundaries form a fractal—zoom in and you'll find all three colors arbitrarily interleaved.


### H3. Escape Radius Proofs

**Mandelbrot Fact 1:** If $|c| > 2$, then $c \notin \mathcal{M}$.

*Proof:* With $z_0 = 0$, we have $z_1 = c$. For $n \geq 1$:
$$|z_{n+1}| = |z_n^2 + c| \geq |z_n|^2 - |c|$$

If $|z_n| > |c| > 2$, then $|z_n|^2 - |c| > |z_n|(|z_n| - 1) > |z_n|$, so the sequence is increasing. Since $|z_1| = |c| > 2$, the orbit escapes.

**Mandelbrot Fact 2:** If $|z_n| > 2$ for some $n$ (with $|c| \leq 2$), the orbit escapes.

*Proof:* Let $|z_n| = 2 + \epsilon$ for some $\epsilon > 0$. Then:
$$|z_{n+1}| \geq |z_n|^2 - |c| \geq (2+\epsilon)^2 - 2 = 2 + 4\epsilon + \epsilon^2 > 2 + \epsilon$$

By induction, $|z_{n+k}| \to \infty$.

**Julia escape radius:** If $|z| > R$ where $R = \frac{1 + \sqrt{1 + 4|c|}}{2}$, the orbit escapes.

*Proof:* We need $|z|^2 - |c| > |z|$, i.e., $|z|^2 - |z| - |c| > 0$. By the quadratic formula, this holds when $|z| > R$.


### H4. Period Detection

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 c = uv * 2.5;
    c.x = c.x - 0.5;
    
    vec2 z = vec2(0.0, 0.0);
    
    // Track previous iterates for period detection
    vec2 z_prev1 = vec2(0.0, 0.0);
    vec2 z_prev2 = vec2(0.0, 0.0);
    vec2 z_prev3 = vec2(0.0, 0.0);
    vec2 z_prev4 = vec2(0.0, 0.0);
    
    int period = 0;
    float eps = 0.1; //not very precise: but helps ignore floating point errors
    
    int i;
    for (i = 0; i < 500; i++) {
        // Shift history before computing new z
        z_prev4 = z_prev3;
        z_prev3 = z_prev2;
        z_prev2 = z_prev1;
        z_prev1 = z;
        
        z = cmul(z, z) + c;
        
        if (length(z) > 2.0) break;  // escaped
        
        // Check for periods after orbit has settled
        // Period N means z_n = z_{n+N}, so we compare current z to previous values
        if (i > 100) {
            if (length(z - z_prev1) < eps) { period = 1; break; }
            if (length(z - z_prev2) < eps) { period = 2; break; }
            if (length(z - z_prev3) < eps) { period = 3; break; }
            if (length(z - z_prev4) < eps) { period = 4; break; }
        }
    }
    
    vec3 color;
    if (period == 1) {
        color = vec3(0.2, 0.2, 0.9);  // blue: period 1 (main cardioid)
    } else if (period == 2) {
        color = vec3(0.9, 0.2, 0.2);  // red: period 2 (main bulb)
    } else if (period == 3) {
        color = vec3(0.2, 0.9, 0.2);  // green: period 3
    } else if (period == 4) {
        color = vec3(0.9, 0.9, 0.2);  // yellow: period 4
    } else if (i == 500) {
        color = vec3(0.3, 0.0, 0.3);  // purple: bounded, higher period
    } else {
        // Escaped - gray scale by iteration
        float t = float(i) / 500.0;
        float gray = 0.5 * t;
        color = vec3(gray, gray, gray);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The colored regions reveal the internal structure of the Mandelbrot set: the main cardioid is period-1 (blue), the large bulb to the left is period-2 (red), and the smaller bulbs have higher periods. Points with periods above 4 appear purple.


### H5. Orbit Traps

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    vec2 c = uv * 2.5;
    c.x = c.x - 0.5;
    
    vec2 z = vec2(0.0, 0.0);
    
    // Track minimum distance to trap
    float trap_dist = 1000.0;
    
    // Trap: point at origin (try different positions!)
    vec2 trap_point = vec2(0.0, 0.0);
    
    int i;
    for (i = 0; i < 100; i++) {
        z = cmul(z, z) + c;
        if (length(z) > 100.0) break;
        
        // Point trap
        float d = length(z - trap_point);
        
        // Alternative traps:
        // float d = abs(length(z) - 0.5);  // circle of radius 0.5
        // float d = min(abs(z.x), abs(z.y));  // cross at axes
        // float d = abs(z.y);  // real axis
        
        trap_dist = min(trap_dist, d);
    }
    
    vec3 color;
    if (i == 100) {
        // Bounded orbit - color by trap distance
        color = palette(trap_dist * 5.0);
        
        // Alternative: glow effect
        // color = vec3(1.0, 0.9, 0.8) * exp(-trap_dist * 20.0);
    } else {
        // Escaped - just black
        color = vec3(0.0, 0.0, 0.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The interesting structure is all inside the set. Try different traps and different coloring scales.


## Projects

### Project 1: Grid of Julia Sets

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Normalized coordinates centered at origin
    vec2 uv = fragCoord / iResolution.xy - 0.5;
    float aspect = iResolution.x / iResolution.y;
    uv.x *= aspect;
    vec2 p = uv * 3.0;
    
    // Grid setup
    float L = 0.25;
    
    // Grid formula (same as Day 1)
    vec2 cell_id = floor(p / L + 0.5);
    vec2 cell_center = cell_id * L;
    vec2 local = p - cell_center;
    
    // Map cell_center to parameter c in interesting region
    vec2 c = cell_center;
    c.x = c.x * 1.0 - 0.5;  // shift left to center on Mandelbrot
    
    // Map local to starting point z, scaled to [-2, 2]
    vec2 z = local / (L * 0.5) * 2.0;
    
    vec3 color = vec3(0.95, 0.95, 0.9);  // light background
    
    int i;
    for (i = 0; i < 50; i++) {
        if (length(z) > 2.0) break;
        z = cmul(z, z) + c;
    }
    
    // Inverted colors: Julia set dark on light background
    if (i == 50) {
        color = vec3(0.1, 0.1, 0.15);  // dark Julia set
    }
    
    fragColor = vec4(color, 1.0);
}
```

Zoom out to see the Mandelbrot set emerge: cells with $c \in \mathcal{M}$ show dark connected Julia sets, cells outside show scattered dark dust on light backgrounds.


### Project 2: Deep Zoom with Distance Estimation

#### Parts A–C: Basic Distance Estimation

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec2 normalize_coord(vec2 fragCoord, float zoom) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5 / zoom;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Animated zoom
    float zoom = pow(2.0, iTime);
    
    vec2 center = vec2(-0.745, 0.186);  // seahorse valley
    vec2 c = center + normalize_coord(fragCoord, zoom);
    
    vec2 z = vec2(0.0, 0.0);
    vec2 dz = vec2(0.0, 0.0);  // derivative dz/dc
    
    int i;
    for (i = 0; i < 256; i++) {
        if (length(z) > 256.0) break;
        
        // Derivative recurrence: dz' = 2*z*dz + 1
        dz = 2.0 * cmul(z, dz) + vec2(1.0, 0.0);
        
        // Standard iteration
        z = cmul(z, z) + c;
    }
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    if (i < 256) {
        // Distance estimate
        float r = length(z);
        float dr = length(dz);
        float dist = 0.5 * r * log(r) / dr;
        
        // Scale by zoom for constant visual thickness
        float scaled_dist = dist * zoom;
        
        // Sharp boundary
        float pixel_size = 2.5 / iResolution.y;
        if (scaled_dist < pixel_size) {
            color = vec3(1.0, 1.0, 1.0);
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

#### Parts D–F: Full Implementation with Smooth Coloring

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

vec2 normalize_coord(vec2 fragCoord, float zoom) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5 / zoom;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Animated zoom
    float zoom = pow(2.0, iTime * 0.5);  // slower zoom
    
    vec2 center = vec2(-0.745, 0.186);  // seahorse valley
    vec2 c = center + normalize_coord(fragCoord, zoom);
    
    vec2 z = vec2(0.0, 0.0);
    vec2 dz = vec2(0.0, 0.0);
    
    int i;
    for (i = 0; i < 512; i++) {
        if (length(z) > 256.0) break;
        
        dz = 2.0 * cmul(z, dz) + vec2(1.0, 0.0);
        z = cmul(z, z) + c;
    }
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    if (i < 512) {
        // Distance estimate
        float r = length(z);
        float dr = length(dz);
        float dist = 0.5 * r * log(r) / dr;
        
        // Scale by zoom
        float scaled_dist = dist * zoom;
        float pixel_size = 2.5 / iResolution.y;
        
        // Smooth coloring for exterior
        float log_zn = log(length(z));
        float nu = log(log_zn / log(2.0)) / log(2.0);
        float smooth_iter = float(i) + 1.0 - nu;
        float t = smooth_iter / 512.0;
        
        color = palette(t * 5.0);
        
        // Glow near boundary
        float glow = exp(-scaled_dist / pixel_size * 0.5);
        color = mix(color, vec3(1.0, 1.0, 1.0), glow * 0.5);
    }
    
    fragColor = vec4(color, 1.0);
}
```

#### Extension: Dual Complex Numbers

```glsl
// Dual complex: .xy = value, .zw = derivative

vec4 dcAdd(vec4 a, vec4 b) {
    return a + b;
}

vec4 dcSqr(vec4 a) {
    return vec4(
        a.x*a.x - a.y*a.y,            // z²: real
        2.0*a.x*a.y,                   // z²: imag  
        2.0*(a.x*a.z - a.y*a.w),      // (z²)': real
        2.0*(a.x*a.w + a.y*a.z)       // (z²)': imag
    );
}

vec3 palette(float t) {
    vec3 a = vec3(0.5, 0.5, 0.5);
    vec3 b = vec3(0.5, 0.5, 0.5);
    vec3 c = vec3(1.0, 1.0, 1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    
    float zoom = pow(2.0, iTime * 0.5);
    vec2 center = vec2(-0.745, 0.186);
    vec2 c_val = center + uv * 2.5 / zoom;
    
    // Pack c as dual: value = c, derivative = 1 (dc/dc = 1)
    vec4 c = vec4(c_val, 1.0, 0.0);
    vec4 z = vec4(0.0, 0.0, 0.0, 0.0);
    
    int i;
    for (i = 0; i < 512; i++) {
        if (length(z.xy) > 256.0) break;
        z = dcAdd(dcSqr(z), c);
    }
    
    vec3 color = vec3(0.0, 0.0, 0.0);
    
    if (i < 512) {
        float r = length(z.xy);
        float dr = length(z.zw);
        float dist = 0.5 * r * log(r) / dr;
        
        float scaled_dist = dist * zoom;
        float pixel_size = 2.5 / iResolution.y;
        
        float log_zn = log(r);
        float nu = log(log_zn / log(2.0)) / log(2.0);
        float smooth_iter = float(i) + 1.0 - nu;
        float t = smooth_iter / 512.0;
        
        color = palette(t * 5.0);
        
        float glow = exp(-scaled_dist / pixel_size * 0.5);
        color = mix(color, vec3(1.0, 1.0, 1.0), glow * 0.5);
    }
    
    fragColor = vec4(color, 1.0);
}
```


### Project 3: Orbit Visualization

```glsl
vec2 cmul(vec2 z, vec2 w) {
    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);
}

float sdSegment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 2.5;
    
    // z0 from mouse
    vec2 z0;
    if (iMouse.x < 1.0) {
        z0 = vec2(0.3, 0.5);
    } else {
        vec2 mouse_uv = iMouse.xy / iResolution.xy - 0.5;
        mouse_uv.x *= iResolution.x / iResolution.y;
        z0 = mouse_uv * 2.5;
    }
    
    vec2 c = vec2(-0.7, 0.27015);
    
    // Compute orbit
    const int N = 50;
    vec2 orbit[50];
    orbit[0] = z0;
    for (int i = 1; i < N; i++) {
        orbit[i] = cmul(orbit[i-1], orbit[i-1]) + c;
        if (dot(orbit[i], orbit[i]) > 100.0) {
            orbit[i] = orbit[i-1];  // clamp escaped points
        }
    }
    
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    // Julia set in background (faint)
    vec2 z = p;
    int iter;
    for (iter = 0; iter < 100; iter++) {
        if (length(z) > 2.0) break;
        z = cmul(z, z) + c;
    }
    if (iter == 100) color = vec3(0.15, 0.15, 0.2);
    
    // Orbit lines
    for (int i = 0; i < N - 1; i++) {
        float d = sdSegment(p, orbit[i], orbit[i+1]);
        float t = float(i) / float(N);
        vec3 lineColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.3, 0.1), t);
        if (d < 0.02) color = lineColor;
    }
    
    // Orbit points
    for (int i = 0; i < N; i++) {
        float d = length(p - orbit[i]);
        float t = float(i) / float(N);
        float size = mix(0.06, 0.02, t);
        if (d < size) {
            color = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.5, 0.0), t);
        }
    }
    
    // Highlight z0
    if (length(p - z0) < 0.08) {
        color = vec3(1.0, 1.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```
