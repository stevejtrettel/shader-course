# Day 3: Hyperbolic Tilings — Solutions

## Checkpoints

### C1. Custom Palette

Simply change the color constants at the top of any tiling shader:

```glsl
// High contrast option
const vec3 CREAM = vec3(1.0, 1.0, 1.0);
const vec3 SLATE = vec3(0.0, 0.0, 0.0);

// Complementary colors
const vec3 CREAM = vec3(1.0, 0.6, 0.2);  // orange
const vec3 SLATE = vec3(0.2, 0.4, 1.0);  // blue

// Low contrast, earthy
const vec3 CREAM = vec3(0.76, 0.70, 0.62);
const vec3 SLATE = vec3(0.55, 0.52, 0.48);

// Neon
const vec3 CREAM = vec3(0.0, 1.0, 0.8);  // cyan
const vec3 SLATE = vec3(1.0, 0.0, 0.5);  // magenta
```

---

### C2. Growing Tiling

```glsl
// Color palette
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    // Animated iteration limit
    int max_iter = int(mod(iTime * 10.0, 100.0)) + 1;
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        if (i >= max_iter) break;
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? CREAM : SLATE;
    
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C3. The (2,4,5) Triangle

```glsl
// Color palette
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    // The (2,4,5) triangle
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);           // x > 0
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);     // outside unit circle
    HalfSpaceCirc third = HalfSpaceCirc(-1.70, 2.40, -1.0);  // inside this circle
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, bottom, foldCount);
        z = reflectInto(z, third, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? CREAM : SLATE;
    
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

The (2,4,5) tiling has larger triangles than (2,3,7) because the angle sum is closer to π. Fewer triangles fit around each vertex.

---

### C4. F Markers in (2,3,7)

```glsl
// Color palette
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 MAROON = vec3(0.6, 0.2, 0.2);
const vec3 NAVY = vec3(0.2, 0.2, 0.6);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {
    vec3 color = bgColor;
    // Small F for the (2,3,7) fundamental domain
    if (p.x > -0.04 && p.x < -0.01 && p.y > -0.06 && p.y < 0.06) color = fgColor;
    if (p.x > -0.04 && p.x < 0.04 && p.y > 0.03 && p.y < 0.06) color = fgColor;
    if (p.x > -0.04 && p.x < 0.02 && p.y > -0.01 && p.y < 0.02) color = fgColor;
    return color;
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    // The (2,3,7) triangle
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    HalfSpaceCirc third = HalfSpaceCirc(-0.7665, 1.533, -1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, bottom, foldCount);
        z = reflectInto(z, third, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 bg = (parity < 0.5) ? CREAM : SLATE;
    vec3 fg = (parity < 0.5) ? MAROON : NAVY;
    
    // Position F in the fundamental domain
    vec3 color = drawF(z - vec2(0.15, 1.15), bg, fg);
    
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C5. Rainbow Tiling

```glsl
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    // Rainbow coloring by fold count
    float t = float(foldCount) / 20.0;
    vec3 color = 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));
    
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

Rainbow coloring reveals the "layers" of the tiling—tiles that require the same number of reflections to reach have the same color. You can see concentric rings of color radiating from the fundamental domain.

---

## Explorations

### E1. Hyperbolic Circles

```glsl
float acosh(float x) {
    return log(x + sqrt(x * x - 1.0));
}

float hypDist(vec2 z1, vec2 z2) {
    vec2 diff = z1 - z2;
    float num = dot(diff, diff);
    float denom = 2.0 * z1.y * z2.y;
    return acosh(1.0 + num / denom);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv.y *= iResolution.y / iResolution.x;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 z = normalize_coord(fragCoord);
    
    // Mouse position as center (mapped to upper half-plane)
    vec2 mouse = iMouse.xy / iResolution.xy;
    mouse.y *= iResolution.y / iResolution.x;
    mouse = mouse * 4.0;
    
    // Default center if no mouse input
    if (iMouse.x < 1.0) {
        mouse = vec2(1.0, 1.0);
    }
    
    // Ensure center is in upper half-plane
    mouse.y = max(mouse.y, 0.1);
    
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    // Only compute for upper half-plane
    if (z.y > 0.0) {
        float d = hypDist(z, mouse);
        
        // Draw circles at hyperbolic radii 0.5 and 1.0
        if (abs(d - 0.5) < 0.02) {
            color = vec3(1.0, 0.8, 0.3);
        }
        if (abs(d - 1.0) < 0.02) {
            color = vec3(0.3, 0.8, 1.0);
        }
        
        // Mark center
        if (length(z - mouse) < 0.05) {
            color = vec3(1.0, 0.3, 0.3);
        }
    }
    
    // Draw real axis
    if (z.y < 0.02) {
        color = vec3(0.2, 0.2, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E2. Dragging a Hyperbolic Ball

```glsl
float acosh(float x) {
    return log(x + sqrt(x * x - 1.0));
}

float hypDist(vec2 z1, vec2 z2) {
    vec2 diff = z1 - z2;
    float num = dot(diff, diff);
    float denom = 2.0 * z1.y * z2.y;
    return acosh(1.0 + num / denom);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv.y *= iResolution.y / iResolution.x;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 z = normalize_coord(fragCoord);
    
    // Mouse position as ball center
    vec2 center = iMouse.xy / iResolution.xy;
    center.y *= iResolution.y / iResolution.x;
    center = center * 4.0;
    
    // Default position
    if (iMouse.x < 1.0) {
        center = vec2(1.0, 1.0);
    }
    
    // Keep in upper half-plane
    center.y = max(center.y, 0.1);
    
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    if (z.y > 0.0) {
        float d = hypDist(z, center);
        
        // Filled hyperbolic disk of radius 0.3
        if (d < 0.3) {
            // Gradient from center to edge
            float t = d / 0.3;
            color = mix(vec3(1.0, 0.5, 0.2), vec3(0.8, 0.3, 0.1), t);
        }
        
        // Edge highlight
        if (abs(d - 0.3) < 0.01) {
            color = vec3(1.0, 1.0, 1.0);
        }
    }
    
    // Real axis
    if (z.y < 0.02) {
        color = vec3(0.2, 0.2, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Extension: Poincaré disk version**

```glsl
float acosh(float x) {
    return log(x + sqrt(x * x - 1.0));
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

float hypDist(vec2 z1, vec2 z2) {
    vec2 diff = z1 - z2;
    float num = dot(diff, diff);
    float denom = 2.0 * z1.y * z2.y;
    return acosh(1.0 + num / denom);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    
    // Mouse in disk coordinates
    vec2 mouse_w = iMouse.xy / iResolution.xy;
    mouse_w = mouse_w - vec2(0.5, 0.5);
    mouse_w.x *= iResolution.x / iResolution.y;
    mouse_w = mouse_w * 2.5;
    
    // Default to center
    if (iMouse.x < 1.0) {
        mouse_w = vec2(0.0, 0.0);
    }
    
    // Clamp inside disk
    if (length(mouse_w) > 0.95) {
        mouse_w = normalize(mouse_w) * 0.95;
    }
    
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    if (length(w) < 1.0) {
        // Convert to UHP for distance calculation
        vec2 z = diskToUHP(w);
        vec2 center_z = diskToUHP(mouse_w);
        
        float d = hypDist(z, center_z);
        
        if (d < 0.5) {
            float t = d / 0.5;
            color = mix(vec3(1.0, 0.5, 0.2), vec3(0.8, 0.3, 0.1), t);
        }
        
        if (abs(d - 0.5) < 0.02) {
            color = vec3(1.0, 1.0, 1.0);
        }
    } else {
        color = vec3(0.05, 0.05, 0.05);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E3. Edge Highlighting (Euclidean Triangle)

```glsl
// Color palette
const vec3 WHITE = vec3(1.0, 1.0, 1.0);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);

struct HalfSpace {
    vec2 normal;
    float offset;
    float side;
};

vec2 reflectInto(vec2 p, HalfSpace h, inout int count) {
    float val = dot(h.normal, p) - h.offset;
    if (val * h.side < 0.0) return p;
    count++;
    return p - 2.0 * val * h.normal;
}

float distToLine(vec2 p, vec2 normal, float offset) {
    return abs(dot(normal, p) - offset);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 6.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Equilateral triangle half-spaces
    HalfSpace h1 = HalfSpace(vec2(0.0, 1.0),       -0.5, -1.0);  // Bottom
    HalfSpace h2 = HalfSpace(vec2(0.866, -0.5),    -0.5, -1.0);  // Upper-right
    HalfSpace h3 = HalfSpace(vec2(-0.866, -0.5),   -0.5, -1.0);  // Upper-left
    
    int foldCount = 0;
    for (int i = 0; i < 30; i++) {
        vec2 p0 = p;
        p = reflectInto(p, h1, foldCount);
        p = reflectInto(p, h2, foldCount);
        p = reflectInto(p, h3, foldCount);
        if (length(p - p0) < 0.0001) break;
    }
    
    // Distance to bottom edge (the one with normal (0, 1))
    float distToEdge = distToLine(p, vec2(0.0, 1.0), -0.5);
    
    // Color by distance to edge
    float brightness = smoothstep(0.0, 0.4, distToEdge);
    vec3 color = mix(WHITE, SLATE, brightness);
    
    fragColor = vec4(color, 1.0);
}
```

This reveals hexagonal patterns! The white "stripes" form hexagon boundaries.

---

### E4. Edges of the Tiling

```glsl
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 WHITE = vec3(1.0, 1.0, 1.0);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

float acosh(float x) {
    return log(x + sqrt(x * x - 1.0));
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

// Distance to vertical geodesic at x = c
float distToVert(vec2 z, float c) {
    z.x -= c;
    return acosh(length(z) / z.y);
}

// Distance to semicircular geodesic
float distToCirc(vec2 z, float center, float radius) {
    vec2 num = z - vec2(center + radius, 0.0);
    vec2 denom = z - vec2(center - radius, 0.0);
    vec2 w = cdiv(num, denom);
    return acosh(length(w) / w.y);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    // Background by parity
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? CREAM : SLATE;
    
    // Draw edges
    float d1 = distToVert(z, 0.0);
    float d2 = distToVert(z, 0.5);
    float d3 = distToCirc(z, 0.0, 1.0);
    
    float minDist = min(d1, min(d2, d3));
    if (minDist < 0.03) {
        color = WHITE;
    }
    
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E5. Soccer Ball Coloring

```glsl
const vec3 WHITE = vec3(1.0, 1.0, 1.0);
const vec3 DARK = vec3(0.15, 0.15, 0.15);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

float acosh(float x) {
    return log(x + sqrt(x * x - 1.0));
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

float hypDist(vec2 z1, vec2 z2) {
    vec2 diff = z1 - z2;
    float num = dot(diff, diff);
    float denom = 2.0 * z1.y * z2.y;
    return acosh(1.0 + num / denom);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    // (2,3,7) triangle
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    HalfSpaceCirc third = HalfSpaceCirc(-0.7665, 1.533, -1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, bottom, foldCount);
        z = reflectInto(z, third, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    // Vertices of the (2,3,7) triangle:
    // pi/2 vertex at i (where vertical meets unit circle)
    // pi/3 vertex at approximately 0.5 + 0.866i
    // pi/7 vertex at approximately 0.1234 + 1.073i (on the third geodesic)
    
    vec2 v_pi2 = vec2(0.0, 1.0);
    vec2 v_pi3 = vec2(0.5, 0.866);
    vec2 v_pi7 = vec2(0.1234, 1.073);
    
    // Find which vertex is closest (hyperbolic distance)
    float d_pi2 = hypDist(z, v_pi2);
    float d_pi3 = hypDist(z, v_pi3);
    float d_pi7 = hypDist(z, v_pi7);
    
    vec3 color;
    if (d_pi2 < d_pi3 && d_pi2 < d_pi7) {
        color = WHITE;  // Near pi/2 vertex
    } else if (d_pi3 < d_pi7) {
        color = DARK;   // Near pi/3 vertex (black pentagons... err wait, triangles)
    } else {
        color = WHITE;  // Near pi/7 vertex
    }
    
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

Note: The vertex positions need adjustment for perfect results. The pi/7 vertex can be computed from the geodesic equations.

---

## Challenges

### H1. The Klein Disk Model

```glsl
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

// Klein to Poincaré
vec2 kleinToPoincare(vec2 k) {
    float r2 = dot(k, k);
    return k / (1.0 + sqrt(1.0 - r2));
}

// Poincaré to UHP
vec2 poincareToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 k = normalize_coord(fragCoord);  // Klein coordinates
    
    vec3 color = BLACK;
    
    if (length(k) < 0.999) {
        vec2 w = kleinToPoincare(k);
        vec2 z = poincareToUHP(w);
        
        HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
        HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
        HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
        
        int foldCount = 0;
        for (int i = 0; i < 100; i++) {
            vec2 z0 = z;
            z = reflectInto(z, left, foldCount);
            z = reflectInto(z, right, foldCount);
            z = reflectInto(z, bottom, foldCount);
            if (length(z - z0) < 0.0001) break;
        }
        
        float parity = mod(float(foldCount), 2.0);
        color = (parity < 0.5) ? CREAM : SLATE;
    }
    
    fragColor = vec4(color, 1.0);
}
```

In the Klein model, all geodesics appear as straight lines! The triangles look like ordinary Euclidean triangles.

---

### H2. The Band Model

```glsl
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

// Band to Poincaré (inverse of log transform)
vec2 bandToPoincare(vec2 b) {
    // b = log((1+w)/(1-w))
    // exp(b) = (1+w)/(1-w)
    // exp(b)(1-w) = 1+w
    // exp(b) - 1 = w(1 + exp(b))
    // w = (exp(b) - 1)/(exp(b) + 1) = tanh(b/2)
    
    vec2 eb = vec2(exp(b.x) * cos(b.y), exp(b.x) * sin(b.y));
    vec2 one = vec2(1.0, 0.0);
    return cdiv(eb - one, eb + one);
}

vec2 poincareToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    // Band model: x from -inf to inf, y from 0 to pi
    return vec2(uv.x * 8.0, uv.y * 3.14159 + 1.5708);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 b = normalize_coord(fragCoord);  // Band coordinates
    
    vec3 color = BLACK;
    
    // Band is valid for y in (0, pi)
    if (b.y > 0.01 && b.y < 3.13) {
        vec2 w = bandToPoincare(b);
        vec2 z = poincareToUHP(w);
        
        HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
        HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
        HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
        
        int foldCount = 0;
        for (int i = 0; i < 100; i++) {
            vec2 z0 = z;
            z = reflectInto(z, left, foldCount);
            z = reflectInto(z, right, foldCount);
            z = reflectInto(z, bottom, foldCount);
            if (length(z - z0) < 0.0001) break;
        }
        
        float parity = mod(float(foldCount), 2.0);
        color = (parity < 0.5) ? CREAM : SLATE;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### H3. Interactive Möbius Transformations

```glsl
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

// Möbius transformation (az + b)/(cz + d)
vec2 mobius(vec2 z, float a, float b, float c, float d) {
    vec2 num = vec2(a * z.x + b, a * z.y);
    vec2 denom = vec2(c * z.x + d, c * z.y);
    return cdiv(num, denom);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    // Mouse controls transformation
    float mx = iMouse.x / iResolution.x;
    float my = iMouse.y / iResolution.y;
    
    // Default values if no mouse
    if (iMouse.x < 1.0) {
        mx = 0.5;
        my = 0.5;
    }
    
    // Horizontal translation: z -> z + t
    float translation = (mx - 0.5) * 4.0;
    z.x += translation;
    
    // Scaling: z -> k*z
    float scale = exp((my - 0.5) * 2.0);
    z = z * scale;
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? CREAM : SLATE;
    
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## Project: General Triangle Tilings

### Complete Solution

```glsl
// Color palette
const vec3 CREAM = vec3(0.85, 0.8, 0.75);
const vec3 SLATE = vec3(0.35, 0.4, 0.45);
const vec3 WHITE = vec3(1.0, 1.0, 1.0);
const vec3 BLACK = vec3(0.05, 0.05, 0.05);

const float PI = 3.14159265359;

struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

float acosh(float x) {
    return log(x + sqrt(x * x - 1.0));
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    if ((z.x - h.x) * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z = z / h.radius;
    z = z / dot(z, z);
    z = z * h.radius;
    z.x += h.center;
    count++;
    return z;
}

// Distance to vertical geodesic
float distToVert(vec2 z, float c) {
    z.x -= c;
    return acosh(length(z) / z.y);
}

// Distance to circular geodesic
float distToCirc(vec2 z, float center, float radius) {
    vec2 num = z - vec2(center + radius, 0.0);
    vec2 denom = z - vec2(center - radius, 0.0);
    vec2 w = cdiv(num, denom);
    return acosh(length(w) / w.y);
}

// Compute third geodesic for (2, q, r) triangle
void computeTriangle(float q, float r, out float center, out float radius) {
    float p = 2.0;
    
    float num = cos(PI/r) + cos(PI/p) * cos(PI/q);
    float denom = sin(PI/p) * sin(PI/q);
    float sr = acosh(num / denom);
    
    float eucH = sin(PI/p) * exp(sr);
    float want = eucH / tan(PI/q);
    
    center = -cos(PI/p) - want;
    radius = sqrt(want * want + eucH * eucH);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 2.5;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    // Triangle parameters - change these!
    float q = 3.0;
    float r = 7.0;
    
    // Compute the three half-spaces
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    float center, radius;
    computeTriangle(q, r, center, radius);
    HalfSpaceCirc third = HalfSpaceCirc(center, radius, -1.0);
    
    // Fold into fundamental domain
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, bottom, foldCount);
        z = reflectInto(z, third, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    // Background by parity
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? CREAM : SLATE;
    
    // Draw edges
    float d1 = distToVert(z, 0.0);
    float d2 = distToCirc(z, 0.0, 1.0);
    float d3 = distToCirc(z, center, radius);
    
    float minDist = min(d1, min(d2, d3));
    if (minDist < 0.02) {
        color = WHITE;
    }
    
    // Mask outside disk
    if (length(w) > 1.0) {
        color = BLACK;
    }
    
    fragColor = vec4(color, 1.0);
}
```

### Verification

Running the `computeTriangle` function:

**For (2,3,7):**
- q=3, r=7
- num = cos(π/7) + 0 ≈ 0.901
- denom = 1 × sin(π/3) ≈ 0.866
- sr = acosh(1.04) ≈ 0.284
- eucH = 1 × exp(0.284) ≈ 1.328
- want = 1.328 / tan(π/3) ≈ 0.767
- center = 0 - 0.767 = -0.767 ✓
- radius = sqrt(0.588 + 1.764) ≈ 1.533 ✓

**For (2,4,5):**
- q=4, r=5
- num = cos(π/5) + 0 ≈ 0.809
- denom = 1 × sin(π/4) ≈ 0.707
- sr = acosh(1.144) ≈ 0.531
- eucH = 1 × exp(0.531) ≈ 1.70
- want = 1.70 / tan(π/4) = 1.70
- center = 0 - 1.70 = -1.70 ✓
- radius = sqrt(2.89 + 2.89) ≈ 2.40 ✓

**For (2,3,∞):**
As r → ∞, cos(π/r) → 1, so num → 1 + 0 = 1.
sr → acosh(1/sin(π/3)) = acosh(1.155) ≈ 0.505
eucH → exp(0.505) ≈ 1.66
The third geodesic moves further left and becomes approximately vertical at x = 0.5 (requires limit analysis).