# Day 3: Exercise Solutions

Complete shader solutions for the Day 3 exercises.

---

## Checkpoints

### C1. Hyperbolic Circles

Draw hyperbolic circles of radius 0.1 and 0.5 around the mouse position.

```glsl
float hypDist(vec2 z1, vec2 z2) {
    vec2 diff = z1 - z2;
    float num = dot(diff, diff);
    float denom = 2.0 * z1.y * z2.y;
    float arg = 1.0 + num / denom;
    return log(arg + sqrt(arg * arg - 1.0));  // acosh
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv.y *= iResolution.y / iResolution.x;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 z = normalize_coord(fragCoord);
    
    // Get mouse position in same coordinates
    vec2 center = normalize_coord(iMouse.xy);
    
    // Default center when not clicking
    if (iMouse.z < 0.5) {
        center = vec2(2.0, 2.0);
    }
    
    // Hyperbolic distance from center
    float d = hypDist(z, center);
    
    // Background
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    // Draw circle at radius 0.1
    if (abs(d - 0.1) < 0.02) {
        color = vec3(0.3, 0.7, 0.9);
    }
    
    // Draw circle at radius 0.5
    if (abs(d - 0.5) < 0.02) {
        color = vec3(0.9, 0.5, 0.3);
    }
    
    // Mark center
    if (length(z - center) < 0.03) {
        color = vec3(1.0, 1.0, 1.0);
    }
    
    // Darken below real axis
    if (z.y < 0.01) {
        color = vec3(0.05);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C2. Edges of the (2,3,∞) Tiling

Add edge drawing using hyperbolic distance to geodesics.

```glsl
struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    float val = z.x - h.x;
    if (val * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

float distToGeodesic(vec2 z, HalfSpaceVert h) {
    z.x -= h.x;
    return acosh(length(z) / z.y);
}

float distToGeodesic(vec2 z, HalfSpaceCirc h) {
    vec2 num = z - vec2(h.center + h.radius, 0.0);
    vec2 denom = z - vec2(h.center - h.radius, 0.0);
    vec2 w = cdiv(num, denom);
    return acosh(length(w) / w.y);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv.y *= iResolution.y / iResolution.x;
    return uv * 4.0 - vec2(0.75, 0.0);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 z = normalize_coord(fragCoord);
    vec2 z_orig = z;
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    // Draw edges using hyperbolic distance
    float edgeThickness = 0.03;
    float d1 = distToGeodesic(z, left);
    float d2 = distToGeodesic(z, right);
    float d3 = distToGeodesic(z, bottom);
    
    if (d1 < edgeThickness || d2 < edgeThickness || d3 < edgeThickness) {
        color = vec3(1.0);
    }
    
    if (z_orig.y < 0.01) color = vec3(0.15);
    
    fragColor = vec4(color, 1.0);
}
```

---

## Explorations

### E1. Vertices and Edges in Both Models

Drawing vertices and edges, in both UHP and Poincaré disk.

```glsl
struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    float val = z.x - h.x;
    if (val * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

float distToGeodesic(vec2 z, HalfSpaceVert h) {
    z.x -= h.x;
    return acosh(length(z) / z.y);
}

float distToGeodesic(vec2 z, HalfSpaceCirc h) {
    vec2 num = z - vec2(h.center + h.radius, 0.0);
    vec2 denom = z - vec2(h.center - h.radius, 0.0);
    vec2 w = cdiv(num, denom);
    return acosh(length(w) / w.y);
}

float hypDist(vec2 z1, vec2 z2) {
    vec2 diff = z1 - z2;
    float num = dot(diff, diff);
    float denom = 2.0 * z1.y * z2.y;
    float arg = 1.0 + num / denom;
    return log(arg + sqrt(arg * arg - 1.0));
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.5;
    uv.x *= iResolution.x / iResolution.y;
    return uv;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    // Draw edges
    float edgeThickness = 0.02;
    float d1 = distToGeodesic(z, left);
    float d2 = distToGeodesic(z, right);
    float d3 = distToGeodesic(z, bottom);
    
    if (d1 < edgeThickness || d2 < edgeThickness || d3 < edgeThickness) {
        color = vec3(0.2);
    }
    
    // Draw vertices
    vec2 v1 = vec2(0.0, 1.0);                    // i (angle pi/2)
    vec2 v2 = vec2(0.5, 0.866);                  // 1/2 + sqrt(3)/2 * i (angle pi/3)
    
    float vertexRadius = 0.08;
    if (hypDist(z, v1) < vertexRadius) {
        color = vec3(0.9, 0.3, 0.3);
    }
    if (hypDist(z, v2) < vertexRadius) {
        color = vec3(0.3, 0.9, 0.3);
    }
    
    if (length(w) > 1.0) color = vec3(0.05);
    
    fragColor = vec4(color, 1.0);
}
```

---

### E2. The Klein Disk Model

Display the tiling in the Klein disk where geodesics are straight lines.

```glsl
struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    float val = z.x - h.x;
    if (val * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

// Klein disk to Poincaré disk
vec2 kleinToPoincare(vec2 k) {
    float k_mag2 = dot(k, k);
    float denom = 1.0 + sqrt(1.0 - k_mag2);
    return k / denom;
}

// Poincaré disk to upper half-plane
vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.5;
    uv.x *= iResolution.x / iResolution.y;
    return uv;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 k = normalize_coord(fragCoord);  // Klein disk coordinates
    
    // Convert Klein -> Poincaré -> UHP
    vec2 w = kleinToPoincare(k);
    vec2 z = diskToUHP(w);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    if (length(k) > 1.0) color = vec3(0.05);
    
    fragColor = vec4(color, 1.0);
}
```

---

### E3. The Band Model

::: {.callout-warning}
## Solution TODO
The band model solution needs to be written. The conversion uses `ctanh` to map from band to Poincaré disk, then the standard disk-to-UHP conversion.
:::

---

### E4. Interactive Möbius Transformations

Use mouse to translate and scale the tiling.

```glsl
struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    float val = z.x - h.x;
    if (val * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

// Apply Möbius transformation (a*z + b) / (c*z + d) with real coefficients
vec2 mobius(vec2 z, float a, float b, float c, float d) {
    vec2 num = vec2(a * z.x + b, a * z.y);
    vec2 denom = vec2(c * z.x + d, c * z.y);
    return cdiv(num, denom);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.5;
    uv.x *= iResolution.x / iResolution.y;
    return uv;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    // Get mouse position for transformation parameters
    vec2 mouse = iMouse.xy / iResolution.xy;
    if (iMouse.z < 0.5) {
        mouse = vec2(0.5, 0.5);
    }
    
    // Horizontal translation: z -> z + t (positive t moves tiling left, so add t)
    float t = (mouse.x - 0.5) * 4.0;
    z.x += t;
    
    // Scaling: z -> k*z (k > 1 zooms in, so divide)
    float k = exp((mouse.y - 0.5) * 2.0);
    z /= k;
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    if (length(w) > 1.0) color = vec3(0.05);
    
    fragColor = vec4(color, 1.0);
}
```

---

## Challenges

### H1. Animated Model Transitions

Smoothly morph between upper half-plane and Poincaré disk.

The key insight is to interpolate at the level of matrices. The Cayley transform $C(z) = \frac{z-i}{z+i}$ has matrix $M = \begin{pmatrix} 1 & -i \\ 1 & i \end{pmatrix}$, and identity has matrix $I$. The linear interpolation $M_t = (1-t)I + tM$ has determinant $1 - t + it \neq 0$ for $t \in [0,1]$, so each $M_t$ is invertible.

This gives us: $f_t(z) = \frac{z - it}{tz + (1-t+it)}$

```glsl
struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    float val = z.x - h.x;
    if (val * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

// Interpolated Cayley transform: f_t(z) = (z - it) / (tz + (1-t+it))
vec2 partialCayley(vec2 z, float t) {
    vec2 num = z - vec2(0.0, t);                    // z - it
    vec2 denom = t * z + vec2(1.0 - t, t);          // tz + (1-t+it)
    return cdiv(num, denom);
}

// Inverse of partial Cayley: solve w = (z - it) / (tz + (1-t+it)) for z
// w(tz + (1-t+it)) = z - it
// wtz + w(1-t+it) = z - it
// wtz - z = -it - w(1-t+it)
// z(wt - 1) = -it - w(1-t+it)
// z = (it + w(1-t+it)) / (1 - wt)
vec2 invPartialCayley(vec2 w, float t) {
    vec2 it = vec2(0.0, t);
    vec2 coef = vec2(1.0 - t, t);                   // (1-t+it)
    vec2 num = it + cmul(w, coef);                  // it + w(1-t+it)
    vec2 denom = vec2(1.0, 0.0) - t * w;            // 1 - wt
    return cdiv(num, denom);
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.5;
    uv.x *= iResolution.x / iResolution.y;
    return uv;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float t = 0.5 + 0.5 * sin(iTime * 0.5);
    
    // Screen shows a disk-like region
    vec2 w = normalize_coord(fragCoord);
    
    // Apply inverse partial Cayley to get UHP coordinates
    vec2 z = invPartialCayley(w, t);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    // Always black in lower half-plane (z.y < 0 in UHP)
    if (z.y < 0.0) {
        color = vec3(0.05);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### H2. Dual Tiling

Draw geodesics connecting centers of adjacent triangles.

```glsl
struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    float val = z.x - h.x;
    if (val * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

float hypDist(vec2 z1, vec2 z2) {
    vec2 diff = z1 - z2;
    float num = dot(diff, diff);
    float denom = 2.0 * z1.y * z2.y;
    float arg = 1.0 + num / denom;
    return log(arg + sqrt(arg * arg - 1.0));
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.5;
    uv.x *= iResolution.x / iResolution.y;
    return uv;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    // Triangle incenter (approximate center of fundamental domain)
    vec2 incenter = vec2(0.25, 1.1);
    
    // Draw dual edges: geodesic segments from incenter perpendicular to each edge
    // These are the only three segments we draw; reflections tile the rest
    
    // Edge 1: perpendicular to left edge (x=0)
    // The perpendicular geodesic from incenter to x=0 is a semicircle 
    // centered at origin passing through incenter
    // It hits x=0 at y = |incenter| (the radius)
    float r1 = length(incenter);
    float d1 = abs(length(z) - r1);
    // Only draw between incenter and the edge (y <= incenter.y, x near 0 side)
    bool onSeg1 = (z.y <= r1) && (z.x >= 0.0) && (z.x <= incenter.x);
    
    // Edge 2: perpendicular to right edge (x=0.5)
    // Semicircle centered at (0.5, 0) passing through incenter
    vec2 c2 = vec2(0.5, 0.0);
    float r2 = length(incenter - c2);
    float d2 = abs(length(z - c2) - r2);
    // Only draw between incenter and x=0.5
    bool onSeg2 = (z.x >= incenter.x) && (z.x <= 0.5);
    
    // Edge 3: perpendicular to bottom (unit circle centered at origin)
    // The perpendicular from incenter to unit circle is a vertical line x = incenter.x
    // (since unit circle is centered at origin, radial lines are perpendicular)
    float d3 = abs(z.x - incenter.x);
    // Only draw from incenter down to unit circle (y between 1 and incenter.y)
    float yOnCircle = sqrt(1.0 - incenter.x * incenter.x);
    bool onSeg3 = (z.y >= yOnCircle) && (z.y <= incenter.y);
    
    // Draw dual edges with hyperbolic-ish thickness
    float thickness = 0.02;
    if ((d1 < thickness && onSeg1) || 
        (d2 < thickness && onSeg2) || 
        (d3 < thickness && onSeg3)) {
        color = vec3(0.8, 0.2, 0.2);
    }
    
    // Draw dual vertex (incenter)
    float dv = hypDist(z, incenter);
    if (dv < 0.05) {
        color = vec3(0.2, 0.2, 0.8);
    }
    
    if (length(w) > 1.0) color = vec3(0.05);
    
    fragColor = vec4(color, 1.0);
}
```

---

### H3. Single-Edge Tilings

Draw only the circular geodesic edge.

```glsl
struct HalfSpaceVert {
    float x;
    float side;
};

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {
    float val = z.x - h.x;
    if (val * h.side < 0.0) return z;
    z.x = 2.0 * h.x - z.x;
    count++;
    return z;
}

vec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

float distToGeodesic(vec2 z, HalfSpaceCirc h) {
    vec2 num = z - vec2(h.center + h.radius, 0.0);
    vec2 denom = z - vec2(h.center - h.radius, 0.0);
    vec2 w = cdiv(num, denom);
    return acosh(length(w) / w.y);
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.5;
    uv.x *= iResolution.x / iResolution.y;
    return uv;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);
    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);
    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInto(z, left, foldCount);
        z = reflectInto(z, right, foldCount);
        z = reflectInto(z, bottom, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    // Draw ONLY the circular edge
    float d = distToGeodesic(z, bottom);
    if (d < 0.03) {
        color = vec3(1.0);
    }
    
    if (length(w) > 1.0) color = vec3(0.05);
    
    fragColor = vec4(color, 1.0);
}
```

---

## Projects

### P1. General (p,q,r) Triangle Tilings

This is a more substantial project. Here's a starting point for the (2,3,7) tiling—a compact hyperbolic triangle with all finite vertices.

The key challenge is computing the geodesic positions from the angle constraints. For (2,3,7):
- Angle at vertex A: π/2
- Angle at vertex B: π/3  
- Angle at vertex C: π/7

```glsl
// Note: This is a simplified solution showing the structure.
// Computing exact vertex positions for arbitrary (p,q,r) requires
// solving hyperbolic trigonometry equations.

struct HalfSpaceCirc {
    float center;
    float radius;
    float side;
};

vec2 cdiv(vec2 a, vec2 b) {
    float denom = dot(b, b);
    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;
}

vec2 cmul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

vec2 reflectInCircle(vec2 z, HalfSpaceCirc h, inout int count) {
    vec2 rel = z - vec2(h.center, 0.0);
    float dist2 = dot(rel, rel);
    
    if ((dist2 - h.radius * h.radius) * h.side > 0.0) return z;
    
    z.x -= h.center;
    z /= h.radius;
    z /= dot(z, z);
    z *= h.radius;
    z.x += h.center;
    
    count++;
    return z;
}

vec2 diskToUHP(vec2 w) {
    vec2 i = vec2(0.0, 1.0);
    vec2 one = vec2(1.0, 0.0);
    return cmul(i, cdiv(one + w, one - w));
}

vec2 normalize_coord(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.5;
    uv.x *= iResolution.x / iResolution.y;
    return uv;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 w = normalize_coord(fragCoord);
    vec2 z = diskToUHP(w);
    
    // (2,3,7) triangle - precomputed geodesics
    // These values are approximate - exact computation requires
    // solving cosh(a) = cos(pi/p) + cos(pi/q)*cos(pi/r) / (sin(pi/q)*sin(pi/r))
    // for the side lengths, then positioning the geodesics.
    
    HalfSpaceCirc edge1 = HalfSpaceCirc(-0.3, 1.1, 1.0);
    HalfSpaceCirc edge2 = HalfSpaceCirc(0.5, 0.9, 1.0);
    HalfSpaceCirc edge3 = HalfSpaceCirc(0.0, 0.7, 1.0);
    
    int foldCount = 0;
    for (int i = 0; i < 100; i++) {
        vec2 z0 = z;
        z = reflectInCircle(z, edge1, foldCount);
        z = reflectInCircle(z, edge2, foldCount);
        z = reflectInCircle(z, edge3, foldCount);
        if (length(z - z0) < 0.0001) break;
    }
    
    float parity = mod(float(foldCount), 2.0);
    vec3 color = (parity < 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);
    
    if (length(w) > 1.0) color = vec3(0.05);
    
    fragColor = vec4(color, 1.0);
}
```

**To complete this project:**

1. Implement the hyperbolic law of cosines to compute side lengths from angles
2. Position three geodesics (semicircles) that meet at the correct angles
3. Add edge and vertex drawing
4. Make p, q, r adjustable via uniforms
5. Add validation that 1/p + 1/q + 1/r < 1 (hyperbolic condition)