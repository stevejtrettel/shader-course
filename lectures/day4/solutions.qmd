# Day 4 Solutions

## Checkpoints

### C1. HighLife

HighLife uses rule B36/S23: birth with 3 or 6 neighbors, survival with 2 or 3.

**Buffer A:**
```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize with random cells
    if (iFrame == 0) {
        float r = hash(fragCoord);
        float alive = r < 0.3 ? 1.0 : 0.0;
        fragColor = vec4(alive, alive, alive, 1.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    // Read self and neighbors
    float self = texelFetch(iChannel0, p, 0).r;
    float neighbors = 
        texelFetch(iChannel0, p + ivec2(-1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  1), 0).r;
    
    // HighLife rules: B36/S23
    float alive;
    if (self > 0.5) {
        // Currently alive: survive with 2 or 3 neighbors
        alive = (neighbors > 1.5 && neighbors < 3.5) ? 1.0 : 0.0;
    } else {
        // Currently dead: birth with 3 OR 6 neighbors
        alive = (neighbors > 2.5 && neighbors < 3.5) || 
                (neighbors > 5.5 && neighbors < 6.5) ? 1.0 : 0.0;
    }
    
    fragColor = vec4(alive, alive, alive, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

---

### C2. Two Hot Spots

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: two hot disks
    if (iFrame == 0) {
        vec2 center1 = iResolution.xy * 0.5 + vec2(-100.0, 0.0);
        vec2 center2 = iResolution.xy * 0.5 + vec2(100.0, 0.0);
        float d1 = length(fragCoord - center1);
        float d2 = length(fragCoord - center2);
        float temp = (d1 < 60.0 || d2 < 60.0) ? 1.0 : 0.0;
        fragColor = vec4(temp, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary: edges fixed at zero
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Read neighbors
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    // Laplacian
    float laplacian = n + s + e + w - 4.0 * c;
    
    // Explicit Euler step
    float alpha = 0.5;
    float dt = 0.4;
    float newTemp = c + dt * alpha * laplacian;
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
vec3 heatColor(float t) {
    return mix(vec3(0.0, 0.0, 0.3), vec3(1.0, 0.3, 0.0), t);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float temp = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    fragColor = vec4(heatColor(temp), 1.0);
}
```

---

### C3. Off-Center Pluck

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: off-center Gaussian pluck
    if (iFrame == 0) {
        vec2 pluck = iResolution.xy * 0.5 + vec2(150.0, 100.0);
        float d = length(fragCoord - pluck);
        float sigma = 30.0;
        float u = exp(-d * d / (2.0 * sigma * sigma));
        fragColor = vec4(u, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: zero velocity
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C4. Damped Waves

Only Buffer B changes — add damping after computing newV:

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    // Damping: waves lose energy over time
    newV *= 0.998;
    
    // Mouse adds velocity kick
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

---

## Explorations

### E1. Brian's Brain

**Buffer A:**
```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

// Count only "On" neighbors (value between 0.5 and 1.5)
float countOn(float val) {
    return (val > 0.5 && val < 1.5) ? 1.0 : 0.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize with random states: 0 (off), 1 (on), 2 (dying)
    if (iFrame == 0) {
        float r = hash(fragCoord);
        float state = r < 0.33 ? 0.0 : (r < 0.66 ? 1.0 : 2.0);
        fragColor = vec4(state, 0.0, 0.0, 1.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    // Read current state
    float self = texelFetch(iChannel0, p, 0).r;
    
    // Count only "On" neighbors
    float n  = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s  = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e  = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w  = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float ne = texelFetch(iChannel0, p + ivec2( 1,  1), 0).r;
    float nw = texelFetch(iChannel0, p + ivec2(-1,  1), 0).r;
    float se = texelFetch(iChannel0, p + ivec2( 1, -1), 0).r;
    float sw = texelFetch(iChannel0, p + ivec2(-1, -1), 0).r;
    
    float neighbors = countOn(n) + countOn(s) + countOn(e) + countOn(w) +
                      countOn(ne) + countOn(nw) + countOn(se) + countOn(sw);
    
    float newState;
    
    if (self < 0.5) {
        // Off -> On if exactly 2 neighbors are On
        newState = (neighbors > 1.5 && neighbors < 2.5) ? 1.0 : 0.0;
    } else if (self < 1.5) {
        // On -> Dying
        newState = 2.0;
    } else {
        // Dying -> Off
        newState = 0.0;
    }
    
    fragColor = vec4(newState, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float state = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    
    vec3 color;
    if (state < 0.5) {
        color = vec3(0.0);              // Off: black
    } else if (state < 1.5) {
        color = vec3(1.0);              // On: white
    } else {
        color = vec3(0.0, 0.5, 1.0);    // Dying: blue
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E2. Ring of Fire

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: ring (hot between two radii)
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float temp = (d > 60.0 && d < 100.0) ? 1.0 : 0.0;
        fragColor = vec4(temp, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    float laplacian = n + s + e + w - 4.0 * c;
    
    float alpha = 0.5;
    float dt = 0.4;
    float newTemp = c + dt * alpha * laplacian;
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

**Image:** Same as heat equation.

---

### E3. Spatially Varying Diffusion

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float temp = d < 80.0 ? 1.0 : 0.0;
        fragColor = vec4(temp, 0.0, 0.0, 1.0);
        return;
    }
    
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    float laplacian = n + s + e + w - 4.0 * c;
    
    // Spatially varying diffusion: right half diffuses faster
    float alpha = 0.2 + 0.6 * step(iResolution.x * 0.5, fragCoord.x);
    
    // Alternative: sinusoidal pattern
    // float alpha = 0.2 + 0.4 * (0.5 + 0.5 * sin(fragCoord.x * 0.02));
    
    float dt = 0.4;
    float newTemp = c + dt * alpha * laplacian;
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

---

### E4. Wave Interference

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: two Gaussian plucks
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        vec2 pluck1 = center + vec2(-100.0, 0.0);
        vec2 pluck2 = center + vec2(100.0, 0.0);
        float sigma = 30.0;
        float d1 = length(fragCoord - pluck1);
        float d2 = length(fragCoord - pluck2);
        float u = exp(-d1*d1 / (2.0*sigma*sigma)) + exp(-d2*d2 / (2.0*sigma*sigma));
        // For opposite signs, use: - exp(-d2*d2 / (2.0*sigma*sigma));
        fragColor = vec4(u, 0.0, 0.0, 1.0);
        return;
    }
    
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B and Image:** Same as standard wave equation.

---

### E5. Stadium Boundary

**Common:**
```glsl
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

float sdStadium(vec2 p, float halfLength, float radius) {
    // Union of a box and two circles at each end
    float box = sdBox(p, vec2(halfLength, radius));
    float circle1 = sdCircle(p - vec2(halfLength, 0.0), radius);
    float circle2 = sdCircle(p + vec2(halfLength, 0.0), radius);
    return min(box, min(circle1, circle2));
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.3;
    vec2 p = (fragCoord - center) / scale;
    return sdStadium(p, 1.0, 0.5) < 0.0;
}
```

**Buffer A, Buffer B, Image:** Same as wave-circle, using the shared `inDomain` function.

---

## Challenges

### H1. Julia Set Boundary

**Common:**
```glsl
bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.25;
    vec2 z = (fragCoord - center) / scale;
    vec2 c = vec2(-0.4, 0.6);  // Try different values!
    
    for (int i = 0; i < 100; i++) {
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if (dot(z, z) > 4.0) return false;
    }
    return true;
}
```

**Buffer A, Buffer B, Image:** Same as wave-circle.

---

### H2. Gray-Scott Reaction-Diffusion

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: u=1 everywhere, small patch of v in center
    if (iFrame == 0) {
        float u = 1.0;
        float v = 0.0;
        
        vec2 center = iResolution.xy * 0.5;
        if (length(fragCoord - center) < 20.0) {
            v = 1.0;
        }
        // Add some noise for more interesting patterns
        v += 0.1 * fract(sin(dot(fragCoord, vec2(12.9898, 78.233))) * 43758.5453);
        
        fragColor = vec4(u, v, 0.0, 1.0);
        return;
    }
    
    // Parameters
    float Du = 0.2;
    float Dv = 0.1;
    float f = 0.04;
    float k = 0.06;
    float dt = 1.0;
    
    ivec2 p = ivec2(fragCoord);
    
    // Read current state
    vec2 uv = texelFetch(iChannel0, p, 0).rg;
    float u = uv.x;
    float v = uv.y;
    
    // Laplacian of u
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float lap_u = u_n + u_s + u_e + u_w - 4.0 * u;
    
    // Laplacian of v
    float v_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).g;
    float v_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).g;
    float v_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).g;
    float v_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).g;
    float lap_v = v_n + v_s + v_e + v_w - 4.0 * v;
    
    // Reaction term
    float uvv = u * v * v;
    
    // Gray-Scott equations
    float newU = u + dt * (Du * lap_u - uvv + f * (1.0 - u));
    float newV = v + dt * (Dv * lap_v + uvv - (f + k) * v);
    
    // Clamp to valid range
    newU = clamp(newU, 0.0, 1.0);
    newV = clamp(newV, 0.0, 1.0);
    
    fragColor = vec4(newU, newV, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = texelFetch(iChannel0, ivec2(fragCoord), 0).rg;
    
    // Display v (the interesting chemical)
    float v = uv.g;
    
    // Color gradient from dark blue to white
    vec3 color = mix(vec3(0.0, 0.0, 0.2), vec3(1.0), v);
    
    fragColor = vec4(color, 1.0);
}
```

**Extension: Gray-Scott in the Mandelbrot Set**

Add a Common tab with the Mandelbrot domain check:

**Common:**
```glsl
bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.3;
    vec2 c = (fragCoord - center) / scale;
    c.x -= 0.5;
    
    vec2 z = vec2(0.0);
    for (int i = 0; i < 100; i++) {
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if (dot(z, z) > 4.0) return false;
    }
    return true;
}
```

Modify Buffer A to check the domain:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Outside Mandelbrot: fixed at u=1, v=0
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(1.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // ... rest of Gray-Scott code unchanged
}
```

And update Image to show the boundary:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.15, 0.15, 0.15, 1.0);
        return;
    }
    
    vec2 uv = texelFetch(iChannel0, ivec2(fragCoord), 0).rg;
    float v = uv.g;
    vec3 color = mix(vec3(0.0, 0.0, 0.2), vec3(1.0, 0.9, 0.6), v);
    fragColor = vec4(color, 1.0);
}
```

---

### H3. Physical Coordinates

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Physical domain: [-L, L] x [-L, L]
    float L = 2.0;
    
    // Grid spacing
    float h = 2.0 * L / min(iResolution.x, iResolution.y);
    
    // Physical coordinates (for initial condition)
    vec2 physCoord = (fragCoord - iResolution.xy * 0.5) * h;
    
    // Initialize: hot disk of radius 0.5 in physical units
    if (iFrame == 0) {
        float d = length(physCoord);
        float temp = d < 0.5 ? 1.0 : 0.0;
        fragColor = vec4(temp, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    // Laplacian with proper grid spacing
    float laplacian = (n + s + e + w - 4.0 * c) / (h * h);
    
    // Physical diffusion coefficient
    float alpha = 1.0;
    
    // Timestep satisfying stability: dt < h^2 / (4 * alpha)
    float dt = 0.2 * h * h / alpha;
    
    float newTemp = c + dt * alpha * laplacian;
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

---

### H4. Single-Buffer Wave Equation

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: Gaussian pluck, zero velocity
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float sigma = 30.0;
        float u = exp(-d * d / (2.0 * sigma * sigma));
        float v = 0.0;
        fragColor = vec4(u, v, 0.0, 1.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    // Read current state: red = displacement, green = velocity
    vec2 state = texelFetch(iChannel0, p, 0).rg;
    float u = state.r;
    float v = state.g;
    
    // Laplacian of displacement (red channel)
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u;
    
    float dt = 0.5;
    float c = 0.5;
    
    float newU = u + dt * v;
    float newV = v + dt * c * c * laplacian;
    
    // Mouse interaction
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newU, newV, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## Project: Waves on Orbifolds

This solution uses the equilateral triangle wave equation with folding in the Image shader.

**Common:**
```glsl
float sdEquilateralTriangle(vec2 p) {
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    if (p.x + k * p.y > 0.0) {
        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;
    }
    p.x -= clamp(p.x, -2.0, 0.0);
    return -length(p) * sign(p.y);
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = (fragCoord - center) / scale;
    p.y += 0.25;
    return sdEquilateralTriangle(p) < 0.0;
}

// Fold point into fundamental domain (equilateral triangle)
vec2 foldTriangle(vec2 p) {
    const float k = sqrt(3.0);
    
    // Reflect across the three edges until inside
    for (int i = 0; i < 20; i++) {
        // Reflect across vertical line x = 0
        p.x = abs(p.x);
        
        // Reflect across line from (1, -1/sqrt(3)) with normal (sqrt(3)/2, 1/2)
        float d = dot(p - vec2(1.0, -1.0/k), vec2(k/2.0, 0.5));
        if (d > 0.0) {
            p -= 2.0 * d * vec2(k/2.0, 0.5);
        }
        
        // Reflect across line from (-1, -1/sqrt(3)) with normal (-sqrt(3)/2, 1/2)
        d = dot(p - vec2(-1.0, -1.0/k), vec2(-k/2.0, 0.5));
        if (d > 0.0) {
            p -= 2.0 * d * vec2(-k/2.0, 0.5);
        }
    }
    
    return p;
}
```

**Buffer A (displacement):** Same as wave-triangle.

**Buffer B (velocity):** Same as wave-triangle.

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 center = iResolution.xy * 0.5;
    float scale = min(iResolution.x, iResolution.y) * 0.4;
    
    // Transform to normalized coordinates
    vec2 p = (fragCoord - center) / scale;
    p.y += 0.25;  // match the centering offset
    
    // Fold into fundamental domain
    vec2 folded = foldTriangle(p);
    
    // Convert back to pixel coordinates
    folded.y -= 0.25;
    vec2 foldedCoord = folded * scale + center;
    
    // Read displacement from folded position
    float u = texelFetch(iChannel0, ivec2(foldedCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Note:** The folding creates a tiled view of the wave simulation. Waves appear to propagate continuously through triangle boundaries because the folding "unwraps" them.

**Extension — Color-coded copies:**
```glsl
// In foldTriangle, count the number of reflections:
vec2 foldTriangle(vec2 p, out int foldCount) {
    foldCount = 0;
    // ... same folding code, but increment foldCount each time you reflect
}

// In Image shader:
int folds;
vec2 folded = foldTriangle(p, folds);
// Tint based on fold count:
color *= 0.7 + 0.3 * cos(float(folds) * 0.5);
```