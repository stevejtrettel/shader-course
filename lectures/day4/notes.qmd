# Day 4: Simulation

## Overview

By the end of today, you'll be able to create things like this:

{{< shader-demo day4/wave-star >}}

Waves bouncing inside a star. Click to add ripples — watch them reflect off the points and interfere with each other. The wave equation, running in real time on the GPU.

And this:

{{< shader-demo day4/gray-scott-mandelbrot >}}

Reaction-diffusion chemistry confined to the Mandelbrot set. Two simulated chemicals react and diffuse, creating organic patterns that grow and divide inside a fractal boundary.

These are **simulations**: computations where each frame depends on the previous frame. Unlike our earlier shaders, which could compute any frame directly from `iTime`, simulations must evolve step by step. To make them work, we need a new capability: **memory**.

Today we'll learn:

- How buffers store state between frames
- Cellular automata (Game of Life) as a first simulation
- The heat equation: continuous diffusion
- The wave equation: propagation and reflection
- How to trap simulations inside arbitrary boundaries using SDFs


## Buffers and Persistent State

Every shader we've written so far has a fundamental limitation: no memory. Each frame, `mainImage` runs fresh — it doesn't know what it computed last frame, or the frame before that. The screen is a blank slate, redrawn from scratch sixty times per second.

This is fine for static images and even for animation, where motion comes from `iTime`. But it rules out an entire class of phenomena: **simulations**, where the next state depends on the current state. A cellular automaton needs to know which cells were alive. A heat simulation needs to know the current temperature everywhere. A wave needs to know its current shape and velocity.

Today we add memory.

### What Is a Buffer?

Until now, our shader has been a single function — `mainImage` — that writes directly to the screen. The GPU runs it once per pixel, the results appear, and then they're gone. Next frame, we start over.

A **buffer** is a shader that writes to a *stored image* instead of the screen. That image lives in GPU memory and persists between frames. On the next frame, any shader — including the buffer itself — can read from it.

This changes everything. If a buffer reads from itself, it sees what it wrote last frame. Now computations can accumulate. State can evolve. We can simulate.

### Shadertoy's Buffer System

Shadertoy gives us up to four buffers (Buffer A through Buffer D) plus a final Image shader that draws to the screen. Each buffer is its own shader with its own `mainImage` function.

The key mechanism is **channels**. Each shader has four input channels (`iChannel0` through `iChannel3`) that can be connected to various sources: textures, audio, other buffers, or even the buffer's own output.

Here's the setup we'll use most often:

- **Buffer A** reads from itself via `iChannel0` (this creates persistence)
- **Image** reads from Buffer A via `iChannel0` (this displays the result)

To set this up in Shadertoy:

1. Click the **+** tab next to "Image" and select "Buffer A"
2. In Buffer A, click `iChannel0` at the bottom and select "Buffer A" from the Misc tab
3. In Image, click `iChannel0` and select "Buffer A"

Now Buffer A can see its own previous output, and Image can display whatever Buffer A computed.

### Reading from a Buffer

To sample from a buffer, we use `texelFetch`:

```glsl
vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
```

This reads the pixel at exactly the integer coordinates we specify. The third argument (0) is the mipmap level — always use 0 for buffers.

Why `texelFetch` instead of the `texture` function you might have seen elsewhere? The `texture` function uses normalized coordinates (0 to 1) and can interpolate between pixels. For simulations, we want exact pixel values at exact integer locations. `texelFetch` gives us that precision.

### A Painting Program

Let's build the simplest possible buffer shader: a program that remembers where you've drawn.

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read what was here last frame
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    
    // Keep it
    fragColor = prev;
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Just display whatever Buffer A computed
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

Run this and... nothing happens. The screen is black and stays black. But something important *is* happening: Buffer A is reading its previous output and writing it back. It's maintaining state — there's just nothing interesting in that state yet.

Let's add a brush. When the mouse is pressed, we'll draw a white dot:

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read what was here last frame
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    
    // Check distance to mouse
    float d = length(fragCoord - iMouse.xy);
    
    // If mouse is pressed (z > 0) and we're close, paint white
    if (iMouse.z > 0.0 && d < 10.0) {
        fragColor = vec4(1.0);
    } else {
        fragColor = prev;
    }
}
```

Now click and drag. White dots appear — and they *stay*. Release the mouse, click somewhere else, and the old marks are still there. We have persistence.

{{< shader-demo day4/paint-basic >}}

### Frame by Frame

Let's trace through exactly what happens:

**Frame 0:** Buffer A reads from itself, but there's nothing there yet — we get black (zeros). The mouse isn't pressed, so every pixel writes back black.

**Frame 1:** Same thing. Black in, black out.

**Frame 47:** You click at position (200, 150). Pixels within distance 10 of that point write white. Everything else reads black and writes black.

**Frame 48:** Mouse still pressed at (205, 150) — you're dragging. Buffer A reads from last frame: most pixels see black, but pixels near (200, 150) see white. Pixels near the new mouse position write white. Pixels near the old position read white *and write it back*. The stroke accumulates.

**Frame 200:** You've released the mouse. Every pixel reads its previous value and writes it back unchanged. The drawing persists.

This is the core loop: read previous state, decide what the new state should be, write it out.

### Adding Fade

Permanent marks are nice, but let's add some dynamics. What if the paint slowly fades?

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read and fade
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    prev *= 0.99;
    
    // Paint at mouse
    float d = length(fragCoord - iMouse.xy);
    if (iMouse.z > 0.0 && d < 10.0) {
        fragColor = vec4(1.0);
    } else {
        fragColor = prev;
    }
}
```

Now each frame, every pixel's brightness drops to 99% of what it was. Draw something and watch it slowly disappear. Keep drawing and you get glowing trails — new paint is bright, old paint fades into darkness.

{{< shader-demo day4/paint-fade >}}

That single line — `prev *= 0.99` — transforms our painting program into something dynamic. The state isn't just persisting; it's *evolving*. Each frame's output depends on the previous frame's output.

This is the essence of simulation.

### What We've Learned

- **Buffers** are shaders that write to stored images instead of the screen
- Buffer output **persists** between frames
- A buffer can **read from itself** to see its previous output
- Use `texelFetch(iChannel, ivec2(fragCoord), 0)` to read exact pixel values
- The **Image shader** displays the final result by reading from a buffer

With these tools, we can build systems where state evolves over time. But so far, each pixel only looks at itself — its own previous value. In the next section, we'll read from *neighboring* pixels, and that opens up a whole new world: cellular automata, diffusion, waves. Let's start with the most famous cellular automaton of all.


## Game of Life

Conway's Game of Life is the most famous cellular automaton — a grid of cells that evolve according to simple rules, yet produce astonishingly complex behavior. Gliders, oscillators, and self-replicating patterns emerge from just four rules.

It's also the perfect first simulation: the rules are easy to state, the implementation teaches us how to read neighboring pixels, and the results are immediately satisfying.

### The Rules

The Game of Life plays out on a grid where each cell is either **alive** (1) or **dead** (0). Every step, each cell looks at its eight neighbors and decides its next state:

1. **Underpopulation:** A live cell with fewer than 2 live neighbors dies
2. **Survival:** A live cell with 2 or 3 live neighbors survives
3. **Overpopulation:** A live cell with more than 3 live neighbors dies
4. **Reproduction:** A dead cell with exactly 3 live neighbors becomes alive

That's it. These four rules, applied simultaneously to every cell, generate everything from static "still lifes" to traveling "gliders" to chaotic, unpredictable evolution.

### Reading Neighbors

Until now, each pixel only looked at itself — `texelFetch(iChannel0, ivec2(fragCoord), 0)`. To implement Game of Life, we need to read the eight surrounding pixels.

The key insight: `texelFetch` takes integer coordinates, and we can add offsets:

```glsl
ivec2 p = ivec2(fragCoord);

float self  = texelFetch(iChannel0, p, 0).r;
float north = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
float south = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
float east  = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
float west  = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
float ne    = texelFetch(iChannel0, p + ivec2( 1,  1), 0).r;
float nw    = texelFetch(iChannel0, p + ivec2(-1,  1), 0).r;
float se    = texelFetch(iChannel0, p + ivec2( 1, -1), 0).r;
float sw    = texelFetch(iChannel0, p + ivec2(-1, -1), 0).r;
```

::: {.callout-note}
## GLSL: Integer Vectors

We've been using `vec2` for 2D coordinates — these hold floating-point numbers. GLSL also provides **integer vectors**: `ivec2`, `ivec3`, `ivec4`.

The `texelFetch` function requires integer coordinates (it reads exact pixels, not interpolated positions), so we convert with `ivec2(fragCoord)`. This truncates the fractional part, giving us the pixel's integer position.

Integer vectors support the same operations as float vectors — addition, subtraction, component access with `.x` and `.y` — but with integer arithmetic.
:::

We read from the red channel (`.r`) since we only need one value per cell — alive or dead. Now we can count live neighbors:

```glsl
float neighbors = north + south + east + west + ne + nw + se + sw;
```

### The Update Rule

With the neighbor count in hand, we apply Conway's rules:

```glsl
float alive = 0.0;

if (self == 1.0) {
    // Live cell survives with 2 or 3 neighbors
    if (neighbors == 2.0 || neighbors == 3.0) {
        alive = 1.0;
    }
} else {
    // Dead cell becomes alive with exactly 3 neighbors
    if (neighbors == 3.0) {
        alive = 1.0;
    }
}
```

Since each cell stores exactly `0.0` or `1.0`, the neighbor sum is always exactly `0.0`, `1.0`, `2.0`, etc. Small integers are represented exactly in floating point, so direct comparison works perfectly here.

::: {.callout-note}
## When Can You Compare Floats for Equality?

You may have heard "never compare floats for equality." That's good advice when dealing with *computed* values that might accumulate rounding errors. But here we control the data — cells are always set to exactly `1.0` or `0.0`, never something like `0.9999`. When you're comparing values you explicitly stored, equality is safe.
:::

### Initialization

We need to seed the grid with an initial pattern. If we don't, every cell starts dead and stays dead forever — not very interesting.

This is where `iFrame` comes in. On the first frame, we ignore the buffer (it's empty anyway) and write random initial values:

```glsl
if (iFrame == 0) {
    // Initialize with random cells
    float random = hash(fragCoord);
    fragColor = vec4(step(0.5, random));  // 50% chance alive
    return;
}
```

The `hash` function turns coordinates into pseudorandom numbers. Here's a simple one that works well:

```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}
```

This is a common trick in shader programming: use arithmetic operations that scramble the bits of the input coordinates to produce apparently random output. It's deterministic (same input gives same output) but chaotic enough to look random.

Let's see what it looks like:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float random = hash(fragCoord);
    fragColor = vec4(vec3(random), 1.0);
}
```

{{< shader-demo day4/random-noise >}}

Static noise — every pixel gets a different value, but the pattern is fixed (no animation, since the hash only depends on position). When we threshold this at 0.5, roughly half the pixels will be white and half black — our random initial state for Game of Life.

::: {.callout-note}
## The Initialization Pattern

You'll use this pattern in almost every buffer shader:

```glsl
if (iFrame == 0) {
    // Set up initial conditions
    fragColor = ...;
    return;
}

// Normal simulation
```

On frame 0, we write initial state and skip the simulation logic. Every subsequent frame reads the previous state and evolves it.

If you ever notice your simulation not initializing properly — perhaps after resizing the window or switching tabs — you can broaden the check to `if (iFrame < 5)` to catch edge cases.
:::

::: {.callout-tip}
## The Rewind Button

When working with buffer shaders, the **rewind button** (⏮) is your friend. It resets `iFrame` to 0, which re-runs your initialization code.

If you modify your shader and don't see any change, or if things look wrong, hit rewind. The buffer remembers its previous contents — without rewinding, your `iFrame == 0` initialization won't run again.
:::

### The Complete Shader

Putting it all together:

**Buffer A:**
```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize on first frame
    if (iFrame == 0) {
        float random = hash(fragCoord);
        fragColor = vec4(step(0.5, random));
        return;
    }
    
    // Read self and neighbors
    ivec2 p = ivec2(fragCoord);
    
    float self = texelFetch(iChannel0, p, 0).r;
    float neighbors = 
        texelFetch(iChannel0, p + ivec2(-1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  1), 0).r;
    
    // Apply Conway's rules
    float alive = 0.0;
    
    if (self == 1.0) {
        // Live cell survives with 2 or 3 neighbors
        if (neighbors == 2.0 || neighbors == 3.0) {
            alive = 1.0;
        }
    } else {
        // Dead cell becomes alive with exactly 3 neighbors
        if (neighbors == 3.0) {
            alive = 1.0;
        }
    }
    
    fragColor = vec4(alive, alive, alive, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

{{< shader-demo day4/game-of-life >}}

Watch it run! You'll see:

- **Still lifes:** Stable patterns like blocks and beehives that don't change
- **Oscillators:** Patterns that cycle through a sequence of states (blinkers, toads)
- **Gliders:** Patterns that move across the screen
- **Chaos:** Regions of unpredictable activity that eventually settle down

### The Simulation Loop Pattern

Look at the structure of our Game of Life shader:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // 1. Initialize (first frame only)
    if (iFrame == 0) {
        fragColor = initialState(fragCoord);
        return;
    }
    
    // 2. Read current state and neighbors
    float self = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    float neighbors = /* sum of 8 neighbors */;
    
    // 3. Compute new state
    float newState = updateRule(self, neighbors);
    
    // 4. Write new state
    fragColor = vec4(newState);
}
```

This is the **simulation loop pattern**, and we'll use it for every simulation in this chapter:

1. **Initialize** on the first frame
2. **Read** the current state (self and neighbors)
3. **Compute** the new state based on some rule
4. **Write** the new state

The heat equation and wave equation will follow exactly this structure. Only the update rule changes — everything else stays the same.




## The Heat Equation

The heat equation is one of the fundamental PDEs:

$$\frac{\partial u}{\partial t} = \alpha \Delta u$$

Temperature $u$ evolves over time, driven by the Laplacian $\Delta u$. The constant $\alpha$ controls diffusion speed.

To simulate this, we discretize space (pixel grid), time (frames), and the Laplacian (finite differences). The result has the same structure as Game of Life: an initial state and an update rule applied each frame.

### The Discrete Laplacian

The Laplacian is the sum of second partial derivatives:

$$\Delta u = \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}$$

We discretize each term using finite differences:

$$\frac{\partial^2 u}{\partial x^2} \approx u_{i+1,j} - 2u_{i,j} + u_{i-1,j}$$

$$\frac{\partial^2 u}{\partial y^2} \approx u_{i,j+1} - 2u_{i,j} + u_{i,j-1}$$

(taking grid spacing $h = 1$). Adding these:

$$\Delta u \approx u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}$$

The corresponding stencil:

$$\begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \end{bmatrix}$$

In code, this is the same neighbor-sampling pattern as Game of Life:

```glsl
ivec2 p = ivec2(fragCoord);
float center = texelFetch(iChannel0, p, 0).r;
float north  = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
float south  = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
float east   = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
float west   = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;

float laplacian = north + south + east + west - 4.0 * center;
```

### Time Stepping

The heat equation tells us the rate of change: $\partial u / \partial t = \alpha \Delta u$. We step forward in time using explicit Euler:

$$u^{n+1} = u^n + dt \cdot \alpha \cdot \Delta u^n$$

where the superscript denotes the time step. This is the simplest scheme. More sophisticated methods (implicit Euler, Crank-Nicolson, etc.) have better stability properties, but explicit Euler is easiest to implement and illustrates the core idea.

```glsl
float alpha = 0.5;
float dt = 0.4;
float newTemp = center + dt * alpha * laplacian;
```

### Boundary Conditions

What happens at the edges? When we sample neighbors at the boundary, some fall outside the domain. We need to specify boundary conditions.

The simplest choice is **Dirichlet conditions**: fix the boundary values. We'll hold the edges at zero temperature, as if the boundary is in contact with a cold reservoir.

```glsl
// Dirichlet boundary: edges fixed at zero
if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
    fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
    fragColor = vec4(0.0, 0.0, 0.0, 1.0);
    return;
}
```

Other choices include Neumann conditions (zero flux at boundary) or periodic conditions (wrap around). We'll explore these in the exercises.

### Initial Conditions

Let's start with a hot disk in the center — temperature 1 inside, 0 outside:

```glsl
if (iFrame == 0) {
    vec2 center = iResolution.xy * 0.5;
    float d = length(fragCoord - center);
    float temp = d < 80.0 ? 1.0 : 0.0;
    fragColor = vec4(temp, 0.0, 0.0, 1.0);
    return;
}
```

The sharp edge is deliberate — watch the heat equation smooth it out.

::: {.callout-note}
## A Note on Coordinates

We're working directly in pixel coordinates — the grid spacing is $h = 1$ pixel, and distances like `80.0` are measured in pixels. This keeps the code simple, but it means the simulation's appearance depends on your screen resolution. A proper physical simulation would define a domain (say, $[-1, 1]^2$), map pixels to that domain, and account for the actual grid spacing $h$ in the Laplacian. We'll explore this in the exercises.
:::

### The Complete Shader

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: hot disk in center
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float temp = d < 80.0 ? 1.0 : 0.0;
        fragColor = vec4(temp, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary: edges fixed at zero
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Read neighbors
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    // Laplacian
    float laplacian = n + s + e + w - 4.0 * c;
    
    // Explicit Euler step
    float alpha = 0.5;
    float dt = 0.4;
    float newTemp = c + dt * alpha * laplacian;
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
vec3 heatColor(float t) {
    return mix(vec3(0.0, 0.0, 0.3), vec3(1.0, 0.3, 0.0), t);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float temp = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    fragColor = vec4(heatColor(temp), 1.0);
}
```

{{< shader-demo day4/heat-equation >}}

The sharp boundary of the disk immediately begins to blur. Heat diffuses outward while also draining through the cold boundaries. Eventually everything decays to zero.

::: {.callout-warning}
## Stability

Try changing `dt` to `1.0` and hitting rewind.

The simulation explodes. Instead of smooth diffusion, you get oscillations that grow exponentially.

This is a fundamental limitation of explicit methods. The scheme computes the new value from old values alone, without any implicit coupling to the future state. When $dt$ is too large, errors from one step get amplified in the next.

The problem is most severe for high-frequency components — the checkerboard pattern (alternating hot and cold pixels) is the worst case. The Laplacian of a checkerboard is large, so the update overshoots, creating an inverted checkerboard, which overshoots again, and so on.

The stability condition for explicit Euler on the 2D heat equation is:

$$dt < \frac{h^2}{4\alpha}$$

With grid spacing $h = 1$ and $\alpha = 0.5$, this gives $dt < 0.5$. Our choice `dt = 0.4` is safe; `dt = 1.0` violates the condition and blows up.
:::

### Adding Heat Interactively

We can inject heat with the mouse. After computing `newTemp`, add:

```glsl
if (iMouse.z > 0.0) {
    float d = length(fragCoord - iMouse.xy);
    if (d < 20.0) {
        newTemp = 1.0;
    }
}
```

{{< shader-demo day4/heat-interactive >}}

Click and drag to paint heat; watch it diffuse away. We'll use the same technique for the wave equation, where clicks create ripples instead.


## The Wave Equation

The wave equation describes propagating disturbances:

$$\frac{\partial^2 u}{\partial t^2} = c^2 \Delta u$$

Unlike the heat equation, this is **second-order in time**. Heat diffuses and dissipates; waves propagate and reflect.

### Two Quantities

A second-order equation in time requires two pieces of initial data: the initial displacement *and* the initial velocity. We introduce velocity as a separate variable:

$$v = \frac{\partial u}{\partial t}$$

This converts our second-order equation into two coupled first-order equations:

$$\frac{\partial u}{\partial t} = v$$

$$\frac{\partial v}{\partial t} = c^2 \Delta u$$

The first says displacement changes according to velocity. The second says velocity changes according to the Laplacian of displacement — where the surface is curved, it accelerates.

### Two Buffers

We need to store both $u$ and $v$ at each pixel. The cleanest approach: use two buffers.

- **Buffer A** stores displacement $u$
- **Buffer B** stores velocity $v$

Each buffer needs to read from *both* buffers to compute its update. This is our first multi-buffer shader.

In Shadertoy, set up:
- Buffer A: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Buffer B: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Image: `iChannel0` = Buffer A (we display displacement)

Both buffers read from the previous frame's state of A and B, then write their new values simultaneously.

### The Update Rules

Discretizing with explicit Euler:

$$u^{n+1} = u^n + dt \cdot v^n$$

$$v^{n+1} = v^n + dt \cdot c^2 \cdot \Delta u^n$$

Buffer A computes the new displacement:

```glsl
// Buffer A: update displacement
float u = texelFetch(iChannel0, p, 0).r;  // current displacement
float v = texelFetch(iChannel1, p, 0).r;  // current velocity

float newU = u + dt * v;
```

Buffer B computes the new velocity, which requires the Laplacian of $u$:

```glsl
// Buffer B: update velocity
float u_c = texelFetch(iChannel0, p, 0).r;
float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;

float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;

float v = texelFetch(iChannel1, p, 0).r;
float newV = v + dt * c * c * laplacian;
```

### Initial Conditions

We start with a Gaussian "pluck" — a bump in displacement with zero initial velocity:

```glsl
// In Buffer A (displacement)
if (iFrame == 0) {
    vec2 center = iResolution.xy * 0.5;
    float d = length(fragCoord - center);
    float sigma = 30.0;
    float u = exp(-d * d / (2.0 * sigma * sigma));
    fragColor = vec4(u, 0.0, 0.0, 1.0);
    return;
}

// In Buffer B (velocity)
if (iFrame == 0) {
    fragColor = vec4(0.0);  // zero initial velocity
    return;
}
```

### Boundary Conditions

We use Dirichlet conditions: displacement fixed at zero on the boundary. Waves reflect off the fixed edges.

```glsl
if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
    fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
    fragColor = vec4(0.0);
    return;
}
```

### The Complete Shader

Buffer A updates displacement. It reads the current displacement from Buffer A and current velocity from Buffer B, then steps forward: $u^{n+1} = u^n + dt \cdot v^n$.

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: Gaussian pluck
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float sigma = 30.0;
        float u = exp(-d * d / (2.0 * sigma * sigma));
        fragColor = vec4(u, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

Buffer B updates velocity. It reads displacement from Buffer A (including neighbors, to compute the Laplacian) and current velocity from Buffer B, then steps forward: $v^{n+1} = v^n + dt \cdot c^2 \cdot \Delta u^n$.

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: zero velocity
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    // Laplacian of displacement
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

The Image shader reads displacement from Buffer A and maps it to color. Positive displacement is orange, negative is blue.

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    
    // Amplify for visibility
    u *= 5.0;
    
    // Map displacement to color: negative = blue, zero = black, positive = orange
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

{{< shader-demo day4/wave-equation >}}

Watch the circular wave expand from the initial pluck, hit the boundaries, and reflect back. The reflections interfere with each other, creating complex patterns.

### Stability

As with the heat equation, explicit Euler has a stability condition. For the wave equation it's the CFL condition:

$$dt < \frac{h}{c}$$

With $h = 1$ and $c = 0.5$, we need $dt < 2$. Our choice `dt = 0.5` is safe.

### Interactive Waves

To create ripples with the mouse, we add a velocity kick in Buffer B — a small Gaussian impulse:

```glsl
// In Buffer B, after computing newV:
if (iMouse.z > 0.0) {
    float d = length(fragCoord - iMouse.xy);
    float sigma = 15.0;
    newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
}
```

{{< shader-demo day4/wave-interactive >}}

Click to create ripples. Watch them spread, reflect, and interfere.


## Boundary Geometry

So far our waves have bounced off the edges of a rectangle — the screen boundary. But we can trap waves in any shape. The technique: use a signed distance function to define the domain, and force displacement to zero outside it.

This connects back to Day 1. Any SDF works: circles, polygons, even fractals.

### Circular Boundary

Let's trap waves in a circular domain. We need a function that checks whether a pixel is inside. Since both buffers and the Image shader need this function, we'll use Shadertoy's **Common** tab — code placed there gets prepended to every shader in your project.

**Common:**
```glsl
float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = fragCoord - center;
    return sdCircle(p, scale) < 0.0;
}
```

Now in Buffer A, Buffer B, and Image, we just call `inDomain(fragCoord, iResolution.xy)`. The boundary check forces displacement and velocity to zero outside the circle — a Dirichlet condition on the circular boundary.

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.15, 0.15, 0.15, 1.0);
        return;
    }
    
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

{{< shader-demo day4/wave-circle >}}

Click to create ripples. The circular boundary creates beautiful radial reflections.

### Triangular Boundary

To change the domain, we only modify Common — the buffers and Image shader stay exactly the same:

**Common:**
```glsl
float sdEquilateralTriangle(vec2 p) {
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    if (p.x + k * p.y > 0.0) {
        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;
    }
    p.x -= clamp(p.x, -2.0, 0.0);
    return -length(p) * sign(p.y);
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = (fragCoord - center) / scale;
    p.y += 0.25;  // shift down to center the triangle
    return sdEquilateralTriangle(p) < 0.0;
}
```

{{< shader-demo day4/wave-triangle >}}

The corners create focusing effects — waves reflecting off two edges concentrate toward the opposite vertex.


## Exercises

Homework is organized into four types:

**Checkpoints** — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.

**Explorations** — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you're right on track with the course.

**Challenges** — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.

**Project** — An extended project for someone familiar with shader basics, to make an artwork.

---

### Checkpoints

**C1. HighLife.** Modify the Game of Life rules to implement HighLife (B36/S23): cells are born with 3 or 6 neighbors, and survive with 2 or 3 neighbors. The only change is in the birth condition — add a check for exactly 6 neighbors:

```glsl
// Currently dead: birth with 3 OR 6 neighbors
alive = (neighbors > 2.5 && neighbors < 3.5) || 
        (neighbors > 5.5 && neighbors < 6.5) ? 1.0 : 0.0;
```

The "6" in the birth rule creates a pattern called a "replicator" that copies itself. Start with random initial conditions and watch for small patterns that duplicate.

**C2. Two Hot Spots.** Modify the heat equation's initial condition to have two hot disks instead of one:

```glsl
if (iFrame == 0) {
    vec2 center1 = iResolution.xy * 0.5 + vec2(-100.0, 0.0);
    vec2 center2 = iResolution.xy * 0.5 + vec2(100.0, 0.0);
    float d1 = length(fragCoord - center1);
    float d2 = length(fragCoord - center2);
    float temp = (d1 < 60.0 || d2 < 60.0) ? 1.0 : 0.0;
    fragColor = vec4(temp, 0.0, 0.0, 1.0);
    return;
}
```

Watch the two hot regions diffuse and eventually merge into one blob.

**C3. Off-Center Pluck.** Modify the wave equation's initial condition to place the Gaussian pluck away from the center:

```glsl
vec2 pluck = iResolution.xy * 0.5 + vec2(150.0, 100.0);  // off-center
float d = length(fragCoord - pluck);
```

Observe how the asymmetric position creates more complex interference patterns as waves reflect off different edges at different times.

**C4. Damped Waves.** Add friction to the wave equation. In Buffer B, after computing `newV`, multiply by a decay factor:

```glsl
newV *= 0.998;
```

This causes waves to gradually lose energy — they still propagate and reflect, but their amplitude decreases over time. Experiment with different decay values: 0.999 for slow decay, 0.99 for fast decay. With mouse interaction, you can keep adding energy to fight the damping.

---

### Explorations

**E1. Brian's Brain.** Brian's Brain is a cellular automaton with three states instead of two:

- **Off** (0): Becomes **On** if exactly 2 neighbors are **On**
- **On** (1): Always becomes **Dying** next step
- **Dying** (2): Always becomes **Off** next step

The key insight: **On** cells are like firing neurons — they fire once, go through a refractory period (Dying), then reset. This creates self-sustaining waves of activity.

**Implementation:** Store the state as a float: 0.0 for Off, 1.0 for On, 2.0 for Dying. When counting neighbors, only count **On** cells (value 1.0):

```glsl
// Count only "On" neighbors (value == 1.0)
float countOn(float val) {
    return (val > 0.5 && val < 1.5) ? 1.0 : 0.0;
}

// In main:
float neighbors = countOn(n) + countOn(s) + countOn(e) + countOn(w) 
                + countOn(ne) + countOn(nw) + countOn(se) + countOn(sw);

float self = texelFetch(iChannel0, p, 0).r;
float newState;

if (self < 0.5) {
    // Off -> On if exactly 2 neighbors are On
    newState = (neighbors > 1.5 && neighbors < 2.5) ? 1.0 : 0.0;
} else if (self < 1.5) {
    // On -> Dying
    newState = 2.0;
} else {
    // Dying -> Off
    newState = 0.0;
}
```

**Initialization:** Start with random values 0.0, 1.0, or 2.0:
```glsl
float r = hash(fragCoord);
float state = r < 0.33 ? 0.0 : (r < 0.66 ? 1.0 : 2.0);
```

**Visualization:** In the Image shader, map states to colors:
```glsl
float state = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
vec3 color;
if (state < 0.5) color = vec3(0.0);           // Off: black
else if (state < 1.5) color = vec3(1.0);      // On: white
else color = vec3(0.0, 0.5, 1.0);             // Dying: blue
```

The result looks like constantly firing neurons — waves of activity that never die out.

**E2. Ring of Fire.** Create a heat equation with an initial condition that's a ring — hot between two radii, cold elsewhere:

```glsl
if (iFrame == 0) {
    vec2 center = iResolution.xy * 0.5;
    float d = length(fragCoord - center);
    float temp = (d > 60.0 && d < 100.0) ? 1.0 : 0.0;
    fragColor = vec4(temp, 0.0, 0.0, 1.0);
    return;
}
```

Watch the ring diffuse both inward (filling the hole) and outward. The inner and outer edges blur at the same rate. How long until the center reaches maximum temperature?

**E3. Spatially Varying Diffusion.** Make the diffusion coefficient α depend on position. Instead of a constant:

```glsl
float alpha = 0.5;
```

Try a pattern:
```glsl
float alpha = 0.2 + 0.6 * step(iResolution.x * 0.5, fragCoord.x);
```

This makes the right half diffuse three times faster than the left. Watch heat spread quickly on one side and slowly on the other.

For more interesting effects, try a smooth gradient or a sinusoidal pattern:
```glsl
float alpha = 0.2 + 0.4 * (0.5 + 0.5 * sin(fragCoord.x * 0.02));
```

Can you create a pattern where heat "flows around" a low-diffusion barrier?

**E4. Wave Interference.** Start the wave equation with two Gaussian plucks at different positions:

```glsl
if (iFrame == 0) {
    vec2 center = iResolution.xy * 0.5;
    vec2 pluck1 = center + vec2(-100.0, 0.0);
    vec2 pluck2 = center + vec2(100.0, 0.0);
    float sigma = 30.0;
    float d1 = length(fragCoord - pluck1);
    float d2 = length(fragCoord - pluck2);
    float u = exp(-d1*d1 / (2.0*sigma*sigma)) + exp(-d2*d2 / (2.0*sigma*sigma));
    fragColor = vec4(u, 0.0, 0.0, 1.0);
    return;
}
```

Watch the circular waves expand and interfere. Where they meet, you'll see constructive interference (bright) and destructive interference (dark).

**Variations to try:**
- Opposite signs: subtract the second Gaussian instead of adding
- Different sizes: use different sigma values
- Different positions: try diagonal placement
- Three or more plucks: create complex interference patterns

**E5. Stadium Boundary.** A stadium (or "discorectangle") is two semicircles connected by straight edges. It's famous in dynamical systems because billiards in a stadium are chaotic — balls bounce unpredictably and eventually visit every part of the domain.

Build the stadium SDF by combining shapes from Day 1. You need:
- A box (rectangle) for the middle part
- Two circles at each end

Use `min()` to take the union:
```glsl
float sdStadium(vec2 p, float halfLength, float radius) {
    // Your code here: combine sdBox and sdCircle
    // The box has half-width halfLength and half-height radius
    // The circles are centered at (±halfLength, 0) with the given radius
}
```

Hint: Think about it geometrically — a point is inside the stadium if it's inside the rectangle OR inside either semicircle.

Once you have the SDF working, use it as a boundary for the wave equation. Click to create ripples and watch them bounce chaotically, eventually filling the entire stadium.

---

### Challenges

**H1. Julia Set Boundary.** Use a Julia set as the boundary for the wave equation. Instead of an SDF, use the escape-time algorithm from Day 2: a point is inside the filled Julia set if it doesn't escape after many iterations.

Replace the `inDomain` function in Common:

```glsl
bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.25;
    vec2 z = (fragCoord - center) / scale;
    vec2 c = vec2(-0.4, 0.6);  // Julia parameter — try different values!
    
    for (int i = 0; i < 100; i++) {
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if (dot(z, z) > 4.0) return false;
    }
    return true;
}
```

The rest of the wave equation code stays exactly the same — that's the beauty of factoring out `inDomain`.

Waves bouncing inside a Julia set create organic, almost biological patterns. Try different Julia parameters:
- `c = vec2(-0.4, 0.6)` — a connected "rabbit" shape
- `c = vec2(0.285, 0.01)` — delicate spirals
- `c = vec2(-0.8, 0.156)` — dendrite-like branches

**H2. Gray-Scott Reaction-Diffusion.** The Gray-Scott model simulates two chemicals that react and diffuse, producing spots, stripes, and labyrinthine patterns. This is substantially more complex than the heat equation — you're simulating a real chemical system.

**The setup:** Two chemicals, $u$ and $v$, with concentrations at each pixel. Think of $u$ as "food" and $v$ as "catalyst." The catalyst consumes food to replicate, but also dies over time.

**The equations:**
$$\frac{\partial u}{\partial t} = D_u \Delta u - uv^2 + f(1-u)$$
$$\frac{\partial v}{\partial t} = D_v \Delta v + uv^2 - (f+k)v$$

Let's understand each term:
- $D_u \Delta u$ and $D_v \Delta v$: Diffusion, just like the heat equation. The chemicals spread out.
- $-uv^2$ and $+uv^2$: The reaction. When $u$ and $v$ meet, $u$ is consumed (negative) and $v$ is produced (positive). The $v^2$ makes it autocatalytic — more $v$ means faster reaction.
- $f(1-u)$: Feed. Fresh $u$ is added at rate $f$, up to a maximum of 1.
- $-(f+k)v$: Kill. The catalyst $v$ dies at rate $f+k$.

**Implementation:** Use a single buffer with two channels — red for $u$, green for $v$.

```glsl
// Parameters — try these first, then experiment
float Du = 0.2;   // u diffuses faster
float Dv = 0.1;   // v diffuses slower
float f = 0.04;   // feed rate
float k = 0.06;   // kill rate
float dt = 1.0;   // timestep

// Read current state
vec2 uv = texelFetch(iChannel0, p, 0).rg;
float u = uv.x;
float v = uv.y;

// Compute Laplacians for both chemicals
float u_n = texelFetch(iChannel0, p + ivec2(0,1), 0).r;
float u_s = texelFetch(iChannel0, p + ivec2(0,-1), 0).r;
float u_e = texelFetch(iChannel0, p + ivec2(1,0), 0).r;
float u_w = texelFetch(iChannel0, p + ivec2(-1,0), 0).r;
float lap_u = u_n + u_s + u_e + u_w - 4.0 * u;

float v_n = texelFetch(iChannel0, p + ivec2(0,1), 0).g;
float v_s = texelFetch(iChannel0, p + ivec2(0,-1), 0).g;
float v_e = texelFetch(iChannel0, p + ivec2(1,0), 0).g;
float v_w = texelFetch(iChannel0, p + ivec2(-1,0), 0).g;
float lap_v = v_n + v_s + v_e + v_w - 4.0 * v;

// Reaction term
float uvv = u * v * v;

// Update
float newU = u + dt * (Du * lap_u - uvv + f * (1.0 - u));
float newV = v + dt * (Dv * lap_v + uvv - (f + k) * v);

fragColor = vec4(newU, newV, 0.0, 1.0);
```

**Initialization:** Start with $u = 1$ everywhere (full of food) and a small patch of $v$ in the center:

```glsl
if (iFrame == 0) {
    float u = 1.0;
    float v = 0.0;
    
    vec2 center = iResolution.xy * 0.5;
    if (length(fragCoord - center) < 20.0) {
        v = 1.0;
    }
    
    fragColor = vec4(u, v, 0.0, 1.0);
    return;
}
```

**Visualization:** In the Image shader, display $v$ (the interesting chemical):
```glsl
float v = texelFetch(iChannel0, ivec2(fragCoord), 0).g;
fragColor = vec4(vec3(v), 1.0);
```

**Different patterns:** The behavior depends sensitively on $f$ and $k$:
- $f = 0.04$, $k = 0.06$: Mitosis (dividing spots)
- $f = 0.035$, $k = 0.065$: Coral-like growth
- $f = 0.025$, $k = 0.05$: Stripes and labyrinths
- $f = 0.04$, $k = 0.065$: Solitons (stable spots)

This simulation is slow to develop — you might need to wait hundreds of frames to see patterns emerge. Be patient!

**Extension:** Once you have Gray-Scott working, try confining it to a fractal domain — use the Mandelbrot set as your boundary (same technique as challenge H1). The organic reaction-diffusion patterns inside the organic fractal boundary create something magical.

**H3. Physical Coordinates.** Our simulations use pixel coordinates with grid spacing $h = 1$. This means the simulation looks different at different window sizes. Implement proper physical coordinates so the physics is resolution-independent.

**Step 1:** Define a physical domain. Say we want to simulate a $4 \times 4$ square centered at the origin:

```glsl
float L = 2.0;  // half-width of domain
```

**Step 2:** Map pixel coordinates to physical coordinates:

```glsl
float scale = min(iResolution.x, iResolution.y) / (2.0 * L);
vec2 physCoord = (fragCoord - iResolution.xy * 0.5) / scale;
```

**Step 3:** Compute the actual grid spacing. If the smaller screen dimension has $N$ pixels spanning a distance of $2L$:

```glsl
float h = 2.0 * L / min(iResolution.x, iResolution.y);
```

**Step 4:** The Laplacian formula assumed $h = 1$. With actual grid spacing, divide by $h^2$:

```glsl
float laplacian = (u_n + u_s + u_e + u_w - 4.0 * u) / (h * h);
```

**Step 5:** Adjust the timestep for stability. The condition is now:

$$dt < \frac{h^2}{4\alpha}$$

With smaller $h$ (higher resolution), you need smaller $dt$.

**Test:** Run your simulation at different window sizes. The physics should look the same — just more or less detailed.

**H4. Single-Buffer Wave Equation.** Our wave equation uses two buffers: Buffer A for displacement $u$, Buffer B for velocity $v$. But we can do it with one buffer by storing both quantities in different color channels.

Use red for $u$ (displacement) and green for $v$ (velocity). Both update in the same shader:

```glsl
vec2 state = texelFetch(iChannel0, p, 0).rg;
float u = state.r;
float v = state.g;

// Laplacian of u (read from red channel of neighbors)
float u_n = texelFetch(iChannel0, p + ivec2(0,1), 0).r;
// ... etc

float laplacian = u_n + u_s + u_e + u_w - 4.0 * u;

float newU = u + dt * v;
float newV = v + dt * c * c * laplacian;

fragColor = vec4(newU, newV, 0.0, 1.0);
```

This is more efficient (one buffer instead of two) but slightly harder to reason about. The Image shader reads from the red channel to display displacement.

---

### Project: Waves on Orbifolds

The triangle boundary creates a fundamental domain — waves reflect off the edges. But what if instead of reflecting, we could *see through* to the adjacent copy? This project combines the wave simulation with the folding technique from Day 3.

**The idea:** The simulation runs in one triangle, but the Image shader tiles it across the plane using folding. Waves appear to pass through triangle edges into adjacent copies.

**Step 1:** Start with the wave-triangle shader from the lecture. The simulation runs normally in a single triangle.

**Step 2:** Modify the Image shader to fold coordinates before reading displacement. Use the triangle folding code from Day 3:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 center = iResolution.xy * 0.5;
    float scale = min(iResolution.x, iResolution.y) * 0.4;
    vec2 p = (fragCoord - center) / scale;
    
    // Fold into fundamental domain
    // (Insert your triangle folding code from Day 3 here)
    // This should repeatedly reflect p until it's inside the triangle
    
    // Convert back to pixel coordinates
    vec2 foldedCoord = p * scale + center;
    
    // Read displacement from the folded position
    float u = texelFetch(iChannel0, ivec2(foldedCoord), 0).r;
    
    // Color as usual
    u *= 5.0;
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Step 3:** The buffers don't change at all — the simulation still runs in one triangle with reflecting boundaries. Only the visualization is tiled.

**What you should see:** A tiled plane of triangles, with waves that appear to propagate continuously across the entire pattern. When a wave hits an edge in the simulation, its reflection shows up in all the adjacent copies, creating the illusion of waves passing through.

**Extensions:**

- **Color-code copies:** Track how many folds were applied and tint each copy differently. This reveals the structure of the tiling.

- **Different symmetries:** The equilateral triangle with edge reflections gives a $(3,3,3)$ tiling. Try:
  - A right triangle with angles $(\pi/2, \pi/3, \pi/6)$ for the $(2,3,6)$ tiling
  - A right triangle with angles $(\pi/2, \pi/4, \pi/4)$ for the $(2,4,4)$ tiling
  - A square with edge reflections for a checkerboard pattern

- **Rotational orbifolds:** Instead of reflecting across edges, rotate around vertices. An equilateral triangle with 3-fold rotation at each vertex gives a different orbifold structure.

This reveals the wave equation on the orbifold's universal cover — what the wave "really" looks like on an infinite tiled plane, with all copies evolving coherently.