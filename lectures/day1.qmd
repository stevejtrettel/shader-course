# Day 1: Introduction

## Overview

By the end of today, you'll be able to create things like this:

{{< shader-demo day1/elliptic-family >}}

A family of elliptic curves $y^2 = x^3 + ax + b$, drawn for several values of $a$ simultaneously, with $b$ varying across the screen. The curves shift in brightness to show the family structure, and you can watch singularities appear and disappear along the discriminant locus.

This image is computed in real time, every pixel evaluated independently on the GPU. To get here, we'll learn:

- What a shader is: a function from coordinates to colors, evaluated in parallel
- How to set up a coordinate system for mathematical visualization
- How to draw shapes using distance functions
- How to render implicit curves $F(x,y) = 0$ with uniform thickness
- How to add interactivity with mouse input

Let's begin.

## What is a Shader?

We want to draw images on a screen.

Mathematically, an image is a function from a region $S \subset \mathbb{R}^2$ to the space of visible colors $\mathcal{C}$. This color space is three-dimensional, spanned by the responses of the three types of cone cells in our eyes. A convenient basis, roughly aligned with these responses, is red, green, and blue.

To realize this on a computer, we discretize. A screen is a grid of *pixels*: $X$ pixels wide, $Y$ pixels tall. Each pixel is a point in the integer lattice
$$\{0, 1, \ldots, X-1\} \times \{0, 1, \ldots, Y-1\}.$$

Colors are represented as RGB triples: red, green, and blue intensities, each in $[0,1]$. The constraint to $[0,1]$ reflects physical reality—a pixel has a maximum brightness it can display. (We can't draw the sun.) So an image is a function
$$f\colon \{0,\ldots,X-1\} \times \{0,\ldots,Y-1\} \to [0,1]^3$$
$$(i,j) \mapsto (r,g,b).$$

In practice, we add a fourth component: *alpha*, representing transparency. This matters when compositing multiple layers (we won't use it in this course, but the machinery expects it). So our shader computes
$$f\colon (i,j) \mapsto (r,g,b,1).$$

This is what a shader is. You write a function that takes pixel coordinates and returns an RGBA color. The GPU evaluates your function at every pixel to produce the image.

### Parallelism

A 1920×1080 display has over two million pixels. How do we evaluate $f$ at all of them fast enough to animate at 60 frames per second?

The answer is parallelism. A GPU contains thousands of cores, and it evaluates $f$ at all pixels *simultaneously*. There's no loop over pixels in your code—you write $f$, and the hardware handles the rest.

The tradeoff: each pixel's computation must be *independent*. Pixel $(100, 200)$ cannot ask what color pixel $(100, 199)$ received. Every pixel sees the same global inputs—coordinates, time, mouse position—and must determine its color from those alone. Learning to think within this constraint is what shader programming is about.

::: {.callout-note}
## Why "shader"?
The name comes from 3D graphics, where these programs computed *shading*—how light interacts with surfaces. It stuck even though we now use shaders for fractals, simulations, and mathematical visualization.
:::

### Why Shadertoy?

Shader programming normally requires substantial setup: OpenGL contexts, buffer management, compilation, render loops. [Shadertoy](https://www.shadertoy.com) abstracts all of this—you write one function, press play, and see results. We'll use it throughout the course.


## First Shaders: Colors and Syntax

### The mainImage Function

In Shadertoy, your shader is a function called `mainImage`:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // your code here
}
```

This function is called once per pixel, every frame. The inputs and outputs:

- `fragCoord` — the pixel coordinates, passed *in* to your function
- `fragColor` — the RGBA color, which you write *out*

The `in` and `out` keywords are explicit about data flow: `fragCoord` is read-only input, `fragColor` is where you write your result. The function returns `void` because the output goes through `fragColor`, not a return value.

### Hello World: A Solid Color

The simplest shader: make every pixel red.

{{< shader-demo day1/red >}}

The `vec4(1.0, 0.0, 0.0, 1.0)` constructs a 4-component vector: red=1, green=0, blue=0, alpha=1. Every pixel receives the same color, so the screen fills with red.

### GLSL Syntax Essentials

GLSL (OpenGL Shading Language) will feel familiar if you've seen C-like syntax, but a few things are worth noting upfront.

**Semicolons** are required at the end of each statement.

**Floats must include a decimal point.** Write `1.0`, not `1`. The integer `1` and the float `1.0` are different types, and GLSL is strict about this.

**Vector types** are built in: `vec2`, `vec3`, `vec4` for 2, 3, and 4 component vectors. Construct them with:

```glsl
vec2 p = vec2(3.0, 4.0);
vec3 color = vec3(1.0, 0.5, 0.0);
vec4 rgba = vec4(1.0, 0.0, 0.0, 1.0);
```

**Arithmetic is component-wise.** Adding two vectors adds their components:

```glsl
vec2(1.0, 2.0) + vec2(3.0, 4.0)  // = vec2(4.0, 6.0)
```

**Scalar-vector operations** apply the scalar to each component:

```glsl
2.0 * vec2(1.0, 3.0)  // = vec2(2.0, 6.0)
```

**Accessing components** uses `.x`, `.y`, `.z`, `.w`:

```glsl
vec2 p = vec2(3.0, 4.0);
float a = p.x;  // 3.0
float b = p.y;  // 4.0
```

For colors, `.r`, `.g`, `.b`, `.a` are synonyms—`color.r` is the same as `color.x`.

**Common math functions** work as expected: `sin`, `cos`, `abs`, `min`, `max`, `sqrt`, `pow`. These operate on floats, and apply component-wise to vectors:

```glsl
sin(vec2(0.0, 3.14159))  // = vec2(0.0, ~0.0)
```

**For loops** work as you'd expect:

```glsl
for (int i = 0; i < 5; i++) {
    // body executes with i = 0, 1, 2, 3, 4
}
```

The loop variable is an `int`. Note that some older GPUs require the loop bounds to be constants known at compile time—you can't always loop up to a variable. We'll use loops extensively starting tomorrow.

### Uniforms: Global Inputs

Shadertoy provides *uniforms*—global values that are constant across all pixels. Unlike `fragCoord`, which takes a different value at each pixel, a uniform has the same value everywhere. They're how external information (time, screen size, mouse position) gets into your shader.

| Uniform | Type | Description |
|---------|------|-------------|
| `iResolution` | `vec3` | Viewport size: `(width, height, pixel_aspect_ratio)` |
| `iTime` | `float` | Seconds since the shader started |
| `iMouse` | `vec4` | Mouse position and click state |

We'll use `iResolution` constantly (for coordinate transforms) and `iTime` for animation.

### Animation: Using iTime

Let's make the red channel pulse:

{{< shader-demo day1/red-pulsing >}}

Since `sin(iTime)` oscillates between -1 and 1, the expression `0.5 + 0.5 * sin(iTime)` oscillates between 0 and 1. The screen pulses from black to red.

This is our first *animated* shader—the output depends on time.

## Coordinate Systems

### Pixel Coordinates

The input `fragCoord` gives the pixel coordinates of the current pixel. The coordinate system:

- Origin at the **bottom-left** corner
- `fragCoord.x` increases to the right
- `fragCoord.y` increases upward
- Ranges from $(0, 0)$ to $(X, Y)$ where $X \times Y$ is the screen resolution

This is workable, but inconvenient for mathematics. We'd prefer coordinates centered at the origin with a reasonable scale. Let's build up a transformation step by step.

### Step 1: Normalize to $[0,1]^2$

Divide by the resolution to map pixel coordinates to the unit square:

```glsl
vec2 uv = fragCoord / iResolution.xy;
```

Now `uv` ranges from $(0,0)$ at bottom-left to $(1,1)$ at top-right.

Since both coordinates are in $[0,1]$, we can visualize them directly as color:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);
}
```

{{< shader-demo day1/coordinates >}}

Black at bottom-left (0,0), red at bottom-right (1,0), green at top-left (0,1), yellow at top-right (1,1).

### Step 2: Center the Origin

Subtract $(0.5, 0.5)$ to center the origin:

```glsl
uv = uv - vec2(0.5, 0.5);
```

Now `uv` ranges from $(-0.5, -0.5)$ to $(0.5, 0.5)$, with $(0,0)$ at the screen center.

### Step 3: Aspect Ratio Correction

We've mapped a rectangle of pixels ($X \times Y$) to the square $[-0.5, 0.5]^2$. This is an affine transformation, not a similarity—it distorts shapes. A circle in our coordinates would render as an ellipse on screen.

To fix this, we scale the $x$-coordinate by the aspect ratio:

```glsl
uv.x *= iResolution.x / iResolution.y;
```

Now a circle in our coordinates appears as a circle on screen. (When we draw shapes later, try commenting out this line to see the distortion.)

### Step 4: Scale to a Useful Range

Finally, scale to a convenient window:

```glsl
vec2 p = uv * 4.0;
```

With a scale factor of 4, our coordinates range roughly from $-2$ to $2$—a good default for visualizing mathematical objects.

### The Standard Boilerplate

Putting it together, here's the coordinate setup we'll use throughout the course:

```glsl
vec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]
uv = uv - vec2(0.5, 0.5);               // center origin
uv.x *= iResolution.x / iResolution.y;  // aspect correction
vec2 p = uv * 4.0;                      // scale
```

From here on, `p` is our mathematical coordinate, centered at the origin, aspect-corrected, with a reasonable range.

## Drawing with Distance

So far we've colored every pixel the same, or colored based on position as a gradient. Now we want to *draw*: to render a shape on screen.

What does it mean to draw a shape? For a simple filled region, we need a rule that tells us, for each pixel: are you inside the shape or not? When inside, we do one thing (say, color yellow). When outside, we do another (color blue). The boundary of the shape is where we switch.

### Half-Planes

The simplest shape is a half-plane. Consider the rule: is the $y$-coordinate greater than 0? This divides the plane into two regions—above and below the $x$-axis.

```glsl
float L = p.y;

vec3 color;
if (L < 0.0) {
    color = vec3(1.0, 0.0, 0.0);  // red below
} else {
    color = vec3(0.0, 0.0, 1.0);  // blue above
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/half-plane >}}

To color left versus right instead, use `p.x` in place of `p.y`.

More generally, a line in the plane has the form $ax + by + c = 0$. This divides the plane into two half-planes: where $ax + by + c < 0$ and where $ax + by + c > 0$.

```glsl
float a = 1.0, b = 1.0, c = 0.0;
float L = a * p.x + b * p.y + c;

vec3 color;
if (L < 0.0) {
    color = vec3(1.0, 0.0, 0.0);  // red
} else {
    color = vec3(0.0, 0.0, 1.0);  // blue
}

fragColor = vec4(color, 1.0);
```

Recall that $(a, b)$ is the normal vector to the line, and $c$ is an offset. Since these are just variables, we can animate them to move the line around:

```glsl
float a = cos(iTime);
float b = sin(iTime);
float c = 0.5 * sin(iTime * 0.7);
```

{{< shader-demo day1/half-plane-animated >}}

### Circles

Now consider the function $d(p) = |p|$, the distance from the origin. Geometrically, the graph of this function is a cone—zero at the origin, increasing linearly in all directions.

To draw a filled disk of radius $r$, we could threshold on $d < r$ versus $d \geq r$. But it's cleaner to define $f(p) = |p| - r$. This function is negative inside the circle (where $d < r$) and positive outside (where $d > r$). The circle itself is the level set $f = 0$.

```glsl
float d = length(p);
float r = 1.0;
float f = d - r;

vec3 color;
if (f < 0.0) {
    color = vec3(1.0, 1.0, 0.0);  // yellow inside
} else {
    color = vec3(0.1, 0.1, 0.3);  // dark blue outside
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/circle >}}

Try commenting out the aspect ratio correction (`uv.x *= ...`) to see the distortion—the circle becomes an ellipse.

To center the circle at a point $c$ instead of the origin, compute distance from $c$:

```glsl
vec2 center = vec2(1.0, 0.5);
float d = length(p - center);
```

Since `center` and `r` are variables, you can animate them with `iTime` to create moving, pulsing circles.

### Drawing a Ring

Our function $f = d - r$ is negative inside the circle and positive outside. To draw a filled disk, we colored based on the sign of $f$.

But what if we want just the boundary—a ring of some thickness? We want to color one way when $f$ is small in absolute value (near the circle), and a different way when $|f|$ is large (far from the circle).

So we look at $|f| = |d - r|$ and ask: is this less than some threshold $\varepsilon$, or greater? Equivalently, is $|d - r| - \varepsilon$ negative or positive?

```glsl
float d = length(p);
float r = 1.0;
float eps = 0.1;
float f = abs(d - r) - eps;

vec3 color;
if (f < 0.0) {
    color = vec3(1.0, 1.0, 1.0);  // white ring
} else {
    color = vec3(0.1, 0.1, 0.3);  // dark background
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/circle-ring >}}

## Implicit Curves

We've drawn circles using the distance function $|p| - r$. But circles are just one example of curves defined by an equation. Any equation $F(x,y) = 0$ defines a curve—the set of points satisfying that equation. We can draw it the same way: threshold on $|F|$.

### A First Example: The Parabola

Consider $F(x,y) = y - x^2$. The curve $F = 0$ is the parabola $y = x^2$. Points where $F < 0$ lie below the parabola; points where $F > 0$ lie above.

To draw the curve itself, we color pixels where $|F|$ is small:

```glsl
float F = p.y - p.x * p.x;
float eps = 0.1;

vec3 color;
if (abs(F) < eps) {
    color = vec3(1.0, 1.0, 0.0);  // yellow curve
} else {
    color = vec3(0.1, 0.1, 0.3);  // dark background
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/parabola >}}

### More Examples

An ellipse: $F(x,y) = \frac{x^2}{a^2} + \frac{y^2}{b^2} - 1$

```glsl
float a = 2.0, b = 1.0;
float F = (p.x*p.x)/(a*a) + (p.y*p.y)/(b*b) - 1.0;
```

A hyperbola: $F(x,y) = \frac{x^2}{a^2} - \frac{y^2}{b^2} - 1$

```glsl
float a = 1.0, b = 1.0;
float F = (p.x*p.x)/(a*a) - (p.y*p.y)/(b*b) - 1.0;
```

The lemniscate of Bernoulli: $(x^2 + y^2)^2 = a^2(x^2 - y^2)$, or $F = (x^2+y^2)^2 - a^2(x^2 - y^2)$

```glsl
float a = 1.5;
float r2 = dot(p, p);  // x² + y²
float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);
```

### The Thickness Problem

Look carefully at the parabola. The rendered thickness isn't uniform—it's thinner where the curve is steep, thicker where it's flat. The problem gets worse with more complicated curves, especially those with singularities. Here's the lemniscate:

{{< shader-demo day1/lemniscate-naive >}}

Notice how the thickness blows up near the origin, where the curve crosses itself.

Why does this happen? The set $|F| < \varepsilon$ contains all points within $\varepsilon$ of zero *in the $F$ direction*. But $F$ doesn't measure distance to the curve—it's just some function that happens to be zero on the curve. Where $|\nabla F|$ is large, $F$ changes rapidly, so the band $|F| < \varepsilon$ is narrow. Where $|\nabla F|$ is small, $F$ changes slowly, so the band is wide. At the singular point, $\nabla F = 0$, and the band becomes infinitely wide.

### Why Circles Worked

For the circle, we used $f(p) = |p| - r$. This is the *signed distance function*: it measures actual geometric distance to the curve. The gradient of a distance function has magnitude 1 everywhere (it points toward or away from the curve at unit rate). So $|f| < \varepsilon$ really does capture points within distance $\varepsilon$, giving uniform thickness.

This is a fact from differential geometry: $|\nabla d| = 1$ for a distance function $d$. When we use an arbitrary implicit equation $F = 0$, we lose this property.

### Gradient Correction

We can fix the non-uniform thickness by dividing by the gradient magnitude. Instead of thresholding $|F| < \varepsilon$, we threshold
$$\frac{|F|}{|\nabla F|} < \varepsilon.$$

This approximates the signed distance to the curve. The intuition: $|F|/|\nabla F|$ estimates how far you'd need to travel (in the direction $F$ changes fastest) to reach the curve.

For the lemniscate, we compute the gradient analytically:
$$\nabla F = \bigl(4x(x^2+y^2) - 2a^2 x,\; 4y(x^2+y^2) + 2a^2 y\bigr)$$

```glsl
float a = 1.5;
float r2 = dot(p, p);
float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);

vec2 grad = vec2(
    4.0 * p.x * r2 - 2.0 * a * a * p.x,
    4.0 * p.y * r2 + 2.0 * a * a * p.y
);

float dist = abs(F) / max(length(grad), 0.01);  // avoid division by zero
float eps = 0.05;

vec3 color;
if (dist < eps) {
    color = vec3(1.0, 1.0, 0.0);
} else {
    color = vec3(0.1, 0.1, 0.3);
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/lemniscate-gradient >}}

Compare with the naive version above to see the difference in thickness uniformity.

### Animated Curve Families

The lemniscate is part of a one-parameter family called the Cassini ovals, defined by the product of distances from two foci being constant:
$$(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4$$

As the parameter $a$ varies relative to the fixed focal distance $c$, the topology changes: two separate loops when $a < c$, a lemniscate when $a = c$, a single oval when $a > c$.

{{< shader-demo day1/lemniscate-animated >}}

## Interactivity and Abstraction

So far our shaders respond to time (`iTime`) but not to user input. Shadertoy provides `iMouse` for mouse interaction.

### The iMouse Uniform

`iMouse` is a `vec4`:

- `iMouse.xy` — current mouse position (in pixels)
- `iMouse.zw` — position where the mouse was last clicked

For now we'll focus on `iMouse.xy`.

### Dragging a Circle

Let's draw a circle centered at the mouse position. Since `iMouse.xy` is in pixel coordinates, we need to normalize it the same way we normalize `fragCoord`:

```glsl
// Normalize fragment coordinate
vec2 uv = fragCoord / iResolution.xy;
uv = uv - vec2(0.5, 0.5);
uv.x *= iResolution.x / iResolution.y;
vec2 p = uv * 4.0;

// Normalize mouse coordinate the same way
vec2 mouse = iMouse.xy / iResolution.xy;
mouse = mouse - vec2(0.5, 0.5);
mouse.x *= iResolution.x / iResolution.y;
mouse = mouse * 4.0;

// Circle centered at mouse
float d = length(p - mouse);
float r = 0.5;

vec3 color;
if (d < r) {
    color = vec3(1.0, 0.9, 0.2);  // yellow
} else {
    color = vec3(0.1, 0.1, 0.3);
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/circle-mouse >}}

Click and drag to move the circle.

### Writing a Helper Function

We just wrote the same four lines of coordinate normalization twice. This is a sign we should write a function.

A GLSL function declares its return type, then the function name, then its parameters with their types:

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}
```

Functions must be defined before they're used, so they go above `mainImage`. Here's the overall structure:

```glsl
vec2 normalize_coord(vec2 coord) {
    // normalization logic here
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 p = normalize_coord(fragCoord);
    vec2 mouse = normalize_coord(iMouse.xy);
    
    // code using p and mouse
}
```

Now our shader is cleaner, and we won't make mistakes copying the normalization code.

### Combining iMouse and iTime: Sun and Earth

Let's make a circle orbit around the mouse position:

```glsl
vec2 p = normalize_coord(fragCoord);
vec2 sun = normalize_coord(iMouse.xy);

// Earth orbits the sun
float orbit_radius = 0.8;
vec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));

// Draw sun (larger, yellow)
float d_sun = length(p - sun);
// Draw earth (smaller, blue)
float d_earth = length(p - earth);

vec3 color = vec3(0.02, 0.02, 0.05);  // dark background
if (d_sun < 0.3) {
    color = vec3(1.0, 0.9, 0.2);  // yellow sun
}
if (d_earth < 0.15) {
    color = vec3(0.2, 0.5, 1.0);  // blue earth
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/sun-earth >}}

Drag to move the sun; the earth follows in orbit. (Exercise: add a moon orbiting the earth!)

### Mouse as Parameter

The mouse doesn't have to control position—it can control any parameter. A useful pattern: map `iMouse.x` to a parameter range and drag across the screen to explore a family of curves.

The folium of Descartes is the curve $x^3 + y^3 = 3axy$. We can explore its level sets by drawing $x^3 + y^3 - 3axy = c$ for different values of $c$:

```glsl
vec2 p = normalize_coord(fragCoord);

// Fixed parameter a
float a = 1.5;

// Map mouse x to level set value c in [-2, 2]
float c = mix(-2.0, 2.0, iMouse.x / iResolution.x);

// Folium of Descartes: x³ + y³ - 3axy = c
float F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;

// Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)
vec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);
float dist = abs(F) / max(length(grad), 0.01);

vec3 color;
if (dist < 0.05) {
    color = vec3(1.0, 1.0, 0.0);
} else {
    color = vec3(0.1, 0.1, 0.3);
}

fragColor = vec4(color, 1.0);
```

{{< shader-demo day1/folium-mouse >}}

Drag left and right to sweep through the level sets and watch the curve topology change.

## Exercises

Homework is organized into four types:

**Checkpoints** — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.

**Explorations** — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you're right on track with the course.

**Challenges** — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.

**Project** — An extended project for someone familiar with shader basics, to make an artwork.

---

### Checkpoints

**C1. Solid Colors.** Modify the red screen shader to display: (a) green, (b) cyan, (c) a color of your choice using all three RGB channels.

**C2. Vertical Split.** Modify the half-plane shader to divide the screen into left (red) and right (blue) instead of top and bottom.

**C3. Off-Center Circle.** Draw a filled circle of radius 0.5 centered at the point $(1, 1)$ instead of the origin.

**C4. Pulsing Circle.** Make a circle whose radius oscillates between 0.5 and 1.5 over time using `iTime`.

**C5. Ring Thickness.** Draw a ring (circle outline) centered at the origin. Experiment with different values of `eps` to understand how it controls thickness.

---

### Explorations

**E1. Concentric Rings.** Draw several concentric rings (circles of different radii, all centered at the origin). Can you color alternate rings differently?

**E2. Moon Orbit.** Extend the sun-earth shader to add a moon that orbits the earth. The moon should be smaller than the earth and orbit faster.

**E3. Your Favorite Curve.** Pick an implicit curve from your mathematical experience (or find one online) and render it. Some suggestions: the cardioid $(x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)$, the astroid $x^{2/3} + y^{2/3} = a^{2/3}$, or a rose curve in implicit form. Apply gradient correction for uniform thickness.

**E4. Curve Explorer.** Take any one-parameter family of curves and build a mouse-controlled explorer (like the folium example). Map `iMouse.x` to the parameter and drag to explore the family.

**E5. Two Circles.** Draw two filled circles at different positions. What happens when they overlap? Can you make one "in front of" the other? Can you make the intersection a different color, like a Venn diagram?

---

### Challenges

**H1. Parabola Graphing Calculator.** Build an interactive graphing calculator for the parabola $y = ax^2 + bx + c$. Requirements:
- Draw coordinate axes (the lines $x = 0$ and $y = 0$)
- Draw the parabola using implicit curve techniques
- Find the roots (where $y = 0$) and draw small circles around them
- Use mouse position to control two of the coefficients (e.g., $a$ and $b$, with $c$ fixed, or $b$ and $c$ with $a$ fixed)

As you drag the mouse, the parabola should reshape and the root indicators should move (or appear/disappear as roots become real or complex).

**H2. Elliptic Curve Explorer.** Elliptic curves in Weierstrass form are $y^2 = x^3 + ax + b$. Build a shader where the mouse position controls $(a, b)$. Use gradient correction for uniform thickness. The *discriminant* $\Delta = 4a^3 + 27b^2$ determines whether the curve is smooth ($\Delta \neq 0$) or singular ($\Delta = 0$). Can you display the current value of $\Delta$ somehow, or change the curve's color when it becomes singular?

**H3. Signed Distance Functions.** For a filled circle, $f(p) = |p| - r$ is the *signed* distance function: negative inside, positive outside, with $|f|$ giving the actual distance to the boundary. What is the signed distance function for a half-plane? For an axis-aligned rectangle? Implement both and draw them with uniform-thickness boundaries. Note: when you have the true signed distance function, you don't need the gradient correction trick—that's the payoff for computing the right thing from the start!

**H4. Smooth Blending.** When two circles overlap, we currently just draw one on top of the other. Research *smooth minimum* functions (e.g., `smin`) that blend distance fields smoothly. Draw two circles that "melt together" where they meet.

**H5. Inversion.** Circle inversion is the map $p \mapsto p / |p|^2$. Apply this transformation to your coordinate $p$ before drawing a shape. What happens to a line? What happens to a circle not passing through the origin? Experiment with different shapes.

---

### Project: Grid Patterns

This extended project introduces a powerful technique—using modular arithmetic to repeat patterns across the plane. We'll build up the machinery carefully, since we'll use it again in Day 2 to create grids of Julia sets.

#### Part 1: Setting Up a Grid of Square Cells

We want to tile the screen with square cells—say, 4 cells across. The challenge: the screen isn't square, so we need to handle the aspect ratio.

Let's say we want `N` columns of cells. Each cell has width $L = \text{screen\_width} / N$ in pixels, and since cells are square, height $L$ as well. The number of rows depends on the screen's aspect ratio.

Working in our normalized coordinates (after aspect correction), the screen spans roughly $[-2 \cdot \text{aspect}, 2 \cdot \text{aspect}]$ in $x$ and $[-2, 2]$ in $y$. If we want cells of side length $L$ in these coordinates:

```glsl
float aspect = iResolution.x / iResolution.y;
float N = 5.0;  // number of columns
float L = (4.0 * aspect) / N;  // cell size in our coordinate system
```

Now each cell is an $L \times L$ square.

#### Part 2: Cell Coordinates and Identity

For each pixel, we want two things:

1. **Which cell are we in?** Integer coordinates $(i, j)$ identifying the cell.
2. **Where in the cell are we?** Local coordinates ranging from $-L/2$ to $L/2$, with $(0,0)$ at the cell center.

```glsl
vec2 cell_id = floor(p / L);
vec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);
```

The `cell_id` tells us which cell; the `cell_p` gives local coordinates within that cell.

If we want local coordinates normalized to $[-1, 1]$ (useful for drawing things at a standard scale), we can rescale:

```glsl
vec2 local = cell_p / (L / 2.0);  // now in [-1, 1] x [-1, 1]
```

This is exactly the setup we'll need for Day 2, where each cell will contain a Julia set with its own coordinate system.

#### Part 3: Drawing in Each Cell

Now draw something using the local coordinates. A filled circle at the center of each cell:

```glsl
float d = length(cell_p);
float r = L * 0.4;  // radius relative to cell size

vec3 color;
if (d < r) {
    color = vec3(1.0, 1.0, 0.0);
} else {
    color = vec3(0.1, 0.1, 0.3);
}
```

<!-- {{< shader-demo day1/grid-circles >}} -->

Try changing `N` to get more or fewer columns. The cells stay square regardless of screen shape.

#### Part 4: Varying by Cell

The `cell_id` lets each cell behave differently. Some ideas:

**Checkerboard background:**

```glsl
float checker = mod(cell_id.x + cell_id.y, 2.0);
vec3 bg = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);
```

**Radius varying by cell:**

```glsl
float r = L * (0.2 + 0.15 * mod(cell_id.x + cell_id.y, 3.0));
```

**Wave animation:**

```glsl
float cell_dist = length(cell_id);
float r = L * (0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5));
```

#### Part 5: Design Challenge

Design a grid-based pattern that you find visually interesting. Some directions:

**Connecting shapes:** Draw shapes that connect across cell boundaries. Quarter-circles in each corner create a continuous network. What implicit curves tile seamlessly?

**Alternating motifs:** Use `cell_id` to alternate between different shapes—circles in some cells, rings in others, or different orientations.

**Color fields:** Map `cell_id` to colors using distance from origin, stripes, or a palette.

**Phase shifts:** Animate cells with different phase offsets to create waves or ripples.

**Using local coordinates:** Draw something more complex in each cell using the $[-1,1]$ local coordinate system—perhaps a small implicit curve, or a pattern that changes based on `cell_id`.

The goal is to produce an image you'd be happy to hang on a wall.


### Project: Fourier Epicycles

This project builds a visualization of Fourier series using epicycles—circles whose centers sit on the circumferences of other circles. This is how Ptolemy modeled planetary motion, and it turns out to be exactly how Fourier series work geometrically.

#### Part 1: The Idea

Any periodic function can be written as a sum of sines and cosines. Geometrically, $\sin(n\omega t)$ and $\cos(n\omega t)$ describe a point moving around a circle of frequency $n\omega$. Adding these components corresponds to stacking circles: each circle's center rides on the previous circle's edge.

For example, the square wave has Fourier series:
$$f(t) = \sum_{n=1,3,5,...} \frac{1}{n} \sin(n\omega t)$$

This means circles with:
- Radii: $1, \frac{1}{3}, \frac{1}{5}, \frac{1}{7}, ...$
- Frequencies: $\omega, 3\omega, 5\omega, 7\omega, ...$

The more terms we add, the closer the final point's $y$-coordinate approximates a square wave.

#### Part 2: Drawing Circles

Start by drawing a chain of circles. Each circle is centered at the current position, and the next position is computed by moving along the circle:

```glsl
vec2 pos = vec2(0.0, 0.0);  // start at origin

for (int i = 0; i < N; i++) {
    int n = 2 * i + 1;  // 1, 3, 5, 7, ...
    float r = scale / float(n);
    float freq = float(n) * omega;
    
    // Draw circle at current position
    float d_circle = abs(length(p - pos) - r);
    if (d_circle < 0.02) {
        // color the circle
    }
    
    // Move to next position
    pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));
}

// Draw final point
float d_point = length(p - pos);
if (d_point < 0.08) {
    // bright color
}
```

Try this with `N = 1`, then `N = 3`, then `N = 7`. Watch how more circles create more complex motion.

#### Part 3: The Line Segment SDF

To draw the arms connecting circle centers, we need the signed distance function for a line segment. Given endpoints $a$ and $b$, the distance from point $p$ to the segment is:

```glsl
float sd_segment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * t);
}
```

The math: we project $p - a$ onto the line direction $b - a$, clamp to $[0, 1]$ to stay within the segment, then measure the distance to that closest point.

#### Part 4: Connecting the Arms

Now modify your loop to also draw line segments:

```glsl
vec2 pos = vec2(0.0, 0.0);

for (int i = 0; i < N; i++) {
    int n = 2 * i + 1;
    float r = scale / float(n);
    float freq = float(n) * omega;
    
    vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));
    
    // Draw circle
    float d_circle = abs(length(p - pos) - r);
    if (d_circle < 0.02) {
        // faint circle color
    }
    
    // Draw arm from pos to next_pos
    float d_arm = sd_segment(p, pos, next_pos);
    if (d_arm < 0.015) {
        // arm color
    }
    
    pos = next_pos;
}
```

#### Part 5: Polish and Explore

Now make it beautiful:

**Fading circles:** Later circles are smaller and less important. Fade their brightness:
```glsl
float fade = 1.0 - float(i) / float(N);
```

**Color variation:** Color circles differently based on their index, or based on their frequency.

**Different waves:** The square wave uses odd harmonics with $1/n$ coefficients. Try:
- Triangle wave: odd harmonics with $1/n^2$ coefficients (alternating signs)
- Sawtooth wave: all harmonics with $1/n$ coefficients

**Mouse control:** Map `iMouse.x` to the number of terms, so dragging adds or removes circles.

The goal: create a mesmerizing animation that reveals the geometry hidden inside Fourier series.