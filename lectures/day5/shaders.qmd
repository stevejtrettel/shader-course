# Day 5 Code

Complete, standalone code for each shader referenced in Day 5. Each listing can be copied directly into [Shadertoy](https://www.shadertoy.com/new).

## Buffer Shader Setup

Day 5 uses **buffer shaders** — shaders that write to persistent storage instead of the screen. To set up a buffer shader in Shadertoy:

1. Click the **+** tab next to "Image" and select "Buffer A"
2. In Buffer A, click `iChannel0` at the bottom and select "Buffer A" from the Misc tab
3. In Image, click `iChannel0` and select "Buffer A"

Each shader below lists the code for both Buffer A and Image.

---

## paint-basic

Simple persistent painting — click and drag to draw white dots that stay on screen.

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read what was here last frame
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    
    // Check distance to mouse
    float d = length(fragCoord - iMouse.xy);
    
    // If mouse is pressed (z > 0) and we're close, paint white
    if (iMouse.z > 0.0 && d < 10.0) {
        fragColor = vec4(1.0);
    } else {
        fragColor = prev;
    }
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

---

## paint-fade

Painting with fading trails — each frame, all pixels fade slightly toward black.

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Read and fade
    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);
    prev *= 0.99;
    
    // Paint at mouse
    float d = length(fragCoord - iMouse.xy);
    if (iMouse.z > 0.0 && d < 10.0) {
        fragColor = vec4(1.0);
    } else {
        fragColor = prev;
    }
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

---

## random-noise

Visualizing the hash function — static noise where each pixel gets a pseudorandom value. This is a single-pass shader (no buffer needed).

```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float random = hash(fragCoord);
    fragColor = vec4(vec3(random), 1.0);
}
```

---

## game-of-life

Conway's Game of Life — cells live or die based on their neighbor count.

**Buffer A:**
```glsl
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize on first frame
    if (iFrame == 0) {
        float random = hash(fragCoord);
        fragColor = vec4(step(0.5, random));
        return;
    }
    
    // Read self and neighbors
    ivec2 p = ivec2(fragCoord);
    
    float self = texelFetch(iChannel0, p, 0).r;
    float neighbors = 
        texelFetch(iChannel0, p + ivec2(-1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0, -1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1, -1), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  0), 0).r +
        texelFetch(iChannel0, p + ivec2(-1,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 0,  1), 0).r +
        texelFetch(iChannel0, p + ivec2( 1,  1), 0).r;
    
    // Apply Conway's rules
    float alive;
    if (self > 0.5) {
        // Currently alive: survive with 2 or 3 neighbors
        alive = (neighbors > 1.5 && neighbors < 3.5) ? 1.0 : 0.0;
    } else {
        // Currently dead: birth with exactly 3 neighbors
        alive = (neighbors > 2.5 && neighbors < 3.5) ? 1.0 : 0.0;
    }
    
    fragColor = vec4(alive, alive, alive, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);
}
```

---

## heat-equation

Heat diffusion from a hot disk. Watch the sharp boundary smooth out over time.

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: hot disk in center
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float temp = d < 80.0 ? 1.0 : 0.0;
        fragColor = vec4(temp, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary: edges fixed at zero
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Read neighbors
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    // Laplacian
    float laplacian = n + s + e + w - 4.0 * c;
    
    // Explicit Euler step
    float alpha = 0.5;
    float dt = 0.4;
    float newTemp = c + dt * alpha * laplacian;
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
vec3 heatColor(float t) {
    return mix(vec3(0.0, 0.0, 0.3), vec3(1.0, 0.3, 0.0), t);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float temp = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    fragColor = vec4(heatColor(temp), 1.0);
}
```

---

## heat-interactive

Heat diffusion with mouse interaction. Click and drag to add heat.

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: start cold
    if (iFrame == 0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary: edges fixed at zero
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Read neighbors
    ivec2 p = ivec2(fragCoord);
    float c = texelFetch(iChannel0, p, 0).r;
    float n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    
    // Laplacian
    float laplacian = n + s + e + w - 4.0 * c;
    
    // Explicit Euler step
    float alpha = 0.5;
    float dt = 0.4;
    float newTemp = c + dt * alpha * laplacian;
    
    // Mouse adds heat
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        if (d < 20.0) {
            newTemp = 1.0;
        }
    }
    
    fragColor = vec4(newTemp, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
vec3 heatColor(float t) {
    return mix(vec3(0.0, 0.0, 0.3), vec3(1.0, 0.3, 0.0), t);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float temp = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    fragColor = vec4(heatColor(temp), 1.0);
}
```

---

## wave-equation

Wave propagation from a Gaussian pluck. Uses two buffers: Buffer A for displacement, Buffer B for velocity.

**Setup:** 
- Buffer A: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Buffer B: `iChannel0` = Buffer A, `iChannel1` = Buffer B  
- Image: `iChannel0` = Buffer A

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: Gaussian pluck
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float sigma = 30.0;
        float u = exp(-d * d / (2.0 * sigma * sigma));
        fragColor = vec4(u, 0.0, 0.0, 1.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: zero velocity
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    // Laplacian of displacement
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    
    // Amplify for visibility
    u *= 5.0;
    
    // Map displacement to color: negative = blue, zero = black, positive = orange
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## wave-interactive

Interactive wave simulation. Click to create ripples.

**Setup:** 
- Buffer A: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Buffer B: `iChannel0` = Buffer A, `iChannel1` = Buffer B  
- Image: `iChannel0` = Buffer A

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: flat surface
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Initialize: zero velocity
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    // Boundary
    if (fragCoord.x < 1.0 || fragCoord.x > iResolution.x - 1.0 ||
        fragCoord.y < 1.0 || fragCoord.y > iResolution.y - 1.0) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    // Laplacian of displacement
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    // Mouse adds velocity kick (Gaussian impulse)
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    
    // Amplify for visibility
    u *= 5.0;
    
    // Map displacement to color: negative = blue, zero = black, positive = orange
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## wave-circle

Wave equation in a circular domain. Click to create ripples.

**Setup:** 
- Common: shared SDF and domain function
- Buffer A: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Buffer B: `iChannel0` = Buffer A, `iChannel1` = Buffer B  
- Image: `iChannel0` = Buffer A

**Common:**
```glsl
float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = fragCoord - center;
    return sdCircle(p, scale) < 0.0;
}
```

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.15, 0.15, 0.15, 1.0);
        return;
    }
    
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## wave-triangle

Wave equation in an equilateral triangle domain. Click to create ripples. Buffer A, Buffer B, and Image are identical to wave-circle — only Common changes.

**Setup:** 
- Common: shared SDF and domain function
- Buffer A: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Buffer B: `iChannel0` = Buffer A, `iChannel1` = Buffer B  
- Image: `iChannel0` = Buffer A

**Common:**
```glsl
float sdEquilateralTriangle(vec2 p) {
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    if (p.x + k * p.y > 0.0) {
        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;
    }
    p.x -= clamp(p.x, -2.0, 0.0);
    return -length(p) * sign(p.y);
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = (fragCoord - center) / scale;
    p.y += 0.25;  // shift down to center the triangle
    return sdEquilateralTriangle(p) < 0.0;
}
```

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.15, 0.15, 0.15, 1.0);
        return;
    }
    
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## wave-star

Wave equation in a 5-pointed star. Hook demo for Day 5.

**Setup:** 
- Common: shared SDF and domain function
- Buffer A: `iChannel0` = Buffer A, `iChannel1` = Buffer B
- Buffer B: `iChannel0` = Buffer A, `iChannel1` = Buffer B  
- Image: `iChannel0` = Buffer A

**Common:**
```glsl
float sdStar5(vec2 p, float r, float rf) {
    const vec2 k1 = vec2(0.809016994, -0.587785252);
    const vec2 k2 = vec2(-k1.x, k1.y);
    p.x = abs(p.x);
    p -= 2.0 * max(dot(k1, p), 0.0) * k1;
    p -= 2.0 * max(dot(k2, p), 0.0) * k2;
    p.x = abs(p.x);
    p.y -= r;
    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0, 1);
    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);
    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);
}

bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.4;
    vec2 p = (fragCoord - center) / scale;
    return sdStar5(p, 1.0, 0.4) < 0.0;
}
```

**Buffer A (displacement):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        vec2 center = iResolution.xy * 0.5;
        float d = length(fragCoord - center);
        float sigma = 30.0;
        float u = exp(-d * d / (2.0 * sigma * sigma));
        fragColor = vec4(u, 0.0, 0.0, 1.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    float u = texelFetch(iChannel0, p, 0).r;
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float newU = u + dt * v;
    
    fragColor = vec4(newU, 0.0, 0.0, 1.0);
}
```

**Buffer B (velocity):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (iFrame == 0) {
        fragColor = vec4(0.0);
        return;
    }
    
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.0);
        return;
    }
    
    ivec2 p = ivec2(fragCoord);
    
    float u_c = texelFetch(iChannel0, p, 0).r;
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float laplacian = u_n + u_s + u_e + u_w - 4.0 * u_c;
    
    float v = texelFetch(iChannel1, p, 0).r;
    
    float dt = 0.5;
    float c = 0.5;
    float newV = v + dt * c * c * laplacian;
    
    if (iMouse.z > 0.0) {
        float d = length(fragCoord - iMouse.xy);
        float sigma = 15.0;
        newV += 0.001 * exp(-d * d / (2.0 * sigma * sigma));
    }
    
    fragColor = vec4(newV, 0.0, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.15, 0.15, 0.15, 1.0);
        return;
    }
    
    float u = texelFetch(iChannel0, ivec2(fragCoord), 0).r;
    u *= 5.0;
    
    vec3 color;
    if (u > 0.0) {
        color = mix(vec3(0.0), vec3(1.0, 0.5, 0.0), u);
    } else {
        color = mix(vec3(0.0), vec3(0.0, 0.3, 1.0), -u);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## gray-scott-mandelbrot

Gray-Scott reaction-diffusion inside the Mandelbrot set. Hook demo for Day 5.

**Setup:** 
- Common: shared domain function
- Buffer A: `iChannel0` = Buffer A
- Image: `iChannel0` = Buffer A

**Common:**
```glsl
bool inDomain(vec2 fragCoord, vec2 resolution) {
    vec2 center = resolution * 0.5;
    float scale = min(resolution.x, resolution.y) * 0.3;
    vec2 c = (fragCoord - center) / scale;
    c.x -= 0.5;
    
    vec2 z = vec2(0.0);
    for (int i = 0; i < 100; i++) {
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if (dot(z, z) > 4.0) return false;
    }
    return true;
}
```

**Buffer A:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(1.0, 0.0, 0.0, 1.0);
        return;
    }
    
    if (iFrame == 0) {
        float u = 1.0;
        float v = 0.0;
        
        vec2 center = iResolution.xy * 0.5;
        if (length(fragCoord - center) < 20.0) {
            v = 1.0;
            u = 0.0;
        }
        
        fragColor = vec4(u, v, 0.0, 1.0);
        return;
    }
    
    float Du = 0.2;
    float Dv = 0.1;
    float f = 0.04;
    float k = 0.06;
    float dt = 1.0;
    
    ivec2 p = ivec2(fragCoord);
    
    vec2 uv = texelFetch(iChannel0, p, 0).rg;
    float u = uv.x;
    float v = uv.y;
    
    float u_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).r;
    float u_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).r;
    float u_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).r;
    float u_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).r;
    float lap_u = u_n + u_s + u_e + u_w - 4.0 * u;
    
    float v_n = texelFetch(iChannel0, p + ivec2( 0,  1), 0).g;
    float v_s = texelFetch(iChannel0, p + ivec2( 0, -1), 0).g;
    float v_e = texelFetch(iChannel0, p + ivec2( 1,  0), 0).g;
    float v_w = texelFetch(iChannel0, p + ivec2(-1,  0), 0).g;
    float lap_v = v_n + v_s + v_e + v_w - 4.0 * v;
    
    float uvv = u * v * v;
    
    float newU = u + dt * (Du * lap_u - uvv + f * (1.0 - u));
    float newV = v + dt * (Dv * lap_v + uvv - (f + k) * v);
    
    newU = clamp(newU, 0.0, 1.0);
    newV = clamp(newV, 0.0, 1.0);
    
    fragColor = vec4(newU, newV, 0.0, 1.0);
}
```

**Image:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    if (!inDomain(fragCoord, iResolution.xy)) {
        fragColor = vec4(0.15, 0.15, 0.15, 1.0);
        return;
    }
    
    vec2 uv = texelFetch(iChannel0, ivec2(fragCoord), 0).rg;
    float v = uv.g;
    
    vec3 color = mix(vec3(0.0, 0.0, 0.2), vec3(1.0, 0.9, 0.6), v);
    
    fragColor = vec4(color, 1.0);
}
```