[
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "lectures/day3.html",
    "href": "lectures/day3.html",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "Today we’ll extend our per-pixel computations to study geometric tilings: we’ll produce some beautiful hyperbolic tilings and if you work through the homework you’ll be able to create something like below: a tiling morphs smoothly between two different views of the same geometry—the unbounded upper half-plane and the circular Poincaré disk.\n\n  \n  \n  \n\n\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\nBy the end of today, you will be able to:\n\nImplement the folding algorithm to create tilings from any fundamental domain\nUse half-space abstractions to define arbitrary polygonal regions\nUnderstand why the algorithm works through the lens of reflection groups\nApply the same techniques in hyperbolic geometry\nConvert between different models of hyperbolic space\n\n\n\n\n\nOur goal today is to draw beautiful tilings—of the plane, the hyperbolic plane, and beyond—efficiently on the GPU. We’ll learn a powerful technique: fold any point back into a fundamental domain by repeatedly reflecting across boundaries. The algorithm is simple, parallelizes perfectly, and works identically in Euclidean and hyperbolic geometry.\n\n\nLet’s start with the simplest case: tiling the plane with horizontal strips. We define a fundamental domain—the strip where \\(0 &lt; x &lt; 1\\)—and reflect any point outside back in.\nThe reflection across a vertical line \\(x = c\\) is simple: \\((x, y) \\mapsto (2c - x, y)\\).\nThe algorithm:\n\nIf \\(x &lt; 0\\), reflect across \\(x = 0\\)\nIf \\(x &gt; 1\\), reflect across \\(x = 1\\)\nRepeat until the point stops moving\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fold into the strip [0, 1]\n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;           // Reflect across x = 0\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;      // Reflect across x = 1\n    }\n    \n    // Draw a circle in the fundamental domain\n    float d = length(p - vec2(0.5, 0.0));\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    if (d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThe circle tiles the entire strip! But circles are symmetric—we can’t tell if tiles are being reflected or just translated. Let’s draw something asymmetric instead.\nWe’ll use the letter “F”, which has no mirror symmetry. We define a helper function that draws an F centered at the origin:\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    // Vertical bar\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    // Top horizontal bar\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    // Middle horizontal bar\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\nThen we replace the circle drawing with a call to drawF:\nvec3 color = drawF(p - vec2(0.5, 0.0), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n\n  \n  \n  \n\n\nNow we can see what’s happening: the “F” alternates between normal and mirrored! This is reflection, not translation. Each time we cross a boundary, the image flips. We draw the shape once in the fundamental domain, and the folding algorithm tiles it everywhere.\n\n\n\nExtending to two dimensions is straightforward—just add boundaries for \\(y\\):\n// Fold into the square [0,1] × [0,1]\nfor (int i = 0; i &lt; 20; i++) {\n    if (p.x &lt; 0.0) p.x = -p.x;\n    if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n    if (p.y &lt; 0.0) p.y = -p.y;\n    if (p.y &gt; 1.0) p.y = 2.0 - p.y;\n}\n\n  \n  \n  \n\n\nThe “F” now tiles in both directions, with reflections across all four boundaries creating a kaleidoscopic pattern.\n\n\n\nLet’s track how many reflections were needed to reach the fundamental domain. This reveals the structure of the tiling:\n// Fold into the square, counting reflections\nint foldCount = 0;\nfor (int i = 0; i &lt; 20; i++) {\n    vec2 p0 = p;\n    \n    if (p.x &lt; 0.0) { p.x = -p.x; foldCount++; }\n    if (p.x &gt; 1.0) { p.x = 2.0 - p.x; foldCount++; }\n    if (p.y &lt; 0.0) { p.y = -p.y; foldCount++; }\n    if (p.y &gt; 1.0) { p.y = 2.0 - p.y; foldCount++; }\n    \n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n// Color by fold count\nfloat t = float(foldCount) / 10.0;\nvec3 color = 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));\n\n  \n  \n  \n\n\nPoints near the fundamental domain (center of screen) need few reflections; points far away need many. The color bands show “distance” in terms of reflection count.\n\n\n\nFor tilings, we often want to distinguish adjacent tiles. The parity of the fold count (odd vs even) gives us a checkerboard pattern:\n// After folding...\nfloat parity = mod(float(foldCount), 2.0);\nvec3 color = (parity &lt; 0.5) \n    ? vec3(0.9, 0.85, 0.8)   // Light\n    : vec3(0.3, 0.35, 0.4);  // Dark\n\n  \n  \n  \n\n\nThis works because each reflection flips orientation—an odd number of reflections gives a mirror image of the fundamental domain, while an even number preserves orientation.\n\n\n\n\nLooking at our square tiling code, we see a repeated pattern: check if we’re outside a boundary, reflect if so. Let’s abstract this so we can handle arbitrary shapes—including triangles, which will be our gateway to hyperbolic geometry.\n\n\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions:\n\nPoints where \\(ax + by &lt; c\\)\nPoints where \\(ax + by &gt; c\\)\n\nWe encode a half-space by storing the line and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line: ax + by = c\n    float side;     // +1 or -1: which side we want\n};\nThe side parameter determines our inequality: we’re “inside” the half-space when \\((ax + by - c) \\cdot \\text{side} &lt; 0\\).\n\n\n\nTwo functions do all the work. First, checking if a point is inside:\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\nSecond, reflecting into the half-space (only if we’re outside):\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    \n    // Already inside?\n    if (val * h.side &lt; 0.0) return p;\n    \n    // Reflect across the boundary line\n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);  // Unit normal\n    float dist = val / length(vec2(h.a, h.b));  // Signed distance to line\n    count++;\n    return p - 2.0 * dist * n;\n}\n\n\n\n\n\n\nNoteGLSL: The inout Keyword\n\n\n\nThe inout keyword lets a function both read and modify a variable passed to it. When we write:\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count)\nthe count parameter is passed by reference—changes inside the function affect the original variable. This is how we track the total number of reflections: each call to reflectInto can increment the same counter.\nGLSL has three parameter modes: - in (default): pass by value, function gets a copy - out: function must write to it, caller receives the value - inout: function can read and write, changes persist\nThis is similar to reference parameters in C++ or ref in C#.\n\n\nThe reflection formula comes from linear algebra: we move the point by twice its signed distance to the line, in the normal direction. We also increment the count each time we actually reflect.\n\n\n\nLet’s see what a half-space looks like:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\nIn mainImage, we test whether each point is inside and color accordingly:\n// Half-space: x &lt; 1 (left side of vertical line)\nHalfSpace h = HalfSpace(1.0, 0.0, 1.0, 1.0);\n\nvec3 color = inside(p, h) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.15);\n\n// Draw the boundary line\nfloat dist = abs(h.a * p.x + h.b * p.y - h.c) / length(vec2(h.a, h.b));\nif (dist &lt; 0.03) color = vec3(1.0);\n\n  \n  \n  \n\n\nThe blue region is “inside” the half-space. Try changing the parameters to see different lines and sides!\n\n\n\nLet’s rebuild our square tiling using this abstraction. The square \\([0, 1] \\times [0, 1]\\) is defined by four half-spaces:\n\nLeft edge (\\(x = 0\\)): want \\(x &gt; 0\\), so HalfSpace(1.0, 0.0, 0.0, -1.0)\nRight edge (\\(x = 1\\)): want \\(x &lt; 1\\), so HalfSpace(1.0, 0.0, 1.0, 1.0)\nBottom edge (\\(y = 0\\)): want \\(y &gt; 0\\), so HalfSpace(0.0, 1.0, 0.0, -1.0)\nTop edge (\\(y = 1\\)): want \\(y &lt; 1\\), so HalfSpace(0.0, 1.0, 1.0, 1.0)\n\nWe need a function that reflects a point into a half-space if it’s outside:\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    if (val * h.side &lt; 0.0) return p;  // Already inside\n    \n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);\n    float dist = val / length(vec2(h.a, h.b));\n    count++;\n    return p - 2.0 * dist * n;\n}\nNow the folding loop becomes:\n// Four half-spaces defining [0,1] × [0,1]\nHalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\nHalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\nHalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\nHalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n\nint foldCount = 0;\nfor (int i = 0; i &lt; 20; i++) {\n    vec2 p0 = p;\n    p = reflectInto(p, left, foldCount);\n    p = reflectInto(p, right, foldCount);\n    p = reflectInto(p, bottom, foldCount);\n    p = reflectInto(p, top, foldCount);\n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n  \n  \n  \n\n\nIt works! The result is identical to our earlier square tiling, but now the code is structured around half-spaces.\n\n\n\nNow the payoff—changing from a square to a triangle just means changing the half-space definitions. An equilateral triangle centered at the origin:\n// Three half-spaces defining equilateral triangle\nHalfSpace h1 = HalfSpace(0.0, 1.0, -0.5, -1.0);           // Bottom edge\nHalfSpace h2 = HalfSpace(0.866, -0.5, -0.5, -1.0);        // Upper-right edge  \nHalfSpace h3 = HalfSpace(-0.866, -0.5, -0.5, -1.0);       // Upper-left edge\n\n// Fold into triangle (three reflections instead of four)\nfor (int i = 0; i &lt; 30; i++) {\n    vec2 p0 = p;\n    p = reflectInto(p, h1, foldCount);\n    p = reflectInto(p, h2, foldCount);\n    p = reflectInto(p, h3, foldCount);\n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n  \n  \n  \n\n\nBeautiful! The “F” shows us exactly how each triangle relates to its neighbors through reflection.\n\n\n\n\n\n\nNoteThe Power of Abstraction\n\n\n\nCompare the square and triangle tilings. The folding loop is identical—only the half-space definitions change. This abstraction will pay off enormously when we move to hyperbolic geometry: the algorithm stays the same, we just need different reflection operations!\n\n\n\n\n\n\nWe’ve seen the folding algorithm work for strips, squares, and triangles. But why does it work? The answer comes from group theory.\n\n\nEach reflection across a half-space boundary is an isometry—a transformation that preserves distances. When we compose reflections, we get more isometries. The set of all such compositions forms a group called a reflection group (or Coxeter group).\nFor our triangle tiling, the group is generated by three reflections \\(r_1, r_2, r_3\\) across the three edges. Every element of the group is a finite product of these generators: \\[g = r_{i_1} \\circ r_{i_2} \\circ \\cdots \\circ r_{i_k}\\]\n\n\n\nOur triangle (or square) is a fundamental domain for the group action. This means:\n\nThe images of the fundamental domain under all group elements tile the plane: every point lies in some image \\(g(F)\\)\nDifferent images don’t overlap (except on boundaries): if \\(g \\neq h\\), then \\(g(F)\\) and \\(h(F)\\) have disjoint interiors\n\n\n\n\n[PROOF HERE]\n\n\n\nWhat our shader computes is the orbit map: for each point \\(p\\), find the unique group element \\(g\\) such that \\(g(p) \\in F\\). The folded position is \\(g(p)\\), and the fold count tells us \\(|g|\\) (the length of \\(g\\) as a word in the generators).\nParity coloring works because reflections have determinant \\(-1\\): an odd number of reflections reverses orientation, an even number preserves it.\n\n\n\n\nSo far we’ve tiled the Euclidean plane. Now we’ll tile the hyperbolic plane—a geometry with constant negative curvature, where the folding algorithm works exactly the same way.\n\n\nWe represent the hyperbolic plane as the upper half-plane: \\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThe real axis \\(y = 0\\) is the boundary at infinity—not part of the space, but infinitely far away from every interior point.\nWhat makes this hyperbolic rather than Euclidean is the metric: distances are scaled by \\(1/y\\). Near the boundary (\\(y\\) small), distances are stretched enormously. High up (\\(y\\) large), distances are compressed. The Riemannian metric is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\n\n\n\nThe distance between two points \\(z_1 = x_1 + iy_1\\) and \\(z_2 = x_2 + iy_2\\) is: \\[d(z_1, z_2) = \\text{arccosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2 y_1 y_2}\\right)\\]\nThis formula captures the key property: distances grow without bound as either point approaches the boundary (\\(y \\to 0\\)). The boundary is infinitely far from any interior point.\n\n\n\n\n\n\nIn hyperbolic geometry, the “straight lines” are called geodesics. In the upper half-plane model, geodesics come in two types:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c\\)\nSemicircles: centered on the real axis\n\nBoth meet the boundary at right angles.\n\n\n\nJust as in Euclidean geometry, a geodesic divides the plane into two half-spaces. We define a struct for each type:\nstruct HalfSpaceVert {\n    float x;      // vertical line at x = c\n    float side;   // +1: want x &lt; c, -1: want x &gt; c\n};\n\nstruct HalfSpaceCirc {\n    float center;   // center of semicircle (on real axis)\n    float radius;   // radius of semicircle\n    float side;     // +1: want outside circle, -1: want inside\n};\nLet’s visualize one of each:\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nbool inside(vec2 z, HalfSpaceVert h) {\n    return (z.x - h.x) * h.side &lt; 0.0;\n}\n\nbool inside(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    return (dist2 - h.radius * h.radius) * h.side &gt; 0.0;\n}\n\n  Missing Demo\n  Shader demo day3/hyp-halfspaces not found.\n\n\nThe blue region is “inside” the vertical half-space (where \\(x &gt; 1\\)). The orange-tinted region is “inside” the circular half-space (outside the semicircle). Where they overlap, the colors blend.\n\n\n\nNow we define reflectInto for each type. For a vertical half-space, we flip the \\(x\\)-coordinate:\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    if ((z.x - h.x) * h.side &lt; 0.0) return z;  // Already inside\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\nFor a circular half-space, we use circle inversion:\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;  // Already inside\n    \n    // Circle inversion\n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\n\n\n\n\n\nImportantConnection to Day 2\n\n\n\nThis is exactly the circle inversion formula from Day 2! When we inverted through circles in the Apollonian gasket, we were performing hyperbolic reflections. The Apollonian gasket lives in hyperbolic space—we just didn’t know it yet.\n\n\nLet’s see these reflections in action. We’ll place our “F” and reflect it across each type of half-space, alternating between them:\n\n  \n  \n  \n\n\nThe shader alternates every 2 seconds: first reflecting across the vertical line (F flips horizontally), then across the semicircle (F gets inverted through the circle, distorting its shape).\n\n\n\nNow we can tile the hyperbolic plane! The \\((2,3,\\infty)\\) triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an ideal vertex at infinity). We set it up with:\n\nLeft boundary: Vertical line at \\(x = 0\\), want \\(x &gt; 0\\)\nRight boundary: Vertical line at \\(x = 1/2\\), want \\(x &lt; 1/2\\)\nBottom boundary: Unit semicircle centered at origin, want outside\n\nThe vertices are at \\(i\\) (angle \\(\\pi/2\\)), at \\(\\frac{1}{2} + \\frac{\\sqrt{3}}{2}i\\) (angle \\(\\pi/3\\)), and at infinity where the two vertical lines meet (angle \\(0\\)).\n\n  \n  \n  \n\n\nThe blue region is our fundamental domain—the \\((2,3,\\infty)\\) triangle where all three half-space conditions are satisfied. Now let’s tile!\nThe reflectInto functions are the same as before, now with inout int count to track reflections. The mainImage is:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    // (2,3,∞) triangle\n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);        // x &gt; 0\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);        // x &lt; 0.5\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);  // outside unit circle\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThe hyperbolic tiling emerges! Notice how the triangles appear to shrink as they approach the boundary—they’re all the same hyperbolic size, but Euclidean distances compress near \\(y = 0\\).\n\n\n\n\n\n\nNoteCompare to Euclidean\n\n\n\nThe structure is identical to our Euclidean tilings:\nEuclidean triangle:\np = reflectInto(p, h1, foldCount);\np = reflectInto(p, h2, foldCount);\np = reflectInto(p, h3, foldCount);\nHyperbolic triangle:\nz = reflectInto(z, left, foldCount);\nz = reflectInto(z, right, foldCount);\nz = reflectInto(z, bottom, foldCount);\nSame loop structure, same counting. The only difference is the type of half-space (and thus which reflectInto overload is called). This is the power of abstraction!\n\n\n\n\n\n\nThe upper half-plane is just one way to visualize hyperbolic geometry. The Poincaré disk model fits the entire hyperbolic plane inside a unit disk, making the global structure easier to see.\n\n\nIn the Poincaré disk model: - The hyperbolic plane is the open unit disk \\(\\{z : |z| &lt; 1\\}\\) - The boundary circle \\(|z| = 1\\) represents infinity - Geodesics are circular arcs perpendicular to the boundary (and diameters)\n\n\n\nWe convert between models using the Cayley transform:\n\\[w = \\frac{z - i}{z + i}\\]\nThis maps the upper half-plane to the unit disk, sending \\(i \\mapsto 0\\) and the real axis to the unit circle. The inverse is:\n\\[z = i\\frac{1 + w}{1 - w}\\]\nTo display our tiling in the Poincaré disk, we add complex arithmetic helpers and a conversion function:\n// Complex multiplication and division\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\n// Poincaré disk to upper half-plane\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\nIn mainImage, we start with disk coordinates and convert to UHP before folding:\nvec2 w = normalize_coord(fragCoord);  // Disk coordinates\nvec2 z = diskToUHP(w);                // Convert to UHP\n\n// ... same folding code as before ...\n\n// Darken outside disk\nif (length(w) &gt; 1.0) color = vec3(0.05);\n\n  \n  \n  \n\n\nThe same tiling, now visible in its entirety! The disk model shows the beautiful self-similarity of hyperbolic tilings—triangles recede toward the boundary in an infinite cascade.\n\n\n\nLet’s add our “F” to see the reflections clearly. We draw the F in the fundamental domain, and the folding algorithm automatically tiles it across the hyperbolic plane:\n\n  \n  \n  \n\n\nThe “F” tiles the hyperbolic plane! Notice how reflected copies flip orientation—each triangle’s F is a mirror image of its neighbors, exactly as in our Euclidean tilings.\n\n\n\n\n\n\nC1. Hyperbolic Circles. Draw hyperbolic circles around the mouse position. Use the distance formula: \\[d(z_1, z_2) = \\text{arccosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2 y_1 y_2}\\right)\\]\nIn GLSL, \\(\\text{arccosh}(x) = \\log(x + \\sqrt{x^2 - 1})\\).\nDraw two circles: one with hyperbolic radius 0.1 (small) and one with radius 0.5 (larger). Color pixels where the distance from the mouse is within 0.02 of these target radii.\nNotice how the circles change shape as you move the mouse toward the boundary—they stretch horizontally and compress vertically, reflecting the hyperbolic metric.\nC2. Edges of the (2,3,∞) Tiling. Add edge drawing to the hyperbolic tiling. After folding to the fundamental domain, check hyperbolic distance to each geodesic boundary.\nDistance to vertical geodesic at \\(x = c\\): \\[d(z, \\text{geodesic}) = \\text{arccosh}\\left(\\frac{|z - c|}{y}\\right)\\]\nwhere \\(|z - c| = \\sqrt{(x-c)^2 + y^2}\\) is the Euclidean distance to the point \\((c, 0)\\).\nfloat distToGeodesic(vec2 z, HalfSpaceVert h) {\n    z.x -= h.x;\n    return acosh(length(z) / z.y);\n}\nDistance to semicircular geodesic centered at \\(c\\) with radius \\(r\\):\nThe trick is to apply a Möbius transformation that sends the semicircle to a vertical line, then use the formula above. The transformation \\(w = \\frac{z - (c+r)}{z - (c-r)}\\) sends the endpoints \\(c \\pm r\\) to \\(0\\) and \\(\\infty\\), mapping the semicircle to the imaginary axis.\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    // Möbius transform sending semicircle to imaginary axis\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    \n    // Distance to vertical geodesic at x = 0\n    return acosh(length(w) / w.y);\n}\nDraw the edge white where distance &lt; 0.03. The edges should have consistent hyperbolic thickness—appearing to fan out near the boundary in Euclidean terms.\n\n\n\nE1. Vertices and Edges in Both Models. Extend C2 to also draw vertices. The \\((2,3,\\infty)\\) triangle has vertices at:\n\n\\(z = i\\) (angle \\(\\pi/2\\))\n\\(z = \\frac{1}{2} + \\frac{\\sqrt{3}}{2}i\\) (angle \\(\\pi/3\\))\n\\(z = \\infty\\) (ideal vertex—don’t draw this one)\n\nAfter folding, check if the folded point is near one of these vertices and draw a small circle.\nThen adapt your shader to work in the Poincaré disk: apply your edge/vertex drawing after folding but before converting back. The same tiling should appear, now curved into the disk.\nE2. The Klein Disk Model. The Klein disk (or Beltrami-Klein model) represents the hyperbolic plane in a unit disk where geodesics appear as straight Euclidean line segments. This makes some properties clearer but distorts angles.\nThe conversions are:\nPoincaré → Klein: \\[k = \\frac{2w}{1 + |w|^2}\\]\nKlein → Poincaré: \\[w = \\frac{k}{1 + \\sqrt{1 - |k|^2}}\\]\nImplement these and display the \\((2,3,\\infty)\\) tiling in the Klein model. Notice how the curved geodesics become straight lines! The triangles look like ordinary Euclidean triangles, but they’re all the same hyperbolic size.\nE3. The Band Model. The band model maps the hyperbolic plane to an infinite horizontal strip of height \\(\\pi\\). It’s useful for visualizing hyperbolic translations.\nThe conversion from Poincaré disk uses the complex logarithm:\nPoincaré → Band: \\[b = \\log\\left(\\frac{1 + w}{1 - w}\\right)\\]\nwhere the result has real part in \\((-\\infty, \\infty)\\) and imaginary part in \\((0, \\pi)\\).\nIn GLSL, implement this as:\nvec2 poincareToБand(vec2 w) {\n    // (1+w)/(1-w) as complex division\n    vec2 num = vec2(1.0, 0.0) + w;\n    vec2 denom = vec2(1.0, 0.0) - w;\n    vec2 ratio = cdiv(num, denom);\n    // Complex log: log|z| + i*arg(z)\n    return vec2(0.5 * log(dot(ratio, ratio)), atan(ratio.y, ratio.x));\n}\nDisplay the tiling in the band model. Horizontal translation in the band corresponds to hyperbolic translation along a geodesic!\nE4. Interactive Möbius Transformations. The isometries of the hyperbolic plane are Möbius transformations: \\[z \\mapsto \\frac{az + b}{cz + d}\\] where \\(a, b, c, d\\) are real and \\(ad - bc = 1\\) (for the upper half-plane).\nThese transformations preserve hyperbolic distances and map geodesics to geodesics. They form the group \\(\\text{PSL}(2, \\mathbb{R})\\).\nSome useful isometries:\nHorizontal translation by distance \\(t\\): \\[z \\mapsto z + t\\]\nScaling (hyperbolic translation along the \\(y\\)-axis) by factor \\(k\\): \\[z \\mapsto kz\\]\nRotation around \\(i\\) by angle \\(\\theta\\): \\[z \\mapsto \\frac{z \\cos(\\theta/2) + \\sin(\\theta/2)}{-z \\sin(\\theta/2) + \\cos(\\theta/2)}\\]\nMake the tiling interactive: use mouse x-position to control horizontal translation and mouse y-position to control scaling. The tiling should slide and zoom while preserving its structure.\n\n\n\nH1. Animated Model Transitions. Create a smooth animation morphing between the upper half-plane and Poincaré disk.\nThe key insight: the Cayley transform \\(w = \\frac{z - i}{z + i}\\) is itself a Möbius transformation. You can interpolate between the identity and the Cayley transform using a one-parameter family.\nOne approach: the Cayley transform sends \\(i \\mapsto 0\\). Construct a family of Möbius transformations \\(T_t\\) where \\(T_0\\) is the identity and \\(T_1\\) is the Cayley transform. Use the matrix representation and interpolate.\nAlternatively, interpolate the visual effect: blend between UHP coordinates and disk coordinates based on time.\nH2. Dual Tiling. Every tiling has a dual obtained by connecting the centers of adjacent tiles.\nFor the triangle tiling, find the incenter (or centroid) of each fundamental triangle. Draw geodesics connecting centers of adjacent triangles instead of the original edges.\nHint: after folding, you know which fundamental domain you’re in. The center of a \\((2,3,\\infty)\\) triangle is at approximately \\(z = 0.25 + 1.1i\\). Use the fold sequence to transform this center to each tile.\nH3. Single-Edge Tilings. Instead of drawing all three edges of each triangle, draw only ONE edge (say, the circular geodesic at the bottom).\nThis creates a different pattern: pairs of triangles glued along the missing edges form quadrilaterals. You get the “order-2” truncation of the original tiling.\nTry drawing only the left vertical edge, or only the right vertical edge. Each choice produces a different pattern!\n\n\n\nP1. General (p,q,r) Triangle Tilings. Implement tilings for arbitrary triangle groups \\((p, q, r)\\) where the angles are \\(\\pi/p\\), \\(\\pi/q\\), and \\(\\pi/r\\).\nThe geometry: For a hyperbolic triangle (where \\(\\frac{1}{p} + \\frac{1}{q} + \\frac{1}{r} &lt; 1\\)), you need to compute the geodesics forming the edges. This requires solving for:\n\nThe positions of the three vertices\nThe semicircles (or vertical lines) connecting them\n\nFor a triangle with one ideal vertex (like \\((2,3,\\infty)\\)), two edges are vertical lines and one is a semicircle. For a compact triangle (like \\((2,3,7)\\)), all three edges are semicircles.\nThe algorithm: 1. Place one vertex at a convenient location (e.g., on the positive imaginary axis) 2. Use the angle constraints to determine the other vertices 3. Compute the semicircle through each pair of vertices\nImplementation: - Allow the user to input \\(p\\), \\(q\\), \\(r\\) (perhaps via uniforms or compile-time constants) - Validate that the triangle is hyperbolic - Compute and draw the tiling with edges and vertices - Show the tiling in both UHP and Poincaré disk models\nThis is a substantial project requiring both geometric reasoning and careful implementation!",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day3.html#the-folding-algorithm",
    "href": "lectures/day3.html#the-folding-algorithm",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "Our goal today is to draw beautiful tilings—of the plane, the hyperbolic plane, and beyond—efficiently on the GPU. We’ll learn a powerful technique: fold any point back into a fundamental domain by repeatedly reflecting across boundaries. The algorithm is simple, parallelizes perfectly, and works identically in Euclidean and hyperbolic geometry.\n\n\nLet’s start with the simplest case: tiling the plane with horizontal strips. We define a fundamental domain—the strip where \\(0 &lt; x &lt; 1\\)—and reflect any point outside back in.\nThe reflection across a vertical line \\(x = c\\) is simple: \\((x, y) \\mapsto (2c - x, y)\\).\nThe algorithm:\n\nIf \\(x &lt; 0\\), reflect across \\(x = 0\\)\nIf \\(x &gt; 1\\), reflect across \\(x = 1\\)\nRepeat until the point stops moving\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fold into the strip [0, 1]\n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;           // Reflect across x = 0\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;      // Reflect across x = 1\n    }\n    \n    // Draw a circle in the fundamental domain\n    float d = length(p - vec2(0.5, 0.0));\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    if (d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThe circle tiles the entire strip! But circles are symmetric—we can’t tell if tiles are being reflected or just translated. Let’s draw something asymmetric instead.\nWe’ll use the letter “F”, which has no mirror symmetry. We define a helper function that draws an F centered at the origin:\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    // Vertical bar\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    // Top horizontal bar\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    // Middle horizontal bar\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\nThen we replace the circle drawing with a call to drawF:\nvec3 color = drawF(p - vec2(0.5, 0.0), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n\n  \n  \n  \n\n\nNow we can see what’s happening: the “F” alternates between normal and mirrored! This is reflection, not translation. Each time we cross a boundary, the image flips. We draw the shape once in the fundamental domain, and the folding algorithm tiles it everywhere.\n\n\n\nExtending to two dimensions is straightforward—just add boundaries for \\(y\\):\n// Fold into the square [0,1] × [0,1]\nfor (int i = 0; i &lt; 20; i++) {\n    if (p.x &lt; 0.0) p.x = -p.x;\n    if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n    if (p.y &lt; 0.0) p.y = -p.y;\n    if (p.y &gt; 1.0) p.y = 2.0 - p.y;\n}\n\n  \n  \n  \n\n\nThe “F” now tiles in both directions, with reflections across all four boundaries creating a kaleidoscopic pattern.\n\n\n\nLet’s track how many reflections were needed to reach the fundamental domain. This reveals the structure of the tiling:\n// Fold into the square, counting reflections\nint foldCount = 0;\nfor (int i = 0; i &lt; 20; i++) {\n    vec2 p0 = p;\n    \n    if (p.x &lt; 0.0) { p.x = -p.x; foldCount++; }\n    if (p.x &gt; 1.0) { p.x = 2.0 - p.x; foldCount++; }\n    if (p.y &lt; 0.0) { p.y = -p.y; foldCount++; }\n    if (p.y &gt; 1.0) { p.y = 2.0 - p.y; foldCount++; }\n    \n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n// Color by fold count\nfloat t = float(foldCount) / 10.0;\nvec3 color = 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));\n\n  \n  \n  \n\n\nPoints near the fundamental domain (center of screen) need few reflections; points far away need many. The color bands show “distance” in terms of reflection count.\n\n\n\nFor tilings, we often want to distinguish adjacent tiles. The parity of the fold count (odd vs even) gives us a checkerboard pattern:\n// After folding...\nfloat parity = mod(float(foldCount), 2.0);\nvec3 color = (parity &lt; 0.5) \n    ? vec3(0.9, 0.85, 0.8)   // Light\n    : vec3(0.3, 0.35, 0.4);  // Dark\n\n  \n  \n  \n\n\nThis works because each reflection flips orientation—an odd number of reflections gives a mirror image of the fundamental domain, while an even number preserves orientation.",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day3.html#half-spaces-and-reflections",
    "href": "lectures/day3.html#half-spaces-and-reflections",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "Looking at our square tiling code, we see a repeated pattern: check if we’re outside a boundary, reflect if so. Let’s abstract this so we can handle arbitrary shapes—including triangles, which will be our gateway to hyperbolic geometry.\n\n\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions:\n\nPoints where \\(ax + by &lt; c\\)\nPoints where \\(ax + by &gt; c\\)\n\nWe encode a half-space by storing the line and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line: ax + by = c\n    float side;     // +1 or -1: which side we want\n};\nThe side parameter determines our inequality: we’re “inside” the half-space when \\((ax + by - c) \\cdot \\text{side} &lt; 0\\).\n\n\n\nTwo functions do all the work. First, checking if a point is inside:\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\nSecond, reflecting into the half-space (only if we’re outside):\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    \n    // Already inside?\n    if (val * h.side &lt; 0.0) return p;\n    \n    // Reflect across the boundary line\n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);  // Unit normal\n    float dist = val / length(vec2(h.a, h.b));  // Signed distance to line\n    count++;\n    return p - 2.0 * dist * n;\n}\n\n\n\n\n\n\nNoteGLSL: The inout Keyword\n\n\n\nThe inout keyword lets a function both read and modify a variable passed to it. When we write:\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count)\nthe count parameter is passed by reference—changes inside the function affect the original variable. This is how we track the total number of reflections: each call to reflectInto can increment the same counter.\nGLSL has three parameter modes: - in (default): pass by value, function gets a copy - out: function must write to it, caller receives the value - inout: function can read and write, changes persist\nThis is similar to reference parameters in C++ or ref in C#.\n\n\nThe reflection formula comes from linear algebra: we move the point by twice its signed distance to the line, in the normal direction. We also increment the count each time we actually reflect.\n\n\n\nLet’s see what a half-space looks like:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\nIn mainImage, we test whether each point is inside and color accordingly:\n// Half-space: x &lt; 1 (left side of vertical line)\nHalfSpace h = HalfSpace(1.0, 0.0, 1.0, 1.0);\n\nvec3 color = inside(p, h) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.15);\n\n// Draw the boundary line\nfloat dist = abs(h.a * p.x + h.b * p.y - h.c) / length(vec2(h.a, h.b));\nif (dist &lt; 0.03) color = vec3(1.0);\n\n  \n  \n  \n\n\nThe blue region is “inside” the half-space. Try changing the parameters to see different lines and sides!\n\n\n\nLet’s rebuild our square tiling using this abstraction. The square \\([0, 1] \\times [0, 1]\\) is defined by four half-spaces:\n\nLeft edge (\\(x = 0\\)): want \\(x &gt; 0\\), so HalfSpace(1.0, 0.0, 0.0, -1.0)\nRight edge (\\(x = 1\\)): want \\(x &lt; 1\\), so HalfSpace(1.0, 0.0, 1.0, 1.0)\nBottom edge (\\(y = 0\\)): want \\(y &gt; 0\\), so HalfSpace(0.0, 1.0, 0.0, -1.0)\nTop edge (\\(y = 1\\)): want \\(y &lt; 1\\), so HalfSpace(0.0, 1.0, 1.0, 1.0)\n\nWe need a function that reflects a point into a half-space if it’s outside:\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    if (val * h.side &lt; 0.0) return p;  // Already inside\n    \n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);\n    float dist = val / length(vec2(h.a, h.b));\n    count++;\n    return p - 2.0 * dist * n;\n}\nNow the folding loop becomes:\n// Four half-spaces defining [0,1] × [0,1]\nHalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\nHalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\nHalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\nHalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n\nint foldCount = 0;\nfor (int i = 0; i &lt; 20; i++) {\n    vec2 p0 = p;\n    p = reflectInto(p, left, foldCount);\n    p = reflectInto(p, right, foldCount);\n    p = reflectInto(p, bottom, foldCount);\n    p = reflectInto(p, top, foldCount);\n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n  \n  \n  \n\n\nIt works! The result is identical to our earlier square tiling, but now the code is structured around half-spaces.\n\n\n\nNow the payoff—changing from a square to a triangle just means changing the half-space definitions. An equilateral triangle centered at the origin:\n// Three half-spaces defining equilateral triangle\nHalfSpace h1 = HalfSpace(0.0, 1.0, -0.5, -1.0);           // Bottom edge\nHalfSpace h2 = HalfSpace(0.866, -0.5, -0.5, -1.0);        // Upper-right edge  \nHalfSpace h3 = HalfSpace(-0.866, -0.5, -0.5, -1.0);       // Upper-left edge\n\n// Fold into triangle (three reflections instead of four)\nfor (int i = 0; i &lt; 30; i++) {\n    vec2 p0 = p;\n    p = reflectInto(p, h1, foldCount);\n    p = reflectInto(p, h2, foldCount);\n    p = reflectInto(p, h3, foldCount);\n    if (length(p - p0) &lt; 0.0001) break;\n}\n\n  \n  \n  \n\n\nBeautiful! The “F” shows us exactly how each triangle relates to its neighbors through reflection.\n\n\n\n\n\n\nNoteThe Power of Abstraction\n\n\n\nCompare the square and triangle tilings. The folding loop is identical—only the half-space definitions change. This abstraction will pay off enormously when we move to hyperbolic geometry: the algorithm stays the same, we just need different reflection operations!",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day3.html#why-it-works",
    "href": "lectures/day3.html#why-it-works",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "We’ve seen the folding algorithm work for strips, squares, and triangles. But why does it work? The answer comes from group theory.\n\n\nEach reflection across a half-space boundary is an isometry—a transformation that preserves distances. When we compose reflections, we get more isometries. The set of all such compositions forms a group called a reflection group (or Coxeter group).\nFor our triangle tiling, the group is generated by three reflections \\(r_1, r_2, r_3\\) across the three edges. Every element of the group is a finite product of these generators: \\[g = r_{i_1} \\circ r_{i_2} \\circ \\cdots \\circ r_{i_k}\\]\n\n\n\nOur triangle (or square) is a fundamental domain for the group action. This means:\n\nThe images of the fundamental domain under all group elements tile the plane: every point lies in some image \\(g(F)\\)\nDifferent images don’t overlap (except on boundaries): if \\(g \\neq h\\), then \\(g(F)\\) and \\(h(F)\\) have disjoint interiors\n\n\n\n\n[PROOF HERE]\n\n\n\nWhat our shader computes is the orbit map: for each point \\(p\\), find the unique group element \\(g\\) such that \\(g(p) \\in F\\). The folded position is \\(g(p)\\), and the fold count tells us \\(|g|\\) (the length of \\(g\\) as a word in the generators).\nParity coloring works because reflections have determinant \\(-1\\): an odd number of reflections reverses orientation, an even number preserves it.",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day3.html#hyperbolic-geometry",
    "href": "lectures/day3.html#hyperbolic-geometry",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "So far we’ve tiled the Euclidean plane. Now we’ll tile the hyperbolic plane—a geometry with constant negative curvature, where the folding algorithm works exactly the same way.\n\n\nWe represent the hyperbolic plane as the upper half-plane: \\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThe real axis \\(y = 0\\) is the boundary at infinity—not part of the space, but infinitely far away from every interior point.\nWhat makes this hyperbolic rather than Euclidean is the metric: distances are scaled by \\(1/y\\). Near the boundary (\\(y\\) small), distances are stretched enormously. High up (\\(y\\) large), distances are compressed. The Riemannian metric is: \\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\n\n\n\nThe distance between two points \\(z_1 = x_1 + iy_1\\) and \\(z_2 = x_2 + iy_2\\) is: \\[d(z_1, z_2) = \\text{arccosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2 y_1 y_2}\\right)\\]\nThis formula captures the key property: distances grow without bound as either point approaches the boundary (\\(y \\to 0\\)). The boundary is infinitely far from any interior point.",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day3.html#hyperbolic-reflections-and-tilings",
    "href": "lectures/day3.html#hyperbolic-reflections-and-tilings",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "In hyperbolic geometry, the “straight lines” are called geodesics. In the upper half-plane model, geodesics come in two types:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c\\)\nSemicircles: centered on the real axis\n\nBoth meet the boundary at right angles.\n\n\n\nJust as in Euclidean geometry, a geodesic divides the plane into two half-spaces. We define a struct for each type:\nstruct HalfSpaceVert {\n    float x;      // vertical line at x = c\n    float side;   // +1: want x &lt; c, -1: want x &gt; c\n};\n\nstruct HalfSpaceCirc {\n    float center;   // center of semicircle (on real axis)\n    float radius;   // radius of semicircle\n    float side;     // +1: want outside circle, -1: want inside\n};\nLet’s visualize one of each:\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nbool inside(vec2 z, HalfSpaceVert h) {\n    return (z.x - h.x) * h.side &lt; 0.0;\n}\n\nbool inside(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    return (dist2 - h.radius * h.radius) * h.side &gt; 0.0;\n}\n\n  Missing Demo\n  Shader demo day3/hyp-halfspaces not found.\n\n\nThe blue region is “inside” the vertical half-space (where \\(x &gt; 1\\)). The orange-tinted region is “inside” the circular half-space (outside the semicircle). Where they overlap, the colors blend.\n\n\n\nNow we define reflectInto for each type. For a vertical half-space, we flip the \\(x\\)-coordinate:\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    if ((z.x - h.x) * h.side &lt; 0.0) return z;  // Already inside\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\nFor a circular half-space, we use circle inversion:\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;  // Already inside\n    \n    // Circle inversion\n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\n\n\n\n\n\nImportantConnection to Day 2\n\n\n\nThis is exactly the circle inversion formula from Day 2! When we inverted through circles in the Apollonian gasket, we were performing hyperbolic reflections. The Apollonian gasket lives in hyperbolic space—we just didn’t know it yet.\n\n\nLet’s see these reflections in action. We’ll place our “F” and reflect it across each type of half-space, alternating between them:\n\n  \n  \n  \n\n\nThe shader alternates every 2 seconds: first reflecting across the vertical line (F flips horizontally), then across the semicircle (F gets inverted through the circle, distorting its shape).\n\n\n\nNow we can tile the hyperbolic plane! The \\((2,3,\\infty)\\) triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an ideal vertex at infinity). We set it up with:\n\nLeft boundary: Vertical line at \\(x = 0\\), want \\(x &gt; 0\\)\nRight boundary: Vertical line at \\(x = 1/2\\), want \\(x &lt; 1/2\\)\nBottom boundary: Unit semicircle centered at origin, want outside\n\nThe vertices are at \\(i\\) (angle \\(\\pi/2\\)), at \\(\\frac{1}{2} + \\frac{\\sqrt{3}}{2}i\\) (angle \\(\\pi/3\\)), and at infinity where the two vertical lines meet (angle \\(0\\)).\n\n  \n  \n  \n\n\nThe blue region is our fundamental domain—the \\((2,3,\\infty)\\) triangle where all three half-space conditions are satisfied. Now let’s tile!\nThe reflectInto functions are the same as before, now with inout int count to track reflections. The mainImage is:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    // (2,3,∞) triangle\n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);        // x &gt; 0\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);        // x &lt; 0.5\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);  // outside unit circle\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThe hyperbolic tiling emerges! Notice how the triangles appear to shrink as they approach the boundary—they’re all the same hyperbolic size, but Euclidean distances compress near \\(y = 0\\).\n\n\n\n\n\n\nNoteCompare to Euclidean\n\n\n\nThe structure is identical to our Euclidean tilings:\nEuclidean triangle:\np = reflectInto(p, h1, foldCount);\np = reflectInto(p, h2, foldCount);\np = reflectInto(p, h3, foldCount);\nHyperbolic triangle:\nz = reflectInto(z, left, foldCount);\nz = reflectInto(z, right, foldCount);\nz = reflectInto(z, bottom, foldCount);\nSame loop structure, same counting. The only difference is the type of half-space (and thus which reflectInto overload is called). This is the power of abstraction!",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day3.html#other-models",
    "href": "lectures/day3.html#other-models",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "The upper half-plane is just one way to visualize hyperbolic geometry. The Poincaré disk model fits the entire hyperbolic plane inside a unit disk, making the global structure easier to see.\n\n\nIn the Poincaré disk model: - The hyperbolic plane is the open unit disk \\(\\{z : |z| &lt; 1\\}\\) - The boundary circle \\(|z| = 1\\) represents infinity - Geodesics are circular arcs perpendicular to the boundary (and diameters)\n\n\n\nWe convert between models using the Cayley transform:\n\\[w = \\frac{z - i}{z + i}\\]\nThis maps the upper half-plane to the unit disk, sending \\(i \\mapsto 0\\) and the real axis to the unit circle. The inverse is:\n\\[z = i\\frac{1 + w}{1 - w}\\]\nTo display our tiling in the Poincaré disk, we add complex arithmetic helpers and a conversion function:\n// Complex multiplication and division\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\n// Poincaré disk to upper half-plane\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\nIn mainImage, we start with disk coordinates and convert to UHP before folding:\nvec2 w = normalize_coord(fragCoord);  // Disk coordinates\nvec2 z = diskToUHP(w);                // Convert to UHP\n\n// ... same folding code as before ...\n\n// Darken outside disk\nif (length(w) &gt; 1.0) color = vec3(0.05);\n\n  \n  \n  \n\n\nThe same tiling, now visible in its entirety! The disk model shows the beautiful self-similarity of hyperbolic tilings—triangles recede toward the boundary in an infinite cascade.\n\n\n\nLet’s add our “F” to see the reflections clearly. We draw the F in the fundamental domain, and the folding algorithm automatically tiles it across the hyperbolic plane:\n\n  \n  \n  \n\n\nThe “F” tiles the hyperbolic plane! Notice how reflected copies flip orientation—each triangle’s F is a mirror image of its neighbors, exactly as in our Euclidean tilings.",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day3.html#exercises",
    "href": "lectures/day3.html#exercises",
    "title": "1 Day 3: Tilings",
    "section": "",
    "text": "C1. Hyperbolic Circles. Draw hyperbolic circles around the mouse position. Use the distance formula: \\[d(z_1, z_2) = \\text{arccosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2 y_1 y_2}\\right)\\]\nIn GLSL, \\(\\text{arccosh}(x) = \\log(x + \\sqrt{x^2 - 1})\\).\nDraw two circles: one with hyperbolic radius 0.1 (small) and one with radius 0.5 (larger). Color pixels where the distance from the mouse is within 0.02 of these target radii.\nNotice how the circles change shape as you move the mouse toward the boundary—they stretch horizontally and compress vertically, reflecting the hyperbolic metric.\nC2. Edges of the (2,3,∞) Tiling. Add edge drawing to the hyperbolic tiling. After folding to the fundamental domain, check hyperbolic distance to each geodesic boundary.\nDistance to vertical geodesic at \\(x = c\\): \\[d(z, \\text{geodesic}) = \\text{arccosh}\\left(\\frac{|z - c|}{y}\\right)\\]\nwhere \\(|z - c| = \\sqrt{(x-c)^2 + y^2}\\) is the Euclidean distance to the point \\((c, 0)\\).\nfloat distToGeodesic(vec2 z, HalfSpaceVert h) {\n    z.x -= h.x;\n    return acosh(length(z) / z.y);\n}\nDistance to semicircular geodesic centered at \\(c\\) with radius \\(r\\):\nThe trick is to apply a Möbius transformation that sends the semicircle to a vertical line, then use the formula above. The transformation \\(w = \\frac{z - (c+r)}{z - (c-r)}\\) sends the endpoints \\(c \\pm r\\) to \\(0\\) and \\(\\infty\\), mapping the semicircle to the imaginary axis.\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    // Möbius transform sending semicircle to imaginary axis\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    \n    // Distance to vertical geodesic at x = 0\n    return acosh(length(w) / w.y);\n}\nDraw the edge white where distance &lt; 0.03. The edges should have consistent hyperbolic thickness—appearing to fan out near the boundary in Euclidean terms.\n\n\n\nE1. Vertices and Edges in Both Models. Extend C2 to also draw vertices. The \\((2,3,\\infty)\\) triangle has vertices at:\n\n\\(z = i\\) (angle \\(\\pi/2\\))\n\\(z = \\frac{1}{2} + \\frac{\\sqrt{3}}{2}i\\) (angle \\(\\pi/3\\))\n\\(z = \\infty\\) (ideal vertex—don’t draw this one)\n\nAfter folding, check if the folded point is near one of these vertices and draw a small circle.\nThen adapt your shader to work in the Poincaré disk: apply your edge/vertex drawing after folding but before converting back. The same tiling should appear, now curved into the disk.\nE2. The Klein Disk Model. The Klein disk (or Beltrami-Klein model) represents the hyperbolic plane in a unit disk where geodesics appear as straight Euclidean line segments. This makes some properties clearer but distorts angles.\nThe conversions are:\nPoincaré → Klein: \\[k = \\frac{2w}{1 + |w|^2}\\]\nKlein → Poincaré: \\[w = \\frac{k}{1 + \\sqrt{1 - |k|^2}}\\]\nImplement these and display the \\((2,3,\\infty)\\) tiling in the Klein model. Notice how the curved geodesics become straight lines! The triangles look like ordinary Euclidean triangles, but they’re all the same hyperbolic size.\nE3. The Band Model. The band model maps the hyperbolic plane to an infinite horizontal strip of height \\(\\pi\\). It’s useful for visualizing hyperbolic translations.\nThe conversion from Poincaré disk uses the complex logarithm:\nPoincaré → Band: \\[b = \\log\\left(\\frac{1 + w}{1 - w}\\right)\\]\nwhere the result has real part in \\((-\\infty, \\infty)\\) and imaginary part in \\((0, \\pi)\\).\nIn GLSL, implement this as:\nvec2 poincareToБand(vec2 w) {\n    // (1+w)/(1-w) as complex division\n    vec2 num = vec2(1.0, 0.0) + w;\n    vec2 denom = vec2(1.0, 0.0) - w;\n    vec2 ratio = cdiv(num, denom);\n    // Complex log: log|z| + i*arg(z)\n    return vec2(0.5 * log(dot(ratio, ratio)), atan(ratio.y, ratio.x));\n}\nDisplay the tiling in the band model. Horizontal translation in the band corresponds to hyperbolic translation along a geodesic!\nE4. Interactive Möbius Transformations. The isometries of the hyperbolic plane are Möbius transformations: \\[z \\mapsto \\frac{az + b}{cz + d}\\] where \\(a, b, c, d\\) are real and \\(ad - bc = 1\\) (for the upper half-plane).\nThese transformations preserve hyperbolic distances and map geodesics to geodesics. They form the group \\(\\text{PSL}(2, \\mathbb{R})\\).\nSome useful isometries:\nHorizontal translation by distance \\(t\\): \\[z \\mapsto z + t\\]\nScaling (hyperbolic translation along the \\(y\\)-axis) by factor \\(k\\): \\[z \\mapsto kz\\]\nRotation around \\(i\\) by angle \\(\\theta\\): \\[z \\mapsto \\frac{z \\cos(\\theta/2) + \\sin(\\theta/2)}{-z \\sin(\\theta/2) + \\cos(\\theta/2)}\\]\nMake the tiling interactive: use mouse x-position to control horizontal translation and mouse y-position to control scaling. The tiling should slide and zoom while preserving its structure.\n\n\n\nH1. Animated Model Transitions. Create a smooth animation morphing between the upper half-plane and Poincaré disk.\nThe key insight: the Cayley transform \\(w = \\frac{z - i}{z + i}\\) is itself a Möbius transformation. You can interpolate between the identity and the Cayley transform using a one-parameter family.\nOne approach: the Cayley transform sends \\(i \\mapsto 0\\). Construct a family of Möbius transformations \\(T_t\\) where \\(T_0\\) is the identity and \\(T_1\\) is the Cayley transform. Use the matrix representation and interpolate.\nAlternatively, interpolate the visual effect: blend between UHP coordinates and disk coordinates based on time.\nH2. Dual Tiling. Every tiling has a dual obtained by connecting the centers of adjacent tiles.\nFor the triangle tiling, find the incenter (or centroid) of each fundamental triangle. Draw geodesics connecting centers of adjacent triangles instead of the original edges.\nHint: after folding, you know which fundamental domain you’re in. The center of a \\((2,3,\\infty)\\) triangle is at approximately \\(z = 0.25 + 1.1i\\). Use the fold sequence to transform this center to each tile.\nH3. Single-Edge Tilings. Instead of drawing all three edges of each triangle, draw only ONE edge (say, the circular geodesic at the bottom).\nThis creates a different pattern: pairs of triangles glued along the missing edges form quadrilaterals. You get the “order-2” truncation of the original tiling.\nTry drawing only the left vertical edge, or only the right vertical edge. Each choice produces a different pattern!\n\n\n\nP1. General (p,q,r) Triangle Tilings. Implement tilings for arbitrary triangle groups \\((p, q, r)\\) where the angles are \\(\\pi/p\\), \\(\\pi/q\\), and \\(\\pi/r\\).\nThe geometry: For a hyperbolic triangle (where \\(\\frac{1}{p} + \\frac{1}{q} + \\frac{1}{r} &lt; 1\\)), you need to compute the geodesics forming the edges. This requires solving for:\n\nThe positions of the three vertices\nThe semicircles (or vertical lines) connecting them\n\nFor a triangle with one ideal vertex (like \\((2,3,\\infty)\\)), two edges are vertical lines and one is a semicircle. For a compact triangle (like \\((2,3,7)\\)), all three edges are semicircles.\nThe algorithm: 1. Place one vertex at a convenient location (e.g., on the positive imaginary axis) 2. Use the angle constraints to determine the other vertices 3. Compute the semicircle through each pair of vertices\nImplementation: - Allow the user to input \\(p\\), \\(q\\), \\(r\\) (perhaps via uniforms or compile-time constants) - Validate that the triangle is hyperbolic - Compute and draw the tiling with edges and vertices - Show the tiling in both UHP and Poincaré disk models\nThis is a substantial project requiring both geometric reasoning and careful implementation!",
    "crumbs": [
      "Day 3: Tilings",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day4.html",
    "href": "lectures/day4.html",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "Missing Demo\n  Shader demo day4/barth-sextic-final not found.\n\n\nThis is the Barth sextic — an algebraic surface with 50 singular points and icosahedral symmetry, rendered entirely on the GPU.\nThis chapter covers a lot of ground. In class, we’ll focus on the fundamentals: cameras, rays, signed distance functions, and the raymarching algorithm. But if you work through the exercises and the final project, you can build something like what you see above — a rotating algebraic variety with multi-colored lighting and shadows.\nWe’ll start with the classical approach — solving ray-surface intersections analytically — and see why it becomes unwieldy for complex geometry. Then we’ll develop a more flexible technique: raymarching with signed distance functions. This approach lets us render almost anything we can describe mathematically, including the algebraic varieties that have fascinated geometers for centuries.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\nBy the end of today, you will be able to:\n\nSet up a camera and generate rays for each pixel\nCompute ray-surface intersections analytically\nUnderstand why analytical methods become challenging for complex geometry\nUse signed distance functions as an alternative representation\nImplement the raymarching algorithm (sphere tracing)\nBuild scenes with multiple objects and materials\n\n\n\n\n\n\nWe want to draw 3D scenes on a 2D screen. The basic question: for each pixel, what color should it be?\nThe answer comes from simulating how light reaches a camera. In the real world, light bounces around a scene and some of it enters a camera through its lens, forming an image. Simulating this fully is expensive, so we reverse the process: instead of tracing light from sources to the camera, we trace rays from the camera out into the scene. For each pixel, we ask: what does this ray hit, and what color is that surface?\n\n\nThe simplest camera model is the pinhole camera: all light enters through a single point. This means every ray passes through the same origin—the camera position. The only thing that varies from pixel to pixel is the ray’s direction.\nReal cameras have lenses with finite aperture, which create depth of field and focus effects. We ignore all of that. The pinhole model is mathematically clean: one point, many directions.\n\n\n\nWe need to agree on which way is “up.” We’ll use the standard graphics convention:\n\nY-axis points up\nZ-axis points toward the camera (out of the screen)\nX-axis points right\nRight-handed coordinate system\n\nOur camera sits at the origin, looking down the negative Z-axis. The scene lives in front of the camera, at negative Z values.\n\n\n\nA ray is a half-line: it starts at a point and extends infinitely in one direction. We parameterize it as:\n\\[\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(\\mathbf{o}\\) is the origin (camera position), \\(\\mathbf{d}\\) is the direction (unit vector), and \\(t \\geq 0\\) is the parameter. Points with \\(t &gt; 0\\) lie in front of the camera; \\(t = 0\\) is the camera itself.\nA ray has two parts: where it starts and where it points. We bundle these into a struct:\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\nFor our pinhole camera, the origin is the same for every ray—the camera position at \\((0, 0, 0)\\). Only the direction varies, depending on which pixel we’re computing.\n\n\n\nThe field of view (FOV) controls how wide the camera sees. To understand it precisely, imagine an image plane sitting at distance \\(f\\) in front of the camera (at \\(z = -f\\)). We set up coordinates so the visible portion of this plane spans \\([-1, 1]\\) in both \\(x\\) and \\(y\\). Each pixel maps to a point on this plane, and the ray direction is the vector from the camera through that point.\n\nThe FOV is the angle between rays hitting opposite edges of the screen. Half that angle, \\(\\theta = \\text{FOV}/2\\), is the angle from the center ray to the edge. A ray to the top edge of the image plane reaches the point \\((0, 1, -f)\\), forming a right triangle with opposite side 1 and adjacent side \\(f\\). So \\(\\tan(\\theta) = 1/f\\), giving us:\n\\[f = \\frac{1}{\\tan(\\text{FOV}/2)}\\]\nThe intuition: a wide FOV means the image plane is close, so rays spread out sharply. A narrow FOV means the image plane is far, so rays stay nearly parallel—like a telephoto lens.\n\n\n\nFor a pixel at screen position fragCoord, we compute its ray in three steps:\n\nNormalize pixel coordinates to \\([-1, 1]^2\\)\nCorrect for aspect ratio so circles render as circles\nForm the direction vector toward the image plane and normalize it\n\nRay generateRay(vec2 fragCoord) {\n    // Map pixel coordinates to [-1, 1]\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Focal length from field of view\n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    \n    return ray;\n}\nThe direction’s \\(z\\)-component is \\(-f\\) because we’re looking down the negative Z-axis. The normalize ensures our direction is a unit vector, which simplifies intersection calculations later.\n\n\n\nLet’s verify our setup by coloring each pixel according to its ray direction:\n\n  Missing Demo\n  Shader demo day4/ray-visualization not found.\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Map direction components from [-1,1] to [0,1] for display\n    vec3 color = ray.dir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}\nThe center of the screen is bluish (ray pointing straight into \\(-Z\\)), while the edges shift toward red and green (larger \\(X\\) and \\(Y\\) components). This gradient confirms our rays fan out correctly from the camera.\n\n\n\n\nWe have rays. Now we need to find where they hit things.\nThe core problem: given a ray \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) and a surface, find the value of \\(t\\) where they intersect. Once we know the intersection point, we can compute its color based on lighting and material properties.\n\n\nWe’ll start with the simplest 3D shape: a sphere. A sphere of radius \\(r\\) centered at \\(\\mathbf{c}\\) is the set of points satisfying:\n\\[|\\mathbf{p} - \\mathbf{c}|^2 = r^2\\]\nTo find where our ray intersects this sphere, we substitute the ray equation for \\(\\mathbf{p}\\):\n\\[|\\mathbf{o} + t\\mathbf{d} - \\mathbf{c}|^2 = r^2\\]\nLet \\(\\boldsymbol{\\delta} = \\mathbf{o} - \\mathbf{c}\\) be the vector from the sphere’s center to the ray’s origin. Expanding:\n\\[|\\boldsymbol{\\delta} + t\\mathbf{d}|^2 = r^2\\] \\[|\\boldsymbol{\\delta}|^2 + 2t(\\boldsymbol{\\delta} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nSince \\(\\mathbf{d}\\) is a unit vector, \\(|\\mathbf{d}|^2 = 1\\). Rearranging into standard quadratic form \\(at^2 + bt + c = 0\\):\n\\[t^2 + 2(\\boldsymbol{\\delta} \\cdot \\mathbf{d})t + (|\\boldsymbol{\\delta}|^2 - r^2) = 0\\]\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us how many solutions exist:\n\n\\(\\Delta &lt; 0\\): no intersection (ray misses the sphere)\n\\(\\Delta = 0\\): one intersection (ray grazes the sphere)\n\\(\\Delta &gt; 0\\): two intersections (ray enters and exits)\n\nWhen \\(\\Delta \\geq 0\\), we get:\n\\[t = -(\\boldsymbol{\\delta} \\cdot \\mathbf{d}) \\pm \\sqrt{(\\boldsymbol{\\delta} \\cdot \\mathbf{d})^2 - |\\boldsymbol{\\delta}|^2 + r^2}\\]\nWe want the smallest positive \\(t\\) — the first intersection in front of the camera.\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;  // First intersection in front\n    if (t2 &gt; 0.0) return t2;  // We're inside the sphere\n    return -1.0;              // Sphere is behind us\n}\nWe return \\(-1\\) as a sentinel value meaning “no intersection.” Since valid hits have \\(t &gt; 0\\) (the intersection is in front of the camera), any negative value would work — \\(-1\\) is just conventional. When we use this function, we check if (t &gt; 0.0) to see if we hit anything.\nLet’s test it:\n\n  Missing Demo\n  Shader demo day4/sphere-flat not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nIt works — but it looks like a flat red disk! We can’t see the sphere’s curvature because every hit pixel gets the same color. We need lighting.\n\n\n\nLighting depends on how a surface is oriented relative to the light. The surface normal is a unit vector perpendicular to the surface at a given point. For a sphere, the normal at point \\(\\mathbf{p}\\) points directly away from the center:\n\\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the direction from the center to the surface, normalized.\nWe can visualize the normals by mapping them to colors, just like we did with ray directions:\n\n  Missing Demo\n  Shader demo day4/sphere-normals not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        color = normal * 0.5 + 0.5;  // Map [-1,1] to [0,1]\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow we see the sphere’s shape! The normal points right (red) on the right side, up (green) on top, and toward us (blue) in the center. This is exactly the information we need for lighting.\n\n\n\n\n\nA matte surface scatters incoming light equally in all directions. The brightness depends only on the angle between the surface normal and the light direction: when light hits head-on, the surface is bright; when light hits at a glancing angle, less energy is deposited and the surface is dim.\nThis is Lambertian shading. If \\(\\mathbf{n}\\) is the surface normal and \\(\\mathbf{l}\\) is the direction toward the light, the brightness is:\n\\[I_{\\text{diffuse}} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max\\) ensures surfaces facing away from the light don’t go negative.\n\n  Missing Demo\n  Shader demo day4/sphere-diffuse not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Direction toward light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Shading\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse);\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow the sphere looks 3D! The side facing the light is bright, and it falls off smoothly into shadow. We’ve added a small ambient term (0.1) so the dark side isn’t completely black — in the real world, indirect light would fill in the shadows.\n\n\n\nShiny surfaces have highlights — bright spots where light reflects directly toward the viewer. This is specular reflection.\nThe Phong model computes specular highlights by comparing the reflection direction to the view direction. If \\(\\mathbf{r}\\) is the light direction reflected about the normal, and \\(\\mathbf{v}\\) is the direction toward the camera, then:\n\\[I_{\\text{specular}} = \\max(0, \\mathbf{r} \\cdot \\mathbf{v})^n\\]\nThe exponent \\(n\\) controls how tight the highlight is: large \\(n\\) gives a small, sharp highlight (like polished metal); small \\(n\\) gives a broad, soft highlight (like plastic).\nGLSL has a built-in reflect function: reflect(-lightDir, normal) gives the reflection of the incoming light direction about the normal.\n\n  Missing Demo\n  Shader demo day4/sphere-lit not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Directions\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Toward light\n        vec3 viewDir = -ray.dir;                         // Toward camera\n        vec3 reflectDir = reflect(-lightDir, normal);    // Light reflected about normal\n        \n        // Diffuse: brightness based on angle to light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Specular: bright spot where reflection aligns with view\n        float shininess = 32.0;\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), shininess);\n        \n        // Combine lighting\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe sphere now has a shiny highlight! Try changing the shininess from 32 to other values — 8 gives a soft plastic look, 128 gives a tight metallic gleam.\n\n\n\n\n\nThe sphere worked beautifully: substitute the ray equation, get a quadratic, solve with a formula you learned in high school. What about other shapes?\n\n\nA torus is the surface you get by revolving a circle around an axis — a donut shape. It’s defined by two radii: the major radius \\(R\\) (distance from the center of the torus to the center of the tube) and the minor radius \\(r\\) (the radius of the tube itself).\n\nThe implicit equation for a torus centered at the origin with the axis along \\(Y\\) is:\n\\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nThe inner square root computes the distance from the Y-axis; subtracting \\(R\\) gives the distance from the “core circle” of the torus; that quantity squared plus \\(y^2\\) equals \\(r^2\\) defines a tube of radius \\(r\\) around that core.\n\n\n\nTo find where a ray hits this surface, we substitute \\(\\mathbf{p} = \\mathbf{o} + t\\mathbf{d}\\) as before. The square root makes this awkward, so we first isolate and square it:\n\\[\\sqrt{x^2 + z^2} = R \\pm \\sqrt{r^2 - y^2}\\]\nAfter substituting the ray equation and squaring twice to eliminate the radicals, we get a quartic polynomial in \\(t\\):\n\\[a_4 t^4 + a_3 t^3 + a_2 t^2 + a_1 t + a_0 = 0\\]\nThe coefficients \\(a_i\\) are complicated expressions involving the ray origin, direction, and the two radii. Unlike the quadratic case, there’s no simple formula you can memorize. Solving a quartic requires either:\n\nThe quartic formula (which exists but is unwieldy), or\nNumerical methods (Newton’s method, bisection), or\nClever algebraic manipulation to reduce it to simpler equations\n\nInigo Quilez, the creator of Shadertoy, worked out an elegant analytical solution. Here it is:\n// Torus intersection by Inigo Quilez\n// https://iquilezles.org/articles/intersectors/\nfloat intersectTorus(Ray ray, vec2 tor) {\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ray.origin, ray.origin);\n    float n = dot(ray.origin, ray.dir);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*ray.dir.z*ray.dir.z + k;\n    float k1 = k*n + Ra2*ray.origin.z*ray.dir.z;\n    float k0 = k*k + Ra2*ray.origin.z*ray.origin.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01) {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0) {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4) {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    if(result &gt; 1e10) return -1.0;\n    return result;\n}\nThat’s about 80 lines to intersect a ray with a torus. Compare that to the 15 lines for a sphere.\n\n\n\nFor lighting, we need the surface normal. For any implicit surface \\(F(\\mathbf{p}) = 0\\), the normal is the gradient of \\(F\\), normalized:\n\\[\\mathbf{n} = \\frac{\\nabla F}{|\\nabla F|}\\]\nFor the torus, this works out to:\nvec3 torusNormal(vec3 p, vec2 tor) {\n    float R = tor.x;\n    float denom = sqrt(p.x*p.x + p.y*p.y);\n    return normalize(vec3(\n        p.x * (1.0 - R/denom),\n        p.y * (1.0 - R/denom),\n        p.z\n    ));\n}\n\n\n\nWith intersection and normal in hand, we can render a lit torus:\n\n  Missing Demo\n  Shader demo day4/torus-analytical not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Torus parameters: (major radius, minor radius)\n    vec2 torus = vec2(1.0, 0.4);\n    \n    // Move torus in front of camera\n    ray.origin.z += 3.0;\n    \n    float t = intersectTorus(ray, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        // Lighting (same as sphere)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nIt works! The torus renders correctly with proper lighting and that satisfying donut shape.\nTo see the torus from different angles, let’s make it rotate. We’ll explore how to animate and transform objects in the exercises.\n\n  Missing Demo\n  Shader demo day4/torus-rotating not found.\n\n\n\n\n\nAnalytical ray intersection gives exact results and can be very fast — there’s no iteration, just direct computation. For mathematical visualization, where precision matters and you’re rendering well-understood algebraic surfaces, this approach is sometimes exactly what you want.\nBut the complexity grows quickly with the degree of the surface. A sphere (degree 2) gives a quadratic. A torus (degree 4) gives a quartic. Higher-degree surfaces require solving higher-degree polynomials, and combining multiple objects requires even more sophisticated algebra.\n\n\n\n\n\n\nNoteWhat About Meshes?\n\n\n\nThe other major approach in computer graphics is to approximate surfaces with triangle meshes — thousands or millions of tiny triangles. This is still intersection-based: we write a ray-triangle intersection routine (which is a simple linear system), then test every triangle. Clever data structures (BVHs, k-d trees) make it fast to find which triangles a ray might hit without testing all of them.\nThis is how most video games and production renderers work. But it requires having mesh data — vertices, faces, connectivity — which is a lot of infrastructure. For mathematical visualization, where we work with implicit surfaces and procedural geometry, SDFs and raymarching are more natural. We define shapes with equations, not polygon soup.\n\n\nIn the next section, we’ll see a different approach that trades some precision for dramatic simplicity.\n\n\n\n\nWe’ve seen that analytical intersection works but scales poorly with geometric complexity. The core problem is that we’re asking a hard question: “where exactly does this ray hit the surface?” For a sphere, that’s a quadratic equation. For a torus, a quartic. For more complex surfaces, the algebra becomes intractable.\nWhat if we asked an easier question instead?\n\n\nSuppose we have a function that, given any point \\(\\mathbf{p}\\) in space, tells us the distance to the nearest surface. Not which surface, not where on the surface — just how far.\nNow imagine walking along a ray from the camera. At each step, we ask: “how far is the surface from here?” If the answer is \\(d\\), we know it’s safe to step forward by \\(d\\) — we can’t possibly hit anything closer than that. So we step forward, ask again, step again. Eventually one of two things happens:\n\nThe distance gets very small — we’ve arrived at the surface\nWe’ve walked very far without hitting anything — the ray misses\n\nThis is raymarching. Instead of solving for the exact intersection, we iterate our way there. And the function that answers “how far to the surface?” is called a signed distance function (SDF).\n\n\n\nA signed distance function maps every point in space to a number:\n\\[d(\\mathbf{p}) = \\begin{cases}\n&gt; 0 & \\text{outside the surface} \\\\\n= 0 & \\text{on the surface} \\\\\n&lt; 0 & \\text{inside the surface}\n\\end{cases}\\]\nThe magnitude \\(|d(\\mathbf{p})|\\) is the Euclidean distance to the nearest point on the surface. The sign tells you which side you’re on.\nThe sign matters because surfaces have an inside and an outside. When raymarching, we typically start outside an object and walk until we reach the surface (where \\(d \\approx 0\\)). But the sign also lets us do things like carve holes in objects or detect when the camera is inside something.\n\n\n\nBefore we use SDFs for 3D rendering, let’s build intuition in 2D. We can visualize an SDF by coloring the plane according to distance: one color outside, another inside, with contour lines showing level sets.\nThe simplest SDF is a circle of radius \\(r\\) centered at the origin:\n\\[d(\\mathbf{p}) = |\\mathbf{p}| - r\\]\nIf you’re at distance \\(|\\mathbf{p}|\\) from the origin, your signed distance to the circle is how much farther (positive) or closer (negative) you are than \\(r\\).\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n  Missing Demo\n  Shader demo day4/sdf-circle-2d not found.\n\n\nThe contour lines are level sets of the SDF — curves where \\(d(\\mathbf{p}) = k\\) for various values of \\(k\\). On the boundary (\\(k = 0\\)), you’re exactly on the circle. The contours inside are negative; the contours outside are positive.\nA box is more interesting. For an axis-aligned box with half-widths \\((w, h)\\), the SDF is:\nfloat sdBox(vec2 p, vec2 halfSize) {\n    vec2 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nThe formula has two parts: outside the box, we measure distance to the nearest corner or edge; inside, we take the largest (least negative) coordinate distance.\n\n  Missing Demo\n  Shader demo day4/sdf-box-2d not found.\n\n\nNotice how the contour lines “round out” near the corners. The SDF doesn’t know the box has sharp corners — it just measures distance, and distance from a corner is distance from a point.\n\n\n\nThe same idea extends to 3D. Here are SDFs for the shapes we care about:\nSphere:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nOne line. Compare to our 15-line analytical intersection.\nTorus:\nfloat sdTorus(vec3 p, vec2 tor) {\n    // tor.x = major radius, tor.y = minor radius\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\nFour lines. Compare to the 80-line quartic solver.\n\n\n\n\n\n\nNoteGLSL: Swizzling\n\n\n\nGLSL lets you extract and rearrange vector components using swizzle notation. Writing p.xy creates a vec2 containing the x and y components of p. You can use any combination: p.xz, p.zyx, even p.xxx. This is handy for working with different planes — length(p.xy) gives the distance from the Z-axis, treating the xy-plane as 2D.\n\n\nThe logic: length(p.xy) - tor.x gives the distance from the central ring (a circle of radius \\(R\\) in the xy-plane). Then we measure distance from that to the point, accounting for the \\(z\\) coordinate, and subtract the tube radius.\nBox:\nfloat sdBox(vec3 p, vec3 halfSize) {\n    vec3 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\nSame idea as 2D, extended to three dimensions.\nPlane:\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\nA horizontal plane at \\(y = h\\). Points above have positive distance; points below have negative distance. This will be our ground plane.\n\n\n\nFor lighting, we need surface normals. An SDF is an implicit function — the surface is the level set where \\(d(\\mathbf{p}) = 0\\). As we saw with the torus, the gradient of an implicit function points perpendicular to its level sets. So \\(\\nabla d\\) gives us the normal direction.\nWe estimate the gradient numerically using finite differences:\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\nThis works for any SDF — spheres, tori, boxes, or shapes we haven’t even defined yet. We evaluate the SDF at six nearby points and see which direction it increases fastest. That’s the normal.\n\n\n\n\nWe’ve defined SDFs and explained the idea: march along the ray, using the distance field to take safe steps. Now let’s implement it.\n\n\nStarting from the ray origin, we repeatedly:\n\nEvaluate the SDF at our current position\nStep forward along the ray by that distance\nCheck if we’re close enough to the surface (hit) or too far away (miss)\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;  // Distance traveled along ray\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;  // Current position\n        float d = sceneSDF(p);               // Distance to nearest surface\n        \n        if (d &lt; 0.001) {\n            return t;  // Hit: we're close enough\n        }\n        \n        t += d;  // Step forward by the safe distance\n        \n        if (t &gt; 100.0) {\n            return -1.0;  // Miss: we've gone too far\n        }\n    }\n    \n    return -1.0;  // Gave up: too many steps\n}\nThe threshold 0.001 controls how close we need to get before declaring a hit — smaller means more precision but more steps. The maximum distance 100.0 and iteration count 100 are practical limits to avoid infinite loops.\n\n\n\nLet’s render a sphere using raymarching instead of analytical intersection:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\nWith our estimateNormal function from the previous section and the same lighting code we used for analytical rendering:\n\n  Missing Demo\n  Shader demo day4/raymarch-sphere not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Same lighting as before\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result looks identical to our analytical sphere — same shape, same lighting, same specular highlight. But we found the intersection by marching, not by solving a quadratic.\n\n\n\nNow for the payoff. To render a torus, we change one function:\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdTorus(p, vec2(1.0, 0.4));\n}\nThat’s it. The raymarching loop doesn’t change. The normal estimation doesn’t change. The lighting doesn’t change. We swap four lines of SDF code for four different lines, and:\n\n  Missing Demo\n  Shader demo day4/raymarch-torus not found.\n\n\nCompare this to the analytical torus: 80 lines of quartic algebra reduced to 4 lines of distance calculation. The raymarching framework absorbs all the complexity — we just need to answer “how far is the surface?”\n\n\n\n\nWe can render a sphere. We can render a torus. How do we render both at once?\n\n\nThe SDF tells us the distance to the nearest surface. If we have two objects, the nearest surface is whichever one is closer. So we just take the minimum:\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    float torus = sdTorus(p, vec2(1.0, 0.4));\n    return min(sphere, torus);\n}\nThat’s it. The raymarcher doesn’t change — it still asks “how far to the nearest surface?” and marches accordingly. Now “nearest surface” might be the sphere or the torus depending on where we are.\nAdding more objects is the same pattern:\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    float torus = sdTorus(p, vec2(1.0, 0.4));\n    float ground = sdPlane(p, -1.0);\n    return min(sphere, min(torus, ground));\n}\n\n\n\n\n\n\nNoteConstructive Solid Geometry\n\n\n\nThere’s something elegant happening here. An SDF represents a shape as a function \\(f: \\mathbb{R}^3 \\to \\mathbb{R}\\), where the shape is the zero set \\(\\{p : f(p) = 0\\}\\). Set operations on shapes become pointwise operations on functions:\n\nUnion \\(A \\cup B\\): \\(\\min(f_A, f_B)\\)\nIntersection \\(A \\cap B\\): \\(\\max(f_A, f_B)\\)\nComplement \\(A^c\\): \\(-f_A\\)\n\nThis is constructive solid geometry (CSG) — building complex shapes from simple primitives via boolean operations. With SDFs, CSG is just arithmetic. We’ll explore intersection and subtraction in the exercises.\n\n\n\n\n\nWe can combine objects, but now everything is the same color. To shade each object differently, we need to know which object we hit.\nA simple approach: track a material ID as we build the scene. When we find a new closest surface, record which object it belongs to.\n// Which object is closest: 1 = sphere, 2 = torus, 3 = ground\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;  // Start with large distance\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p + vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\nThen we look up the color based on the ID:\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);  // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\nThis pattern — a global variable modified inside sceneSDF — isn’t the most elegant. It’s a side effect hidden inside what looks like a pure function. But it’s simple, it’s the common idiom in Shadertoy, and it works. For a cleaner approach, you could return a struct containing both distance and material ID; we’ll explore this in the exercises.\n\n\n\nPutting it all together:\n\n  Missing Demo\n  Shader demo day4/scene-multi not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;  // Move camera back\n    ray.origin.y += 1.0;  // Move camera up\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThree objects, three colors, one unified raymarching framework. Adding more objects is just more calls to min().\n\n\n\n\n\n\nThese exercises verify your understanding of the core concepts. Each one should take just a few minutes.\nCheckpoint 1: Move the Sphere\nIn the raymarched sphere demo (A10), the sphere is centered at vec3(0.0, 0.0, -3.0). Move it to the right by changing the center to vec3(1.0, 0.0, -3.0). Then try moving it up, down, closer, farther. What happens if you move it behind the camera (positive z)?\nCheckpoint 2: Torus Proportions\nIn the raymarched torus demo (A11), the torus has major radius 1.0 and minor radius 0.4. Try:\n\nA thin ring: vec2(1.0, 0.1)\nA fat donut: vec2(1.0, 0.8)\nA small tight ring: vec2(0.5, 0.2)\n\nWhat happens when the minor radius exceeds the major radius?\nCheckpoint 3: Add an Object\nIn the multi-object scene (A12), add a second sphere on the right side of the scene. You’ll need to:\n\nAdd the SDF evaluation\nCheck if it’s the closest surface\nAssign it a new material ID (4.0)\nAdd a color for material 4 in getMaterialColor\n\nCheckpoint 4: Change the Palette\nIn the multi-object scene (A12), change the color scheme. Try:\n\nA sunset palette: orange sphere, pink torus, dark purple ground\nA nature palette: green sphere, brown torus, tan ground\nYour own palette\n\nCheckpoint 5: Move the Light\nThe light direction is normalize(vec3(1.0, 1.0, 1.0)) — coming from the upper-right-front. Try:\n\nLight from directly above: vec3(0.0, 1.0, 0.0)\nLight from the left: vec3(-1.0, 0.5, 0.5)\nLight from behind the camera: vec3(0.0, 0.0, 1.0)\n\nHow does the shading change? Where do the specular highlights move?\nCheckpoint 6: Field of View\nIn generateRay, the FOV is set to 90 degrees. Try:\n\nWide angle (120°): objects appear smaller, more of the scene is visible\nTelephoto (30°): objects appear larger, zoomed in, less distortion\n\nWhat FOV feels most natural to you?\n\n\n\nThese exercises go deeper into specific topics. Each one might take 15-30 minutes.\nExploration 1: Two Lights\nAdd a second light source to the scene. You’ll need to:\n\nDefine a second light direction (try normalize(vec3(-1.0, 0.5, -0.5)) for a fill light)\nCompute diffuse and specular for both lights\nAdd the contributions together\n\nFor a nice effect, make the main light white and the fill light slightly colored (e.g., multiply by vec3(0.3, 0.3, 0.5) for a cool fill). This is a common technique in photography and film: a warm key light with a cool fill.\nExploration 2: Fog\nAdd distance-based fog to create atmosphere and depth. After raymarching, you have t — the distance to the hit point. Use this to blend toward a fog color:\nvec3 fogColor = vec3(0.5, 0.6, 0.7);\nfloat fogAmount = 1.0 - exp(-t * 0.1);  // Exponential fog\ncolor = mix(color, fogColor, fogAmount);\nTo see the effect clearly, create a scene with several objects at different distances — try a row of spheres receding into the distance:\nfloat sceneSDF(vec3 p) {\n    float d = sdPlane(p, -1.0);\n    for (float i = 0.0; i &lt; 5.0; i++) {\n        d = min(d, sdSphere(p, vec3(0.0, 0.0, -3.0 - i * 3.0), 0.8));\n    }\n    return d;\n}\nExploration 3: Animation\nMake the scene come alive with iTime. Here’s a pulsing sphere:\nfloat sdPulsingSphere(vec3 p, vec3 center, float baseRadius) {\n    float r = baseRadius * (1.0 + 0.2 * sin(iTime * 3.0));\n    return length(p - center) - r;\n}\nNow try your own animations:\n\nA torus that rotates (hint: rotate p before passing to sdTorus)\nA sphere that orbits another sphere\nObjects that bounce up and down\nA “breathing” scene where everything pulses together\n\nExploration 4: Cone SDF\nLet’s derive SDFs for shapes with rotational symmetry.\nA cylinder is the set of points within distance \\(r\\) of an axis, bounded by two heights. For a cylinder along the Y-axis, we measure distance from the Y-axis by ignoring the y-coordinate:\nfloat sdCylinder(vec3 p, float r, float h) {\n    float dRadial = length(p.xz) - r;    // Distance from curved surface\n    float dVertical = abs(p.y) - h;       // Distance from caps (half-height h)\n    \n    return min(max(dRadial, dVertical), 0.0) + \n           length(max(vec2(dRadial, dVertical), 0.0));\n}\nThis combines a “2D circle” (in xz) with a “1D segment” (in y) — the same pattern as the box SDF.\nYour task: Derive the SDF for a cone. A cone has its tip at the origin, opens upward along the Y-axis, and has a half-angle \\(\\theta\\). Think about:\n\nAt height \\(y\\), what’s the radius of the cone at that level?\nHow do you measure distance from a slanted surface?\nHow do you cap the cone at a maximum height?\n\nHint: The key insight is that at height \\(y\\), the cone’s radius is \\(y \\tan(\\theta)\\). The radial distance becomes length(p.xz) - p.y * tan(angle).\nAdd both a cylinder and a cone to your scene to verify they work.\nExploration 5: Smooth Blending\nThe min function creates hard unions — objects meet at sharp seams. For organic shapes, we want smooth blending. The smooth minimum interpolates between distances:\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\nThe parameter k controls the blending radius — larger k means smoother blends.\nCreate a “metaball” or “lava lamp” effect:\nfloat sceneSDF(vec3 p) {\n    float s1 = sdSphere(p, vec3(-0.8, 0.0, 0.0), 1.0);\n    float s2 = sdSphere(p, vec3(0.8, 0.0, 0.0), 1.0);\n    return smin(s1, s2, 0.5);\n}\nNow animate the spheres moving toward and away from each other. Watch them merge and separate!\nExploration 6: Normal Coloring\nSurface normals aren’t just for lighting — they can be the color itself. This is a classic debugging visualization that also creates beautiful abstract images.\nThe normal vector has components in \\([-1, 1]\\), but colors need to be in \\([0, 1]\\). Remap with:\nvec3 color = normal * 0.5 + 0.5;\nNow surfaces facing right (+X) are red, surfaces facing up (+Y) are green, and surfaces facing the camera (+Z) are blue. Mixtures create cyan, magenta, yellow.\nTry this on your multi-object scene. Notice how it reveals the surface geometry in a way that solid colors hide. This is also useful for debugging — if you see unexpected colors, your normals might be wrong.\nExtend this:\n\nTry abs(normal) instead — what changes?\nUse only one component: vec3(normal.y * 0.5 + 0.5) for a height-based coloring\nAnimate: blend between normal coloring and your regular material colors\n\n\n\n\nThese are substantial projects that extend the techniques from the lecture. Each might take an hour or more.\nChallenge 1: CSG Operations\nWe used min for union. Implement intersection and subtraction:\n\nIntersection: max(a, b) — only points inside both shapes\nSubtraction: max(a, -b) — points inside A but outside B\n\nPractice with these shapes:\n\nA cube with a spherical cavity (intersection of cube and inverted sphere)\nThe intersection of two spheres (lens shape)\nA sphere with a cylindrical hole through it\n\nThen put it all together: make a coffee cup. You’ll need:\n\nA cylinder for the body\nA smaller cylinder subtracted for the hollow interior\nA torus attached with smin for the handle\n\nChallenge 2: Infinite Repetition\nThe mod function can repeat space, creating infinite grids of objects:\nfloat sceneSDF(vec3 p) {\n    vec3 spacing = vec3(4.0);\n    vec3 q = mod(p + spacing * 0.5, spacing) - spacing * 0.5;\n    return sdSphere(q, vec3(0.0), 1.0);\n}\nThis creates an infinite 3D grid of spheres. Experiment with:\n\nDifferent spacing in different directions\nRepeating only in 2D (an infinite floor of objects)\nCombining repeated and non-repeated objects\nAlternating shapes using floor(p / spacing)\n\nChallenge 3: Orbiting Camera\nImplement a camera that orbits around the scene. You’ll need a rotation matrix:\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\nIn mainImage:\nfloat angle = iTime * 0.5;  // Rotate over time\nmat3 rot = rotateY(angle);\n\nRay ray = generateRay(fragCoord);\nray.origin = rot * vec3(0.0, 2.0, 5.0);  // Camera position, rotated\nray.dir = rot * ray.dir;                  // View direction, rotated\nThis rotates the camera around a fixed scene. Alternatively, you could keep the camera fixed and rotate p inside sceneSDF — this rotates the scene instead of the camera. Try both and see which feels more natural.\nExtend this to:\n\nAdd vertical bobbing with sin(iTime)\nLet the camera tilt (rotation around X)\nZoom in and out over time\n\nChallenge 4: Reflections\nMake the ground plane into a mirror. The idea: when a ray hits a reflective surface, compute the reflection direction and raymarch again.\nWe check which object we hit using materialID, and only reflect off the ground:\nvec3 color = shade(hitPoint, normal, ray.dir);\n\n// Only reflect off the ground (material 3)\nif (materialID &gt; 2.5) {\n    vec3 reflectDir = reflect(ray.dir, normal);\n    Ray reflectedRay;\n    reflectedRay.origin = hitPoint + normal * 0.01;  // Offset to avoid self-intersection\n    reflectedRay.dir = reflectDir;\n    \n    float t2 = raymarch(reflectedRay);\n    if (t2 &gt; 0.0) {\n        vec3 reflectedHit = reflectedRay.origin + t2 * reflectedRay.dir;\n        vec3 reflectedNormal = estimateNormal(reflectedHit);\n        vec3 reflectedColor = shade(reflectedHit, reflectedNormal, reflectedRay.dir);\n        color = mix(color, reflectedColor, 0.5);  // 50% reflective\n    }\n}\nThe small offset (normal * 0.01) prevents the reflected ray from immediately hitting the same surface it started from.\nChallenge 5: Struct-Based Materials\nRefactor the global materialID pattern into a cleaner struct-based design:\nstruct Surface {\n    float dist;\n    float matID;\n};\n\nSurface sdSphere(vec3 p, vec3 center, float radius, float matID) {\n    return Surface(length(p - center) - radius, matID);\n}\n\nSurface opUnion(Surface a, Surface b) {\n    return (a.dist &lt; b.dist) ? a : b;\n}\n\nSurface sceneSDF(vec3 p) {\n    Surface s = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0, 1.0);\n    s = opUnion(s, sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4), 2.0));\n    s = opUnion(s, sdPlane(p, -1.0, 3.0));\n    return s;\n}\nYou’ll need to update:\n\nAll SDF primitives to return Surface\nThe raymarch function to work with Surface.dist\nThe estimateNormal function (it only needs distance, so call sceneSDF(p).dist)\n\nThis is more code, but the material tracking is now explicit and composable.\nChallenge 6: Hard Shadows\nShadows add tremendous depth to a scene. The idea: before shading a point, check if there’s anything between it and the light.\nWe already know how to check if a ray hits something — that’s raymarching! For shadows, we raymarch from the hit point toward the light:\nfloat hardShadow(vec3 origin, vec3 lightDir, float maxDist) {\n    float t = 0.02;  // Start slightly away from surface\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + lightDir * t);\n        if (d &lt; 0.001) return 0.0;  // Hit something — in shadow\n        t += d;\n        if (t &gt; maxDist) break;\n    }\n    \n    return 1.0;  // Reached the light — not in shadow\n}\nUse it in your lighting calculation:\nvec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));\nfloat shadow = hardShadow(hitPoint + normal * 0.02, lightDir, 10.0);\n\nfloat diffuse = max(0.0, dot(normal, lightDir));\ncolor = matColor * (ambient + diffuse * shadow);\nThe offset normal * 0.02 prevents the shadow ray from immediately hitting the surface it started from (self-shadowing artifacts).\nThings to try:\n\nAdd shadows to your multi-object scene\nUse different shadow intensities (multiply by 0.5 instead of 0.0 for softer shadows)\nOnly cast shadows from your key light, not fill lights\n\n\n\n\nAlgebraic Variety Rendering\nAn algebraic variety is the zero set of a polynomial — a surface defined by \\(f(x, y, z) = 0\\). These surfaces have been studied for centuries, and some of them are strikingly beautiful. In this project, you’ll build a raymarcher that can render any algebraic variety.\n\n\nWe can’t compute an exact SDF for a general polynomial, but we can estimate the distance. The key insight: near the surface, the function value \\(f(\\mathbf{p})\\) is approximately proportional to distance, with the gradient \\(\\nabla f\\) telling us how fast \\(f\\) changes.\nThis gives us the distance estimate:\n\\[d \\approx \\frac{|f(\\mathbf{p})|}{|\\nabla f(\\mathbf{p})|}\\]\nThis isn’t a true SDF — it can overestimate or underestimate — but it’s good enough for raymarching if we’re conservative. In practice, we often scale it down slightly:\nfloat estimateDistance(vec3 p) {\n    float f = polynomial(p);\n    vec3 grad = gradient(p);\n    return 0.5 * abs(f) / length(grad);  // Factor of 0.5 for safety\n}\nYou’ll need to compute the gradient. You can either derive it analytically from the polynomial (faster, exact), or estimate it numerically with finite differences (easier, works for any polynomial):\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        polynomial(p + vec3(eps, 0, 0)) - polynomial(p - vec3(eps, 0, 0)),\n        polynomial(p + vec3(0, eps, 0)) - polynomial(p - vec3(0, eps, 0)),\n        polynomial(p + vec3(0, 0, eps)) - polynomial(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\n\n\nAlgebraic varieties can extend to infinity or have complex topology. To raymarch efficiently, first intersect with a bounding sphere or box:\nfloat sceneSDF(vec3 p) {\n    // Bounding sphere\n    float bounds = length(p) - 2.0;\n    if (bounds &gt; 0.01) {\n        return bounds;  // Outside bounds: use sphere distance\n    }\n    \n    // Inside bounds: use variety distance estimate\n    return estimateDistance(p);\n}\nThis lets us skip the expensive polynomial evaluation until we’re close.\n\n\n\nFor lighting, the gradient gives us the normal direction:\nvec3 normal = normalize(gradient(hitPoint));\nIf the gradient points “inward” relative to your camera, you may need to flip it.\n\n\n\nTo view the variety from different angles, rotate the point before evaluating:\nfloat polynomial(vec3 p) {\n    p = rotateY(iTime * 0.3) * p;  // Slow rotation\n    // ... evaluate polynomial ...\n}\n\n\n\nHere are some beautiful algebraic surfaces to try. Each is written as \\(f(x,y,z) = 0\\).\nBarth Sextic (degree 6) — 50 double points, icosahedral symmetry:\n\\[4(\\phi^2 x^2 - y^2)(\\phi^2 y^2 - z^2)(\\phi^2 z^2 - x^2) - (1 + 2\\phi)(x^2 + y^2 + z^2 - 1)^2 = 0\\]\nwhere \\(\\phi = \\frac{1 + \\sqrt{5}}{2}\\) is the golden ratio.\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\nClebsch Diagonal Cubic (degree 3) — contains exactly 27 lines:\n\\[81(x^3 + y^3 + z^3) - 189(x^2 y + x^2 z + y^2 x + y^2 z + z^2 x + z^2 y) + 54xyz + 126(xy + xz + yz) - 9(x^2 + y^2 + z^2) - 9(x + y + z) + 1 = 0\\]\nfloat clebschCubic(vec3 p) {\n    float x = p.x, y = p.y, z = p.z;\n    float x2 = x*x, y2 = y*y, z2 = z*z;\n    float x3 = x2*x, y3 = y2*y, z3 = z2*z;\n    \n    return 81.0*(x3 + y3 + z3)\n         - 189.0*(x2*y + x2*z + y2*x + y2*z + z2*x + z2*y)\n         + 54.0*x*y*z\n         + 126.0*(x*y + x*z + y*z)\n         - 9.0*(x2 + y2 + z2)\n         - 9.0*(x + y + z)\n         + 1.0;\n}\nCayley Cubic (degree 3) — 4 nodes:\n\\[x^2 + y^2 - x^2 z + y^2 z + z^2 - 1 = 0\\]\nfloat cayleyCubic(vec3 p) {\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    return x2 + y2 - x2 * p.z + y2 * p.z + z2 - 1.0;\n}\nKummer Surface (degree 4) — 16 nodes:\n\\[(x^2 + y^2 + z^2 - \\mu^2)^2 - \\lambda \\cdot p_0 p_1 p_2 p_3 = 0\\]\nwhere \\(p_i\\) are planes forming a tetrahedron. A simplified version:\nfloat kummerSurface(vec3 p) {\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float sum = x2 + y2 + z2;\n    float prod = x2 * y2 + y2 * z2 + z2 * x2;\n    \n    float mu = 1.3;\n    float lambda = 3.0;\n    \n    float a = sum - mu * mu;\n    return a * a - lambda * prod;\n}\nHeart Surface (degree 6) — for fun:\n\\[(x^2 + \\frac{9}{4}y^2 + z^2 - 1)^3 - x^2 z^3 - \\frac{9}{80}y^2 z^3 = 0\\]\nfloat heartSurface(vec3 p) {\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    float z3 = z2 * p.z;\n    \n    float a = x2 + 2.25 * y2 + z2 - 1.0;\n    return a * a * a - x2 * z3 - 0.1125 * y2 * z3;\n}\n\n\n\nBuild a beautiful scene featuring an algebraic variety. Your shader should:\n\nImplement distance estimation for at least one variety\nUse a bounding volume for efficiency\nInclude proper lighting with surface normals\n\nBeyond that, get creative! Some ideas:\n\nAdd a reflective floor beneath the variety\nUse multiple colored lights\nAdd fog for atmosphere\nMake the variety rotate slowly\nTry different varieties and find your favorite\nCombine multiple varieties in one scene"
  },
  {
    "objectID": "lectures/day4.html#overview",
    "href": "lectures/day4.html#overview",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "Missing Demo\n  Shader demo day4/barth-sextic-final not found.\n\n\nThis is the Barth sextic — an algebraic surface with 50 singular points and icosahedral symmetry, rendered entirely on the GPU.\nThis chapter covers a lot of ground. In class, we’ll focus on the fundamentals: cameras, rays, signed distance functions, and the raymarching algorithm. But if you work through the exercises and the final project, you can build something like what you see above — a rotating algebraic variety with multi-colored lighting and shadows.\nWe’ll start with the classical approach — solving ray-surface intersections analytically — and see why it becomes unwieldy for complex geometry. Then we’ll develop a more flexible technique: raymarching with signed distance functions. This approach lets us render almost anything we can describe mathematically, including the algebraic varieties that have fascinated geometers for centuries.\n\n\n\n\n\n\nNoteLearning Objectives\n\n\n\nBy the end of today, you will be able to:\n\nSet up a camera and generate rays for each pixel\nCompute ray-surface intersections analytically\nUnderstand why analytical methods become challenging for complex geometry\nUse signed distance functions as an alternative representation\nImplement the raymarching algorithm (sphere tracing)\nBuild scenes with multiple objects and materials"
  },
  {
    "objectID": "lectures/day4.html#cameras-and-rays",
    "href": "lectures/day4.html#cameras-and-rays",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "We want to draw 3D scenes on a 2D screen. The basic question: for each pixel, what color should it be?\nThe answer comes from simulating how light reaches a camera. In the real world, light bounces around a scene and some of it enters a camera through its lens, forming an image. Simulating this fully is expensive, so we reverse the process: instead of tracing light from sources to the camera, we trace rays from the camera out into the scene. For each pixel, we ask: what does this ray hit, and what color is that surface?\n\n\nThe simplest camera model is the pinhole camera: all light enters through a single point. This means every ray passes through the same origin—the camera position. The only thing that varies from pixel to pixel is the ray’s direction.\nReal cameras have lenses with finite aperture, which create depth of field and focus effects. We ignore all of that. The pinhole model is mathematically clean: one point, many directions.\n\n\n\nWe need to agree on which way is “up.” We’ll use the standard graphics convention:\n\nY-axis points up\nZ-axis points toward the camera (out of the screen)\nX-axis points right\nRight-handed coordinate system\n\nOur camera sits at the origin, looking down the negative Z-axis. The scene lives in front of the camera, at negative Z values.\n\n\n\nA ray is a half-line: it starts at a point and extends infinitely in one direction. We parameterize it as:\n\\[\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(\\mathbf{o}\\) is the origin (camera position), \\(\\mathbf{d}\\) is the direction (unit vector), and \\(t \\geq 0\\) is the parameter. Points with \\(t &gt; 0\\) lie in front of the camera; \\(t = 0\\) is the camera itself.\nA ray has two parts: where it starts and where it points. We bundle these into a struct:\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\nFor our pinhole camera, the origin is the same for every ray—the camera position at \\((0, 0, 0)\\). Only the direction varies, depending on which pixel we’re computing.\n\n\n\nThe field of view (FOV) controls how wide the camera sees. To understand it precisely, imagine an image plane sitting at distance \\(f\\) in front of the camera (at \\(z = -f\\)). We set up coordinates so the visible portion of this plane spans \\([-1, 1]\\) in both \\(x\\) and \\(y\\). Each pixel maps to a point on this plane, and the ray direction is the vector from the camera through that point.\n\nThe FOV is the angle between rays hitting opposite edges of the screen. Half that angle, \\(\\theta = \\text{FOV}/2\\), is the angle from the center ray to the edge. A ray to the top edge of the image plane reaches the point \\((0, 1, -f)\\), forming a right triangle with opposite side 1 and adjacent side \\(f\\). So \\(\\tan(\\theta) = 1/f\\), giving us:\n\\[f = \\frac{1}{\\tan(\\text{FOV}/2)}\\]\nThe intuition: a wide FOV means the image plane is close, so rays spread out sharply. A narrow FOV means the image plane is far, so rays stay nearly parallel—like a telephoto lens.\n\n\n\nFor a pixel at screen position fragCoord, we compute its ray in three steps:\n\nNormalize pixel coordinates to \\([-1, 1]^2\\)\nCorrect for aspect ratio so circles render as circles\nForm the direction vector toward the image plane and normalize it\n\nRay generateRay(vec2 fragCoord) {\n    // Map pixel coordinates to [-1, 1]\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Focal length from field of view\n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    \n    return ray;\n}\nThe direction’s \\(z\\)-component is \\(-f\\) because we’re looking down the negative Z-axis. The normalize ensures our direction is a unit vector, which simplifies intersection calculations later.\n\n\n\nLet’s verify our setup by coloring each pixel according to its ray direction:\n\n  Missing Demo\n  Shader demo day4/ray-visualization not found.\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Map direction components from [-1,1] to [0,1] for display\n    vec3 color = ray.dir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}\nThe center of the screen is bluish (ray pointing straight into \\(-Z\\)), while the edges shift toward red and green (larger \\(X\\) and \\(Y\\) components). This gradient confirms our rays fan out correctly from the camera."
  },
  {
    "objectID": "lectures/day4.html#raytracing",
    "href": "lectures/day4.html#raytracing",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "We have rays. Now we need to find where they hit things.\nThe core problem: given a ray \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) and a surface, find the value of \\(t\\) where they intersect. Once we know the intersection point, we can compute its color based on lighting and material properties.\n\n\nWe’ll start with the simplest 3D shape: a sphere. A sphere of radius \\(r\\) centered at \\(\\mathbf{c}\\) is the set of points satisfying:\n\\[|\\mathbf{p} - \\mathbf{c}|^2 = r^2\\]\nTo find where our ray intersects this sphere, we substitute the ray equation for \\(\\mathbf{p}\\):\n\\[|\\mathbf{o} + t\\mathbf{d} - \\mathbf{c}|^2 = r^2\\]\nLet \\(\\boldsymbol{\\delta} = \\mathbf{o} - \\mathbf{c}\\) be the vector from the sphere’s center to the ray’s origin. Expanding:\n\\[|\\boldsymbol{\\delta} + t\\mathbf{d}|^2 = r^2\\] \\[|\\boldsymbol{\\delta}|^2 + 2t(\\boldsymbol{\\delta} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nSince \\(\\mathbf{d}\\) is a unit vector, \\(|\\mathbf{d}|^2 = 1\\). Rearranging into standard quadratic form \\(at^2 + bt + c = 0\\):\n\\[t^2 + 2(\\boldsymbol{\\delta} \\cdot \\mathbf{d})t + (|\\boldsymbol{\\delta}|^2 - r^2) = 0\\]\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us how many solutions exist:\n\n\\(\\Delta &lt; 0\\): no intersection (ray misses the sphere)\n\\(\\Delta = 0\\): one intersection (ray grazes the sphere)\n\\(\\Delta &gt; 0\\): two intersections (ray enters and exits)\n\nWhen \\(\\Delta \\geq 0\\), we get:\n\\[t = -(\\boldsymbol{\\delta} \\cdot \\mathbf{d}) \\pm \\sqrt{(\\boldsymbol{\\delta} \\cdot \\mathbf{d})^2 - |\\boldsymbol{\\delta}|^2 + r^2}\\]\nWe want the smallest positive \\(t\\) — the first intersection in front of the camera.\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;  // First intersection in front\n    if (t2 &gt; 0.0) return t2;  // We're inside the sphere\n    return -1.0;              // Sphere is behind us\n}\nWe return \\(-1\\) as a sentinel value meaning “no intersection.” Since valid hits have \\(t &gt; 0\\) (the intersection is in front of the camera), any negative value would work — \\(-1\\) is just conventional. When we use this function, we check if (t &gt; 0.0) to see if we hit anything.\nLet’s test it:\n\n  Missing Demo\n  Shader demo day4/sphere-flat not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nIt works — but it looks like a flat red disk! We can’t see the sphere’s curvature because every hit pixel gets the same color. We need lighting.\n\n\n\nLighting depends on how a surface is oriented relative to the light. The surface normal is a unit vector perpendicular to the surface at a given point. For a sphere, the normal at point \\(\\mathbf{p}\\) points directly away from the center:\n\\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the direction from the center to the surface, normalized.\nWe can visualize the normals by mapping them to colors, just like we did with ray directions:\n\n  Missing Demo\n  Shader demo day4/sphere-normals not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        color = normal * 0.5 + 0.5;  // Map [-1,1] to [0,1]\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow we see the sphere’s shape! The normal points right (red) on the right side, up (green) on top, and toward us (blue) in the center. This is exactly the information we need for lighting.\n\n\n\n\n\nA matte surface scatters incoming light equally in all directions. The brightness depends only on the angle between the surface normal and the light direction: when light hits head-on, the surface is bright; when light hits at a glancing angle, less energy is deposited and the surface is dim.\nThis is Lambertian shading. If \\(\\mathbf{n}\\) is the surface normal and \\(\\mathbf{l}\\) is the direction toward the light, the brightness is:\n\\[I_{\\text{diffuse}} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max\\) ensures surfaces facing away from the light don’t go negative.\n\n  Missing Demo\n  Shader demo day4/sphere-diffuse not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Direction toward light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Shading\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse);\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow the sphere looks 3D! The side facing the light is bright, and it falls off smoothly into shadow. We’ve added a small ambient term (0.1) so the dark side isn’t completely black — in the real world, indirect light would fill in the shadows.\n\n\n\nShiny surfaces have highlights — bright spots where light reflects directly toward the viewer. This is specular reflection.\nThe Phong model computes specular highlights by comparing the reflection direction to the view direction. If \\(\\mathbf{r}\\) is the light direction reflected about the normal, and \\(\\mathbf{v}\\) is the direction toward the camera, then:\n\\[I_{\\text{specular}} = \\max(0, \\mathbf{r} \\cdot \\mathbf{v})^n\\]\nThe exponent \\(n\\) controls how tight the highlight is: large \\(n\\) gives a small, sharp highlight (like polished metal); small \\(n\\) gives a broad, soft highlight (like plastic).\nGLSL has a built-in reflect function: reflect(-lightDir, normal) gives the reflection of the incoming light direction about the normal.\n\n  Missing Demo\n  Shader demo day4/sphere-lit not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Directions\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Toward light\n        vec3 viewDir = -ray.dir;                         // Toward camera\n        vec3 reflectDir = reflect(-lightDir, normal);    // Light reflected about normal\n        \n        // Diffuse: brightness based on angle to light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Specular: bright spot where reflection aligns with view\n        float shininess = 32.0;\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), shininess);\n        \n        // Combine lighting\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe sphere now has a shiny highlight! Try changing the shininess from 32 to other values — 8 gives a soft plastic look, 128 gives a tight metallic gleam."
  },
  {
    "objectID": "lectures/day4.html#the-limits-of-analytical-methods",
    "href": "lectures/day4.html#the-limits-of-analytical-methods",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "The sphere worked beautifully: substitute the ray equation, get a quadratic, solve with a formula you learned in high school. What about other shapes?\n\n\nA torus is the surface you get by revolving a circle around an axis — a donut shape. It’s defined by two radii: the major radius \\(R\\) (distance from the center of the torus to the center of the tube) and the minor radius \\(r\\) (the radius of the tube itself).\n\nThe implicit equation for a torus centered at the origin with the axis along \\(Y\\) is:\n\\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nThe inner square root computes the distance from the Y-axis; subtracting \\(R\\) gives the distance from the “core circle” of the torus; that quantity squared plus \\(y^2\\) equals \\(r^2\\) defines a tube of radius \\(r\\) around that core.\n\n\n\nTo find where a ray hits this surface, we substitute \\(\\mathbf{p} = \\mathbf{o} + t\\mathbf{d}\\) as before. The square root makes this awkward, so we first isolate and square it:\n\\[\\sqrt{x^2 + z^2} = R \\pm \\sqrt{r^2 - y^2}\\]\nAfter substituting the ray equation and squaring twice to eliminate the radicals, we get a quartic polynomial in \\(t\\):\n\\[a_4 t^4 + a_3 t^3 + a_2 t^2 + a_1 t + a_0 = 0\\]\nThe coefficients \\(a_i\\) are complicated expressions involving the ray origin, direction, and the two radii. Unlike the quadratic case, there’s no simple formula you can memorize. Solving a quartic requires either:\n\nThe quartic formula (which exists but is unwieldy), or\nNumerical methods (Newton’s method, bisection), or\nClever algebraic manipulation to reduce it to simpler equations\n\nInigo Quilez, the creator of Shadertoy, worked out an elegant analytical solution. Here it is:\n// Torus intersection by Inigo Quilez\n// https://iquilezles.org/articles/intersectors/\nfloat intersectTorus(Ray ray, vec2 tor) {\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ray.origin, ray.origin);\n    float n = dot(ray.origin, ray.dir);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*ray.dir.z*ray.dir.z + k;\n    float k1 = k*n + Ra2*ray.origin.z*ray.dir.z;\n    float k0 = k*k + Ra2*ray.origin.z*ray.origin.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01) {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0) {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4) {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    if(result &gt; 1e10) return -1.0;\n    return result;\n}\nThat’s about 80 lines to intersect a ray with a torus. Compare that to the 15 lines for a sphere.\n\n\n\nFor lighting, we need the surface normal. For any implicit surface \\(F(\\mathbf{p}) = 0\\), the normal is the gradient of \\(F\\), normalized:\n\\[\\mathbf{n} = \\frac{\\nabla F}{|\\nabla F|}\\]\nFor the torus, this works out to:\nvec3 torusNormal(vec3 p, vec2 tor) {\n    float R = tor.x;\n    float denom = sqrt(p.x*p.x + p.y*p.y);\n    return normalize(vec3(\n        p.x * (1.0 - R/denom),\n        p.y * (1.0 - R/denom),\n        p.z\n    ));\n}\n\n\n\nWith intersection and normal in hand, we can render a lit torus:\n\n  Missing Demo\n  Shader demo day4/torus-analytical not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Torus parameters: (major radius, minor radius)\n    vec2 torus = vec2(1.0, 0.4);\n    \n    // Move torus in front of camera\n    ray.origin.z += 3.0;\n    \n    float t = intersectTorus(ray, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        // Lighting (same as sphere)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nIt works! The torus renders correctly with proper lighting and that satisfying donut shape.\nTo see the torus from different angles, let’s make it rotate. We’ll explore how to animate and transform objects in the exercises.\n\n  Missing Demo\n  Shader demo day4/torus-rotating not found.\n\n\n\n\n\nAnalytical ray intersection gives exact results and can be very fast — there’s no iteration, just direct computation. For mathematical visualization, where precision matters and you’re rendering well-understood algebraic surfaces, this approach is sometimes exactly what you want.\nBut the complexity grows quickly with the degree of the surface. A sphere (degree 2) gives a quadratic. A torus (degree 4) gives a quartic. Higher-degree surfaces require solving higher-degree polynomials, and combining multiple objects requires even more sophisticated algebra.\n\n\n\n\n\n\nNoteWhat About Meshes?\n\n\n\nThe other major approach in computer graphics is to approximate surfaces with triangle meshes — thousands or millions of tiny triangles. This is still intersection-based: we write a ray-triangle intersection routine (which is a simple linear system), then test every triangle. Clever data structures (BVHs, k-d trees) make it fast to find which triangles a ray might hit without testing all of them.\nThis is how most video games and production renderers work. But it requires having mesh data — vertices, faces, connectivity — which is a lot of infrastructure. For mathematical visualization, where we work with implicit surfaces and procedural geometry, SDFs and raymarching are more natural. We define shapes with equations, not polygon soup.\n\n\nIn the next section, we’ll see a different approach that trades some precision for dramatic simplicity."
  },
  {
    "objectID": "lectures/day4.html#signed-distance-functions",
    "href": "lectures/day4.html#signed-distance-functions",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "We’ve seen that analytical intersection works but scales poorly with geometric complexity. The core problem is that we’re asking a hard question: “where exactly does this ray hit the surface?” For a sphere, that’s a quadratic equation. For a torus, a quartic. For more complex surfaces, the algebra becomes intractable.\nWhat if we asked an easier question instead?\n\n\nSuppose we have a function that, given any point \\(\\mathbf{p}\\) in space, tells us the distance to the nearest surface. Not which surface, not where on the surface — just how far.\nNow imagine walking along a ray from the camera. At each step, we ask: “how far is the surface from here?” If the answer is \\(d\\), we know it’s safe to step forward by \\(d\\) — we can’t possibly hit anything closer than that. So we step forward, ask again, step again. Eventually one of two things happens:\n\nThe distance gets very small — we’ve arrived at the surface\nWe’ve walked very far without hitting anything — the ray misses\n\nThis is raymarching. Instead of solving for the exact intersection, we iterate our way there. And the function that answers “how far to the surface?” is called a signed distance function (SDF).\n\n\n\nA signed distance function maps every point in space to a number:\n\\[d(\\mathbf{p}) = \\begin{cases}\n&gt; 0 & \\text{outside the surface} \\\\\n= 0 & \\text{on the surface} \\\\\n&lt; 0 & \\text{inside the surface}\n\\end{cases}\\]\nThe magnitude \\(|d(\\mathbf{p})|\\) is the Euclidean distance to the nearest point on the surface. The sign tells you which side you’re on.\nThe sign matters because surfaces have an inside and an outside. When raymarching, we typically start outside an object and walk until we reach the surface (where \\(d \\approx 0\\)). But the sign also lets us do things like carve holes in objects or detect when the camera is inside something.\n\n\n\nBefore we use SDFs for 3D rendering, let’s build intuition in 2D. We can visualize an SDF by coloring the plane according to distance: one color outside, another inside, with contour lines showing level sets.\nThe simplest SDF is a circle of radius \\(r\\) centered at the origin:\n\\[d(\\mathbf{p}) = |\\mathbf{p}| - r\\]\nIf you’re at distance \\(|\\mathbf{p}|\\) from the origin, your signed distance to the circle is how much farther (positive) or closer (negative) you are than \\(r\\).\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n  Missing Demo\n  Shader demo day4/sdf-circle-2d not found.\n\n\nThe contour lines are level sets of the SDF — curves where \\(d(\\mathbf{p}) = k\\) for various values of \\(k\\). On the boundary (\\(k = 0\\)), you’re exactly on the circle. The contours inside are negative; the contours outside are positive.\nA box is more interesting. For an axis-aligned box with half-widths \\((w, h)\\), the SDF is:\nfloat sdBox(vec2 p, vec2 halfSize) {\n    vec2 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nThe formula has two parts: outside the box, we measure distance to the nearest corner or edge; inside, we take the largest (least negative) coordinate distance.\n\n  Missing Demo\n  Shader demo day4/sdf-box-2d not found.\n\n\nNotice how the contour lines “round out” near the corners. The SDF doesn’t know the box has sharp corners — it just measures distance, and distance from a corner is distance from a point.\n\n\n\nThe same idea extends to 3D. Here are SDFs for the shapes we care about:\nSphere:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nOne line. Compare to our 15-line analytical intersection.\nTorus:\nfloat sdTorus(vec3 p, vec2 tor) {\n    // tor.x = major radius, tor.y = minor radius\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\nFour lines. Compare to the 80-line quartic solver.\n\n\n\n\n\n\nNoteGLSL: Swizzling\n\n\n\nGLSL lets you extract and rearrange vector components using swizzle notation. Writing p.xy creates a vec2 containing the x and y components of p. You can use any combination: p.xz, p.zyx, even p.xxx. This is handy for working with different planes — length(p.xy) gives the distance from the Z-axis, treating the xy-plane as 2D.\n\n\nThe logic: length(p.xy) - tor.x gives the distance from the central ring (a circle of radius \\(R\\) in the xy-plane). Then we measure distance from that to the point, accounting for the \\(z\\) coordinate, and subtract the tube radius.\nBox:\nfloat sdBox(vec3 p, vec3 halfSize) {\n    vec3 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\nSame idea as 2D, extended to three dimensions.\nPlane:\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\nA horizontal plane at \\(y = h\\). Points above have positive distance; points below have negative distance. This will be our ground plane.\n\n\n\nFor lighting, we need surface normals. An SDF is an implicit function — the surface is the level set where \\(d(\\mathbf{p}) = 0\\). As we saw with the torus, the gradient of an implicit function points perpendicular to its level sets. So \\(\\nabla d\\) gives us the normal direction.\nWe estimate the gradient numerically using finite differences:\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\nThis works for any SDF — spheres, tori, boxes, or shapes we haven’t even defined yet. We evaluate the SDF at six nearby points and see which direction it increases fastest. That’s the normal."
  },
  {
    "objectID": "lectures/day4.html#raymarching",
    "href": "lectures/day4.html#raymarching",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "We’ve defined SDFs and explained the idea: march along the ray, using the distance field to take safe steps. Now let’s implement it.\n\n\nStarting from the ray origin, we repeatedly:\n\nEvaluate the SDF at our current position\nStep forward along the ray by that distance\nCheck if we’re close enough to the surface (hit) or too far away (miss)\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;  // Distance traveled along ray\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;  // Current position\n        float d = sceneSDF(p);               // Distance to nearest surface\n        \n        if (d &lt; 0.001) {\n            return t;  // Hit: we're close enough\n        }\n        \n        t += d;  // Step forward by the safe distance\n        \n        if (t &gt; 100.0) {\n            return -1.0;  // Miss: we've gone too far\n        }\n    }\n    \n    return -1.0;  // Gave up: too many steps\n}\nThe threshold 0.001 controls how close we need to get before declaring a hit — smaller means more precision but more steps. The maximum distance 100.0 and iteration count 100 are practical limits to avoid infinite loops.\n\n\n\nLet’s render a sphere using raymarching instead of analytical intersection:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\nWith our estimateNormal function from the previous section and the same lighting code we used for analytical rendering:\n\n  Missing Demo\n  Shader demo day4/raymarch-sphere not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Same lighting as before\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe result looks identical to our analytical sphere — same shape, same lighting, same specular highlight. But we found the intersection by marching, not by solving a quadratic.\n\n\n\nNow for the payoff. To render a torus, we change one function:\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdTorus(p, vec2(1.0, 0.4));\n}\nThat’s it. The raymarching loop doesn’t change. The normal estimation doesn’t change. The lighting doesn’t change. We swap four lines of SDF code for four different lines, and:\n\n  Missing Demo\n  Shader demo day4/raymarch-torus not found.\n\n\nCompare this to the analytical torus: 80 lines of quartic algebra reduced to 4 lines of distance calculation. The raymarching framework absorbs all the complexity — we just need to answer “how far is the surface?”"
  },
  {
    "objectID": "lectures/day4.html#building-scenes",
    "href": "lectures/day4.html#building-scenes",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "We can render a sphere. We can render a torus. How do we render both at once?\n\n\nThe SDF tells us the distance to the nearest surface. If we have two objects, the nearest surface is whichever one is closer. So we just take the minimum:\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    float torus = sdTorus(p, vec2(1.0, 0.4));\n    return min(sphere, torus);\n}\nThat’s it. The raymarcher doesn’t change — it still asks “how far to the nearest surface?” and marches accordingly. Now “nearest surface” might be the sphere or the torus depending on where we are.\nAdding more objects is the same pattern:\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    float torus = sdTorus(p, vec2(1.0, 0.4));\n    float ground = sdPlane(p, -1.0);\n    return min(sphere, min(torus, ground));\n}\n\n\n\n\n\n\nNoteConstructive Solid Geometry\n\n\n\nThere’s something elegant happening here. An SDF represents a shape as a function \\(f: \\mathbb{R}^3 \\to \\mathbb{R}\\), where the shape is the zero set \\(\\{p : f(p) = 0\\}\\). Set operations on shapes become pointwise operations on functions:\n\nUnion \\(A \\cup B\\): \\(\\min(f_A, f_B)\\)\nIntersection \\(A \\cap B\\): \\(\\max(f_A, f_B)\\)\nComplement \\(A^c\\): \\(-f_A\\)\n\nThis is constructive solid geometry (CSG) — building complex shapes from simple primitives via boolean operations. With SDFs, CSG is just arithmetic. We’ll explore intersection and subtraction in the exercises.\n\n\n\n\n\nWe can combine objects, but now everything is the same color. To shade each object differently, we need to know which object we hit.\nA simple approach: track a material ID as we build the scene. When we find a new closest surface, record which object it belongs to.\n// Which object is closest: 1 = sphere, 2 = torus, 3 = ground\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;  // Start with large distance\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p + vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\nThen we look up the color based on the ID:\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);  // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\nThis pattern — a global variable modified inside sceneSDF — isn’t the most elegant. It’s a side effect hidden inside what looks like a pure function. But it’s simple, it’s the common idiom in Shadertoy, and it works. For a cleaner approach, you could return a struct containing both distance and material ID; we’ll explore this in the exercises.\n\n\n\nPutting it all together:\n\n  Missing Demo\n  Shader demo day4/scene-multi not found.\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;  // Move camera back\n    ray.origin.y += 1.0;  // Move camera up\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThree objects, three colors, one unified raymarching framework. Adding more objects is just more calls to min()."
  },
  {
    "objectID": "lectures/day4.html#exercises",
    "href": "lectures/day4.html#exercises",
    "title": "1 Day 4: 3D Rendering",
    "section": "",
    "text": "These exercises verify your understanding of the core concepts. Each one should take just a few minutes.\nCheckpoint 1: Move the Sphere\nIn the raymarched sphere demo (A10), the sphere is centered at vec3(0.0, 0.0, -3.0). Move it to the right by changing the center to vec3(1.0, 0.0, -3.0). Then try moving it up, down, closer, farther. What happens if you move it behind the camera (positive z)?\nCheckpoint 2: Torus Proportions\nIn the raymarched torus demo (A11), the torus has major radius 1.0 and minor radius 0.4. Try:\n\nA thin ring: vec2(1.0, 0.1)\nA fat donut: vec2(1.0, 0.8)\nA small tight ring: vec2(0.5, 0.2)\n\nWhat happens when the minor radius exceeds the major radius?\nCheckpoint 3: Add an Object\nIn the multi-object scene (A12), add a second sphere on the right side of the scene. You’ll need to:\n\nAdd the SDF evaluation\nCheck if it’s the closest surface\nAssign it a new material ID (4.0)\nAdd a color for material 4 in getMaterialColor\n\nCheckpoint 4: Change the Palette\nIn the multi-object scene (A12), change the color scheme. Try:\n\nA sunset palette: orange sphere, pink torus, dark purple ground\nA nature palette: green sphere, brown torus, tan ground\nYour own palette\n\nCheckpoint 5: Move the Light\nThe light direction is normalize(vec3(1.0, 1.0, 1.0)) — coming from the upper-right-front. Try:\n\nLight from directly above: vec3(0.0, 1.0, 0.0)\nLight from the left: vec3(-1.0, 0.5, 0.5)\nLight from behind the camera: vec3(0.0, 0.0, 1.0)\n\nHow does the shading change? Where do the specular highlights move?\nCheckpoint 6: Field of View\nIn generateRay, the FOV is set to 90 degrees. Try:\n\nWide angle (120°): objects appear smaller, more of the scene is visible\nTelephoto (30°): objects appear larger, zoomed in, less distortion\n\nWhat FOV feels most natural to you?\n\n\n\nThese exercises go deeper into specific topics. Each one might take 15-30 minutes.\nExploration 1: Two Lights\nAdd a second light source to the scene. You’ll need to:\n\nDefine a second light direction (try normalize(vec3(-1.0, 0.5, -0.5)) for a fill light)\nCompute diffuse and specular for both lights\nAdd the contributions together\n\nFor a nice effect, make the main light white and the fill light slightly colored (e.g., multiply by vec3(0.3, 0.3, 0.5) for a cool fill). This is a common technique in photography and film: a warm key light with a cool fill.\nExploration 2: Fog\nAdd distance-based fog to create atmosphere and depth. After raymarching, you have t — the distance to the hit point. Use this to blend toward a fog color:\nvec3 fogColor = vec3(0.5, 0.6, 0.7);\nfloat fogAmount = 1.0 - exp(-t * 0.1);  // Exponential fog\ncolor = mix(color, fogColor, fogAmount);\nTo see the effect clearly, create a scene with several objects at different distances — try a row of spheres receding into the distance:\nfloat sceneSDF(vec3 p) {\n    float d = sdPlane(p, -1.0);\n    for (float i = 0.0; i &lt; 5.0; i++) {\n        d = min(d, sdSphere(p, vec3(0.0, 0.0, -3.0 - i * 3.0), 0.8));\n    }\n    return d;\n}\nExploration 3: Animation\nMake the scene come alive with iTime. Here’s a pulsing sphere:\nfloat sdPulsingSphere(vec3 p, vec3 center, float baseRadius) {\n    float r = baseRadius * (1.0 + 0.2 * sin(iTime * 3.0));\n    return length(p - center) - r;\n}\nNow try your own animations:\n\nA torus that rotates (hint: rotate p before passing to sdTorus)\nA sphere that orbits another sphere\nObjects that bounce up and down\nA “breathing” scene where everything pulses together\n\nExploration 4: Cone SDF\nLet’s derive SDFs for shapes with rotational symmetry.\nA cylinder is the set of points within distance \\(r\\) of an axis, bounded by two heights. For a cylinder along the Y-axis, we measure distance from the Y-axis by ignoring the y-coordinate:\nfloat sdCylinder(vec3 p, float r, float h) {\n    float dRadial = length(p.xz) - r;    // Distance from curved surface\n    float dVertical = abs(p.y) - h;       // Distance from caps (half-height h)\n    \n    return min(max(dRadial, dVertical), 0.0) + \n           length(max(vec2(dRadial, dVertical), 0.0));\n}\nThis combines a “2D circle” (in xz) with a “1D segment” (in y) — the same pattern as the box SDF.\nYour task: Derive the SDF for a cone. A cone has its tip at the origin, opens upward along the Y-axis, and has a half-angle \\(\\theta\\). Think about:\n\nAt height \\(y\\), what’s the radius of the cone at that level?\nHow do you measure distance from a slanted surface?\nHow do you cap the cone at a maximum height?\n\nHint: The key insight is that at height \\(y\\), the cone’s radius is \\(y \\tan(\\theta)\\). The radial distance becomes length(p.xz) - p.y * tan(angle).\nAdd both a cylinder and a cone to your scene to verify they work.\nExploration 5: Smooth Blending\nThe min function creates hard unions — objects meet at sharp seams. For organic shapes, we want smooth blending. The smooth minimum interpolates between distances:\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\nThe parameter k controls the blending radius — larger k means smoother blends.\nCreate a “metaball” or “lava lamp” effect:\nfloat sceneSDF(vec3 p) {\n    float s1 = sdSphere(p, vec3(-0.8, 0.0, 0.0), 1.0);\n    float s2 = sdSphere(p, vec3(0.8, 0.0, 0.0), 1.0);\n    return smin(s1, s2, 0.5);\n}\nNow animate the spheres moving toward and away from each other. Watch them merge and separate!\nExploration 6: Normal Coloring\nSurface normals aren’t just for lighting — they can be the color itself. This is a classic debugging visualization that also creates beautiful abstract images.\nThe normal vector has components in \\([-1, 1]\\), but colors need to be in \\([0, 1]\\). Remap with:\nvec3 color = normal * 0.5 + 0.5;\nNow surfaces facing right (+X) are red, surfaces facing up (+Y) are green, and surfaces facing the camera (+Z) are blue. Mixtures create cyan, magenta, yellow.\nTry this on your multi-object scene. Notice how it reveals the surface geometry in a way that solid colors hide. This is also useful for debugging — if you see unexpected colors, your normals might be wrong.\nExtend this:\n\nTry abs(normal) instead — what changes?\nUse only one component: vec3(normal.y * 0.5 + 0.5) for a height-based coloring\nAnimate: blend between normal coloring and your regular material colors\n\n\n\n\nThese are substantial projects that extend the techniques from the lecture. Each might take an hour or more.\nChallenge 1: CSG Operations\nWe used min for union. Implement intersection and subtraction:\n\nIntersection: max(a, b) — only points inside both shapes\nSubtraction: max(a, -b) — points inside A but outside B\n\nPractice with these shapes:\n\nA cube with a spherical cavity (intersection of cube and inverted sphere)\nThe intersection of two spheres (lens shape)\nA sphere with a cylindrical hole through it\n\nThen put it all together: make a coffee cup. You’ll need:\n\nA cylinder for the body\nA smaller cylinder subtracted for the hollow interior\nA torus attached with smin for the handle\n\nChallenge 2: Infinite Repetition\nThe mod function can repeat space, creating infinite grids of objects:\nfloat sceneSDF(vec3 p) {\n    vec3 spacing = vec3(4.0);\n    vec3 q = mod(p + spacing * 0.5, spacing) - spacing * 0.5;\n    return sdSphere(q, vec3(0.0), 1.0);\n}\nThis creates an infinite 3D grid of spheres. Experiment with:\n\nDifferent spacing in different directions\nRepeating only in 2D (an infinite floor of objects)\nCombining repeated and non-repeated objects\nAlternating shapes using floor(p / spacing)\n\nChallenge 3: Orbiting Camera\nImplement a camera that orbits around the scene. You’ll need a rotation matrix:\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\nIn mainImage:\nfloat angle = iTime * 0.5;  // Rotate over time\nmat3 rot = rotateY(angle);\n\nRay ray = generateRay(fragCoord);\nray.origin = rot * vec3(0.0, 2.0, 5.0);  // Camera position, rotated\nray.dir = rot * ray.dir;                  // View direction, rotated\nThis rotates the camera around a fixed scene. Alternatively, you could keep the camera fixed and rotate p inside sceneSDF — this rotates the scene instead of the camera. Try both and see which feels more natural.\nExtend this to:\n\nAdd vertical bobbing with sin(iTime)\nLet the camera tilt (rotation around X)\nZoom in and out over time\n\nChallenge 4: Reflections\nMake the ground plane into a mirror. The idea: when a ray hits a reflective surface, compute the reflection direction and raymarch again.\nWe check which object we hit using materialID, and only reflect off the ground:\nvec3 color = shade(hitPoint, normal, ray.dir);\n\n// Only reflect off the ground (material 3)\nif (materialID &gt; 2.5) {\n    vec3 reflectDir = reflect(ray.dir, normal);\n    Ray reflectedRay;\n    reflectedRay.origin = hitPoint + normal * 0.01;  // Offset to avoid self-intersection\n    reflectedRay.dir = reflectDir;\n    \n    float t2 = raymarch(reflectedRay);\n    if (t2 &gt; 0.0) {\n        vec3 reflectedHit = reflectedRay.origin + t2 * reflectedRay.dir;\n        vec3 reflectedNormal = estimateNormal(reflectedHit);\n        vec3 reflectedColor = shade(reflectedHit, reflectedNormal, reflectedRay.dir);\n        color = mix(color, reflectedColor, 0.5);  // 50% reflective\n    }\n}\nThe small offset (normal * 0.01) prevents the reflected ray from immediately hitting the same surface it started from.\nChallenge 5: Struct-Based Materials\nRefactor the global materialID pattern into a cleaner struct-based design:\nstruct Surface {\n    float dist;\n    float matID;\n};\n\nSurface sdSphere(vec3 p, vec3 center, float radius, float matID) {\n    return Surface(length(p - center) - radius, matID);\n}\n\nSurface opUnion(Surface a, Surface b) {\n    return (a.dist &lt; b.dist) ? a : b;\n}\n\nSurface sceneSDF(vec3 p) {\n    Surface s = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0, 1.0);\n    s = opUnion(s, sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4), 2.0));\n    s = opUnion(s, sdPlane(p, -1.0, 3.0));\n    return s;\n}\nYou’ll need to update:\n\nAll SDF primitives to return Surface\nThe raymarch function to work with Surface.dist\nThe estimateNormal function (it only needs distance, so call sceneSDF(p).dist)\n\nThis is more code, but the material tracking is now explicit and composable.\nChallenge 6: Hard Shadows\nShadows add tremendous depth to a scene. The idea: before shading a point, check if there’s anything between it and the light.\nWe already know how to check if a ray hits something — that’s raymarching! For shadows, we raymarch from the hit point toward the light:\nfloat hardShadow(vec3 origin, vec3 lightDir, float maxDist) {\n    float t = 0.02;  // Start slightly away from surface\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + lightDir * t);\n        if (d &lt; 0.001) return 0.0;  // Hit something — in shadow\n        t += d;\n        if (t &gt; maxDist) break;\n    }\n    \n    return 1.0;  // Reached the light — not in shadow\n}\nUse it in your lighting calculation:\nvec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));\nfloat shadow = hardShadow(hitPoint + normal * 0.02, lightDir, 10.0);\n\nfloat diffuse = max(0.0, dot(normal, lightDir));\ncolor = matColor * (ambient + diffuse * shadow);\nThe offset normal * 0.02 prevents the shadow ray from immediately hitting the surface it started from (self-shadowing artifacts).\nThings to try:\n\nAdd shadows to your multi-object scene\nUse different shadow intensities (multiply by 0.5 instead of 0.0 for softer shadows)\nOnly cast shadows from your key light, not fill lights\n\n\n\n\nAlgebraic Variety Rendering\nAn algebraic variety is the zero set of a polynomial — a surface defined by \\(f(x, y, z) = 0\\). These surfaces have been studied for centuries, and some of them are strikingly beautiful. In this project, you’ll build a raymarcher that can render any algebraic variety.\n\n\nWe can’t compute an exact SDF for a general polynomial, but we can estimate the distance. The key insight: near the surface, the function value \\(f(\\mathbf{p})\\) is approximately proportional to distance, with the gradient \\(\\nabla f\\) telling us how fast \\(f\\) changes.\nThis gives us the distance estimate:\n\\[d \\approx \\frac{|f(\\mathbf{p})|}{|\\nabla f(\\mathbf{p})|}\\]\nThis isn’t a true SDF — it can overestimate or underestimate — but it’s good enough for raymarching if we’re conservative. In practice, we often scale it down slightly:\nfloat estimateDistance(vec3 p) {\n    float f = polynomial(p);\n    vec3 grad = gradient(p);\n    return 0.5 * abs(f) / length(grad);  // Factor of 0.5 for safety\n}\nYou’ll need to compute the gradient. You can either derive it analytically from the polynomial (faster, exact), or estimate it numerically with finite differences (easier, works for any polynomial):\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        polynomial(p + vec3(eps, 0, 0)) - polynomial(p - vec3(eps, 0, 0)),\n        polynomial(p + vec3(0, eps, 0)) - polynomial(p - vec3(0, eps, 0)),\n        polynomial(p + vec3(0, 0, eps)) - polynomial(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\n\n\nAlgebraic varieties can extend to infinity or have complex topology. To raymarch efficiently, first intersect with a bounding sphere or box:\nfloat sceneSDF(vec3 p) {\n    // Bounding sphere\n    float bounds = length(p) - 2.0;\n    if (bounds &gt; 0.01) {\n        return bounds;  // Outside bounds: use sphere distance\n    }\n    \n    // Inside bounds: use variety distance estimate\n    return estimateDistance(p);\n}\nThis lets us skip the expensive polynomial evaluation until we’re close.\n\n\n\nFor lighting, the gradient gives us the normal direction:\nvec3 normal = normalize(gradient(hitPoint));\nIf the gradient points “inward” relative to your camera, you may need to flip it.\n\n\n\nTo view the variety from different angles, rotate the point before evaluating:\nfloat polynomial(vec3 p) {\n    p = rotateY(iTime * 0.3) * p;  // Slow rotation\n    // ... evaluate polynomial ...\n}\n\n\n\nHere are some beautiful algebraic surfaces to try. Each is written as \\(f(x,y,z) = 0\\).\nBarth Sextic (degree 6) — 50 double points, icosahedral symmetry:\n\\[4(\\phi^2 x^2 - y^2)(\\phi^2 y^2 - z^2)(\\phi^2 z^2 - x^2) - (1 + 2\\phi)(x^2 + y^2 + z^2 - 1)^2 = 0\\]\nwhere \\(\\phi = \\frac{1 + \\sqrt{5}}{2}\\) is the golden ratio.\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\nClebsch Diagonal Cubic (degree 3) — contains exactly 27 lines:\n\\[81(x^3 + y^3 + z^3) - 189(x^2 y + x^2 z + y^2 x + y^2 z + z^2 x + z^2 y) + 54xyz + 126(xy + xz + yz) - 9(x^2 + y^2 + z^2) - 9(x + y + z) + 1 = 0\\]\nfloat clebschCubic(vec3 p) {\n    float x = p.x, y = p.y, z = p.z;\n    float x2 = x*x, y2 = y*y, z2 = z*z;\n    float x3 = x2*x, y3 = y2*y, z3 = z2*z;\n    \n    return 81.0*(x3 + y3 + z3)\n         - 189.0*(x2*y + x2*z + y2*x + y2*z + z2*x + z2*y)\n         + 54.0*x*y*z\n         + 126.0*(x*y + x*z + y*z)\n         - 9.0*(x2 + y2 + z2)\n         - 9.0*(x + y + z)\n         + 1.0;\n}\nCayley Cubic (degree 3) — 4 nodes:\n\\[x^2 + y^2 - x^2 z + y^2 z + z^2 - 1 = 0\\]\nfloat cayleyCubic(vec3 p) {\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    return x2 + y2 - x2 * p.z + y2 * p.z + z2 - 1.0;\n}\nKummer Surface (degree 4) — 16 nodes:\n\\[(x^2 + y^2 + z^2 - \\mu^2)^2 - \\lambda \\cdot p_0 p_1 p_2 p_3 = 0\\]\nwhere \\(p_i\\) are planes forming a tetrahedron. A simplified version:\nfloat kummerSurface(vec3 p) {\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float sum = x2 + y2 + z2;\n    float prod = x2 * y2 + y2 * z2 + z2 * x2;\n    \n    float mu = 1.3;\n    float lambda = 3.0;\n    \n    float a = sum - mu * mu;\n    return a * a - lambda * prod;\n}\nHeart Surface (degree 6) — for fun:\n\\[(x^2 + \\frac{9}{4}y^2 + z^2 - 1)^3 - x^2 z^3 - \\frac{9}{80}y^2 z^3 = 0\\]\nfloat heartSurface(vec3 p) {\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    float z3 = z2 * p.z;\n    \n    float a = x2 + 2.25 * y2 + z2 - 1.0;\n    return a * a * a - x2 * z3 - 0.1125 * y2 * z3;\n}\n\n\n\nBuild a beautiful scene featuring an algebraic variety. Your shader should:\n\nImplement distance estimation for at least one variety\nUse a bounding volume for efficiency\nInclude proper lighting with surface normals\n\nBeyond that, get creative! Some ideas:\n\nAdd a reflective floor beneath the variety\nUse multiple colored lights\nAdd fog for atmosphere\nMake the variety rotate slowly\nTry different varieties and find your favorite\nCombine multiple varieties in one scene"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html",
    "href": "lectures/shaders/day4-shaders.html",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Complete, standalone code for each shader referenced in Day 4. Each listing can be copied directly into Shadertoy and run immediately.\n\n\nThese helper functions are used throughout Day 4:\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\n\n\nVisualize ray directions as colors to verify camera setup.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Map direction components from [-1,1] to [0,1] for display\n    vec3 color = ray.dir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nSphere intersection test with flat color (no lighting).\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;  // First intersection in front\n    if (t2 &gt; 0.0) return t2;  // We're inside the sphere\n    return -1.0;              // Sphere is behind us\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nSphere with normals visualized as colors.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        color = normal * 0.5 + 0.5;  // Map [-1,1] to [0,1]\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nSphere with Lambertian diffuse lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Direction toward light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Shading\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse);\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nSphere with diffuse and specular lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Directions\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Toward light\n        vec3 viewDir = -ray.dir;                         // Toward camera\n        vec3 reflectDir = reflect(-lightDir, normal);    // Light reflected about normal\n        \n        // Diffuse: brightness based on angle to light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Specular: bright spot where reflection aligns with view\n        float shininess = 32.0;\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), shininess);\n        \n        // Combine lighting\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAnalytical ray-torus intersection using quartic solver.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\n// Torus intersection by Inigo Quilez\n// https://iquilezles.org/articles/intersectors/\nfloat intersectTorus(Ray ray, vec2 tor) {\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ray.origin, ray.origin);\n    float n = dot(ray.origin, ray.dir);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*ray.dir.z*ray.dir.z + k;\n    float k1 = k*n + Ra2*ray.origin.z*ray.dir.z;\n    float k0 = k*k + Ra2*ray.origin.z*ray.origin.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01) {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0) {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4) {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    if(result &gt; 1e10) return -1.0;\n    return result;\n}\n\nvec3 torusNormal(vec3 p, vec2 tor) {\n    float R = tor.x;\n    float denom = sqrt(p.x*p.x + p.y*p.y);\n    return normalize(vec3(\n        p.x * (1.0 - R/denom),\n        p.y * (1.0 - R/denom),\n        p.z\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Torus parameters: (major radius, minor radius)\n    vec2 torus = vec2(1.0, 0.4);\n    \n    // Move torus in front of camera\n    ray.origin.z += 3.0;\n    \n    float t = intersectTorus(ray, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        // Lighting (same as sphere)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAnalytical torus rotating around the X axis.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\n// Rotation matrix around X axis\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// Torus intersection by Inigo Quilez\n// https://iquilezles.org/articles/intersectors/\nfloat intersectTorus(Ray ray, vec2 tor) {\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ray.origin, ray.origin);\n    float n = dot(ray.origin, ray.dir);\n    \n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*ray.dir.z*ray.dir.z + k;\n    float k1 = k*n + Ra2*ray.origin.z*ray.dir.z;\n    float k0 = k*k + Ra2*ray.origin.z*ray.origin.z - Ra2*ra2;\n    \n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01) {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0) {\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else {\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4) {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    if(result &gt; 1e10) return -1.0;\n    return result;\n}\n\nvec3 torusNormal(vec3 p, vec2 tor) {\n    float R = tor.x;\n    float denom = sqrt(p.x*p.x + p.y*p.y);\n    return normalize(vec3(\n        p.x * (1.0 - R/denom),\n        p.y * (1.0 - R/denom),\n        p.z\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Torus parameters: (major radius, minor radius)\n    vec2 torus = vec2(1.0, 0.4);\n    \n    // Rotate ray into torus local space\n    mat3 rot = rotateX(iTime);\n    Ray localRay;\n    localRay.origin = rot * (ray.origin + vec3(0.0, 0.0, 3.0));\n    localRay.dir = rot * ray.dir;\n    \n    float t = intersectTorus(localRay, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 localHit = localRay.origin + t * localRay.dir;\n        vec3 localNormal = torusNormal(localHit, torus);\n        \n        // Rotate normal back to world space\n        vec3 normal = transpose(rot) * localNormal;\n        \n        // Lighting in world space\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n2D circle SDF visualization with contour lines.\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates centered at origin\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;  // Scale to [-2, 2]\n    \n    // Evaluate SDF\n    float d = sdCircle(uv, 1.0);\n    \n    // Color by sign: orange outside, blue inside\n    vec3 color = (d &gt; 0.0) ? vec3(1.0, 0.6, 0.2) : vec3(0.2, 0.4, 0.8);\n    \n    // Darken based on distance (further = darker)\n    color *= 1.0 - 0.3 * abs(d);\n    \n    // Contour lines\n    float contour = abs(fract(d * 4.0 + 0.5) - 0.5) * 2.0;\n    color *= 0.5 + 0.5 * smoothstep(0.0, 0.05, contour);\n    \n    // Highlight the zero contour (the actual circle)\n    color = mix(vec3(1.0), color, smoothstep(0.0, 0.02, abs(d)));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n2D box SDF visualization with contour lines.\nfloat sdBox(vec2 p, vec2 halfSize) {\n    vec2 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates centered at origin\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;  // Scale to [-2, 2]\n    \n    // Evaluate SDF\n    float d = sdBox(uv, vec2(1.0, 0.6));\n    \n    // Color by sign: orange outside, blue inside\n    vec3 color = (d &gt; 0.0) ? vec3(1.0, 0.6, 0.2) : vec3(0.2, 0.4, 0.8);\n    \n    // Darken based on distance (further = darker)\n    color *= 1.0 - 0.3 * abs(d);\n    \n    // Contour lines\n    float contour = abs(fract(d * 4.0 + 0.5) - 0.5) * 2.0;\n    color *= 0.5 + 0.5 * smoothstep(0.0, 0.05, contour);\n    \n    // Highlight the zero contour (the actual box boundary)\n    color = mix(vec3(1.0), color, smoothstep(0.0, 0.02, abs(d)));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nRaymarched sphere with lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) {\n            return t;\n        }\n        \n        t += d;\n        \n        if (t &gt; 100.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nRaymarched torus - same code, different SDF.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdTorus(p, vec2(1.0, 0.4));\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) {\n            return t;\n        }\n        \n        t += d;\n        \n        if (t &gt; 100.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Move camera back to see the torus\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nMulti-object scene with materials.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Which object is closest: 1 = sphere, 2 = torus, 3 = ground\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);  // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) {\n            return t;\n        }\n        \n        t += d;\n        \n        if (t &gt; 100.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;  // Move camera back\n    ray.origin.y += 1.0;  // Move camera up\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nThe hero shader for the overview - Barth sextic with full scene.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nfloat barthSextic(vec3 p) {\n    // Apply rotation\n    p = rotateY(iTime * 0.3) * p;\n    \n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n// Hard shadow - returns 0 if in shadow, 1 if lit\nfloat hardShadow(vec3 origin, vec3 dir, float maxt) {\n    float t = 0.02;\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + dir * t);\n        if (d &lt; 0.001) return 0.0;\n        t += d;\n        if (t &gt; maxt) break;\n    }\n    \n    return 1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm, from upper right)\n        vec3 lightDir1 = normalize(vec3(2.0, 2.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.9, 0.8);\n        float diff1 = max(0.0, dot(normal, lightDir1));\n        float spec1 = pow(max(0.0, dot(reflect(-lightDir1, normal), viewDir)), 32.0);\n        float shadow1 = hardShadow(hitPoint + normal * 0.02, lightDir1, 10.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-2.0, 1.0, 0.5));\n        vec3 lightColor2 = vec3(0.4, 0.5, 0.8);\n        float diff2 = max(0.0, dot(normal, lightDir2));\n        float spec2 = pow(max(0.0, dot(reflect(-lightDir2, normal), viewDir)), 32.0);\n        \n        // Rim light (purple, from behind)\n        vec3 lightDir3 = normalize(vec3(0.0, 0.5, -1.0));\n        vec3 lightColor3 = vec3(0.5, 0.3, 0.6);\n        float diff3 = max(0.0, dot(normal, lightDir3));\n        \n        float ambient = 0.08;\n        color = matColor * ambient;\n        color += (matColor * diff1 * lightColor1 + spec1 * lightColor1 * 0.3) * shadow1;\n        color += matColor * diff2 * lightColor2 + spec2 * lightColor2 * 0.2;\n        color += matColor * diff3 * lightColor3;\n        \n        // Gamma correction\n        color = pow(color, vec3(0.4545));\n    }\n    else {\n        color = vec3(0.08, 0.08, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#common-functions",
    "href": "lectures/shaders/day4-shaders.html#common-functions",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "These helper functions are used throughout Day 4:\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a1.-ray-visualization",
    "href": "lectures/shaders/day4-shaders.html#a1.-ray-visualization",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Visualize ray directions as colors to verify camera setup.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Map direction components from [-1,1] to [0,1] for display\n    vec3 color = ray.dir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a2.-sphere-flat",
    "href": "lectures/shaders/day4-shaders.html#a2.-sphere-flat",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Sphere intersection test with flat color (no lighting).\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;  // First intersection in front\n    if (t2 &gt; 0.0) return t2;  // We're inside the sphere\n    return -1.0;              // Sphere is behind us\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a3.-sphere-normals",
    "href": "lectures/shaders/day4-shaders.html#a3.-sphere-normals",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Sphere with normals visualized as colors.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        color = normal * 0.5 + 0.5;  // Map [-1,1] to [0,1]\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a4.-sphere-diffuse",
    "href": "lectures/shaders/day4-shaders.html#a4.-sphere-diffuse",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Sphere with Lambertian diffuse lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Direction toward light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Shading\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse);\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a5.-sphere-lit",
    "href": "lectures/shaders/day4-shaders.html#a5.-sphere-lit",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Sphere with diffuse and specular lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat intersectSphere(Ray ray, vec3 center, float radius) {\n    vec3 delta = ray.origin - center;\n    \n    float b = dot(delta, ray.dir);\n    float c = dot(delta, delta) - radius * radius;\n    float discriminant = b * b - c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;\n    }\n    \n    float sqrtDisc = sqrt(discriminant);\n    float t1 = -b - sqrtDisc;\n    float t2 = -b + sqrtDisc;\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Scene\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(ray, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Compute hit point and normal\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = (hitPoint - sphereCenter) / sphereRadius;\n        \n        // Directions\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));  // Toward light\n        vec3 viewDir = -ray.dir;                         // Toward camera\n        vec3 reflectDir = reflect(-lightDir, normal);    // Light reflected about normal\n        \n        // Diffuse: brightness based on angle to light\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Specular: bright spot where reflection aligns with view\n        float shininess = 32.0;\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), shininess);\n        \n        // Combine lighting\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a6.-torus-analytical",
    "href": "lectures/shaders/day4-shaders.html#a6.-torus-analytical",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Analytical ray-torus intersection using quartic solver.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\n// Torus intersection by Inigo Quilez\n// https://iquilezles.org/articles/intersectors/\nfloat intersectTorus(Ray ray, vec2 tor) {\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ray.origin, ray.origin);\n    float n = dot(ray.origin, ray.dir);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*ray.dir.z*ray.dir.z + k;\n    float k1 = k*n + Ra2*ray.origin.z*ray.dir.z;\n    float k0 = k*k + Ra2*ray.origin.z*ray.origin.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01) {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0) {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4) {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    if(result &gt; 1e10) return -1.0;\n    return result;\n}\n\nvec3 torusNormal(vec3 p, vec2 tor) {\n    float R = tor.x;\n    float denom = sqrt(p.x*p.x + p.y*p.y);\n    return normalize(vec3(\n        p.x * (1.0 - R/denom),\n        p.y * (1.0 - R/denom),\n        p.z\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Torus parameters: (major radius, minor radius)\n    vec2 torus = vec2(1.0, 0.4);\n    \n    // Move torus in front of camera\n    ray.origin.z += 3.0;\n    \n    float t = intersectTorus(ray, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        // Lighting (same as sphere)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a7.-torus-rotating",
    "href": "lectures/shaders/day4-shaders.html#a7.-torus-rotating",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Analytical torus rotating around the X axis.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\n// Rotation matrix around X axis\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// Torus intersection by Inigo Quilez\n// https://iquilezles.org/articles/intersectors/\nfloat intersectTorus(Ray ray, vec2 tor) {\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ray.origin, ray.origin);\n    float n = dot(ray.origin, ray.dir);\n    \n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*ray.dir.z*ray.dir.z + k;\n    float k1 = k*n + Ra2*ray.origin.z*ray.dir.z;\n    float k0 = k*k + Ra2*ray.origin.z*ray.origin.z - Ra2*ra2;\n    \n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01) {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0) {\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else {\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4) {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0) {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    if(result &gt; 1e10) return -1.0;\n    return result;\n}\n\nvec3 torusNormal(vec3 p, vec2 tor) {\n    float R = tor.x;\n    float denom = sqrt(p.x*p.x + p.y*p.y);\n    return normalize(vec3(\n        p.x * (1.0 - R/denom),\n        p.y * (1.0 - R/denom),\n        p.z\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Torus parameters: (major radius, minor radius)\n    vec2 torus = vec2(1.0, 0.4);\n    \n    // Rotate ray into torus local space\n    mat3 rot = rotateX(iTime);\n    Ray localRay;\n    localRay.origin = rot * (ray.origin + vec3(0.0, 0.0, 3.0));\n    localRay.dir = rot * ray.dir;\n    \n    float t = intersectTorus(localRay, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 localHit = localRay.origin + t * localRay.dir;\n        vec3 localNormal = torusNormal(localHit, torus);\n        \n        // Rotate normal back to world space\n        vec3 normal = transpose(rot) * localNormal;\n        \n        // Lighting in world space\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        // Ray missed - background color\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a8.-sdf-circle-2d",
    "href": "lectures/shaders/day4-shaders.html#a8.-sdf-circle-2d",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "2D circle SDF visualization with contour lines.\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates centered at origin\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;  // Scale to [-2, 2]\n    \n    // Evaluate SDF\n    float d = sdCircle(uv, 1.0);\n    \n    // Color by sign: orange outside, blue inside\n    vec3 color = (d &gt; 0.0) ? vec3(1.0, 0.6, 0.2) : vec3(0.2, 0.4, 0.8);\n    \n    // Darken based on distance (further = darker)\n    color *= 1.0 - 0.3 * abs(d);\n    \n    // Contour lines\n    float contour = abs(fract(d * 4.0 + 0.5) - 0.5) * 2.0;\n    color *= 0.5 + 0.5 * smoothstep(0.0, 0.05, contour);\n    \n    // Highlight the zero contour (the actual circle)\n    color = mix(vec3(1.0), color, smoothstep(0.0, 0.02, abs(d)));\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a9.-sdf-box-2d",
    "href": "lectures/shaders/day4-shaders.html#a9.-sdf-box-2d",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "2D box SDF visualization with contour lines.\nfloat sdBox(vec2 p, vec2 halfSize) {\n    vec2 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates centered at origin\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;  // Scale to [-2, 2]\n    \n    // Evaluate SDF\n    float d = sdBox(uv, vec2(1.0, 0.6));\n    \n    // Color by sign: orange outside, blue inside\n    vec3 color = (d &gt; 0.0) ? vec3(1.0, 0.6, 0.2) : vec3(0.2, 0.4, 0.8);\n    \n    // Darken based on distance (further = darker)\n    color *= 1.0 - 0.3 * abs(d);\n    \n    // Contour lines\n    float contour = abs(fract(d * 4.0 + 0.5) - 0.5) * 2.0;\n    color *= 0.5 + 0.5 * smoothstep(0.0, 0.05, contour);\n    \n    // Highlight the zero contour (the actual box boundary)\n    color = mix(vec3(1.0), color, smoothstep(0.0, 0.02, abs(d)));\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a10.-raymarch-sphere",
    "href": "lectures/shaders/day4-shaders.html#a10.-raymarch-sphere",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Raymarched sphere with lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) {\n            return t;\n        }\n        \n        t += d;\n        \n        if (t &gt; 100.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a11.-raymarch-torus",
    "href": "lectures/shaders/day4-shaders.html#a11.-raymarch-torus",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Raymarched torus - same code, different SDF.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdTorus(p, vec2(1.0, 0.4));\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) {\n            return t;\n        }\n        \n        t += d;\n        \n        if (t &gt; 100.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    // Move camera back to see the torus\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a12.-scene-multi",
    "href": "lectures/shaders/day4-shaders.html#a12.-scene-multi",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "Multi-object scene with materials.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Which object is closest: 1 = sphere, 2 = torus, 3 = ground\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);  // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) {\n            return t;\n        }\n        \n        t += d;\n        \n        if (t &gt; 100.0) {\n            return -1.0;\n        }\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;  // Move camera back\n    ray.origin.y += 1.0;  // Move camera up\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Lighting\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day4-shaders.html#a13.-barth-sextic-final",
    "href": "lectures/shaders/day4-shaders.html#a13.-barth-sextic-final",
    "title": "1 Day 4 Code",
    "section": "",
    "text": "The hero shader for the overview - Barth sextic with full scene.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nfloat barthSextic(vec3 p) {\n    // Apply rotation\n    p = rotateY(iTime * 0.3) * p;\n    \n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n// Hard shadow - returns 0 if in shadow, 1 if lit\nfloat hardShadow(vec3 origin, vec3 dir, float maxt) {\n    float t = 0.02;\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + dir * t);\n        if (d &lt; 0.001) return 0.0;\n        t += d;\n        if (t &gt; maxt) break;\n    }\n    \n    return 1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm, from upper right)\n        vec3 lightDir1 = normalize(vec3(2.0, 2.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.9, 0.8);\n        float diff1 = max(0.0, dot(normal, lightDir1));\n        float spec1 = pow(max(0.0, dot(reflect(-lightDir1, normal), viewDir)), 32.0);\n        float shadow1 = hardShadow(hitPoint + normal * 0.02, lightDir1, 10.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-2.0, 1.0, 0.5));\n        vec3 lightColor2 = vec3(0.4, 0.5, 0.8);\n        float diff2 = max(0.0, dot(normal, lightDir2));\n        float spec2 = pow(max(0.0, dot(reflect(-lightDir2, normal), viewDir)), 32.0);\n        \n        // Rim light (purple, from behind)\n        vec3 lightDir3 = normalize(vec3(0.0, 0.5, -1.0));\n        vec3 lightColor3 = vec3(0.5, 0.3, 0.6);\n        float diff3 = max(0.0, dot(normal, lightDir3));\n        \n        float ambient = 0.08;\n        color = matColor * ambient;\n        color += (matColor * diff1 * lightColor1 + spec1 * lightColor1 * 0.3) * shadow1;\n        color += matColor * diff2 * lightColor2 + spec2 * lightColor2 * 0.2;\n        color += matColor * diff3 * lightColor3;\n        \n        // Gamma correction\n        color = pow(color, vec3(0.4545));\n    }\n    else {\n        color = vec3(0.08, 0.08, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html",
    "href": "lectures/shaders/day2-shaders.html",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Complete, standalone code for each shader referenced in Day 2. Each listing can be copied directly into Shadertoy and run immediately.\n\n\nThese helper functions are used throughout Day 2:\n// Normalize screen coordinates to centered, aspect-corrected space\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\n// Complex multiplication: (a + bi)(c + di)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Squared magnitude of complex number (avoids sqrt)\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\n// Cosine palette for smooth coloring\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n\n\nAnimated zoom into the Mandelbrot set with smooth coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    float zoom = pow(1.5, mod(iTime, 30.0));\n    return uv * 4.0 / zoom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Zoom into the seahorse valley\n    vec2 center = vec2(-0.745, 0.186);\n    vec2 c = center + p;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 200;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t * 4.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nBlack and white Mandelbrot set.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;  // shift left to center the interesting part\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nMandelbrot set with grayscale iteration coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = vec3(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nMandelbrot set with cosine palette coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nJulia set with fixed parameter (black and white).\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fixed parameter - try different values!\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // z starts at pixel position\n    vec2 z = p;\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);  // In the set: black\n    } else {\n        color = vec3(1.0);  // Escaped: white\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nInteractive Julia set explorer: gray Mandelbrot as parameter space background, black Julia set overlaid, red dot shows current c.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Get c from mouse position\n    vec2 c = normalize_coord(iMouse.xy);\n    c.x -= 0.5;\n    \n    // Default to interesting value if no mouse\n    if (iMouse.x &lt; 1.0) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Mandelbrot iteration (for background)\n    vec2 mc = p;\n    mc.x -= 0.5;\n    vec2 mz = vec2(0.0);\n    int m_iter;\n    for (m_iter = 0; m_iter &lt; 100; m_iter++) {\n        if (cabs2(mz) &gt; 4.0) break;\n        mz = cmul(mz, mz) + mc;\n    }\n    \n    // Julia iteration (for foreground)\n    vec2 jz = p;\n    int j_iter;\n    for (j_iter = 0; j_iter &lt; 100; j_iter++) {\n        if (cabs2(jz) &gt; 4.0) break;\n        jz = cmul(jz, jz) + c;\n    }\n    \n    // Color: light background, Mandelbrot in gray, Julia in black\n    vec3 color = vec3(0.9);  // light background (escaped both)\n    if (m_iter == 100) {\n        color = vec3(0.6);  // Mandelbrot set in gray\n    }\n    if (j_iter == 100) {\n        color = vec3(0.0);  // Julia set in black\n    }\n    \n    // Draw red dot at c position (in Mandelbrot coordinates)\n    vec2 c_pos = c;\n    c_pos.x += 0.5;  // undo the offset we applied to c\n    if (length(p - c_pos) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nCircle inversion visualization with toggling.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 p_inv = invert(p);\n    \n    // Toggle between original and inverted every second\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;\n    } else {\n        q = p_inv;\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a vertical line at x = 2\n    if (abs(q.x - 2.0) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a horizontal line at y = 1.5\n    if (abs(q.y - 1.5) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a circle centered at (2, 0) with radius 0.5\n    float d_circle = abs(length(q - vec2(2.0, 0.0)) - 0.5);\n    if (d_circle &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nCircle inversion of a grid.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 p_inv = invert(p);\n    \n    // Toggle\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;\n    } else {\n        q = p_inv;\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a grid using mod\n    vec2 grid = mod(q, 0.5);\n    if (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nInversion through a moving circle.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Animate the inversion circle\n    Circle inv_circle;\n    inv_circle.center = vec2(sin(iTime) * 0.5, cos(iTime * 0.7) * 0.5);\n    inv_circle.radius = 1.0 + 0.3 * sin(iTime * 1.3);\n    \n    vec2 p_inv = invert(p, inv_circle);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the inversion circle\n    float d_inv = abs(length(p - inv_circle.center) - inv_circle.radius);\n    if (d_inv &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = mod(p_inv, 0.5);\n    if (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nThe four mutually tangent circles (no iteration).\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Three mutually tangent inner circles plus outer circle\n    // For three circles of radius r centered at vertices of equilateral triangle:\n    // - Side length of triangle = 2r (so circles touch)\n    // - Circumradius of triangle = 2r / sqrt(3)\n    // - Outer circle radius = circumradius + r\n    \n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    // Inner circles at vertices of equilateral triangle\n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    \n    // Outer circle tangent to all three from outside\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw all four circles\n    if (distToCircle(p, c1) &lt; 0.03) color = vec3(1.0, 0.3, 0.3);\n    if (distToCircle(p, c2) &lt; 0.03) color = vec3(0.3, 1.0, 0.3);\n    if (distToCircle(p, c3) &lt; 0.03) color = vec3(0.3, 0.3, 1.0);\n    if (distToCircle(p, outer) &lt; 0.03) color = vec3(1.0, 1.0, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nFull Apollonian gasket with iteration.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Draw circle boundaries\n    float dMin = min(min(distToCircle(p, c1), distToCircle(p, c2)), \n                     min(distToCircle(p, c3), distToCircle(p, outer)));\n    if (dMin &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nApollonian gasket with coloring emphasizing the limit set.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration count, emphasizing the limit set\n    float t = float(iter) / float(max_iter);\n    vec3 color = 30.0 * vec3(pow(t, 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#common-functions",
    "href": "lectures/shaders/day2-shaders.html#common-functions",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "These helper functions are used throughout Day 2:\n// Normalize screen coordinates to centered, aspect-corrected space\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\n// Complex multiplication: (a + bi)(c + di)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Squared magnitude of complex number (avoids sqrt)\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\n// Cosine palette for smooth coloring\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a1.-mandelbrot-zoom",
    "href": "lectures/shaders/day2-shaders.html#a1.-mandelbrot-zoom",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Animated zoom into the Mandelbrot set with smooth coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    float zoom = pow(1.5, mod(iTime, 30.0));\n    return uv * 4.0 / zoom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Zoom into the seahorse valley\n    vec2 center = vec2(-0.745, 0.186);\n    vec2 c = center + p;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 200;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t * 4.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a2.-mandelbrot-bw",
    "href": "lectures/shaders/day2-shaders.html#a2.-mandelbrot-bw",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Black and white Mandelbrot set.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;  // shift left to center the interesting part\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a3.-mandelbrot-gray",
    "href": "lectures/shaders/day2-shaders.html#a3.-mandelbrot-gray",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Mandelbrot set with grayscale iteration coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = vec3(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a4.-mandelbrot-color",
    "href": "lectures/shaders/day2-shaders.html#a4.-mandelbrot-color",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Mandelbrot set with cosine palette coloring.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    vec2 c = p;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a5.-julia-static",
    "href": "lectures/shaders/day2-shaders.html#a5.-julia-static",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Julia set with fixed parameter (black and white).\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fixed parameter - try different values!\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // z starts at pixel position\n    vec2 z = p;\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);  // In the set: black\n    } else {\n        color = vec3(1.0);  // Escaped: white\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a6.-julia-explorer",
    "href": "lectures/shaders/day2-shaders.html#a6.-julia-explorer",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Interactive Julia set explorer: gray Mandelbrot as parameter space background, black Julia set overlaid, red dot shows current c.\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Get c from mouse position\n    vec2 c = normalize_coord(iMouse.xy);\n    c.x -= 0.5;\n    \n    // Default to interesting value if no mouse\n    if (iMouse.x &lt; 1.0) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Mandelbrot iteration (for background)\n    vec2 mc = p;\n    mc.x -= 0.5;\n    vec2 mz = vec2(0.0);\n    int m_iter;\n    for (m_iter = 0; m_iter &lt; 100; m_iter++) {\n        if (cabs2(mz) &gt; 4.0) break;\n        mz = cmul(mz, mz) + mc;\n    }\n    \n    // Julia iteration (for foreground)\n    vec2 jz = p;\n    int j_iter;\n    for (j_iter = 0; j_iter &lt; 100; j_iter++) {\n        if (cabs2(jz) &gt; 4.0) break;\n        jz = cmul(jz, jz) + c;\n    }\n    \n    // Color: light background, Mandelbrot in gray, Julia in black\n    vec3 color = vec3(0.9);  // light background (escaped both)\n    if (m_iter == 100) {\n        color = vec3(0.6);  // Mandelbrot set in gray\n    }\n    if (j_iter == 100) {\n        color = vec3(0.0);  // Julia set in black\n    }\n    \n    // Draw red dot at c position (in Mandelbrot coordinates)\n    vec2 c_pos = c;\n    c_pos.x += 0.5;  // undo the offset we applied to c\n    if (length(p - c_pos) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a7.-inversion-toggle",
    "href": "lectures/shaders/day2-shaders.html#a7.-inversion-toggle",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Circle inversion visualization with toggling.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 p_inv = invert(p);\n    \n    // Toggle between original and inverted every second\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;\n    } else {\n        q = p_inv;\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a vertical line at x = 2\n    if (abs(q.x - 2.0) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a horizontal line at y = 1.5\n    if (abs(q.y - 1.5) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a circle centered at (2, 0) with radius 0.5\n    float d_circle = abs(length(q - vec2(2.0, 0.0)) - 0.5);\n    if (d_circle &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a8.-inversion-grid",
    "href": "lectures/shaders/day2-shaders.html#a8.-inversion-grid",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Circle inversion of a grid.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 p_inv = invert(p);\n    \n    // Toggle\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;\n    } else {\n        q = p_inv;\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a grid using mod\n    vec2 grid = mod(q, 0.5);\n    if (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a9.-inversion-moving",
    "href": "lectures/shaders/day2-shaders.html#a9.-inversion-moving",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Inversion through a moving circle.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Animate the inversion circle\n    Circle inv_circle;\n    inv_circle.center = vec2(sin(iTime) * 0.5, cos(iTime * 0.7) * 0.5);\n    inv_circle.radius = 1.0 + 0.3 * sin(iTime * 1.3);\n    \n    vec2 p_inv = invert(p, inv_circle);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the inversion circle\n    float d_inv = abs(length(p - inv_circle.center) - inv_circle.radius);\n    if (d_inv &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = mod(p_inv, 0.5);\n    if (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a10.-apollonian-setup",
    "href": "lectures/shaders/day2-shaders.html#a10.-apollonian-setup",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "The four mutually tangent circles (no iteration).\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Three mutually tangent inner circles plus outer circle\n    // For three circles of radius r centered at vertices of equilateral triangle:\n    // - Side length of triangle = 2r (so circles touch)\n    // - Circumradius of triangle = 2r / sqrt(3)\n    // - Outer circle radius = circumradius + r\n    \n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    // Inner circles at vertices of equilateral triangle\n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    \n    // Outer circle tangent to all three from outside\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw all four circles\n    if (distToCircle(p, c1) &lt; 0.03) color = vec3(1.0, 0.3, 0.3);\n    if (distToCircle(p, c2) &lt; 0.03) color = vec3(0.3, 1.0, 0.3);\n    if (distToCircle(p, c3) &lt; 0.03) color = vec3(0.3, 0.3, 1.0);\n    if (distToCircle(p, outer) &lt; 0.03) color = vec3(1.0, 1.0, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a11.-apollonian-iterated",
    "href": "lectures/shaders/day2-shaders.html#a11.-apollonian-iterated",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Full Apollonian gasket with iteration.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Draw circle boundaries\n    float dMin = min(min(distToCircle(p, c1), distToCircle(p, c2)), \n                     min(distToCircle(p, c3), distToCircle(p, outer)));\n    if (dMin &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day2-shaders.html#a12.-apollonian-final",
    "href": "lectures/shaders/day2-shaders.html#a12.-apollonian-final",
    "title": "1 Day 2 Code",
    "section": "",
    "text": "Apollonian gasket with coloring emphasizing the limit set.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration count, emphasizing the limit set\n    float t = float(iter) / float(max_iter);\n    vec3 color = 30.0 * vec3(pow(t, 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 2 Code"
    ]
  },
  {
    "objectID": "lectures/solutions/day4-solutions.html",
    "href": "lectures/solutions/day4-solutions.html",
    "title": "1 Day 4 Solutions",
    "section": "",
    "text": "Complete solutions for all Day 4 exercises. Each solution is a standalone shader that can be copied directly into Shadertoy.\n\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    // Sphere moved to the right\n    return sdSphere(p, vec3(1.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    // Fat donut: major radius 1.0, minor radius 0.8\n    return sdTorus(p, vec2(1.0, 0.8));\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Which object is closest: 1 = sphere, 2 = torus, 3 = ground, 4 = second sphere\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Sphere (left)\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Torus (center)\n    float torus = sdTorus(p, vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    // Second sphere (right) - NEW\n    float sphere2 = sdSphere(p, vec3(2.5, 0.0, 0.0), 0.8);\n    if (sphere2 &lt; d) {\n        d = sphere2;\n        materialID = 4.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);  // Torus: cyan\n    if (id &lt; 3.5) return vec3(0.5, 0.5, 0.5);  // Ground: gray\n    return vec3(0.0, 1.0, 0.0);                 // Second sphere: green\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    // Sunset palette\n    if (id &lt; 1.5) return vec3(1.0, 0.5, 0.2);   // Sphere: orange\n    if (id &lt; 2.5) return vec3(1.0, 0.4, 0.6);   // Torus: pink\n    return vec3(0.2, 0.1, 0.3);                  // Ground: dark purple\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Light from directly above\n        vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Telephoto lens: narrow FOV\n    float fov = 30.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm white, from upper right)\n        vec3 lightDir1 = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.95, 0.9);\n        vec3 reflectDir1 = reflect(-lightDir1, normal);\n        float diffuse1 = max(0.0, dot(normal, lightDir1));\n        float specular1 = pow(max(0.0, dot(reflectDir1, viewDir)), 32.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-1.0, 0.5, -0.5));\n        vec3 lightColor2 = vec3(0.3, 0.3, 0.5);\n        vec3 reflectDir2 = reflect(-lightDir2, normal);\n        float diffuse2 = max(0.0, dot(normal, lightDir2));\n        float specular2 = pow(max(0.0, dot(reflectDir2, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        \n        // Combine both lights\n        color = matColor * ambient;\n        color += matColor * diffuse1 * lightColor1 + specular1 * lightColor1 * 0.3;\n        color += matColor * diffuse2 * lightColor2 + specular2 * lightColor2 * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sceneSDF(vec3 p) {\n    float d = sdPlane(p, -1.0);\n    \n    // Row of spheres off to the side, receding into distance\n    for (float i = 0.0; i &lt; 5.0; i++) {\n        d = min(d, sdSphere(p, vec3(-2.0, 0.0, -5.0 - i * 4.0), 0.8));\n    }\n    \n    return d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 fogColor = vec3(0.5, 0.6, 0.7);\n    vec3 color;\n    \n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        // Simple coloring: spheres are red, ground is gray\n        vec3 matColor = (hitPoint.y &gt; -0.9) ? vec3(1.0, 0.4, 0.4) : vec3(0.5, 0.5, 0.5);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n        \n        // Apply fog based on distance\n        float fogAmount = 1.0 - exp(-t * 0.08);\n        color = mix(color, fogColor, fogAmount);\n    }\n    else {\n        color = fogColor;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Rotation matrix around X axis\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Pulsing sphere\n    float pulseRadius = 1.0 + 0.2 * sin(iTime * 3.0);\n    float sphere = sdSphere(p, vec3(-2.0, 0.0, 0.0), pulseRadius);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Rotating torus\n    vec3 torusPos = p - vec3(2.0, 0.0, 0.0);\n    torusPos = rotateX(iTime) * torusPos;\n    float torus = sdTorus(torusPos, vec2(1.0, 0.3));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Bouncing sphere\n    float bounceHeight = abs(sin(iTime * 2.0)) * 1.5;\n    float bounceSphere = sdSphere(p, vec3(0.0, -0.5 + bounceHeight, 0.0), 0.5);\n    if (bounceSphere &lt; d) {\n        d = bounceSphere;\n        materialID = 3.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.5);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 4.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.3, 0.3);  // Pulsing sphere: red\n    if (id &lt; 2.5) return vec3(0.3, 1.0, 0.3);  // Rotating torus: green\n    if (id &lt; 3.5) return vec3(0.3, 0.3, 1.0);  // Bouncing sphere: blue\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 6.0;\n    ray.origin.y += 1.5;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    float dRadial = length(p.xz) - r;\n    float dVertical = abs(p.y) - h;\n    return min(max(dRadial, dVertical), 0.0) + \n           length(max(vec2(dRadial, dVertical), 0.0));\n}\n\n// Cone with tip at origin, opening upward, half-angle theta, capped at height h\nfloat sdCone(vec3 p, float angle, float h) {\n    float tanAngle = tan(angle);\n    \n    // Distance from the slanted surface\n    float q = length(p.xz);\n    float coneRadius = p.y * tanAngle;\n    float dRadial = q - coneRadius;\n    \n    // Distance from the cap\n    float dCap = p.y - h;\n    \n    // Distance from the tip (below y=0)\n    float dTip = -p.y;\n    \n    // Combine: inside cone is negative\n    float dInside = max(dRadial / sqrt(1.0 + tanAngle * tanAngle), max(dCap, dTip));\n    \n    // Outside: distance to nearest surface\n    vec2 closest = vec2(max(dRadial, 0.0), max(max(dCap, dTip), 0.0));\n    float dOutside = length(closest);\n    \n    return (dInside &lt; 0.0) ? dInside : dOutside;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Cylinder on the left\n    float cylinder = sdCylinder(p - vec3(-2.0, 0.0, 0.0), 0.8, 1.5);\n    if (cylinder &lt; d) {\n        d = cylinder;\n        materialID = 1.0;\n    }\n    \n    // Cone on the right\n    float cone = sdCone(p - vec3(2.0, -1.5, 0.0), radians(30.0), 2.5);\n    if (cone &lt; d) {\n        d = cone;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.5);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.8, 0.4, 0.1);  // Cylinder: orange\n    if (id &lt; 2.5) return vec3(0.1, 0.6, 0.8);  // Cone: teal\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 6.0;\n    ray.origin.y += 2.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Smooth minimum for blending\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Two spheres that move toward and away from each other\n    float offset = sin(iTime) * 1.2;\n    \n    float sphere1 = sdSphere(p, vec3(-0.8 - offset, 0.0, 0.0), 1.0);\n    float sphere2 = sdSphere(p, vec3(0.8 + offset, 0.0, 0.0), 1.0);\n    \n    // Smooth blend the spheres\n    float blended = smin(sphere1, sphere2, 0.5);\n    if (blended &lt; d) {\n        d = blended;\n        materialID = 1.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.5);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 2.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.2, 0.4);  // Metaballs: pink\n    return vec3(0.3, 0.3, 0.35);                // Ground: dark gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.15;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    float ground = sdPlane(p, -1.0);\n    \n    return min(min(sphere, torus), ground);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Normal coloring: remap from [-1,1] to [0,1]\n        color = normal * 0.5 + 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    float dRadial = length(p.xz) - r;\n    float dVertical = abs(p.y) - h;\n    return min(max(dRadial, dVertical), 0.0) + \n           length(max(vec2(dRadial, dVertical), 0.0));\n}\n\n// Torus with ring in XY plane (axis along Z)\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Cup body: outer cylinder minus inner cylinder (smooth subtraction)\n    float outerCylinder = sdCylinder(p, 1.0, 1.2);\n    float innerCylinder = sdCylinder(p - vec3(0.0, 0.15, 0.0), 0.85, 1.1);\n    float cupBody = -smin(-outerCylinder, innerCylinder, 0.1);  // Smooth subtraction\n    \n    // Handle: torus on the side\n    // sdTorus has core circle in XY plane (axis along Z) - perfect for a vertical handle\n    vec3 handlePos = p - vec3(1.2, 0.0, 0.0);\n    float handle = sdTorus(handlePos, vec2(0.7, 0.15));\n    \n    // Blend handle with cup body\n    float cup = smin(cupBody, handle, 0.15);\n    \n    if (cup &lt; d) {\n        d = cup;\n        materialID = 1.0;\n    }\n    \n    // Ground plane (not rotated)\n    float ground = p.y + 1.5;\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 2.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.85, 0.8);  // Cup: cream white\n    return vec3(0.3, 0.25, 0.2);                 // Ground: brown\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    ray.origin.x += 2.0;  // Move camera to the side to see handle\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.2;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 halfSize) {\n    vec3 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Infinite grid of spheres\n    vec3 spacing = vec3(3.0, 3.0, 3.0);\n    vec3 q = mod(p + spacing * 0.5, spacing) - spacing * 0.5;\n    \n    // Alternate between spheres and boxes based on cell\n    vec3 cellID = floor((p + spacing * 0.5) / spacing);\n    float checker = mod(cellID.x + cellID.y + cellID.z, 2.0);\n    \n    float shape;\n    if (checker &lt; 0.5) {\n        shape = sdSphere(q, 0.8);\n        if (shape &lt; d) {\n            d = shape;\n            materialID = 1.0;\n        }\n    } else {\n        shape = sdBox(q, vec3(0.6));\n        if (shape &lt; d) {\n            d = shape;\n            materialID = 2.0;\n        }\n    }\n    \n    // Ground plane (not repeated)\n    float ground = sdPlane(p, -2.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.4, 0.4);  // Spheres: red\n    if (id &lt; 2.5) return vec3(0.4, 0.4, 1.0);  // Boxes: blue\n    return vec3(0.4, 0.4, 0.4);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 150; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 fogColor = vec3(0.5, 0.6, 0.7);\n    vec3 color;\n    \n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n        \n        // Fog\n        float fogAmount = 1.0 - exp(-t * 0.05);\n        color = mix(color, fogColor, fogAmount);\n    }\n    else {\n        color = fogColor;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nRay generateRay(vec2 fragCoord, mat3 camRot, vec3 camPos) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = camPos;\n    ray.dir = camRot * normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Orbiting camera\n    float angle = iTime * 0.5;\n    float height = 2.0 + sin(iTime * 0.3) * 1.0;  // Vertical bobbing\n    float radius = 6.0;\n    \n    mat3 camRot = rotateY(angle);\n    vec3 camPos = camRot * vec3(0.0, height, radius);\n    \n    Ray ray = generateRay(fragCoord, camRot, camPos);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.3, 0.3, 0.3);  // Ground: darker for better reflection visibility\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvec3 shade(vec3 hitPoint, vec3 normal, vec3 viewDir) {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 reflectDir = reflect(-lightDir, normal);\n    \n    float diffuse = max(0.0, dot(normal, lightDir));\n    float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n    \n    vec3 matColor = getMaterialColor(materialID);\n    float ambient = 0.1;\n    return matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        color = shade(hitPoint, normal, -ray.dir);\n        float hitMaterial = materialID;\n        \n        // Only reflect off the ground (material 3)\n        if (hitMaterial &gt; 2.5) {\n            vec3 reflectDir = reflect(ray.dir, normal);\n            Ray reflectedRay;\n            reflectedRay.origin = hitPoint + normal * 0.01;  // Offset to avoid self-intersection\n            reflectedRay.dir = reflectDir;\n            \n            float t2 = raymarch(reflectedRay);\n            if (t2 &gt; 0.0) {\n                vec3 reflectedHit = reflectedRay.origin + t2 * reflectedRay.dir;\n                vec3 reflectedNormal = estimateNormal(reflectedHit);\n                vec3 reflectedColor = shade(reflectedHit, reflectedNormal, -reflectedRay.dir);\n                color = mix(color, reflectedColor, 0.5);  // 50% reflective\n            }\n        }\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Surface {\n    float dist;\n    float matID;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nSurface sdSphere(vec3 p, vec3 center, float radius, float matID) {\n    return Surface(length(p - center) - radius, matID);\n}\n\nSurface sdTorus(vec3 p, vec2 tor, float matID) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return Surface(length(q) - tor.y, matID);\n}\n\nSurface sdPlane(vec3 p, float height, float matID) {\n    return Surface(p.y - height, matID);\n}\n\nSurface opUnion(Surface a, Surface b) {\n    if (a.dist &lt; b.dist) {\n        return a;\n    }\n    return b;\n}\n\nSurface sceneSDF(vec3 p) {\n    Surface s = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0, 1.0);\n    s = opUnion(s, sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4), 2.0));\n    s = opUnion(s, sdPlane(p, -1.0, 3.0));\n    return s;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)).dist - sceneSDF(p - vec3(eps, 0, 0)).dist,\n        sceneSDF(p + vec3(0, eps, 0)).dist - sceneSDF(p - vec3(0, eps, 0)).dist,\n        sceneSDF(p + vec3(0, 0, eps)).dist - sceneSDF(p - vec3(0, 0, eps)).dist\n    ));\n}\n\nSurface raymarch(Ray ray) {\n    float t = 0.0;\n    Surface s;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        s = sceneSDF(p);\n        \n        if (s.dist &lt; 0.001) {\n            return Surface(t, s.matID);\n        }\n        \n        t += s.dist;\n        \n        if (t &gt; 100.0) {\n            return Surface(-1.0, 0.0);\n        }\n    }\n    \n    return Surface(-1.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    Surface hit = raymarch(ray);\n    \n    vec3 color;\n    if (hit.dist &gt; 0.0) {\n        vec3 hitPoint = ray.origin + hit.dist * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(hit.matID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.8, 0.2, 0.2);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.2, 0.7, 0.7);  // Torus: cyan\n    return vec3(0.4, 0.4, 0.45);                // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n// Hard shadow - returns 0 if in shadow, 1 if lit\nfloat hardShadow(vec3 origin, vec3 lightDir, float maxDist) {\n    float t = 0.02;  // Start slightly away from surface\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + lightDir * t);\n        if (d &lt; 0.001) return 0.0;  // Hit something - in shadow\n        t += d;\n        if (t &gt; maxDist) break;\n    }\n    \n    return 1.0;  // Reached the light - not in shadow\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        // Check for shadow\n        float shadow = hardShadow(hitPoint + normal * 0.02, lightDir, 10.0);\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        float ambient = 0.15;\n        color = matColor * ambient + matColor * diffuse * shadow + vec3(1.0) * specular * 0.3 * shadow;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\nJust the variety with distance estimation, no bounding volume yet.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat estimateDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = estimateDistance(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 20.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = normalize(gradient(hitPoint));\n        \n        // Flip normal if pointing away from camera\n        if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        color = vec3(0.8, 0.3, 0.2) * (0.1 + diffuse);\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdd a bounding sphere for efficiency.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat estimateDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\nfloat sceneSDF(vec3 p) {\n    // Bounding sphere\n    float bounds = length(p) - 2.0;\n    if (bounds &gt; 0.01) {\n        return bounds;\n    }\n    return estimateDistance(p);\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 20.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = normalize(gradient(hitPoint));\n        \n        if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        color = vec3(0.8, 0.3, 0.2) * (0.1 + diffuse);\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdd a floor, back wall, and specular highlights.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Single light with specular\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflect(-lightDir, normal), viewDir)), 32.0);\n        \n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nThe complete scene with rotation and beautiful lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nfloat barthSextic(vec3 p) {\n    // Apply rotation\n    p = rotateY(iTime * 0.3) * p;\n    \n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm, from upper right)\n        vec3 lightDir1 = normalize(vec3(2.0, 2.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.9, 0.8);\n        float diff1 = max(0.0, dot(normal, lightDir1));\n        float spec1 = pow(max(0.0, dot(reflect(-lightDir1, normal), viewDir)), 32.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-2.0, 1.0, 0.5));\n        vec3 lightColor2 = vec3(0.4, 0.5, 0.8);\n        float diff2 = max(0.0, dot(normal, lightDir2));\n        float spec2 = pow(max(0.0, dot(reflect(-lightDir2, normal), viewDir)), 32.0);\n        \n        // Rim light (purple, from behind)\n        vec3 lightDir3 = normalize(vec3(0.0, 0.5, -1.0));\n        vec3 lightColor3 = vec3(0.5, 0.3, 0.6);\n        float diff3 = max(0.0, dot(normal, lightDir3));\n        \n        float ambient = 0.08;\n        color = matColor * ambient;\n        color += matColor * diff1 * lightColor1 + spec1 * lightColor1 * 0.3;\n        color += matColor * diff2 * lightColor2 + spec2 * lightColor2 * 0.2;\n        color += matColor * diff3 * lightColor3;\n        \n        // Gamma correction\n        color = pow(color, vec3(0.4545));\n    }\n    else {\n        color = vec3(0.08, 0.08, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdding shadows to the rotating scene.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nfloat barthSextic(vec3 p) {\n    // Apply rotation\n    p = rotateY(iTime * 0.3) * p;\n    \n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n// Hard shadow - returns 0 if in shadow, 1 if lit\nfloat hardShadow(vec3 origin, vec3 dir, float maxt) {\n    float t = 0.02;\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + dir * t);\n        if (d &lt; 0.001) return 0.0;\n        t += d;\n        if (t &gt; maxt) break;\n    }\n    \n    return 1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm, from upper right)\n        vec3 lightDir1 = normalize(vec3(2.0, 2.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.9, 0.8);\n        float diff1 = max(0.0, dot(normal, lightDir1));\n        float spec1 = pow(max(0.0, dot(reflect(-lightDir1, normal), viewDir)), 32.0);\n        float shadow1 = hardShadow(hitPoint + normal * 0.02, lightDir1, 10.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-2.0, 1.0, 0.5));\n        vec3 lightColor2 = vec3(0.4, 0.5, 0.8);\n        float diff2 = max(0.0, dot(normal, lightDir2));\n        float spec2 = pow(max(0.0, dot(reflect(-lightDir2, normal), viewDir)), 32.0);\n        \n        // Rim light (purple, from behind)\n        vec3 lightDir3 = normalize(vec3(0.0, 0.5, -1.0));\n        vec3 lightColor3 = vec3(0.5, 0.3, 0.6);\n        float diff3 = max(0.0, dot(normal, lightDir3));\n        \n        float ambient = 0.08;\n        color = matColor * ambient;\n        color += (matColor * diff1 * lightColor1 + spec1 * lightColor1 * 0.3) * shadow1;\n        color += matColor * diff2 * lightColor2 + spec2 * lightColor2 * 0.2;\n        color += matColor * diff3 * lightColor3;\n        \n        // Gamma correction\n        color = pow(color, vec3(0.4545));\n    }\n    else {\n        color = vec3(0.08, 0.08, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day4-solutions.html#checkpoint-solutions",
    "href": "lectures/solutions/day4-solutions.html#checkpoint-solutions",
    "title": "1 Day 4 Solutions",
    "section": "",
    "text": "struct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    // Sphere moved to the right\n    return sdSphere(p, vec3(1.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float ambient = 0.1;\n        color = sphereColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    // Fat donut: major radius 1.0, minor radius 0.8\n    return sdTorus(p, vec2(1.0, 0.8));\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);\n        float ambient = 0.1;\n        color = torusColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Which object is closest: 1 = sphere, 2 = torus, 3 = ground, 4 = second sphere\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Sphere (left)\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Torus (center)\n    float torus = sdTorus(p, vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    // Second sphere (right) - NEW\n    float sphere2 = sdSphere(p, vec3(2.5, 0.0, 0.0), 0.8);\n    if (sphere2 &lt; d) {\n        d = sphere2;\n        materialID = 4.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);  // Torus: cyan\n    if (id &lt; 3.5) return vec3(0.5, 0.5, 0.5);  // Ground: gray\n    return vec3(0.0, 1.0, 0.0);                 // Second sphere: green\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    // Sunset palette\n    if (id &lt; 1.5) return vec3(1.0, 0.5, 0.2);   // Sphere: orange\n    if (id &lt; 2.5) return vec3(1.0, 0.4, 0.6);   // Torus: pink\n    return vec3(0.2, 0.1, 0.3);                  // Ground: dark purple\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Light from directly above\n        vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Telephoto lens: narrow FOV\n    float fov = 30.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day4-solutions.html#exploration-solutions",
    "href": "lectures/solutions/day4-solutions.html#exploration-solutions",
    "title": "1 Day 4 Solutions",
    "section": "",
    "text": "struct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm white, from upper right)\n        vec3 lightDir1 = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.95, 0.9);\n        vec3 reflectDir1 = reflect(-lightDir1, normal);\n        float diffuse1 = max(0.0, dot(normal, lightDir1));\n        float specular1 = pow(max(0.0, dot(reflectDir1, viewDir)), 32.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-1.0, 0.5, -0.5));\n        vec3 lightColor2 = vec3(0.3, 0.3, 0.5);\n        vec3 reflectDir2 = reflect(-lightDir2, normal);\n        float diffuse2 = max(0.0, dot(normal, lightDir2));\n        float specular2 = pow(max(0.0, dot(reflectDir2, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        \n        // Combine both lights\n        color = matColor * ambient;\n        color += matColor * diffuse1 * lightColor1 + specular1 * lightColor1 * 0.3;\n        color += matColor * diffuse2 * lightColor2 + specular2 * lightColor2 * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sceneSDF(vec3 p) {\n    float d = sdPlane(p, -1.0);\n    \n    // Row of spheres off to the side, receding into distance\n    for (float i = 0.0; i &lt; 5.0; i++) {\n        d = min(d, sdSphere(p, vec3(-2.0, 0.0, -5.0 - i * 4.0), 0.8));\n    }\n    \n    return d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 fogColor = vec3(0.5, 0.6, 0.7);\n    vec3 color;\n    \n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        // Simple coloring: spheres are red, ground is gray\n        vec3 matColor = (hitPoint.y &gt; -0.9) ? vec3(1.0, 0.4, 0.4) : vec3(0.5, 0.5, 0.5);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n        \n        // Apply fog based on distance\n        float fogAmount = 1.0 - exp(-t * 0.08);\n        color = mix(color, fogColor, fogAmount);\n    }\n    else {\n        color = fogColor;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Rotation matrix around X axis\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Pulsing sphere\n    float pulseRadius = 1.0 + 0.2 * sin(iTime * 3.0);\n    float sphere = sdSphere(p, vec3(-2.0, 0.0, 0.0), pulseRadius);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    // Rotating torus\n    vec3 torusPos = p - vec3(2.0, 0.0, 0.0);\n    torusPos = rotateX(iTime) * torusPos;\n    float torus = sdTorus(torusPos, vec2(1.0, 0.3));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    // Bouncing sphere\n    float bounceHeight = abs(sin(iTime * 2.0)) * 1.5;\n    float bounceSphere = sdSphere(p, vec3(0.0, -0.5 + bounceHeight, 0.0), 0.5);\n    if (bounceSphere &lt; d) {\n        d = bounceSphere;\n        materialID = 3.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.5);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 4.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.3, 0.3);  // Pulsing sphere: red\n    if (id &lt; 2.5) return vec3(0.3, 1.0, 0.3);  // Rotating torus: green\n    if (id &lt; 3.5) return vec3(0.3, 0.3, 1.0);  // Bouncing sphere: blue\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 6.0;\n    ray.origin.y += 1.5;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    float dRadial = length(p.xz) - r;\n    float dVertical = abs(p.y) - h;\n    return min(max(dRadial, dVertical), 0.0) + \n           length(max(vec2(dRadial, dVertical), 0.0));\n}\n\n// Cone with tip at origin, opening upward, half-angle theta, capped at height h\nfloat sdCone(vec3 p, float angle, float h) {\n    float tanAngle = tan(angle);\n    \n    // Distance from the slanted surface\n    float q = length(p.xz);\n    float coneRadius = p.y * tanAngle;\n    float dRadial = q - coneRadius;\n    \n    // Distance from the cap\n    float dCap = p.y - h;\n    \n    // Distance from the tip (below y=0)\n    float dTip = -p.y;\n    \n    // Combine: inside cone is negative\n    float dInside = max(dRadial / sqrt(1.0 + tanAngle * tanAngle), max(dCap, dTip));\n    \n    // Outside: distance to nearest surface\n    vec2 closest = vec2(max(dRadial, 0.0), max(max(dCap, dTip), 0.0));\n    float dOutside = length(closest);\n    \n    return (dInside &lt; 0.0) ? dInside : dOutside;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Cylinder on the left\n    float cylinder = sdCylinder(p - vec3(-2.0, 0.0, 0.0), 0.8, 1.5);\n    if (cylinder &lt; d) {\n        d = cylinder;\n        materialID = 1.0;\n    }\n    \n    // Cone on the right\n    float cone = sdCone(p - vec3(2.0, -1.5, 0.0), radians(30.0), 2.5);\n    if (cone &lt; d) {\n        d = cone;\n        materialID = 2.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.5);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.8, 0.4, 0.1);  // Cylinder: orange\n    if (id &lt; 2.5) return vec3(0.1, 0.6, 0.8);  // Cone: teal\n    return vec3(0.5, 0.5, 0.5);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 6.0;\n    ray.origin.y += 2.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Smooth minimum for blending\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Two spheres that move toward and away from each other\n    float offset = sin(iTime) * 1.2;\n    \n    float sphere1 = sdSphere(p, vec3(-0.8 - offset, 0.0, 0.0), 1.0);\n    float sphere2 = sdSphere(p, vec3(0.8 + offset, 0.0, 0.0), 1.0);\n    \n    // Smooth blend the spheres\n    float blended = smin(sphere1, sphere2, 0.5);\n    if (blended &lt; d) {\n        d = blended;\n        materialID = 1.0;\n    }\n    \n    // Ground plane\n    float ground = sdPlane(p, -1.5);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 2.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.2, 0.4);  // Metaballs: pink\n    return vec3(0.3, 0.3, 0.35);                // Ground: dark gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.15;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat sceneSDF(vec3 p) {\n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    float ground = sdPlane(p, -1.0);\n    \n    return min(min(sphere, torus), ground);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        // Normal coloring: remap from [-1,1] to [0,1]\n        color = normal * 0.5 + 0.5;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day4-solutions.html#challenge-solutions",
    "href": "lectures/solutions/day4-solutions.html#challenge-solutions",
    "title": "1 Day 4 Solutions",
    "section": "",
    "text": "struct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    float dRadial = length(p.xz) - r;\n    float dVertical = abs(p.y) - h;\n    return min(max(dRadial, dVertical), 0.0) + \n           length(max(vec2(dRadial, dVertical), 0.0));\n}\n\n// Torus with ring in XY plane (axis along Z)\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Cup body: outer cylinder minus inner cylinder (smooth subtraction)\n    float outerCylinder = sdCylinder(p, 1.0, 1.2);\n    float innerCylinder = sdCylinder(p - vec3(0.0, 0.15, 0.0), 0.85, 1.1);\n    float cupBody = -smin(-outerCylinder, innerCylinder, 0.1);  // Smooth subtraction\n    \n    // Handle: torus on the side\n    // sdTorus has core circle in XY plane (axis along Z) - perfect for a vertical handle\n    vec3 handlePos = p - vec3(1.2, 0.0, 0.0);\n    float handle = sdTorus(handlePos, vec2(0.7, 0.15));\n    \n    // Blend handle with cup body\n    float cup = smin(cupBody, handle, 0.15);\n    \n    if (cup &lt; d) {\n        d = cup;\n        materialID = 1.0;\n    }\n    \n    // Ground plane (not rotated)\n    float ground = p.y + 1.5;\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 2.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.85, 0.8);  // Cup: cream white\n    return vec3(0.3, 0.25, 0.2);                 // Ground: brown\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    ray.origin.x += 2.0;  // Move camera to the side to see handle\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.2;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdBox(vec3 p, vec3 halfSize) {\n    vec3 d = abs(p) - halfSize;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Infinite grid of spheres\n    vec3 spacing = vec3(3.0, 3.0, 3.0);\n    vec3 q = mod(p + spacing * 0.5, spacing) - spacing * 0.5;\n    \n    // Alternate between spheres and boxes based on cell\n    vec3 cellID = floor((p + spacing * 0.5) / spacing);\n    float checker = mod(cellID.x + cellID.y + cellID.z, 2.0);\n    \n    float shape;\n    if (checker &lt; 0.5) {\n        shape = sdSphere(q, 0.8);\n        if (shape &lt; d) {\n            d = shape;\n            materialID = 1.0;\n        }\n    } else {\n        shape = sdBox(q, vec3(0.6));\n        if (shape &lt; d) {\n            d = shape;\n            materialID = 2.0;\n        }\n    }\n    \n    // Ground plane (not repeated)\n    float ground = sdPlane(p, -2.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.4, 0.4);  // Spheres: red\n    if (id &lt; 2.5) return vec3(0.4, 0.4, 1.0);  // Boxes: blue\n    return vec3(0.4, 0.4, 0.4);                 // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 150; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 fogColor = vec3(0.5, 0.6, 0.7);\n    vec3 color;\n    \n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n        \n        // Fog\n        float fogAmount = 1.0 - exp(-t * 0.05);\n        color = mix(color, fogColor, fogAmount);\n    }\n    else {\n        color = fogColor;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nRay generateRay(vec2 fragCoord, mat3 camRot, vec3 camPos) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = camPos;\n    ray.dir = camRot * normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Orbiting camera\n    float angle = iTime * 0.5;\n    float height = 2.0 + sin(iTime * 0.3) * 1.0;  // Vertical bobbing\n    float radius = 6.0;\n    \n    mat3 camRot = rotateY(angle);\n    vec3 camPos = camRot * vec3(0.0, height, radius);\n    \n    Ray ray = generateRay(fragCoord, camRot, camPos);\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(materialID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.3, 0.3, 0.3);  // Ground: darker for better reflection visibility\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvec3 shade(vec3 hitPoint, vec3 normal, vec3 viewDir) {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 reflectDir = reflect(-lightDir, normal);\n    \n    float diffuse = max(0.0, dot(normal, lightDir));\n    float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n    \n    vec3 matColor = getMaterialColor(materialID);\n    float ambient = 0.1;\n    return matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        color = shade(hitPoint, normal, -ray.dir);\n        float hitMaterial = materialID;\n        \n        // Only reflect off the ground (material 3)\n        if (hitMaterial &gt; 2.5) {\n            vec3 reflectDir = reflect(ray.dir, normal);\n            Ray reflectedRay;\n            reflectedRay.origin = hitPoint + normal * 0.01;  // Offset to avoid self-intersection\n            reflectedRay.dir = reflectDir;\n            \n            float t2 = raymarch(reflectedRay);\n            if (t2 &gt; 0.0) {\n                vec3 reflectedHit = reflectedRay.origin + t2 * reflectedRay.dir;\n                vec3 reflectedNormal = estimateNormal(reflectedHit);\n                vec3 reflectedColor = shade(reflectedHit, reflectedNormal, -reflectedRay.dir);\n                color = mix(color, reflectedColor, 0.5);  // 50% reflective\n            }\n        }\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Surface {\n    float dist;\n    float matID;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nSurface sdSphere(vec3 p, vec3 center, float radius, float matID) {\n    return Surface(length(p - center) - radius, matID);\n}\n\nSurface sdTorus(vec3 p, vec2 tor, float matID) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return Surface(length(q) - tor.y, matID);\n}\n\nSurface sdPlane(vec3 p, float height, float matID) {\n    return Surface(p.y - height, matID);\n}\n\nSurface opUnion(Surface a, Surface b) {\n    if (a.dist &lt; b.dist) {\n        return a;\n    }\n    return b;\n}\n\nSurface sceneSDF(vec3 p) {\n    Surface s = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0, 1.0);\n    s = opUnion(s, sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4), 2.0));\n    s = opUnion(s, sdPlane(p, -1.0, 3.0));\n    return s;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(1.0, 0.0, 0.0);\n    if (id &lt; 2.5) return vec3(0.0, 0.7, 1.0);\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)).dist - sceneSDF(p - vec3(eps, 0, 0)).dist,\n        sceneSDF(p + vec3(0, eps, 0)).dist - sceneSDF(p - vec3(0, eps, 0)).dist,\n        sceneSDF(p + vec3(0, 0, eps)).dist - sceneSDF(p - vec3(0, 0, eps)).dist\n    ));\n}\n\nSurface raymarch(Ray ray) {\n    float t = 0.0;\n    Surface s;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        s = sceneSDF(p);\n        \n        if (s.dist &lt; 0.001) {\n            return Surface(t, s.matID);\n        }\n        \n        t += s.dist;\n        \n        if (t &gt; 100.0) {\n            return Surface(-1.0, 0.0);\n        }\n    }\n    \n    return Surface(-1.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    Surface hit = raymarch(ray);\n    \n    vec3 color;\n    if (hit.dist &gt; 0.0) {\n        vec3 hitPoint = ray.origin + hit.dist * ray.dir;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        vec3 matColor = getMaterialColor(hit.matID);\n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec2 tor) {\n    vec2 q = vec2(length(p.xy) - tor.x, p.z);\n    return length(q) - tor.y;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    float sphere = sdSphere(p, vec3(-1.5, 0.0, 0.0), 1.0);\n    if (sphere &lt; d) {\n        d = sphere;\n        materialID = 1.0;\n    }\n    \n    float torus = sdTorus(p - vec3(1.5, 0.0, 0.0), vec2(1.0, 0.4));\n    if (torus &lt; d) {\n        d = torus;\n        materialID = 2.0;\n    }\n    \n    float ground = sdPlane(p, -1.0);\n    if (ground &lt; d) {\n        d = ground;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.8, 0.2, 0.2);  // Sphere: red\n    if (id &lt; 2.5) return vec3(0.2, 0.7, 0.7);  // Torus: cyan\n    return vec3(0.4, 0.4, 0.45);                // Ground: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(vec3(\n        sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0)),\n        sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0)),\n        sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps))\n    ));\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 100; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.001) return t;\n        t += d;\n        if (t &gt; 100.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n// Hard shadow - returns 0 if in shadow, 1 if lit\nfloat hardShadow(vec3 origin, vec3 lightDir, float maxDist) {\n    float t = 0.02;  // Start slightly away from surface\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + lightDir * t);\n        if (d &lt; 0.001) return 0.0;  // Hit something - in shadow\n        t += d;\n        if (t &gt; maxDist) break;\n    }\n    \n    return 1.0;  // Reached the light - not in shadow\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 5.0;\n    ray.origin.y += 1.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        vec3 lightDir = normalize(vec3(1.0, 2.0, 1.0));\n        vec3 viewDir = -ray.dir;\n        vec3 reflectDir = reflect(-lightDir, normal);\n        \n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflectDir, viewDir)), 32.0);\n        \n        // Check for shadow\n        float shadow = hardShadow(hitPoint + normal * 0.02, lightDir, 10.0);\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        float ambient = 0.15;\n        color = matColor * ambient + matColor * diffuse * shadow + vec3(1.0) * specular * 0.3 * shadow;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day4-solutions.html#project-solutions",
    "href": "lectures/solutions/day4-solutions.html#project-solutions",
    "title": "1 Day 4 Solutions",
    "section": "",
    "text": "Just the variety with distance estimation, no bounding volume yet.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat estimateDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = estimateDistance(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 20.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = normalize(gradient(hitPoint));\n        \n        // Flip normal if pointing away from camera\n        if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        color = vec3(0.8, 0.3, 0.2) * (0.1 + diffuse);\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdd a bounding sphere for efficiency.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat estimateDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\nfloat sceneSDF(vec3 p) {\n    // Bounding sphere\n    float bounds = length(p) - 2.0;\n    if (bounds &gt; 0.01) {\n        return bounds;\n    }\n    return estimateDistance(p);\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 20.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 3.0;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        vec3 normal = normalize(gradient(hitPoint));\n        \n        if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        color = vec3(0.8, 0.3, 0.2) * (0.1 + diffuse);\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdd a floor, back wall, and specular highlights.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nfloat barthSextic(vec3 p) {\n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Single light with specular\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        float specular = pow(max(0.0, dot(reflect(-lightDir, normal), viewDir)), 32.0);\n        \n        float ambient = 0.1;\n        color = matColor * (ambient + diffuse) + vec3(1.0) * specular * 0.3;\n    }\n    else {\n        color = vec3(0.1, 0.1, 0.15);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nThe complete scene with rotation and beautiful lighting.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nfloat barthSextic(vec3 p) {\n    // Apply rotation\n    p = rotateY(iTime * 0.3) * p;\n    \n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm, from upper right)\n        vec3 lightDir1 = normalize(vec3(2.0, 2.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.9, 0.8);\n        float diff1 = max(0.0, dot(normal, lightDir1));\n        float spec1 = pow(max(0.0, dot(reflect(-lightDir1, normal), viewDir)), 32.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-2.0, 1.0, 0.5));\n        vec3 lightColor2 = vec3(0.4, 0.5, 0.8);\n        float diff2 = max(0.0, dot(normal, lightDir2));\n        float spec2 = pow(max(0.0, dot(reflect(-lightDir2, normal), viewDir)), 32.0);\n        \n        // Rim light (purple, from behind)\n        vec3 lightDir3 = normalize(vec3(0.0, 0.5, -1.0));\n        vec3 lightColor3 = vec3(0.5, 0.3, 0.6);\n        float diff3 = max(0.0, dot(normal, lightDir3));\n        \n        float ambient = 0.08;\n        color = matColor * ambient;\n        color += matColor * diff1 * lightColor1 + spec1 * lightColor1 * 0.3;\n        color += matColor * diff2 * lightColor2 + spec2 * lightColor2 * 0.2;\n        color += matColor * diff3 * lightColor3;\n        \n        // Gamma correction\n        color = pow(color, vec3(0.4545));\n    }\n    else {\n        color = vec3(0.08, 0.08, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdding shadows to the rotating scene.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nRay generateRay(vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n    float f = 1.0 / tan(radians(fov) / 2.0);\n    \n    Ray ray;\n    ray.origin = vec3(0.0);\n    ray.dir = normalize(vec3(uv, -f));\n    return ray;\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nfloat barthSextic(vec3 p) {\n    // Apply rotation\n    p = rotateY(iTime * 0.3) * p;\n    \n    float phi = (1.0 + sqrt(5.0)) / 2.0;\n    float phi2 = phi * phi;\n    \n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n    \n    float a = (phi2 * x2 - y2) * (phi2 * y2 - z2) * (phi2 * z2 - x2);\n    float b = (x2 + y2 + z2 - 1.0);\n    \n    return 4.0 * a - (1.0 + 2.0 * phi) * b * b;\n}\n\nvec3 gradient(vec3 p) {\n    float eps = 0.001;\n    return vec3(\n        barthSextic(p + vec3(eps, 0, 0)) - barthSextic(p - vec3(eps, 0, 0)),\n        barthSextic(p + vec3(0, eps, 0)) - barthSextic(p - vec3(0, eps, 0)),\n        barthSextic(p + vec3(0, 0, eps)) - barthSextic(p - vec3(0, 0, eps))\n    ) / (2.0 * eps);\n}\n\nfloat varietyDistance(vec3 p) {\n    float f = barthSextic(p);\n    vec3 grad = gradient(p);\n    float gradLen = length(grad);\n    return 0.3 * abs(f) / max(gradLen, 0.1);\n}\n\n// 1 = variety, 2 = floor, 3 = wall\nfloat materialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;\n    \n    // Variety (raised up)\n    vec3 varietyPos = p - vec3(0.0, 0.3, 0.0);\n    float bounds = length(varietyPos) - 2.0;\n    float variety;\n    if (bounds &gt; 0.01) {\n        variety = bounds;\n    } else {\n        variety = varietyDistance(varietyPos);\n    }\n    if (variety &lt; d) {\n        d = variety;\n        materialID = 1.0;\n    }\n    \n    // Floor\n    float floor = p.y + 2.0;\n    if (floor &lt; d) {\n        d = floor;\n        materialID = 2.0;\n    }\n    \n    // Back wall\n    float wall = p.z + 4.0;\n    if (wall &lt; d) {\n        d = wall;\n        materialID = 3.0;\n    }\n    \n    return d;\n}\n\nfloat raymarch(Ray ray) {\n    float t = 0.0;\n    \n    for (int i = 0; i &lt; 200; i++) {\n        vec3 p = ray.origin + t * ray.dir;\n        float d = sceneSDF(p);\n        \n        if (d &lt; 0.0005) return t;\n        t += d;\n        if (t &gt; 50.0) return -1.0;\n    }\n    \n    return -1.0;\n}\n\n// Hard shadow - returns 0 if in shadow, 1 if lit\nfloat hardShadow(vec3 origin, vec3 dir, float maxt) {\n    float t = 0.02;\n    \n    for (int i = 0; i &lt; 64; i++) {\n        float d = sceneSDF(origin + dir * t);\n        if (d &lt; 0.001) return 0.0;\n        t += d;\n        if (t &gt; maxt) break;\n    }\n    \n    return 1.0;\n}\n\nvec3 getMaterialColor(float id) {\n    if (id &lt; 1.5) return vec3(0.9, 0.4, 0.3);   // Variety: coral\n    if (id &lt; 2.5) return vec3(0.2, 0.2, 0.22);  // Floor: dark gray\n    return vec3(0.25, 0.25, 0.28);               // Wall: slightly lighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Ray ray = generateRay(fragCoord);\n    ray.origin.z += 4.0;\n    ray.origin.y += 0.3;\n    \n    float t = raymarch(ray);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ray.origin + t * ray.dir;\n        float hitMat = materialID;\n        \n        // Get normal\n        vec3 normal;\n        if (hitMat &lt; 1.5) {\n            // Variety: use gradient\n            vec3 varietyPos = hitPoint - vec3(0.0, 0.3, 0.0);\n            normal = normalize(gradient(varietyPos));\n            if (dot(normal, ray.dir) &gt; 0.0) normal = -normal;\n        } else if (hitMat &lt; 2.5) {\n            // Floor\n            normal = vec3(0.0, 1.0, 0.0);\n        } else {\n            // Wall\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n        \n        vec3 matColor = getMaterialColor(hitMat);\n        vec3 viewDir = -ray.dir;\n        \n        // Key light (warm, from upper right)\n        vec3 lightDir1 = normalize(vec3(2.0, 2.0, 1.0));\n        vec3 lightColor1 = vec3(1.0, 0.9, 0.8);\n        float diff1 = max(0.0, dot(normal, lightDir1));\n        float spec1 = pow(max(0.0, dot(reflect(-lightDir1, normal), viewDir)), 32.0);\n        float shadow1 = hardShadow(hitPoint + normal * 0.02, lightDir1, 10.0);\n        \n        // Fill light (cool blue, from left)\n        vec3 lightDir2 = normalize(vec3(-2.0, 1.0, 0.5));\n        vec3 lightColor2 = vec3(0.4, 0.5, 0.8);\n        float diff2 = max(0.0, dot(normal, lightDir2));\n        float spec2 = pow(max(0.0, dot(reflect(-lightDir2, normal), viewDir)), 32.0);\n        \n        // Rim light (purple, from behind)\n        vec3 lightDir3 = normalize(vec3(0.0, 0.5, -1.0));\n        vec3 lightColor3 = vec3(0.5, 0.3, 0.6);\n        float diff3 = max(0.0, dot(normal, lightDir3));\n        \n        float ambient = 0.08;\n        color = matColor * ambient;\n        color += (matColor * diff1 * lightColor1 + spec1 * lightColor1 * 0.3) * shadow1;\n        color += matColor * diff2 * lightColor2 + spec2 * lightColor2 * 0.2;\n        color += matColor * diff3 * lightColor3;\n        \n        // Gamma correction\n        color = pow(color, vec3(0.4545));\n    }\n    else {\n        color = vec3(0.08, 0.08, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day2-solutions.html",
    "href": "lectures/solutions/day2-solutions.html",
    "title": "1 Appendix: Day 2 Exercise Solutions",
    "section": "",
    "text": "Complete solutions for the Day 2 exercises. Try the exercises yourself before looking here!\n\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Fixed parameter\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // z starts at pixel position (not zero!)\n    vec2 z = p;\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 ccube(vec2 z) {\n    float a = z.x, b = z.y;\n    return vec2(a*a*a - 3.0*a*b*b, 3.0*a*a*b - b*b*b);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 3.0;\n    vec2 z = vec2(0.0);\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = ccube(z) + c;  // z³ + c instead of z² + c\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe cubic Mandelbrot has 3-fold rotational symmetry (120° rotation), compared to the 2-fold symmetry of the standard Mandelbrot.\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Setup circles\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Animate max_iter: grows from 1 to 50, then resets\n    int max_iter = int(mod(iTime * 5.0, 50.0)) + 1;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration\n    float t = float(iter) / 50.0;\n    vec3 color = 30.0 * vec3(pow(t, 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdding color to the Julia set:\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);  // Try different values!\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Fixed parameter\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // z starts at pixel position\n    vec2 z = p;\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTry these palette variations: - d = vec3(0.00, 0.10, 0.20) - cool blues - d = vec3(0.30, 0.20, 0.20) - warm tones - d = vec3(0.50, 0.50, 0.50) - shifted spectrum\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define several circles\n    Circle circles[6];\n    circles[0] = Circle(vec2(-1.0, 0.5), 0.8);\n    circles[1] = Circle(vec2(0.5, 0.3), 0.6);\n    circles[2] = Circle(vec2(-0.3, -0.7), 0.9);\n    circles[3] = Circle(vec2(1.2, -0.2), 0.5);\n    circles[4] = Circle(vec2(0.0, 0.8), 0.4);\n    circles[5] = Circle(vec2(-0.8, -0.3), 0.5);\n    \n    // Count how many circles contain this point\n    int count = 0;\n    for (int i = 0; i &lt; 6; i++) {\n        if (isInside(p, circles[i])) count++;\n    }\n    \n    // Color by count\n    vec3 color;\n    if (count == 0) color = vec3(0.1, 0.1, 0.15);\n    else if (count == 1) color = vec3(0.2, 0.4, 0.8);\n    else if (count == 2) color = vec3(0.8, 0.3, 0.5);\n    else color = vec3(1.0, 0.9, 0.3);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map mouse to [-2, 2] x [-2, 2]\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    mouse_uv = mouse_uv - vec2(0.5, 0.5);\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 c = mouse_uv * 4.0;\n    \n    // Default if no mouse\n    if (iMouse.x &lt; 1.0) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    vec2 z = p;\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Main cardioid boundary parameterization\nvec2 cardioid(float t) {\n    vec2 eit = vec2(cos(t), sin(t));\n    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;\n    return cmul(eit, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Animate c along the cardioid boundary\n    vec2 c = cardioid(iTime * 0.5);\n    \n    // Or try a simple circle:\n    // float angle = iTime * 0.3;\n    // vec2 c = 0.7885 * vec2(cos(angle), sin(angle));\n    \n    vec2 z = p;\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom into seahorse valley to see the effect\n    vec2 center = vec2(-0.745, 0.186);\n    float zoom = 50.0;\n    vec2 c = center + uv * 4.0 / zoom;\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 200;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t;\n        // Toggle between smooth and discrete every 2 seconds\n        if (mod(iTime, 4.0) &lt; 2.0) {\n            // Discrete coloring - notice the bands\n            t = float(iter) / float(max_iter);\n        } else {\n            // Smooth coloring - bands disappear!\n            float log_zn = log(cabs2(z)) / 2.0;\n            float nu = log(log_zn / log(2.0)) / log(2.0);\n            float smooth_iter = float(iter) + 1.0 - nu;\n            t = smooth_iter / float(max_iter);\n        }\n        color = palette(t * 4.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 0.5);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 c = 0.1 * fragCoord / iResolution.y + vec2(1.66, -0.02);\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (dot(z, z) &gt; 1000.0) break;\n        z = cmul(z, z);\n        z.y = abs(z.y);  // abs of imaginary part AFTER squaring\n        z = z - c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(dot(z, z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.30, 0.20, 0.20);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 4.0;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = vec2(z.x, -z.y);  // conjugate\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Tricorn has 3-fold reflection symmetry (symmetric about the real axis and two other axes at 60°).\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 4.0;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        vec2 z2 = cmul(z, z);\n        z = vec2(abs(z2.x), z2.y) + c;  // abs of real part of z²\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    int max_iter = 100;\n    int iter;\n    int lastCircle = -1;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n            lastCircle = 0;\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n            lastCircle = 1;\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n            lastCircle = 2;\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n            lastCircle = 3;\n        } else {\n            break;\n        }\n    }\n    \n    // Color by which circle was last hit\n    vec3 color;\n    if (lastCircle == 0) color = vec3(1.0, 0.2, 0.2);\n    else if (lastCircle == 1) color = vec3(0.2, 1.0, 0.2);\n    else if (lastCircle == 2) color = vec3(0.2, 0.2, 1.0);\n    else if (lastCircle == 3) color = vec3(1.0, 1.0, 0.2);\n    else color = vec3(0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nExample with different-sized inner circles:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Three circles with different radii, manually positioned to be tangent\n    // Using Descartes theorem: (k1+k2+k3+k4)² = 2(k1²+k2²+k3²+k4²)\n    Circle c1 = Circle(vec2(0.0, 1.2), 0.8);\n    Circle c2 = Circle(vec2(-1.0, -0.5), 1.0);\n    Circle c3 = Circle(vec2(1.1, -0.4), 0.7);\n    Circle outer = Circle(vec2(0.0, 0.1), 2.2);\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    float t = float(iter) / float(max_iter);\n    vec3 color = 30.0 * vec3(pow(t, 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}\nNote: Finding four mutually tangent circles with arbitrary radii requires solving Descartes’ theorem. Given three tangent circles with curvatures \\(k_1, k_2, k_3\\), the fourth curvature is: \\[k_4 = k_1 + k_2 + k_3 \\pm 2\\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}\\]\n\n\n\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Get c from mouse position\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    mouse_uv = mouse_uv - vec2(0.5, 0.5);\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 c = mouse_uv * 4.0;\n    c.x -= 0.5;\n    \n    if (iMouse.x &lt; 1.0) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Mandelbrot iteration (background)\n    vec2 mc = p;\n    mc.x -= 0.5;\n    vec2 mz = vec2(0.0);\n    int m_iter;\n    for (m_iter = 0; m_iter &lt; 100; m_iter++) {\n        if (cabs2(mz) &gt; 4.0) break;\n        mz = cmul(mz, mz) + mc;\n    }\n    \n    // Julia iteration (foreground)\n    vec2 jz = p;\n    int j_iter;\n    for (j_iter = 0; j_iter &lt; 100; j_iter++) {\n        if (cabs2(jz) &gt; 4.0) break;\n        jz = cmul(jz, jz) + c;\n    }\n    \n    // Layer: light background, gray Mandelbrot, black Julia\n    vec3 color = vec3(0.9);\n    if (m_iter == 100) {\n        color = vec3(0.6);\n    }\n    if (j_iter == 100) {\n        color = vec3(0.0);\n    }\n    \n    // Red dot at c position\n    vec2 c_pos = c;\n    c_pos.x += 0.5;\n    if (length(p - c_pos) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float denom = dot(w, w);\n    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / denom;\n}\n\nvec2 ccube(vec2 z) {\n    float a = z.x, b = z.y;\n    return vec2(a*a*a - 3.0*a*b*b, 3.0*a*a*b - b*b*b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv * 4.0;\n    \n    // The three cube roots of unity\n    vec2 root1 = vec2(1.0, 0.0);\n    vec2 root2 = vec2(-0.5, 0.866);\n    vec2 root3 = vec2(-0.5, -0.866);\n    \n    int max_iter = 50;\n    int iter;\n    float eps = 0.001;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        // Newton iteration: z = z - (z³-1)/(3z²)\n        // Simplified: z = (2z³ + 1) / (3z²)\n        vec2 z2 = cmul(z, z);\n        vec2 z3 = cmul(z2, z);\n        z = cdiv(2.0 * z3 + vec2(1.0, 0.0), 3.0 * z2);\n        \n        // Check convergence\n        if (dot(z3 - vec2(1.0, 0.0), z3 - vec2(1.0, 0.0)) &lt; eps * eps) break;\n    }\n    \n    // Color by which root we converged to\n    vec3 color;\n    float d1 = length(z - root1);\n    float d2 = length(z - root2);\n    float d3 = length(z - root3);\n    \n    float t = float(iter) / float(max_iter);\n    \n    if (d1 &lt; d2 && d1 &lt; d3) {\n        color = vec3(1.0, 0.2, 0.2) * (1.0 - t * 0.5);\n    } else if (d2 &lt; d3) {\n        color = vec3(0.2, 1.0, 0.2) * (1.0 - t * 0.5);\n    } else {\n        color = vec3(0.2, 0.2, 1.0) * (1.0 - t * 0.5);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cpow(vec2 z, float n) {\n    float r = length(z);\n    if (r &lt; 0.0001) return vec2(0.0);  // Handle z ≈ 0\n    float theta = atan(z.y, z.x);\n    float rn = pow(r, n);\n    return rn * vec2(cos(n * theta), sin(n * theta));\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 3.0;\n    \n    // Start with small offset to avoid z=0 singularity\n    vec2 z = vec2(0.0001, 0.0);\n    \n    float n = 2.5;  // Try different values! Integer and non-integer\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cpow(z, n) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNon-integer powers create interesting branch cut effects!\n\n\n\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Grid parameters\n    float grid_size = 20.0;\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;\n    \n    // c from cell position (map to interesting region)\n    vec2 c = (cell_id / grid_size) * 3.0 - vec2(2.0, 1.5);\n    \n    // Julia iteration within this cell\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Distance to line segment from a to b\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // z0 from mouse, c fixed (or swap roles)\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    mouse_uv = mouse_uv - vec2(0.5, 0.5);\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 z0 = mouse_uv * 4.0;\n    \n    if (iMouse.x &lt; 1.0) {\n        z0 = vec2(0.3, 0.5);\n    }\n    \n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // Compute orbit\n    const int N = 50;\n    vec2 orbit[50];\n    orbit[0] = z0;\n    for (int i = 1; i &lt; N; i++) {\n        orbit[i] = cmul(orbit[i-1], orbit[i-1]) + c;\n        if (dot(orbit[i], orbit[i]) &gt; 100.0) {\n            orbit[i] = orbit[i-1];  // clamp escaped points\n        }\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw Julia set faintly in background\n    vec2 z = p;\n    int iter;\n    for (iter = 0; iter &lt; 100; iter++) {\n        if (dot(z, z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    if (iter == 100) color = vec3(0.15, 0.15, 0.2);\n    \n    // Draw orbit lines\n    for (int i = 0; i &lt; N - 1; i++) {\n        float d = sdSegment(p, orbit[i], orbit[i+1]);\n        float t = float(i) / float(N);\n        vec3 lineColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.3, 0.1), t);\n        if (d &lt; 0.02) color = lineColor;\n    }\n    \n    // Draw orbit points\n    for (int i = 0; i &lt; N; i++) {\n        float d = length(p - orbit[i]);\n        float t = float(i) / float(N);\n        float size = mix(0.06, 0.02, t);\n        if (d &lt; size) {\n            color = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.5, 0.0), t);\n        }\n    }\n    \n    // Highlight z0\n    if (length(p - z0) &lt; 0.08) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day2-solutions.html#checkpoints",
    "href": "lectures/solutions/day2-solutions.html#checkpoints",
    "title": "1 Appendix: Day 2 Exercise Solutions",
    "section": "",
    "text": "vec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Fixed parameter\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // z starts at pixel position (not zero!)\n    vec2 z = p;\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 ccube(vec2 z) {\n    float a = z.x, b = z.y;\n    return vec2(a*a*a - 3.0*a*b*b, 3.0*a*a*b - b*b*b);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 3.0;\n    vec2 z = vec2(0.0);\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = ccube(z) + c;  // z³ + c instead of z² + c\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        color = vec3(1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe cubic Mandelbrot has 3-fold rotational symmetry (120° rotation), compared to the 2-fold symmetry of the standard Mandelbrot.\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Setup circles\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Animate max_iter: grows from 1 to 50, then resets\n    int max_iter = int(mod(iTime * 5.0, 50.0)) + 1;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    // Color by iteration\n    float t = float(iter) / 50.0;\n    vec3 color = 30.0 * vec3(pow(t, 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAdding color to the Julia set:\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);  // Try different values!\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Fixed parameter\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // z starts at pixel position\n    vec2 z = p;\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTry these palette variations: - d = vec3(0.00, 0.10, 0.20) - cool blues - d = vec3(0.30, 0.20, 0.20) - warm tones - d = vec3(0.50, 0.50, 0.50) - shifted spectrum\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define several circles\n    Circle circles[6];\n    circles[0] = Circle(vec2(-1.0, 0.5), 0.8);\n    circles[1] = Circle(vec2(0.5, 0.3), 0.6);\n    circles[2] = Circle(vec2(-0.3, -0.7), 0.9);\n    circles[3] = Circle(vec2(1.2, -0.2), 0.5);\n    circles[4] = Circle(vec2(0.0, 0.8), 0.4);\n    circles[5] = Circle(vec2(-0.8, -0.3), 0.5);\n    \n    // Count how many circles contain this point\n    int count = 0;\n    for (int i = 0; i &lt; 6; i++) {\n        if (isInside(p, circles[i])) count++;\n    }\n    \n    // Color by count\n    vec3 color;\n    if (count == 0) color = vec3(0.1, 0.1, 0.15);\n    else if (count == 1) color = vec3(0.2, 0.4, 0.8);\n    else if (count == 2) color = vec3(0.8, 0.3, 0.5);\n    else color = vec3(1.0, 0.9, 0.3);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day2-solutions.html#explorations",
    "href": "lectures/solutions/day2-solutions.html#explorations",
    "title": "1 Appendix: Day 2 Exercise Solutions",
    "section": "",
    "text": "vec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map mouse to [-2, 2] x [-2, 2]\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    mouse_uv = mouse_uv - vec2(0.5, 0.5);\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 c = mouse_uv * 4.0;\n    \n    // Default if no mouse\n    if (iMouse.x &lt; 1.0) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    vec2 z = p;\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n// Main cardioid boundary parameterization\nvec2 cardioid(float t) {\n    vec2 eit = vec2(cos(t), sin(t));\n    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;\n    return cmul(eit, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Animate c along the cardioid boundary\n    vec2 c = cardioid(iTime * 0.5);\n    \n    // Or try a simple circle:\n    // float angle = iTime * 0.3;\n    // vec2 c = 0.7885 * vec2(cos(angle), sin(angle));\n    \n    vec2 z = p;\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom into seahorse valley to see the effect\n    vec2 center = vec2(-0.745, 0.186);\n    float zoom = 50.0;\n    vec2 c = center + uv * 4.0 / zoom;\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 200;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t;\n        // Toggle between smooth and discrete every 2 seconds\n        if (mod(iTime, 4.0) &lt; 2.0) {\n            // Discrete coloring - notice the bands\n            t = float(iter) / float(max_iter);\n        } else {\n            // Smooth coloring - bands disappear!\n            float log_zn = log(cabs2(z)) / 2.0;\n            float nu = log(log_zn / log(2.0)) / log(2.0);\n            float smooth_iter = float(iter) + 1.0 - nu;\n            t = smooth_iter / float(max_iter);\n        }\n        color = palette(t * 4.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 0.5);\n    vec3 d = vec3(0.00, 0.10, 0.20);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 c = 0.1 * fragCoord / iResolution.y + vec2(1.66, -0.02);\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (dot(z, z) &gt; 1000.0) break;\n        z = cmul(z, z);\n        z.y = abs(z.y);  // abs of imaginary part AFTER squaring\n        z = z - c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(dot(z, z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.30, 0.20, 0.20);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 4.0;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = vec2(z.x, -z.y);  // conjugate\n        z = cmul(z, z) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Tricorn has 3-fold reflection symmetry (symmetric about the real axis and two other axes at 60°).\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 4.0;\n    c.x -= 0.5;\n    \n    vec2 z = vec2(0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        vec2 z2 = cmul(z, z);\n        z = vec2(abs(z2.x), z2.y) + c;  // abs of real part of z²\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        // Smooth coloring\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    int max_iter = 100;\n    int iter;\n    int lastCircle = -1;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n            lastCircle = 0;\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n            lastCircle = 1;\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n            lastCircle = 2;\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n            lastCircle = 3;\n        } else {\n            break;\n        }\n    }\n    \n    // Color by which circle was last hit\n    vec3 color;\n    if (lastCircle == 0) color = vec3(1.0, 0.2, 0.2);\n    else if (lastCircle == 1) color = vec3(0.2, 1.0, 0.2);\n    else if (lastCircle == 2) color = vec3(0.2, 0.2, 1.0);\n    else if (lastCircle == 3) color = vec3(1.0, 1.0, 0.2);\n    else color = vec3(0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nExample with different-sized inner circles:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Three circles with different radii, manually positioned to be tangent\n    // Using Descartes theorem: (k1+k2+k3+k4)² = 2(k1²+k2²+k3²+k4²)\n    Circle c1 = Circle(vec2(0.0, 1.2), 0.8);\n    Circle c2 = Circle(vec2(-1.0, -0.5), 1.0);\n    Circle c3 = Circle(vec2(1.1, -0.4), 0.7);\n    Circle outer = Circle(vec2(0.0, 0.1), 2.2);\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;\n        }\n    }\n    \n    float t = float(iter) / float(max_iter);\n    vec3 color = 30.0 * vec3(pow(t, 2.0));\n    \n    fragColor = vec4(color, 1.0);\n}\nNote: Finding four mutually tangent circles with arbitrary radii requires solving Descartes’ theorem. Given three tangent circles with curvatures \\(k_1, k_2, k_3\\), the fourth curvature is: \\[k_4 = k_1 + k_2 + k_3 \\pm 2\\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}\\]"
  },
  {
    "objectID": "lectures/solutions/day2-solutions.html#challenges",
    "href": "lectures/solutions/day2-solutions.html#challenges",
    "title": "1 Appendix: Day 2 Exercise Solutions",
    "section": "",
    "text": "vec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Get c from mouse position\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    mouse_uv = mouse_uv - vec2(0.5, 0.5);\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 c = mouse_uv * 4.0;\n    c.x -= 0.5;\n    \n    if (iMouse.x &lt; 1.0) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Mandelbrot iteration (background)\n    vec2 mc = p;\n    mc.x -= 0.5;\n    vec2 mz = vec2(0.0);\n    int m_iter;\n    for (m_iter = 0; m_iter &lt; 100; m_iter++) {\n        if (cabs2(mz) &gt; 4.0) break;\n        mz = cmul(mz, mz) + mc;\n    }\n    \n    // Julia iteration (foreground)\n    vec2 jz = p;\n    int j_iter;\n    for (j_iter = 0; j_iter &lt; 100; j_iter++) {\n        if (cabs2(jz) &gt; 4.0) break;\n        jz = cmul(jz, jz) + c;\n    }\n    \n    // Layer: light background, gray Mandelbrot, black Julia\n    vec3 color = vec3(0.9);\n    if (m_iter == 100) {\n        color = vec3(0.6);\n    }\n    if (j_iter == 100) {\n        color = vec3(0.0);\n    }\n    \n    // Red dot at c position\n    vec2 c_pos = c;\n    c_pos.x += 0.5;\n    if (length(p - c_pos) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float denom = dot(w, w);\n    return vec2(z.x * w.x + z.y * w.y, z.y * w.x - z.x * w.y) / denom;\n}\n\nvec2 ccube(vec2 z) {\n    float a = z.x, b = z.y;\n    return vec2(a*a*a - 3.0*a*b*b, 3.0*a*a*b - b*b*b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv * 4.0;\n    \n    // The three cube roots of unity\n    vec2 root1 = vec2(1.0, 0.0);\n    vec2 root2 = vec2(-0.5, 0.866);\n    vec2 root3 = vec2(-0.5, -0.866);\n    \n    int max_iter = 50;\n    int iter;\n    float eps = 0.001;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        // Newton iteration: z = z - (z³-1)/(3z²)\n        // Simplified: z = (2z³ + 1) / (3z²)\n        vec2 z2 = cmul(z, z);\n        vec2 z3 = cmul(z2, z);\n        z = cdiv(2.0 * z3 + vec2(1.0, 0.0), 3.0 * z2);\n        \n        // Check convergence\n        if (dot(z3 - vec2(1.0, 0.0), z3 - vec2(1.0, 0.0)) &lt; eps * eps) break;\n    }\n    \n    // Color by which root we converged to\n    vec3 color;\n    float d1 = length(z - root1);\n    float d2 = length(z - root2);\n    float d3 = length(z - root3);\n    \n    float t = float(iter) / float(max_iter);\n    \n    if (d1 &lt; d2 && d1 &lt; d3) {\n        color = vec3(1.0, 0.2, 0.2) * (1.0 - t * 0.5);\n    } else if (d2 &lt; d3) {\n        color = vec3(0.2, 1.0, 0.2) * (1.0 - t * 0.5);\n    } else {\n        color = vec3(0.2, 0.2, 1.0) * (1.0 - t * 0.5);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cpow(vec2 z, float n) {\n    float r = length(z);\n    if (r &lt; 0.0001) return vec2(0.0);  // Handle z ≈ 0\n    float theta = atan(z.y, z.x);\n    float rn = pow(r, n);\n    return rn * vec2(cos(n * theta), sin(n * theta));\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 c = uv * 3.0;\n    \n    // Start with small offset to avoid z=0 singularity\n    vec2 z = vec2(0.0001, 0.0);\n    \n    float n = 2.5;  // Try different values! Integer and non-integer\n    \n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cpow(z, n) + c;\n    }\n    \n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);\n    } else {\n        float t = float(iter) / float(max_iter);\n        color = palette(t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNon-integer powers create interesting branch cut effects!"
  },
  {
    "objectID": "lectures/solutions/day2-solutions.html#projects",
    "href": "lectures/solutions/day2-solutions.html#projects",
    "title": "1 Appendix: Day 2 Exercise Solutions",
    "section": "",
    "text": "vec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Grid parameters\n    float grid_size = 20.0;\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;\n    \n    // c from cell position (map to interesting region)\n    vec2 c = (cell_id / grid_size) * 3.0 - vec2(2.0, 1.5);\n    \n    // Julia iteration within this cell\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Distance to line segment from a to b\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // z0 from mouse, c fixed (or swap roles)\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    mouse_uv = mouse_uv - vec2(0.5, 0.5);\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 z0 = mouse_uv * 4.0;\n    \n    if (iMouse.x &lt; 1.0) {\n        z0 = vec2(0.3, 0.5);\n    }\n    \n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // Compute orbit\n    const int N = 50;\n    vec2 orbit[50];\n    orbit[0] = z0;\n    for (int i = 1; i &lt; N; i++) {\n        orbit[i] = cmul(orbit[i-1], orbit[i-1]) + c;\n        if (dot(orbit[i], orbit[i]) &gt; 100.0) {\n            orbit[i] = orbit[i-1];  // clamp escaped points\n        }\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw Julia set faintly in background\n    vec2 z = p;\n    int iter;\n    for (iter = 0; iter &lt; 100; iter++) {\n        if (dot(z, z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    if (iter == 100) color = vec3(0.15, 0.15, 0.2);\n    \n    // Draw orbit lines\n    for (int i = 0; i &lt; N - 1; i++) {\n        float d = sdSegment(p, orbit[i], orbit[i+1]);\n        float t = float(i) / float(N);\n        vec3 lineColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.3, 0.1), t);\n        if (d &lt; 0.02) color = lineColor;\n    }\n    \n    // Draw orbit points\n    for (int i = 0; i &lt; N; i++) {\n        float d = length(p - orbit[i]);\n        float t = float(i) / float(N);\n        float size = mix(0.06, 0.02, t);\n        if (d &lt; size) {\n            color = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.5, 0.0), t);\n        }\n    }\n    \n    // Highlight z0\n    if (length(p - z0) &lt; 0.08) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "slides/day3-slides.html#the-folding-algorithm",
    "href": "slides/day3-slides.html#the-folding-algorithm",
    "title": "Day 3",
    "section": "The Folding Algorithm",
    "text": "The Folding Algorithm\nTo create symmetric patterns, we fold points into a fundamental domain:\n// Fold across vertical line at x = 0\nif (p.x &lt; 0.0) p.x = -p.x;\n\n// Fold across horizontal line at y = 0\nif (p.y &lt; 0.0) p.y = -p.y;",
    "crumbs": [
      "Day 3: Tilings",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day3-slides.html#half-space-reflections",
    "href": "slides/day3-slides.html#half-space-reflections",
    "title": "Day 3",
    "section": "Half-Space Reflections",
    "text": "Half-Space Reflections\nA half-space is defined by a line. We reflect points to one side:\nfloat halfspace(vec2 p, vec2 normal, float offset) {\n    return dot(p, normal) - offset;\n}\n\nvec2 reflect_halfspace(vec2 p, vec2 normal, float offset) {\n    float d = halfspace(p, normal, offset);\n    if (d &lt; 0.0) p -= 2.0 * d * normal;\n    return p;\n}",
    "crumbs": [
      "Day 3: Tilings",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day3-slides.html#square-tiling",
    "href": "slides/day3-slides.html#square-tiling",
    "title": "Day 3",
    "section": "Square Tiling",
    "text": "Square Tiling",
    "crumbs": [
      "Day 3: Tilings",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day3-slides.html#hyperbolic-geometry",
    "href": "slides/day3-slides.html#hyperbolic-geometry",
    "title": "Day 3",
    "section": "Hyperbolic Geometry",
    "text": "Hyperbolic Geometry\nIn the Poincaré disk model, the entire hyperbolic plane fits inside a circle.",
    "crumbs": [
      "Day 3: Tilings",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day3-slides.html#hyperbolic-tilings",
    "href": "slides/day3-slides.html#hyperbolic-tilings",
    "title": "Day 3",
    "section": "Hyperbolic Tilings",
    "text": "Hyperbolic Tilings\nReflection groups in hyperbolic space create stunning patterns:",
    "crumbs": [
      "Day 3: Tilings",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day1-slides.html#what-is-a-shader",
    "href": "slides/day1-slides.html#what-is-a-shader",
    "title": "Day 1",
    "section": "What is a Shader?",
    "text": "What is a Shader?\nA shader is a program that runs on the GPU.\n\nExecutes in parallel for every pixel\nTakes coordinates as input\nOutputs a color\nIncredibly fast for mathematical visualization",
    "crumbs": [
      "Day 1: Introduction",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day1-slides.html#the-basic-setup",
    "href": "slides/day1-slides.html#the-basic-setup",
    "title": "Day 1",
    "section": "The Basic Setup",
    "text": "The Basic Setup\nEvery fragment shader has this structure:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates to [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Output a color (RGBA)\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}",
    "crumbs": [
      "Day 1: Introduction",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day1-slides.html#your-first-shader",
    "href": "slides/day1-slides.html#your-first-shader",
    "title": "Day 1",
    "section": "Your First Shader",
    "text": "Your First Shader\nLet’s start with the simplest possible shader - solid red:",
    "crumbs": [
      "Day 1: Introduction",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day1-slides.html#implicit-curves",
    "href": "slides/day1-slides.html#implicit-curves",
    "title": "Day 1",
    "section": "Implicit Curves",
    "text": "Implicit Curves\nWe can draw curves using signed distance functions.\nA circle of radius \\(r\\) centered at the origin:\n\\[d(x, y) = \\sqrt{x^2 + y^2} - r\\]",
    "crumbs": [
      "Day 1: Introduction",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day1-slides.html#the-circle-shader-code",
    "href": "slides/day1-slides.html#the-circle-shader-code",
    "title": "Day 1",
    "section": "The Circle Shader Code",
    "text": "The Circle Shader Code\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float f = d - r;\n    \n    vec3 color;\n    if (f &lt; 0.0) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow inside\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Day 1: Introduction",
      "Slides"
    ]
  },
  {
    "objectID": "OLD/outline.html",
    "href": "OLD/outline.html",
    "title": "Outline",
    "section": "",
    "text": "This mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nFormat: Five days, each with one hour of lecture and approximately 1.5 hours of homework\nPrerequisites: Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required\nAudience: Graduate students, postdocs, and faculty in mathematics\n\n\n\n\n\n\n\nUnderstand the mathematical model of shader programming (function from pixels to colors)\nLearn basic GLSL syntax and conventions\nMaster coordinate system setup and distance calculations\nCreate simple geometric shapes and implicit curves\n\n\n\n\n\nMathematical framing: Shaders as parallel functions computing colors for all pixels simultaneously\nGLSL basics: Syntax, vector types, built-in functions\nCoordinate systems: Centering, normalizing, aspect ratio correction\nConditional coloring: Half-planes and regions defined by inequalities\nDistance fields: Circles, filled and outlined\nRepetition: Using mod() for grids and patterns\nImplicit curves: Rendering curves defined by \\(F(x,y) = 0\\)\n\n\n\n\nRequired: Parabola graphing calculator - Draw coordinate axes - Plot \\(y = ax^2 + bx + c\\) with customizable coefficients - Make it robust for various parameter values\nOptional #1: Animated curve family (vary parameters with time)\nOptional #2: Beautiful tiling pattern using mod()\n\n\n\n\n\n\n\n\nImplement complex number arithmetic in GLSL\nRender the Mandelbrot set through escape-time iteration\nMaster circle inversion as a conformal transformation\nUse structs to organize geometric data\nGenerate the Apollonian gasket through iterated inversions\n\n\n\n\n\nComplex arithmetic: Addition, multiplication, division, conjugation\nMandelbrot set:\n\nIteration \\(z_{n+1} = z_n^2 + c\\) with \\(z_0 = 0\\)\nEscape-time algorithm\nSmooth coloring and palettes\n\nCircle inversion:\n\nMathematical definition and properties\nConformal mapping (preserves angles, maps circles to circles/lines)\nImplementation and visualization\n\nStructs in GLSL: Organizing circle data (center, radius)\nApollonian gasket:\n\nThree mutually tangent circles\nIterated inversions generate fractal structure\nColoring by escape time or basin of attraction\n\n\n\n\n\nRequired: Julia sets - Implement for fixed \\(c\\), varying initial \\(z_0\\) - Explore parameter space (try different values of \\(c\\)) - Optional: animate \\(c\\) to watch morphing\nOptional: Schottky groups - Four or more disjoint circles - Alternating inversion patterns - Create intricate nested structures\n\n\n\n\n\n\n\n\nCreate Euclidean triangle tilings through reflection\nUnderstand hyperbolic geometry models (upper half-plane, Poincaré disk)\nImplement hyperbolic triangle tilings using circle inversion\nConvert between different hyperbolic models\n\n\n\n\n\nEuclidean triangle tiling:\n\nFundamental domain (equilateral triangle)\nReflection across edges\nIterative folding algorithm\nColoring by reflection count\n\nHyperbolic geometry introduction:\n\nUpper half-plane model: \\(\\mathbb{H}^2 = \\{z : \\text{Im}(z) &gt; 0\\}\\)\nHyperbolic metric: \\(ds^2 = \\frac{dx^2 + dy^2}{y^2}\\)\nGeodesics: vertical lines and semicircles\nHyperbolic distance formula\n\nPoincaré disk model:\n\nUnit disk representation\nCayley transform between models\n\nHyperbolic triangle tiling:\n\n\\((2,3,\\infty)\\) triangle with nice edges\nReflection across vertical geodesics (simple)\nReflection across circular geodesics (circle inversion!)\nFolding algorithm\nVisualization in both models\n\n\n\n\n\nRequired #1: Draw geodesics and hyperbolic disks - Visualize geodesics in upper half-plane - Draw hyperbolic disks (constant hyperbolic distance) - Observe metric distortion\nRequired #2: Draw triangle edges and vertices - Compute distance to geodesics - Render triangle boundaries explicitly - Mark vertices\nRequired #3: Model conversion and Möbius transformations - Convert tiling to Poincaré disk - Apply Möbius transformations (isometries) - Observe how tiling transforms\nOptional: - Different triangle groups (e.g., \\((2,3,7)\\) for Escher-like tilings) - Klein model (geodesics become straight lines) - Decorated tiles (Escher-style patterns)\n\n\n\n\n\n\n\n\nSet up camera and generate rays from pixels\nImplement analytical ray-object intersection\nLearn the raymarching algorithm and signed distance functions\nApply basic lighting (diffuse shading)\n\n\n\n\n\nCamera and ray setup:\n\nPinhole camera model\nRay generation from pixel coordinates\nField of view control\n\nAnalytical intersections:\n\nRay-sphere: solve quadratic equation\nCompute surface normals analytically\nRay-torus: implicit equation and gradient\nBisection method for root-finding\n\nLighting introduction:\n\nSurface normals\nDiffuse lighting: dot product with light direction\nSeeing 3D structure through shading\n\nMotivation for raymarching:\n\nAnalytical methods don’t scale\nComplex surfaces need flexible approach\n\nSigned Distance Functions (SDFs):\n\nDefinition and properties\nSDFs for primitives: sphere, box, plane, torus\nDistance as bound for safe marching\n\nRaymarching algorithm:\n\nSphere tracing: march by SDF value\nStopping conditions\nScene composition (minimum distance)\n\nNormal estimation:\n\nGradient via finite differences\nEstimating partial derivatives\nSame lighting applied to raymarched objects\n\nScene progression:\n\nSingle sphere\nTwo spheres\nSphere and torus\n\n\n\n\n\nRequired: Algebraic variety rendering - Choose polynomial implicit surface (degree 3 or 4) - Implement root-finding (bisection or Newton’s method) - Compute gradient for normals - Optional: bounding sphere optimization\nOptional: - Specular lighting (Phong model) - Rotation matrices for object transformation - Complex multi-object scenes\n\n\n\n\n\nThe final day will be determined based on pacing, student interest, and energy levels. Two complete lectures are prepared:\n\n\n\n\n\nMaster domain operations for efficient complex scenes\nUnderstand and apply boolean operations on SDFs\nCreate 3D fractals via iterated folding (Menger sponge)\nBuild sophisticated scenes from simple primitives\n\n\n\n\n\nDomain operations:\n\nRepetition: mod() for infinite object grids\nSymmetry: abs() for mirror planes\nPolar repetition for radial patterns\nZero computational cost for infinite complexity\n\nBoolean operations on SDFs:\n\nUnion: min(d1, d2)\nIntersection: max(d1, d2)\nSubtraction: max(d1, -d2)\nSmooth minimum: smin() for organic blending\n\nMenger sponge:\n\nBox folding in 3D\nAxis-aligned operations\nIterated subdivision\nConnection to 2D fractals\n\nScene building:\n\nCombining techniques\nArchitectural structures\nInfinite repeated patterns\n\n\n\n\n\nRequired: Creative scene building - Build complex scene using domain ops and booleans - Experiment with combinations - Focus on mathematical or aesthetic interest\nOptional: Sierpinski tetrahedron - Implement via 3D folding (non-axis-aligned) - Connection to Day 2’s triangle folding in higher dimension\n\n\n\n\n\n\n\n\nUnderstand buffer-based computation in Shadertoy\nImplement differential operators (Laplacian)\nSolve partial differential equations on the GPU\nCreate dynamic, evolving mathematical systems\n\n\n\n\n\nIntroduction to buffers:\n\nReading from previous frame\nMulti-pass rendering\nSimple example: conditional coloring based on buffer\n\nEdge detection and the Laplacian:\n\nDiscrete Laplacian stencil (5-point or 9-point)\nSampling neighboring pixels\nSpatial derivatives on grids\n\nThe heat equation:\n\nMathematical formulation: \\(u_t = \\alpha\\nabla^2 u\\)\nApplying Laplacian for diffusion\nTime-stepping: u_new = u_old + dt * α * laplacian(u_old)\nInitial conditions (e.g., heat in a fractal region)\nWatching patterns blur and diffuse\n\nBoundary conditions:\n\nZero boundaries (edges set to 0)\nAvoiding wrap-around\n\nTimestep stability:\n\nCFL condition (briefly mentioned)\nProviding stable dt value\n\n\n\n\n\nRequired: Interactive heat equation or reaction-diffusion - Option 1: Heat source at mouse position, watch it diffuse - Option 2: Gray-Scott reaction-diffusion (pattern formation)\nOptional: Wave equation - Requires two buffers (current and previous state) - Implement \\(u_{tt} = c^2\\nabla^2 u\\) - Watch waves propagate and reflect\n\n\n\n\n\n\n\n\n\nMain site: https://www.shadertoy.com\nCommunity examples and tutorials\nGLSL documentation\n\n\n\n\n\nComplex dynamics and fractals\nHyperbolic geometry and tilings\nSigned distance functions (Inigo Quilez: https://iquilezles.org/articles/distfunctions/)\nGPU computing for scientific visualization\n\n\n\n\n\nPath tracing and global illumination\nNon-Euclidean ray tracing\nReal-time denoising\nMore complex PDEs and simulations\n\n\n\n\n\n\nThis is a workshop-style course focused on skill development. Success means: - Completing required homework to keep pace - Experimenting with optional problems based on interest - Developing intuition for when shader programming is appropriate - Leaving with working code templates for future projects\nPhilosophy: Getting something working and understanding it is more valuable than perfect, polished results. The goal is to build practical skills and mathematical intuition, not to create production-quality graphics.\n\n\n\n\n\n\n\n\n\n\n\n\nDay\nTopic\nKey Concepts\n\n\n\n\n1\nShader Basics\nCoordinates, distance fields, implicit curves\n\n\n2\nComplex Dynamics\nMandelbrot, circle inversion, Apollonian gasket\n\n\n3\nGeometric Tilings\nEuclidean and hyperbolic tilings, models\n\n\n4\n3D Rendering\nRaymarching, SDFs, lighting\n\n\n5\nAdvanced (flexible)\nDomain ops + fractals OR buffers + PDEs\n\n\n\nEach day: 1 hour lecture + ~1.5 hours homework Total: 5 lectures, 10-12 programming assignments (5 required, 5-7 optional)"
  },
  {
    "objectID": "OLD/outline.html#course-overview",
    "href": "OLD/outline.html#course-overview",
    "title": "Outline",
    "section": "",
    "text": "This mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nFormat: Five days, each with one hour of lecture and approximately 1.5 hours of homework\nPrerequisites: Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required\nAudience: Graduate students, postdocs, and faculty in mathematics"
  },
  {
    "objectID": "OLD/outline.html#day-1-introduction-to-shader-programming",
    "href": "OLD/outline.html#day-1-introduction-to-shader-programming",
    "title": "Outline",
    "section": "",
    "text": "Understand the mathematical model of shader programming (function from pixels to colors)\nLearn basic GLSL syntax and conventions\nMaster coordinate system setup and distance calculations\nCreate simple geometric shapes and implicit curves\n\n\n\n\n\nMathematical framing: Shaders as parallel functions computing colors for all pixels simultaneously\nGLSL basics: Syntax, vector types, built-in functions\nCoordinate systems: Centering, normalizing, aspect ratio correction\nConditional coloring: Half-planes and regions defined by inequalities\nDistance fields: Circles, filled and outlined\nRepetition: Using mod() for grids and patterns\nImplicit curves: Rendering curves defined by \\(F(x,y) = 0\\)\n\n\n\n\nRequired: Parabola graphing calculator - Draw coordinate axes - Plot \\(y = ax^2 + bx + c\\) with customizable coefficients - Make it robust for various parameter values\nOptional #1: Animated curve family (vary parameters with time)\nOptional #2: Beautiful tiling pattern using mod()"
  },
  {
    "objectID": "OLD/outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "href": "OLD/outline.html#day-2-complex-dynamics-and-iterated-inversions",
    "title": "Outline",
    "section": "",
    "text": "Implement complex number arithmetic in GLSL\nRender the Mandelbrot set through escape-time iteration\nMaster circle inversion as a conformal transformation\nUse structs to organize geometric data\nGenerate the Apollonian gasket through iterated inversions\n\n\n\n\n\nComplex arithmetic: Addition, multiplication, division, conjugation\nMandelbrot set:\n\nIteration \\(z_{n+1} = z_n^2 + c\\) with \\(z_0 = 0\\)\nEscape-time algorithm\nSmooth coloring and palettes\n\nCircle inversion:\n\nMathematical definition and properties\nConformal mapping (preserves angles, maps circles to circles/lines)\nImplementation and visualization\n\nStructs in GLSL: Organizing circle data (center, radius)\nApollonian gasket:\n\nThree mutually tangent circles\nIterated inversions generate fractal structure\nColoring by escape time or basin of attraction\n\n\n\n\n\nRequired: Julia sets - Implement for fixed \\(c\\), varying initial \\(z_0\\) - Explore parameter space (try different values of \\(c\\)) - Optional: animate \\(c\\) to watch morphing\nOptional: Schottky groups - Four or more disjoint circles - Alternating inversion patterns - Create intricate nested structures"
  },
  {
    "objectID": "OLD/outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "href": "OLD/outline.html#day-3-geometric-tilings-in-euclidean-and-hyperbolic-space",
    "title": "Outline",
    "section": "",
    "text": "Create Euclidean triangle tilings through reflection\nUnderstand hyperbolic geometry models (upper half-plane, Poincaré disk)\nImplement hyperbolic triangle tilings using circle inversion\nConvert between different hyperbolic models\n\n\n\n\n\nEuclidean triangle tiling:\n\nFundamental domain (equilateral triangle)\nReflection across edges\nIterative folding algorithm\nColoring by reflection count\n\nHyperbolic geometry introduction:\n\nUpper half-plane model: \\(\\mathbb{H}^2 = \\{z : \\text{Im}(z) &gt; 0\\}\\)\nHyperbolic metric: \\(ds^2 = \\frac{dx^2 + dy^2}{y^2}\\)\nGeodesics: vertical lines and semicircles\nHyperbolic distance formula\n\nPoincaré disk model:\n\nUnit disk representation\nCayley transform between models\n\nHyperbolic triangle tiling:\n\n\\((2,3,\\infty)\\) triangle with nice edges\nReflection across vertical geodesics (simple)\nReflection across circular geodesics (circle inversion!)\nFolding algorithm\nVisualization in both models\n\n\n\n\n\nRequired #1: Draw geodesics and hyperbolic disks - Visualize geodesics in upper half-plane - Draw hyperbolic disks (constant hyperbolic distance) - Observe metric distortion\nRequired #2: Draw triangle edges and vertices - Compute distance to geodesics - Render triangle boundaries explicitly - Mark vertices\nRequired #3: Model conversion and Möbius transformations - Convert tiling to Poincaré disk - Apply Möbius transformations (isometries) - Observe how tiling transforms\nOptional: - Different triangle groups (e.g., \\((2,3,7)\\) for Escher-like tilings) - Klein model (geodesics become straight lines) - Decorated tiles (Escher-style patterns)"
  },
  {
    "objectID": "OLD/outline.html#day-4-introduction-to-3d-rendering",
    "href": "OLD/outline.html#day-4-introduction-to-3d-rendering",
    "title": "Outline",
    "section": "",
    "text": "Set up camera and generate rays from pixels\nImplement analytical ray-object intersection\nLearn the raymarching algorithm and signed distance functions\nApply basic lighting (diffuse shading)\n\n\n\n\n\nCamera and ray setup:\n\nPinhole camera model\nRay generation from pixel coordinates\nField of view control\n\nAnalytical intersections:\n\nRay-sphere: solve quadratic equation\nCompute surface normals analytically\nRay-torus: implicit equation and gradient\nBisection method for root-finding\n\nLighting introduction:\n\nSurface normals\nDiffuse lighting: dot product with light direction\nSeeing 3D structure through shading\n\nMotivation for raymarching:\n\nAnalytical methods don’t scale\nComplex surfaces need flexible approach\n\nSigned Distance Functions (SDFs):\n\nDefinition and properties\nSDFs for primitives: sphere, box, plane, torus\nDistance as bound for safe marching\n\nRaymarching algorithm:\n\nSphere tracing: march by SDF value\nStopping conditions\nScene composition (minimum distance)\n\nNormal estimation:\n\nGradient via finite differences\nEstimating partial derivatives\nSame lighting applied to raymarched objects\n\nScene progression:\n\nSingle sphere\nTwo spheres\nSphere and torus\n\n\n\n\n\nRequired: Algebraic variety rendering - Choose polynomial implicit surface (degree 3 or 4) - Implement root-finding (bisection or Newton’s method) - Compute gradient for normals - Optional: bounding sphere optimization\nOptional: - Specular lighting (Phong model) - Rotation matrices for object transformation - Complex multi-object scenes"
  },
  {
    "objectID": "OLD/outline.html#day-5-choose-your-adventure",
    "href": "OLD/outline.html#day-5-choose-your-adventure",
    "title": "Outline",
    "section": "",
    "text": "The final day will be determined based on pacing, student interest, and energy levels. Two complete lectures are prepared:\n\n\n\n\n\nMaster domain operations for efficient complex scenes\nUnderstand and apply boolean operations on SDFs\nCreate 3D fractals via iterated folding (Menger sponge)\nBuild sophisticated scenes from simple primitives\n\n\n\n\n\nDomain operations:\n\nRepetition: mod() for infinite object grids\nSymmetry: abs() for mirror planes\nPolar repetition for radial patterns\nZero computational cost for infinite complexity\n\nBoolean operations on SDFs:\n\nUnion: min(d1, d2)\nIntersection: max(d1, d2)\nSubtraction: max(d1, -d2)\nSmooth minimum: smin() for organic blending\n\nMenger sponge:\n\nBox folding in 3D\nAxis-aligned operations\nIterated subdivision\nConnection to 2D fractals\n\nScene building:\n\nCombining techniques\nArchitectural structures\nInfinite repeated patterns\n\n\n\n\n\nRequired: Creative scene building - Build complex scene using domain ops and booleans - Experiment with combinations - Focus on mathematical or aesthetic interest\nOptional: Sierpinski tetrahedron - Implement via 3D folding (non-axis-aligned) - Connection to Day 2’s triangle folding in higher dimension\n\n\n\n\n\n\n\n\nUnderstand buffer-based computation in Shadertoy\nImplement differential operators (Laplacian)\nSolve partial differential equations on the GPU\nCreate dynamic, evolving mathematical systems\n\n\n\n\n\nIntroduction to buffers:\n\nReading from previous frame\nMulti-pass rendering\nSimple example: conditional coloring based on buffer\n\nEdge detection and the Laplacian:\n\nDiscrete Laplacian stencil (5-point or 9-point)\nSampling neighboring pixels\nSpatial derivatives on grids\n\nThe heat equation:\n\nMathematical formulation: \\(u_t = \\alpha\\nabla^2 u\\)\nApplying Laplacian for diffusion\nTime-stepping: u_new = u_old + dt * α * laplacian(u_old)\nInitial conditions (e.g., heat in a fractal region)\nWatching patterns blur and diffuse\n\nBoundary conditions:\n\nZero boundaries (edges set to 0)\nAvoiding wrap-around\n\nTimestep stability:\n\nCFL condition (briefly mentioned)\nProviding stable dt value\n\n\n\n\n\nRequired: Interactive heat equation or reaction-diffusion - Option 1: Heat source at mouse position, watch it diffuse - Option 2: Gray-Scott reaction-diffusion (pattern formation)\nOptional: Wave equation - Requires two buffers (current and previous state) - Implement \\(u_{tt} = c^2\\nabla^2 u\\) - Watch waves propagate and reflect"
  },
  {
    "objectID": "OLD/outline.html#resources-and-further-exploration",
    "href": "OLD/outline.html#resources-and-further-exploration",
    "title": "Outline",
    "section": "",
    "text": "Main site: https://www.shadertoy.com\nCommunity examples and tutorials\nGLSL documentation\n\n\n\n\n\nComplex dynamics and fractals\nHyperbolic geometry and tilings\nSigned distance functions (Inigo Quilez: https://iquilezles.org/articles/distfunctions/)\nGPU computing for scientific visualization\n\n\n\n\n\nPath tracing and global illumination\nNon-Euclidean ray tracing\nReal-time denoising\nMore complex PDEs and simulations"
  },
  {
    "objectID": "OLD/outline.html#assessment-philosophy",
    "href": "OLD/outline.html#assessment-philosophy",
    "title": "Outline",
    "section": "",
    "text": "This is a workshop-style course focused on skill development. Success means: - Completing required homework to keep pace - Experimenting with optional problems based on interest - Developing intuition for when shader programming is appropriate - Leaving with working code templates for future projects\nPhilosophy: Getting something working and understanding it is more valuable than perfect, polished results. The goal is to build practical skills and mathematical intuition, not to create production-quality graphics."
  },
  {
    "objectID": "OLD/outline.html#schedule-summary",
    "href": "OLD/outline.html#schedule-summary",
    "title": "Outline",
    "section": "",
    "text": "Day\nTopic\nKey Concepts\n\n\n\n\n1\nShader Basics\nCoordinates, distance fields, implicit curves\n\n\n2\nComplex Dynamics\nMandelbrot, circle inversion, Apollonian gasket\n\n\n3\nGeometric Tilings\nEuclidean and hyperbolic tilings, models\n\n\n4\n3D Rendering\nRaymarching, SDFs, lighting\n\n\n5\nAdvanced (flexible)\nDomain ops + fractals OR buffers + PDEs\n\n\n\nEach day: 1 hour lecture + ~1.5 hours homework Total: 5 lectures, 10-12 programming assignments (5 required, 5-7 optional)"
  },
  {
    "objectID": "OLD/lectures/day3.html",
    "href": "OLD/lectures/day3.html",
    "title": "1 Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "Today we explore geometric tilings through reflection operations. We’ll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.\nThe key insight: the algorithm stays the same across geometries—only the reflection operations change. This mirrors what we saw on Day 2 with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region. But today we’ll understand why this works through the lens of group theory.\nBy the end of today, you’ll understand: - How to construct reflections using linear algebra - Why the folding algorithm works (reflection groups and fundamental domains) - The structure of hyperbolic geometry in the upper half-plane model - How to implement hyperbolic triangle tilings using the same algorithmic pattern - How to convert between different models of hyperbolic space - The connection between circle inversion (Day 2) and hyperbolic isometries\n\n\n\n\n\n\nNoteRoadmap for Today\n\n\n\nPart 1: Euclidean Geometry - Simple tilings (strip, square) - Half-space abstraction - Triangle tilings - Why this works: Reflection groups\nPart 2: Hyperbolic Geometry - The upper half-plane model and metric - Geodesics and reflections (connection to Day 2!) - Triangle tilings in \\(\\mathbb{H}^2\\) - Multiple models (Poincaré disk, Klein) - Historical context and applications\nThe unifying theme is geometric transformations and their groups—the same mathematical structure underlies fractals, tilings, and symmetry across all geometries.\n\n\n\n\n\n\n\n\nBefore we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.\n\n\nImagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip \\(0 &lt; x &lt; 1\\)—and reflect any point outside this strip back inside.\nThe algorithm is remarkably simple: - If \\(x &lt; 0\\), reflect across \\(x = 0\\) - If \\(x &gt; 1\\), reflect across \\(x = 1\\)\n- Repeat until the point stops moving\nFor a vertical line at \\(x = c\\), reflection just flips the \\(x\\)-coordinate: \\((x, y) \\mapsto (2c - x, y)\\).\nHere’s a complete shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.\nWhat’s happening geometrically? Every point on the screen gets mapped back to the fundamental domain \\([0,1]\\). Points that were in reflected copies of the domain get folded back through a sequence of reflections. Since we draw the same pattern in the fundamental domain, all the reflected copies show the same pattern.\n\n\n\n\nLet’s extend to two dimensions. Now we have four boundaries: \\(x = 0\\), \\(x = 1\\), \\(y = 0\\), and \\(y = 1\\). Same algorithm, just more boundaries to check:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);\n    \n    // Circle at center\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nPerfect! A full 2D tiling.\n\n\n\n\nLet’s track how many reflections were needed. This helps us understand the geometry and creates beautiful visualizations:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! The color gradient shows how many reflections were needed—points near the fundamental domain require few iterations, while points far away need many.\nNotice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain and we can stop.\n\n\n\n\n\n\nTipComputational Efficiency: Iteration Count\n\n\n\nWhy does this converge so quickly? Each reflection moves the point strictly closer to the fundamental domain (in the sense of reducing the number of boundary crossings). For a viewport of size \\(4 \\times 4\\) and fundamental domain of size \\(1 \\times 1\\), we need at most \\(\\lceil \\log_2(4) \\rceil = 2\\) reflections per axis, so 4 reflections total in the worst case.\nThe 20-iteration limit is very conservative—most pixels converge in under 5 iterations. We could dynamically adjust this based on the coordinate scale, but for real-time rendering, a fixed conservative bound works well.\n\n\n\n\n\n\n\nLooking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.\n\n\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions: - Points where \\(ax + by &lt; c\\) - Points where \\(ax + by &gt; c\\)\nWe’ll encode a half-space by storing the line parameters and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line parameters: ax + by = c\n    float side;     // +1 or -1 for which side\n};\nThe side parameter determines which inequality we want: - side = -1.0 means we want \\(ax + by &gt; c\\) (equivalently, \\((ax + by - c) \\cdot (-1) &lt; 0\\)) - side = 1.0 means we want \\(ax + by &lt; c\\) (equivalently, \\((ax + by - c) \\cdot (1) &lt; 0\\))\nThis might seem redundant—we could always use \\(ax + by &lt; c\\) and just flip the signs of \\(a, b, c\\) to get the other side. But having an explicit side parameter makes the code clearer and will be essential in hyperbolic geometry where sign-flipping doesn’t work as cleanly.\n\n\n\nBefore we implement reflections, let’s visualize what a half-space is. Here’s a shader that colors one side of a line:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1 (left side of vertical line at x=1)\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the left side of the line colored blue, the right side dark. Try changing the half-space parameters to see how it affects the coloring!\n\n\n\n\n\n\nTipExercise: Drawing the Boundary Line\n\n\n\nWant to see where the line is? Add this distance function:\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\nThen draw the line:\nfloat d = distToHalfSpace(p, hs);\nif(d &lt; 0.02) color = vec3(1.0);  // White boundary\nThis computes the perpendicular distance from the point to the line, then colors points near the line white. See Appendix E4b for the complete implementation!\n\n\n\n\n\nNow let’s intersect four half-spaces to create a square region. We’ll use additive coloring—each half-space we’re inside adds to the color, so the interior (inside all four) will be brightest:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Additive coloring - each half-space adds brightness\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, left))   color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, right))  color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, bottom)) color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, top))    color += vec3(0.1, 0.15, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the square region brightest (inside all four half-spaces), with regions inside fewer half-spaces progressively darker. This additive approach makes it easy to see how the regions overlap!\n\n\n\n\n\n\nTipExercise: Improved Visualization\n\n\n\nFor a cleaner look, you might want to:\n\nBinary coloring (inside domain or not):\n\nbool in_square = inside(p, left) && inside(p, right) && \n                 inside(p, bottom) && inside(p, top);\nvec3 color = in_square ? vec3(0.4, 0.6, 0.8) : vec3(0.1, 0.1, 0.2);\n\nDraw boundaries using the distance function from earlier\nCreate an insideDomain() function:\n\nbool insideDomain(vec2 p, HalfSpace hs1, HalfSpace hs2, \n                  HalfSpace hs3, HalfSpace hs4) {\n    return inside(p, hs1) && inside(p, hs2) && \n           inside(p, hs3) && inside(p, hs4);\n}\nSee Appendix E5b for complete enhanced versions!\n\n\n\n\n\nLet’s visualize three half-spaces defining a triangle:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, hs1)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs2)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs3)) color += vec3(0.15, 0.2, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a triangle region where all three half-spaces overlap! The additive coloring helps visualize the structure.\n\n\n\n\nNow we’re ready to implement reflection. To reflect a point \\(\\mathbf{p} = (x, y)\\) across the line \\(ax + by = c\\), we use linear algebra. The normal vector to the line is \\(\\mathbf{n} = (a, b)\\). After normalizing to \\(\\hat{\\mathbf{n}} = \\mathbf{n}/|\\mathbf{n}|\\), the reflection formula is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere \\(d\\) is the signed distance from \\(\\mathbf{p}\\) to the line:\n\\[d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\]\nThis is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.\nOur reflectInto function checks if we’re on the correct side and only reflects if necessary—it extends our inside() test by conditionally reflecting:\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    // Compute which side of the line we're on\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    // Check if we're already on the correct side (this is our inside() test!)\n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;  // Already inside, nothing to do\n    }\n    \n    // We're on the wrong side - reflect across the boundary line\n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\nThis function encapsulates the entire pattern: check if we’re on the correct side (the inside() test), and only reflect if we’re not. So reflectInto() extends and renames our visualization function to also perform the reflection!\n\n\n\n\n\nLet’s rewrite our square tiling using this abstraction. For the square \\([0, 1] \\times [0, 1]\\), we need four half-spaces:\n\nLeft edge (\\(x = 0\\)): We want \\(x &gt; 0\\) → HalfSpace(1.0, 0.0, 0.0, -1.0)\nRight edge (\\(x = 1\\)): We want \\(x &lt; 1\\) → HalfSpace(1.0, 0.0, 1.0, 1.0)\nBottom and top: Similarly for \\(y\\)\n\nComplete shader:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1]×[0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);\n    \n    // Fold into the square\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, left);\n        p = reflectInto(p, right);\n        p = reflectInto(p, bottom);\n        p = reflectInto(p, top);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis looks identical to our earlier version, but now our code is flexible. The beauty: changing from a square to a triangle only requires changing the half-space definitions!\n\n\n\n\nNow we’re ready for triangles. We’ll use an equilateral triangle with vertices at:\n\\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nThis triangle is centered at the origin with one vertex pointing up.\n\n\nFor each edge, we need to compute the line parameters \\((a, b, c)\\) and determine the correct side. The process:\n\nTake two vertices defining an edge: \\(\\mathbf{v}_i\\) and \\(\\mathbf{v}_j\\)\nCompute edge direction: \\(\\mathbf{d} = \\mathbf{v}_j - \\mathbf{v}_i\\)\nCompute perpendicular (rotate 90° counterclockwise): \\(\\mathbf{n} = (-d_y, d_x)\\)\nLine equation: \\(n_x \\cdot x + n_y \\cdot y = c\\) where \\(c = \\mathbf{n} \\cdot \\mathbf{v}_i\\)\nTest origin: if \\((n_x \\cdot 0 + n_y \\cdot 0 - c) &lt; 0\\), then side = -1.0, else side = 1.0\n\n\n\n\n\n\n\nNoteDerivation of Triangle Half-Space Parameters\n\n\n\n\n\nEdge from \\(v_0 = (0, 1)\\) to \\(v_1 = (-\\sqrt{3}/2, -1/2)\\):\n\nEdge direction: \\(\\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\\)\nPerpendicular (90° CCW): \\(\\mathbf{n} = (1.5, -0.866)\\)\nLine: \\(1.5x - 0.866y = c\\) where \\(c = \\mathbf{n} \\cdot v_0 = (1.5)(0) + (-0.866)(1) = -0.866\\)\nFor origin (inside): \\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\\)\nWe want inside when \\((ax + by - c) &lt; 0\\), so we need side = -1.0\n\nResult: HalfSpace(1.5, -0.866, -0.866, -1.0)\nSimilar calculations give: - Edge \\(v_1\\) to \\(v_2\\): HalfSpace(0.0, 1.732, -0.866, -1.0) - Edge \\(v_2\\) to \\(v_0\\): HalfSpace(-1.5, -0.866, -0.866, -1.0)\n\n\n\nThe computed parameters are:\n\nEdge \\(v_0\\) to \\(v_1\\): HalfSpace(1.5, -0.866, -0.866, -1.0)\nEdge \\(v_1\\) to \\(v_2\\): HalfSpace(0.0, 1.732, -0.866, -1.0)\n\nEdge \\(v_2\\) to \\(v_0\\): HalfSpace(-1.5, -0.866, -0.866, -1.0)\n\nWe already verified these work with our visualization shader above!\n\n\n\nNow we can implement the tiling by copying our reflection shader and just changing the half-spaces:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into the triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! You should see an infinite triangle tiling. The alternating colors show which triangles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.\n\n\n\n\n\n\nTipExercise: Visualizing Triangle Structure\n\n\n\nWant to see the edges and vertices of your triangles? This requires computing distances to half-spaces and vertices.\nFor edges (drawing the boundaries):\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\n// In main rendering:\nfloat d1 = distToHalfSpace(p, hs1);\nfloat d2 = distToHalfSpace(p, hs2);\nfloat d3 = distToHalfSpace(p, hs3);\nfloat border = min(d1, min(d2, d3));\n\nif(border &lt; 0.02) color = vec3(1.0);  // White edges\nFor vertices (marking the corners):\n// Define vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);\nvec2 v2 = vec2(0.866, -0.5);\n\n// Check distance after folding\nfloat dv0 = length(p - v0);\nfloat dv1 = length(p - v1);\nfloat dv2 = length(p - v2);\nfloat vertex_dist = min(dv0, min(dv1, dv2));\n\nif(vertex_dist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);  // Red vertices\nSee Appendix E9 for the complete enhanced version!\n\n\n\n\n\n\n\nWe’ve implemented the folding algorithm, but why does it work? Why does iteratively reflecting guarantee we reach the fundamental domain? The answer lies in group theory.\n\n\nEach reflection \\(r_i\\) across a half-space boundary is an isometry of the Euclidean plane—it preserves distances and angles. Composing reflections gives us more isometries. The set of all compositions of our reflections forms a group under composition:\n\nIdentity: Reflecting twice across the same line returns to the original point (\\(r_i \\circ r_i = \\text{id}\\))\nClosure: Composing reflections gives another isometry (which might be a reflection, rotation, or glide reflection)\nInverses: Every isometry has an inverse (just reflect again)\nAssociativity: Composition is associative\n\nThis group, generated by reflections across the boundaries of our fundamental domain, is called a reflection group or Coxeter group.\n\n\n\nOur fundamental domain \\(F\\) (the square \\([0,1]^2\\) or triangle) is a fundamental domain for the group action. This means:\n\nEvery point in the plane is equivalent to exactly one point in \\(F\\) (modulo boundary points)\nThe orbit of \\(F\\) under the group (all images \\(g(F)\\) for \\(g\\) in the group) tiles the entire plane\nDifferent tiles \\(g(F)\\) and \\(h(F)\\) only overlap on their boundaries\n\nWhen we start with a point \\(p\\) outside \\(F\\), there exists a sequence of group elements (reflections) that maps \\(p\\) into \\(F\\). Our algorithm finds this sequence!\n\n\n\nHere’s the key insight: each reflection across a boundary of \\(F\\) either: - Keeps the point inside \\(F\\) (if it’s already on the correct side) - Moves the point strictly closer to \\(F\\) (if it’s on the wrong side)\n“Closer” here means we reduce some discrete measure—like the number of boundaries we’re on the wrong side of. Since this number is finite and decreases with each reflection, the algorithm must terminate.\nFormally, we can define a height function \\(h(p)\\) that counts how many half-space boundaries \\(p\\) violates. Initially \\(h(p) \\geq 0\\). Each reflection that actually moves the point decreases \\(h(p)\\) by at least 1. When \\(h(p) = 0\\), the point is inside \\(F\\) and the algorithm stops.\n\n\n\n\n\n\nImportantThe Pattern Across Days\n\n\n\nThis is the same fundamental principle we’ve seen throughout:\nDay 2 (Apollonian gasket): - Group: Iterated circle inversions - Fundamental domain: The gaps between circles - Algorithm: Invert until inside the domain\nDay 3 (Euclidean tilings): - Group: Reflections across boundaries - Fundamental domain: The square/triangle - Algorithm: Reflect until inside the domain\nDay 3 (Hyperbolic, coming soon): - Group: Hyperbolic reflections (same structure!) - Fundamental domain: Hyperbolic triangle - Algorithm: Reflect until inside the domain (identical code!)\nThe unifying theme is group actions and fundamental domains. We’re always finding the unique representative of an orbit that lies in the fundamental domain.\n\n\n\n\n\nUnderstanding the group theory gives us insight into the computation:\nConvergence rate: For a viewport of size \\(V\\) and fundamental domain of size \\(F\\), we need at most \\(O(\\log(V/F))\\) reflections per coordinate axis. This is why small iteration limits (20-30) work well.\nParallelism: Each pixel’s orbit is independent—perfect for GPU parallelism. Millions of pixels computing orbits simultaneously with no communication needed.\nThreshold choice: The 0.0001 threshold for detecting convergence balances precision and performance. Smaller thresholds catch more subtle movements but risk floating-point noise; larger thresholds might terminate early but rarely matter for visualization.\nWhy it’s efficient: Most tiles are “nearby” in the group—they’re reached by short sequences of reflections. Only tiles far from the origin require many reflections, and these appear very small on screen (contributing few pixels).\nThis completes our Euclidean foundation. We now understand: 1. The folding algorithm in concrete examples 2. The half-space abstraction that makes it general 3. Why it works: reflection groups and fundamental domains 4. Computational properties: convergence, parallelism, efficiency\nNext, we’ll take this exact algorithmic structure into hyperbolic geometry!\n\n\n\n\n\n\n\n\nHyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant negative curvature. For over two millennia, mathematicians believed Euclidean geometry was the only logically consistent geometry—Euclid’s parallel postulate seemed necessary. The discovery of hyperbolic geometry in the early 19th century revolutionized mathematics.\n\n\nThe story of hyperbolic geometry is one of the great dramas in mathematical history. For centuries, mathematicians tried to prove Euclid’s fifth postulate (the parallel postulate) from the other four axioms. What if you could have multiple parallel lines through a point?\nThree mathematicians independently discovered that this “impossible” geometry was actually perfectly consistent:\nJános Bolyai (1802-1860), a Hungarian mathematician, developed hyperbolic geometry in the 1820s. His father, a mathematician himself, warned him: “For God’s sake, I beseech you, give it up. Fear it no less than sensual passions because it too may take all your time and deprive you of your health, peace of mind and happiness in life.” But János persisted, publishing his work in 1832 as an appendix to his father’s book.\nNikolai Lobachevsky (1792-1856), a Russian mathematician, published the first account of hyperbolic geometry in 1829. He called it “imaginary geometry” and faced considerable resistance from the mathematical establishment. His work was largely ignored during his lifetime.\nCarl Friedrich Gauss (1777-1855), the “Prince of Mathematicians,” had discovered hyperbolic geometry even earlier but never published it. In his private correspondence, he revealed he’d been working on non-Euclidean geometry since the 1790s but feared the “clamor of the Boeotians” (his term for mathematical philistines). When he read Bolyai’s work in 1832, he wrote that he could not praise it “because to praise it would be to praise myself”—he’d discovered the same results years earlier but kept them private.\nThe discovery had profound implications: geometry was not a single truth about space but a family of possible consistent systems. This philosophical shift influenced everything from Einstein’s general relativity (which uses non-Euclidean geometry for curved spacetime) to modern physics and mathematics.\n\n\n\nHyperbolic geometry appears throughout modern mathematics and physics:\n\nComplex analysis: The upper half-plane model is fundamental to the theory of modular forms, elliptic curves, and the Riemann mapping theorem\nNumber theory: The action of \\(SL(2,\\mathbb{Z})\\) on \\(\\mathbb{H}^2\\) produces modular forms—functions crucial to the proof of Fermat’s Last Theorem\nTopology: The study of 3-manifolds and knot theory often requires understanding hyperbolic structures\nTeichmüller theory: Moduli spaces of Riemann surfaces have natural hyperbolic metrics\nKleinian groups: Discrete subgroups of hyperbolic isometries produce fractal limit sets (like we saw with the Apollonian gasket!)\nGeneral relativity: Anti-de Sitter space has constant negative curvature—hyperbolic geometry in spacetime\nMachine learning: Recent work uses hyperbolic embeddings to represent hierarchical data efficiently\n\n\n\n\nWhat makes hyperbolic geometry different from Euclidean geometry?\nParallel lines: Given a line and a point not on it, there are infinitely many lines through the point that don’t intersect the given line (all parallel to it). This is the defining feature that distinguishes hyperbolic geometry.\nTriangle angles: The sum of angles in a triangle is less than \\(\\pi\\). In fact, the area of a hyperbolic triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) is exactly: \\[\\text{Area} = \\pi - (\\alpha + \\beta + \\gamma)\\] This is the Gauss-Bonnet theorem for hyperbolic triangles—a beautiful connection between geometry (angles) and topology (area).\nExponential growth: In Euclidean geometry, the circumference of a circle grows linearly with radius (\\(C = 2\\pi r\\)). In hyperbolic geometry, it grows exponentially: \\(C \\sim e^r\\) for large \\(r\\). This means hyperbolic space has “more room” than Euclidean space—there’s exponentially more area at distance \\(r\\) from a point.\nNo similarity: In Euclidean geometry, you can scale any shape—a small triangle and a large triangle with the same angles are similar. In hyperbolic geometry, there’s an absolute unit of length built into the curvature. All triangles with angles \\((\\pi/2, \\pi/3, \\pi/7)\\) are congruent—there’s no “scaled version.” This makes hyperbolic geometry richer but more rigid.\nThese properties create the “extra room” that allows much richer tiling structures than Euclidean geometry.\n\n\n\n\n\nWe’ll work in the upper half-plane model of hyperbolic geometry, denoted \\(\\mathbb{H}^2\\):\n\\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThis is just complex numbers with positive imaginary part—the upper half of the complex plane. The real axis \\(\\{y = 0\\}\\) forms the boundary “at infinity”—it’s not actually part of \\(\\mathbb{H}^2\\), but represents points infinitely far away in hyperbolic distance.\n\n\nThe hyperbolic metric is what makes \\(\\mathbb{H}^2\\) a hyperbolic space:\n\\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\nThis gives \\(\\mathbb{H}^2\\) the structure of a complete Riemannian manifold with constant curvature \\(-1\\).\nWhat does this mean? The factor \\(1/y^2\\) is a conformal factor that scales the Euclidean metric. As \\(y \\to 0\\) (approaching the boundary), this scaling factor blows up—distances that look small Euclidean-wise are enormous hyperbolically. As \\(y \\to \\infty\\) (going “up” in the upper half-plane), the scaling factor goes to zero—large Euclidean distances are actually finite hyperbolically.\nThe metric is conformal to the Euclidean metric—it preserves angles but not lengths. If two curves meet at angle \\(\\theta\\) in the Euclidean sense, they also meet at angle \\(\\theta\\) in the hyperbolic sense! This is why you can trust your eyes when looking at pictures—angles are what they appear to be.\n\n\n\nIntegrating the metric along paths gives the hyperbolic distance between two points \\(z_1 = x_1 + iy_1\\) and \\(z_2 = x_2 + iy_2\\):\n\\[d_{\\mathbb{H}^2}(z_1, z_2) = \\text{arcosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2y_1 y_2}\\right)\\]\nwhere \\(|z_1 - z_2| = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\\) is the usual Euclidean distance.\nNotice the \\(1/y_1 y_2\\) factor—points near the boundary (\\(y\\) small) are very far apart hyperbolically even if they’re close Euclidean-wise.\nDerivation sketch: For a vertical line from \\(z_1 = x + iy_1\\) to \\(z_2 = x + iy_2\\), the hyperbolic length is: \\[\\int_{y_1}^{y_2} \\frac{dy}{y} = \\log(y_2) - \\log(y_1) = \\log(y_2/y_1)\\]\nFor a general path, you need to integrate along the geodesic connecting the points (which might not be a straight Euclidean line), giving the arcosh formula above.\n\n\n\nLet’s make this concrete with an interactive shader. We’ll start with Euclidean distance, then switch to hyperbolic to see the difference.\nEuclidean distance circles:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);  // Shift up so we're in y &gt; 0\n    \n    // Mouse position as center (or default)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);  // Default if no click\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Euclidean distance\n    float dist = length(p - center);\n    \n    // Draw a disk of radius 0.5 using two circles\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer circle (slightly larger)\n    if(dist &lt; radius + 0.02) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner circle (slightly smaller) - \"cuts out\" interior\n    if(dist &lt; radius - 0.02) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center point\n    if(length(p - center) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nClick and drag around—the circle stays the same size everywhere. This is Euclidean distance: uniform across the plane. Notice how we draw the boundary: we draw a filled circle at radius \\(r + \\epsilon\\) (outer edge), then draw another filled circle at radius \\(r - \\epsilon\\) (inner edge) in a different color. The ring between them is our boundary!\nHyperbolic distance circles:\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // arccosh(arg)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Mouse position as center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Hyperbolic distance\n    float dist = hyperbolicDistance(p, center);\n    \n    // Draw a hyperbolic disk using two \"circles\"\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer boundary\n    if(dist &lt; radius + 0.05) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner region\n    if(dist &lt; radius - 0.05) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center\n    if(hyperbolicDistance(p, center) &lt; 0.1) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow drag the center around! Notice how the “circle” changes shape as you move it. Near the bottom (\\(y \\to 0\\)), the circle appears huge Euclidean-wise—that’s because we’re near the boundary where hyperbolic distances blow up. Higher up (\\(y\\) large), the circle appears smaller.\nThis visualization makes the \\(1/y^2\\) conformal factor visceral: hyperbolic space is compressed near the boundary.\n\n\n\n\n\nThe real axis \\(\\{y = 0\\}\\) is not part of \\(\\mathbb{H}^2\\), but we can think of it as the boundary at infinity—points infinitely far away in hyperbolic distance.\nIdeal points as equivalence classes: An ideal point on the boundary can be defined as an equivalence class of geodesics that asymptotically approach each other. Two geodesics are equivalent if the hyperbolic distance between them goes to zero as you go to infinity along them.\nFor example, the vertical line \\(\\{x = 0\\}\\) and the vertical line \\(\\{x = \\epsilon\\}\\) (for small \\(\\epsilon\\)) both approach the point \\(0\\) on the real axis. As you go up (\\(y \\to \\infty\\)), the hyperbolic distance between corresponding points goes to zero—they’re asymptotically parallel.\nGeometric intuition: In the Poincaré disk model (which we’ll see soon), the boundary at infinity is literally the unit circle \\(|z| = 1\\). Points on this circle are infinitely far away from any interior point, but they still have geometric meaning—they represent directions or “points at infinity.”\nWhy this matters: When we define hyperbolic triangles, we can have vertices “at infinity” on the boundary. These are called ideal vertices or ideal triangles. For instance, our \\((2,3,\\infty)\\) triangle has one vertex at the point \\(\\infty\\) in the upper half-plane (straight up the imaginary axis). The angle at an ideal vertex is zero—the sides become asymptotically parallel as they approach the boundary.\nThe Gauss-Bonnet theorem still works: for a triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), the area is \\(\\pi - (\\alpha + \\beta + \\gamma)\\). If one angle is zero (ideal vertex), the area is \\(\\pi - \\alpha - \\beta &gt; 0\\)—ideal triangles have finite area!\n\n\n\n\n\n\nGeodesics (the “straight lines” of hyperbolic geometry—curves that locally minimize distance) in \\(\\mathbb{H}^2\\) have exactly two forms:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c \\in \\mathbb{R}\\)\nSemicircles: Centered on the real axis, perpendicular to it\n\nThese curves meet the boundary at right angles—this is the characterizing property of geodesics in this model.\nWhy these are geodesics: Reflections across these curves are isometries (they preserve the hyperbolic metric \\(ds^2 = \\frac{dx^2+dy^2}{y^2}\\)). An isometry’s fixed point set is always a geodesic! So we just need to verify that reflection across vertical lines and semicircles preserves the metric.\nFor vertical lines, this is obvious: reflecting across \\(x = c\\) sends \\((x,y) \\mapsto (2c-x, y)\\), which preserves both the Euclidean distance \\(dx^2 + dy^2\\) and the \\(y\\)-coordinate, hence preserves \\(\\frac{dx^2+dy^2}{y^2}\\).\nFor semicircles, we use circle inversion from Day 2! A semicircle centered at \\((c, 0)\\) with radius \\(R\\) is preserved by the inversion: \\[z \\mapsto c + R^2 \\frac{z - c}{|z - c|^2}\\]\nCircle inversion is conformal (preserves angles) and scales distances by exactly \\(1/y^2\\) near the boundary—precisely the conformal factor in the hyperbolic metric! So inversions through semicircles are hyperbolic isometries. Their fixed point sets (the semicircles themselves) are therefore geodesics.\n\n\n\n\n\n\nImportantConnection to Day 2: Circle Inversion is a Hyperbolic Isometry!\n\n\n\nThis is a profound connection: the circle inversions we used on Day 2 for the Apollonian gasket were actually hyperbolic isometries all along! The Apollonian gasket lives in hyperbolic space—the gaps between circles are hyperbolic regions, and the inversions are reflections across hyperbolic geodesics (semicircles).\nWhen we iterated inversions on Day 2, we were doing exactly what we’re doing today—finding the fundamental domain of a group action! The Apollonian gasket is a hyperbolic object, just like our triangle tilings. The same group-theoretic principles apply.\nThis is why the techniques work across days: we’re always working with group actions, whether we realize it or not. The mathematics unifies everything.\n\n\n\n\n\nFor vertical lines (like \\(x = c\\)), reflection is simple—flip the \\(x\\)-coordinate:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    // Check if we're on the correct side\n    if((z.x - x_pos) * side &lt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Reflect: (x,y) ↦ (2c - x, y)\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\nFor semicircles (geodesics from point \\(p\\) to point \\(q\\) on the real axis), we use circle inversion. The semicircle has center \\((c, 0)\\) where \\(c = (p+q)/2\\) and radius \\(R = |p-q|/2\\):\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    \n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);  // Squared distance from center\n    \n    // Check if we're on the correct side\n    if((dist2 - radius * radius) * side &gt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Circle inversion (from Day 2!)\n    vec2 inverted = vec2(center, 0.0) + (radius * radius) * rel / dist2;\n    return inverted;\n}\nNote: We’re inverting through a circle in the Euclidean sense (using Euclidean distance dist2), but this operation is actually a hyperbolic isometry! The magic is that circle inversion’s conformal properties exactly match the hyperbolic metric’s requirements.\n\n\n\n\n\n\nNoteWhy Two Types of Reflections?\n\n\n\nIn Euclidean geometry, all reflections across lines look the same—just the orientation changes. Why do we need two different functions in hyperbolic geometry?\nThe answer is that we’re working in a model of hyperbolic geometry (the upper half-plane). The vertical lines and semicircles are the images of geodesics in this model. In the intrinsic hyperbolic geometry, all reflections across geodesics are the same—there’s only one type of reflection.\nBut when we represent hyperbolic geometry in the Euclidean upper half-plane, geodesics appear as two different types of curves (vertical lines and semicircles), so we need two different formulas. This is an artifact of the model, not the geometry itself.\nIn the Poincaré disk model (coming soon), ALL geodesics are circular arcs perpendicular to the boundary circle, so we’d only need one reflection function there!\n\n\n\n\n\n\n\nLet’s build our first hyperbolic triangle tiling. The notation \\((p, q, r)\\) means the triangle has angles \\(\\pi/p\\), \\(\\pi/q\\), and \\(\\pi/r\\) at its three vertices. So \\((2,3,\\infty)\\) means angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an ideal vertex at infinity).\nWhy this triangle exists in hyperbolic geometry: The Gauss-Bonnet theorem tells us the area of a hyperbolic triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) is: \\[\\text{Area} = \\pi - (\\alpha + \\beta + \\gamma)\\]\nFor a \\((2,3,\\infty)\\) triangle: \\[\\text{Area} = \\pi - \\left(\\frac{\\pi}{2} + \\frac{\\pi}{3} + 0\\right) = \\pi - \\frac{5\\pi}{6} = \\frac{\\pi}{6} &gt; 0\\]\nSo this triangle has finite positive area and can tile the hyperbolic plane. In Euclidean geometry, \\(\\pi/2 + \\pi/3 = 5\\pi/6 &lt; \\pi\\), but that’s not enough—we’d need the sum to equal exactly \\(\\pi\\) to get zero curvature. Since \\(5\\pi/6 &lt; \\pi\\), there’s negative curvature left over, making this a hyperbolic triangle.\nConfiguration: We’ll use a particularly nice setup in the upper half-plane: - Left boundary: Vertical line at \\(x = -1\\) - Right boundary: Vertical line at \\(x = 1\\)\n- Bottom boundary: Unit semicircle from \\(-1\\) to \\(1\\) (centered at origin, radius \\(1\\))\nThis creates a triangle with: - Two finite vertices at approximately \\((-1, 0)\\) and \\((1, 0)\\) (technically infinitesimally above the real axis) - One ideal vertex at \\(\\infty\\) (straight up the imaginary axis) - Angles of \\(\\pi/2\\) at the bottom two vertices (vertical line meets semicircle at right angles) - Angle of \\(\\pi/3\\) between the two vertical lines when measured hyperbolically - Angle of \\(0\\) at the ideal vertex \\(\\infty\\)\n\n\nHere’s the complete shader:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis \\(y = 0\\))—they’re all the same hyperbolic size, but Euclidean distances compress due to the \\(1/y^2\\) metric.\nThe alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.\n\n\n\n\n\n\nNoteCompare to Euclidean\n\n\n\nLook at the structure of this shader compared to the Euclidean triangle tiling:\nEuclidean:\np = reflectInto(p, hs1);\np = reflectInto(p, hs2);\np = reflectInto(p, hs3);\nHyperbolic:\nz = reflectIntoVertical(z, -1.0, -1.0);\nz = reflectIntoVertical(z, 1.0, 1.0);\nz = reflectIntoCircular(z, -1.0, 1.0, 1.0);\nThe algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.\n\n\n\n\n\n\n\n\nTipComputational Analysis\n\n\n\nGPU Parallelism: Just like Days 1 and 2, this algorithm is embarrassingly parallel. Each pixel computes independently—no communication, no shared state, perfect for GPU architecture.\nConvergence: The folding algorithm works for the same group-theoretic reasons as the Euclidean case. The three reflections generate a discrete group of hyperbolic isometries, and our fundamental triangle is a fundamental domain for this group’s action on \\(\\mathbb{H}^2\\).\nPrecision issues: Near \\(y \\to 0\\), floating-point precision degrades. The large conformal factor \\(1/y^2\\) amplifies small errors in distance calculations. This is why we darken the region \\(y &lt; 0\\)—technically it’s not part of the hyperbolic plane, but also our numerics become unreliable there.\nThreshold \\(0.0001\\): This convergence threshold balances precision and performance. Smaller thresholds catch more subtle movements but risk getting stuck in floating-point noise; larger thresholds might terminate early. For visualization purposes, \\(0.0001\\) is a good sweet spot.\nMemory efficiency: Each pixel only needs to store its current position z (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures—just stateless iteration. This is as memory-efficient as you can get!\n\n\n\n\n\n\n\n\nTipExercise: Visualizing Hyperbolic Triangle Structure\n\n\n\nWant to see the edges and vertices of your hyperbolic triangles? This requires computing hyperbolic distances.\nFor hyperbolic distance:\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\nFor drawing edges (vertical lines):\n// Distance to vertical line x = c\nfloat distToVertical = abs(z.x - c);\nif(distToVertical &lt; 0.02) color = vec3(1.0);\nFor drawing edges (semicircular geodesics):\n// Distance to semicircle from p to q\nfloat center = (p + q) / 2.0;\nfloat radius = abs(p - q) / 2.0;\nfloat distToCircle = abs(length(z - vec2(center, 0.0)) - radius);\n// Only draw if above real axis\nif(z.y &gt; 0.0 && distToCircle &lt; 0.02) color = vec3(1.0);\nFor vertices:\n// Check hyperbolic distance to vertices after folding\nvec2 v1 = vec2(-1.0, 0.01);  // Left vertex (slightly above axis)\nvec2 v2 = vec2(1.0, 0.01);   // Right vertex\nif(hyperbolicDistance(z, v1) &lt; 0.1 || hyperbolicDistance(z, v2) &lt; 0.1) {\n    color = vec3(1.0, 0.0, 0.0);  // Red vertices\n}\nSee Appendix H5 for the complete enhanced implementation!\n\n\n\n\n\n\n\nThe upper half-plane is just one way to represent hyperbolic geometry. There are several other models, each with advantages:\n\n\nThe Poincaré disk model represents all of \\(\\mathbb{H}^2\\) as the interior of the unit disk \\(\\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\). The boundary circle \\(|z| = 1\\) represents points at infinity.\nGeodesics in this model are: - Diameters of the disk (straight lines through the origin) - Circular arcs perpendicular to the boundary circle\nThe conformal factor here is \\(\\frac{4}{(1-|z|^2)^2}\\), which blows up as \\(|z| \\to 1\\) (approaching the boundary).\nAdvantages: - The entire hyperbolic plane fits in a bounded region (the disk) - All geodesics look similar (circular arcs)—no distinction between vertical and circular - Visually intuitive for understanding the full structure at once\nDisadvantages: - Harder to compute distances - More complex reflection formulas\n\n\n\nWe can convert between the upper half-plane and Poincaré disk using the Cayley transform (also called the Möbius transformation):\n\\[w = \\frac{z - i}{z + i}\\]\nThis maps: - Upper half-plane \\(\\{z : \\operatorname{Im}(z) &gt; 0\\}\\) → Poincaré disk \\(\\{w : |w| &lt; 1\\}\\) - Real axis \\(\\{z : \\operatorname{Im}(z) = 0\\}\\) → Unit circle \\(\\{w : |w| = 1\\}\\) - Point \\(i\\) in the upper half-plane → origin \\(0\\) in the disk\nThe inverse transform is: \\[z = i\\frac{1 + w}{1 - w}\\]\nHere’s the implementation:\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 uhpToDisk(vec2 z) {\n    // w = (z - i) / (z + i)\n    vec2 i = vec2(0.0, 1.0);\n    return cdiv(z - i, z + i);\n}\n\nvec2 diskToUhp(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\nTo display your tiling in the Poincaré disk:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;  // Fit disk in viewport\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 z = diskToUhp(uv);\n    \n    // Run your tiling algorithm in UHP\n    // ... (fold into (2,3,∞) triangle as before)\n    \n    // Color and render\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nThe Klein model (also called the Beltrami-Klein model or projective disk model) is another disk representation. Its defining feature: geodesics are Euclidean straight lines! This makes some geometric properties clearer but sacrifices the conformal property—angles are distorted.\nConverting from Poincaré disk to Klein disk:\n\\[\\text{Klein}(w) = \\frac{2w}{1 + |w|^2}\\]\nvec2 poincareToKlein(vec2 w) {\n    float denom = 1.0 + dot(w, w);\n    return 2.0 * w / denom;\n}\nThe inverse:\n\\[w = \\frac{\\text{Klein}(w)}{1 + \\sqrt{1 - |\\text{Klein}(w)|^2}}\\]\nvec2 kleinToPoincare(vec2 k) {\n    float k2 = dot(k, k);\n    float denom = 1.0 + sqrt(1.0 - k2);\n    return k / denom;\n}\nAdvantages of Klein: - Geodesics are straight lines (simplest to compute) - Great for understanding incidence relationships\nDisadvantages: - Not conformal—angles are distorted - Harder to see hyperbolic distances\n\n\n\n\n\nThe \\((2,3,\\infty)\\) triangle is just the beginning. Many other hyperbolic triangles can tile the plane! The most famous is the \\((2,3,7)\\) triangle.\n\n\nThis triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(\\pi/7\\). Its area is: \\[\\text{Area} = \\pi - \\left(\\frac{\\pi}{2} + \\frac{\\pi}{3} + \\frac{\\pi}{7}\\right) = \\frac{\\pi}{42}\\]\nThis is one of the smallest compact hyperbolic triangles! It produces incredibly dense tilings—the \\((2,3,7)\\) tiling has a 7-fold symmetry that creates intricate patterns reminiscent of M.C. Escher’s work.\nIn fact, Escher’s famous Circle Limit prints (especially Circle Limit III with the fish) are based on tilings by \\((2,3,7)\\) and related triangle groups. The hyperbolic geometry creates the exponential compression toward the boundary that gives these prints their distinctive character.\nClassification of hyperbolic triangles: Not every combination \\((p,q,r)\\) gives a hyperbolic triangle. The Gauss-Bonnet formula tells us we need: \\[\\frac{1}{p} + \\frac{1}{q} + \\frac{1}{r} &lt; 1\\]\nfor a hyperbolic triangle (negative curvature). If the sum equals exactly \\(1\\), we get a Euclidean triangle. If the sum is greater than \\(1\\), we get a spherical triangle (positive curvature).\nExamples: - \\((2,3,7)\\): \\(\\frac{1}{2} + \\frac{1}{3} + \\frac{1}{7} = \\frac{41}{42} &lt; 1\\) ✓ Hyperbolic - \\((2,3,\\infty)\\): \\(\\frac{1}{2} + \\frac{1}{3} + 0 = \\frac{5}{6} &lt; 1\\) ✓ Hyperbolic - \\((3,3,3)\\): \\(\\frac{1}{3} + \\frac{1}{3} + \\frac{1}{3} = 1\\) ✓ Euclidean (equilateral triangle) - \\((2,3,5)\\): \\(\\frac{1}{2} + \\frac{1}{3} + \\frac{1}{5} = \\frac{31}{30} &gt; 1\\) ✓ Spherical (icosahedron face)\nImplementing other triangle groups requires computing where the third geodesic should be, given the angle constraints. This is non-trivial and involves hyperbolic trigonometry—we leave this as an advanced homework exercise!\n\n\n\n\n\n\nToday we learned:\n\nThe folding algorithm: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry\nHalf-space structure: Boundary + side gives a unified way to encode regions in Euclidean geometry\nWhy it works: Reflection groups and fundamental domains—the group-theoretic perspective that unifies all our iterative algorithms across Days 2 and 3\nHyperbolic geometry: Negative curvature space with two types of geodesics (vertical lines and semicircles in the UHP model)\nConnection to Day 2: Circle inversion is a hyperbolic isometry! The Apollonian gasket is actually a hyperbolic object\nTwo reflection functions: reflectIntoVertical and reflectIntoCircular parallel the Euclidean reflectInto\nMultiple models: Converting between upper half-plane and Poincaré disk using the Cayley transform\nHistorical context: The dramatic discovery of hyperbolic geometry by Gauss, Bolyai, and Lobachevsky in the 19th century\nComputational perspective: GPU parallelism, convergence rates, precision issues, iteration count tuning\n\nKey insight: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!\nThe universal pattern: - Day 1: Distance fields and implicit curves—visualizing mathematics on the GPU - Day 2: Iterating circle inversions to create the Apollonian gasket—first group action - Day 3 (Euclidean): Iterating reflections to create tilings—reflection groups make it work - Day 3 (Hyperbolic): Same algorithm, different geometry—circle inversion reappears as hyperbolic isometry!\nThe through-line is geometric transformations and their groups. When we iterate a group action to reach a fundamental domain, we create tilings, fractals, and beautiful mathematical art.\n\n\n\n\n\n\nGoal: Build geometric intuition for how hyperbolic distance works before implementing tilings.\nTasks:\n\nEuclidean distance visualization: Implement the shader showing Euclidean distance circles (provided in lecture). Drag the center around and observe that circles stay the same size everywhere.\nHyperbolic distance visualization: Implement the hyperbolic version (provided in lecture). Drag the center and observe how the “circle” changes shape—growing huge near \\(y \\to 0\\) and shrinking as \\(y\\) increases.\nObservations: Write 2-3 sentences describing what you observe about how hyperbolic “circles” behave compared to Euclidean ones. Why does the shape change as you drag the center?\n\nExpected output: Two working shaders demonstrating the difference between Euclidean and hyperbolic distance.\n\n\n\n\nGoal: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.\nTasks:\n\nStart with the basic triangle tiling from lecture\nAdd edge visualization using distance to half-spaces\nAdd vertex markers at the three triangle vertices\nCreate an attractive color scheme\n\nExpected output: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.\nSee Appendix E9 for reference implementation.\nBonus: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.\n\n\n\n\nGoal: Create a beautiful hyperbolic triangle tiling with visible structure.\nTasks:\n\nStart with the basic \\((2,3,\\infty)\\) tiling from lecture\nImplement hyperbolic distance functions (see hints in lecture)\nDraw geodesic edges using hyperbolic distance to geodesics\nDraw vertices using hyperbolic distance to vertex points\nCreate an attractive color scheme\n\nExpected output: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.\nSee Appendix H5 for complete reference implementation.\nBonus: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.\n\n\n\n\nGoal: See the same tiling in different representations of hyperbolic space.\nTasks:\n\nPoincaré Disk (already provided in lecture): Verify it works with your tiling code\nKlein Model: Implement the transformation from Poincaré disk to Klein disk (see lecture for formula)\nIn the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.\nComparison: Show your \\((2,3,\\infty)\\) tiling in both the Poincaré disk and Klein model side-by-side. Write a few sentences about what you observe.\n\nDeliverable: Screenshots of your tiling in at least two models, with brief observations.\nSee Appendix H7 for Klein model reference.\n\n\n\n\nGoal: Explore other hyperbolic tilings by implementing different triangle groups.\nThe Challenge: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.\nSuggested triangles to try: - (2, 3, 7): Creates Escher-like tilings with 7-fold symmetry - (2, 4, 6): Different symmetry pattern - (3, 3, 3): Equilateral hyperbolic triangle\nApproach: Use the hyperbolic law of cosines (see lecture for formula) to compute geodesic positions.\nDeliverable: Working tiling for at least one triangle group other than \\((2,3,\\infty)\\). Include screenshots and document your approach.\n\n\n\n\nOptional #1: Unified Abstractions - Create structs that work for both Euclidean and hyperbolic geometry\nOptional #2: Decorated Tiles - Add Escher-style patterns within fundamental domains\nOptional #3: Pentagon Tilings - Right-angled pentagons can tile hyperbolic space!\nSee lecture for details on these optional exercises.\n\n\n\n\n\nWe’ve now seen three days of geometric iteration: - Day 1: Distance fields and implicit functions - Day 2: Circle inversion and the Apollonian gasket - Day 3: Reflection groups in Euclidean and hyperbolic geometry\nThe common thread: group actions on geometric spaces. Iteratively applying transformations to reach a desired region, whether it’s the fundamental domain of a tiling or the gap structure of a fractal.\nThe techniques you’ve learned—GPU parallelism, iterative algorithms, group theory, geometric transformations—apply across a huge landscape of mathematical visualization!"
  },
  {
    "objectID": "OLD/lectures/day3.html#overview",
    "href": "OLD/lectures/day3.html#overview",
    "title": "1 Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "Today we explore geometric tilings through reflection operations. We’ll start by building a general framework for reflections in Euclidean space, then venture into hyperbolic geometry where the same algorithmic approach produces dramatically different patterns.\nThe key insight: the algorithm stays the same across geometries—only the reflection operations change. This mirrors what we saw on Day 2 with the Apollonian gasket: iteratively apply a geometric transformation until we reach a desired region. But today we’ll understand why this works through the lens of group theory.\nBy the end of today, you’ll understand: - How to construct reflections using linear algebra - Why the folding algorithm works (reflection groups and fundamental domains) - The structure of hyperbolic geometry in the upper half-plane model - How to implement hyperbolic triangle tilings using the same algorithmic pattern - How to convert between different models of hyperbolic space - The connection between circle inversion (Day 2) and hyperbolic isometries\n\n\n\n\n\n\nNoteRoadmap for Today\n\n\n\nPart 1: Euclidean Geometry - Simple tilings (strip, square) - Half-space abstraction - Triangle tilings - Why this works: Reflection groups\nPart 2: Hyperbolic Geometry - The upper half-plane model and metric - Geodesics and reflections (connection to Day 2!) - Triangle tilings in \\(\\mathbb{H}^2\\) - Multiple models (Poincaré disk, Klein) - Historical context and applications\nThe unifying theme is geometric transformations and their groups—the same mathematical structure underlies fractals, tilings, and symmetry across all geometries."
  },
  {
    "objectID": "OLD/lectures/day3.html#part-1-reflection-and-tilings-in-euclidean-geometry",
    "href": "OLD/lectures/day3.html#part-1-reflection-and-tilings-in-euclidean-geometry",
    "title": "1 Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "Before we dive into general theory, let’s build intuition with the simplest possible example: creating a repeating strip pattern.\n\n\nImagine we want to tile the plane horizontally. We’ll define a fundamental domain—the strip \\(0 &lt; x &lt; 1\\)—and reflect any point outside this strip back inside.\nThe algorithm is remarkably simple: - If \\(x &lt; 0\\), reflect across \\(x = 0\\) - If \\(x &gt; 1\\), reflect across \\(x = 1\\)\n- Repeat until the point stops moving\nFor a vertical line at \\(x = c\\), reflection just flips the \\(x\\)-coordinate: \\((x, y) \\mapsto (2c - x, y)\\).\nHere’s a complete shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the yellow circle repeat infinitely across the screen! We only drew it once, but the folding algorithm tiles it everywhere.\nWhat’s happening geometrically? Every point on the screen gets mapped back to the fundamental domain \\([0,1]\\). Points that were in reflected copies of the domain get folded back through a sequence of reflections. Since we draw the same pattern in the fundamental domain, all the reflected copies show the same pattern.\n\n\n\n\nLet’s extend to two dimensions. Now we have four boundaries: \\(x = 0\\), \\(x = 1\\), \\(y = 0\\), and \\(y = 1\\). Same algorithm, just more boundaries to check:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);\n    \n    // Circle at center\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nPerfect! A full 2D tiling.\n\n\n\n\nLet’s track how many reflections were needed. This helps us understand the geometry and creates beautiful visualizations:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! The color gradient shows how many reflections were needed—points near the fundamental domain require few iterations, while points far away need many.\nNotice the convergence check: we save the old position and check if the point stopped moving. When no boundary causes a reflection, the point has reached the fundamental domain and we can stop.\n\n\n\n\n\n\nTipComputational Efficiency: Iteration Count\n\n\n\nWhy does this converge so quickly? Each reflection moves the point strictly closer to the fundamental domain (in the sense of reducing the number of boundary crossings). For a viewport of size \\(4 \\times 4\\) and fundamental domain of size \\(1 \\times 1\\), we need at most \\(\\lceil \\log_2(4) \\rceil = 2\\) reflections per axis, so 4 reflections total in the worst case.\nThe 20-iteration limit is very conservative—most pixels converge in under 5 iterations. We could dynamically adjust this based on the coordinate scale, but for real-time rendering, a fixed conservative bound works well.\n\n\n\n\n\n\n\nLooking at our square tiling code, we see repetition: check a boundary, reflect if outside, repeat. Let’s abstract this pattern so we can handle arbitrary shapes.\n\n\nA half-space is one side of a line. Any line \\(ax + by = c\\) divides the plane into two regions: - Points where \\(ax + by &lt; c\\) - Points where \\(ax + by &gt; c\\)\nWe’ll encode a half-space by storing the line parameters and which side we want:\nstruct HalfSpace {\n    float a, b, c;  // Line parameters: ax + by = c\n    float side;     // +1 or -1 for which side\n};\nThe side parameter determines which inequality we want: - side = -1.0 means we want \\(ax + by &gt; c\\) (equivalently, \\((ax + by - c) \\cdot (-1) &lt; 0\\)) - side = 1.0 means we want \\(ax + by &lt; c\\) (equivalently, \\((ax + by - c) \\cdot (1) &lt; 0\\))\nThis might seem redundant—we could always use \\(ax + by &lt; c\\) and just flip the signs of \\(a, b, c\\) to get the other side. But having an explicit side parameter makes the code clearer and will be essential in hyperbolic geometry where sign-flipping doesn’t work as cleanly.\n\n\n\nBefore we implement reflections, let’s visualize what a half-space is. Here’s a shader that colors one side of a line:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1 (left side of vertical line at x=1)\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the left side of the line colored blue, the right side dark. Try changing the half-space parameters to see how it affects the coloring!\n\n\n\n\n\n\nTipExercise: Drawing the Boundary Line\n\n\n\nWant to see where the line is? Add this distance function:\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\nThen draw the line:\nfloat d = distToHalfSpace(p, hs);\nif(d &lt; 0.02) color = vec3(1.0);  // White boundary\nThis computes the perpendicular distance from the point to the line, then colors points near the line white. See Appendix E4b for the complete implementation!\n\n\n\n\n\nNow let’s intersect four half-spaces to create a square region. We’ll use additive coloring—each half-space we’re inside adds to the color, so the interior (inside all four) will be brightest:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Additive coloring - each half-space adds brightness\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, left))   color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, right))  color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, bottom)) color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, top))    color += vec3(0.1, 0.15, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see the square region brightest (inside all four half-spaces), with regions inside fewer half-spaces progressively darker. This additive approach makes it easy to see how the regions overlap!\n\n\n\n\n\n\nTipExercise: Improved Visualization\n\n\n\nFor a cleaner look, you might want to:\n\nBinary coloring (inside domain or not):\n\nbool in_square = inside(p, left) && inside(p, right) && \n                 inside(p, bottom) && inside(p, top);\nvec3 color = in_square ? vec3(0.4, 0.6, 0.8) : vec3(0.1, 0.1, 0.2);\n\nDraw boundaries using the distance function from earlier\nCreate an insideDomain() function:\n\nbool insideDomain(vec2 p, HalfSpace hs1, HalfSpace hs2, \n                  HalfSpace hs3, HalfSpace hs4) {\n    return inside(p, hs1) && inside(p, hs2) && \n           inside(p, hs3) && inside(p, hs4);\n}\nSee Appendix E5b for complete enhanced versions!\n\n\n\n\n\nLet’s visualize three half-spaces defining a triangle:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, hs1)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs2)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs3)) color += vec3(0.15, 0.2, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a triangle region where all three half-spaces overlap! The additive coloring helps visualize the structure.\n\n\n\n\nNow we’re ready to implement reflection. To reflect a point \\(\\mathbf{p} = (x, y)\\) across the line \\(ax + by = c\\), we use linear algebra. The normal vector to the line is \\(\\mathbf{n} = (a, b)\\). After normalizing to \\(\\hat{\\mathbf{n}} = \\mathbf{n}/|\\mathbf{n}|\\), the reflection formula is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere \\(d\\) is the signed distance from \\(\\mathbf{p}\\) to the line:\n\\[d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\]\nThis is a standard result from linear algebra! The signed distance tells us how far we are from the line (positive on one side, negative on the other), and we move twice that distance in the normal direction to get the reflection.\nOur reflectInto function checks if we’re on the correct side and only reflects if necessary—it extends our inside() test by conditionally reflecting:\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    // Compute which side of the line we're on\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    // Check if we're already on the correct side (this is our inside() test!)\n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;  // Already inside, nothing to do\n    }\n    \n    // We're on the wrong side - reflect across the boundary line\n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\nThis function encapsulates the entire pattern: check if we’re on the correct side (the inside() test), and only reflect if we’re not. So reflectInto() extends and renames our visualization function to also perform the reflection!\n\n\n\n\n\nLet’s rewrite our square tiling using this abstraction. For the square \\([0, 1] \\times [0, 1]\\), we need four half-spaces:\n\nLeft edge (\\(x = 0\\)): We want \\(x &gt; 0\\) → HalfSpace(1.0, 0.0, 0.0, -1.0)\nRight edge (\\(x = 1\\)): We want \\(x &lt; 1\\) → HalfSpace(1.0, 0.0, 1.0, 1.0)\nBottom and top: Similarly for \\(y\\)\n\nComplete shader:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1]×[0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);\n    \n    // Fold into the square\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, left);\n        p = reflectInto(p, right);\n        p = reflectInto(p, bottom);\n        p = reflectInto(p, top);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis looks identical to our earlier version, but now our code is flexible. The beauty: changing from a square to a triangle only requires changing the half-space definitions!\n\n\n\n\nNow we’re ready for triangles. We’ll use an equilateral triangle with vertices at:\n\\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nThis triangle is centered at the origin with one vertex pointing up.\n\n\nFor each edge, we need to compute the line parameters \\((a, b, c)\\) and determine the correct side. The process:\n\nTake two vertices defining an edge: \\(\\mathbf{v}_i\\) and \\(\\mathbf{v}_j\\)\nCompute edge direction: \\(\\mathbf{d} = \\mathbf{v}_j - \\mathbf{v}_i\\)\nCompute perpendicular (rotate 90° counterclockwise): \\(\\mathbf{n} = (-d_y, d_x)\\)\nLine equation: \\(n_x \\cdot x + n_y \\cdot y = c\\) where \\(c = \\mathbf{n} \\cdot \\mathbf{v}_i\\)\nTest origin: if \\((n_x \\cdot 0 + n_y \\cdot 0 - c) &lt; 0\\), then side = -1.0, else side = 1.0\n\n\n\n\n\n\n\nNoteDerivation of Triangle Half-Space Parameters\n\n\n\n\n\nEdge from \\(v_0 = (0, 1)\\) to \\(v_1 = (-\\sqrt{3}/2, -1/2)\\):\n\nEdge direction: \\(\\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\\)\nPerpendicular (90° CCW): \\(\\mathbf{n} = (1.5, -0.866)\\)\nLine: \\(1.5x - 0.866y = c\\) where \\(c = \\mathbf{n} \\cdot v_0 = (1.5)(0) + (-0.866)(1) = -0.866\\)\nFor origin (inside): \\(1.5(0) - 0.866(0) - (-0.866) = 0.866 &gt; 0\\)\nWe want inside when \\((ax + by - c) &lt; 0\\), so we need side = -1.0\n\nResult: HalfSpace(1.5, -0.866, -0.866, -1.0)\nSimilar calculations give: - Edge \\(v_1\\) to \\(v_2\\): HalfSpace(0.0, 1.732, -0.866, -1.0) - Edge \\(v_2\\) to \\(v_0\\): HalfSpace(-1.5, -0.866, -0.866, -1.0)\n\n\n\nThe computed parameters are:\n\nEdge \\(v_0\\) to \\(v_1\\): HalfSpace(1.5, -0.866, -0.866, -1.0)\nEdge \\(v_1\\) to \\(v_2\\): HalfSpace(0.0, 1.732, -0.866, -1.0)\n\nEdge \\(v_2\\) to \\(v_0\\): HalfSpace(-1.5, -0.866, -0.866, -1.0)\n\nWe already verified these work with our visualization shader above!\n\n\n\nNow we can implement the tiling by copying our reflection shader and just changing the half-spaces:\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into the triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nBeautiful! You should see an infinite triangle tiling. The alternating colors show which triangles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.\n\n\n\n\n\n\nTipExercise: Visualizing Triangle Structure\n\n\n\nWant to see the edges and vertices of your triangles? This requires computing distances to half-spaces and vertices.\nFor edges (drawing the boundaries):\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\n// In main rendering:\nfloat d1 = distToHalfSpace(p, hs1);\nfloat d2 = distToHalfSpace(p, hs2);\nfloat d3 = distToHalfSpace(p, hs3);\nfloat border = min(d1, min(d2, d3));\n\nif(border &lt; 0.02) color = vec3(1.0);  // White edges\nFor vertices (marking the corners):\n// Define vertices\nvec2 v0 = vec2(0.0, 1.0);\nvec2 v1 = vec2(-0.866, -0.5);\nvec2 v2 = vec2(0.866, -0.5);\n\n// Check distance after folding\nfloat dv0 = length(p - v0);\nfloat dv1 = length(p - v1);\nfloat dv2 = length(p - v2);\nfloat vertex_dist = min(dv0, min(dv1, dv2));\n\nif(vertex_dist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);  // Red vertices\nSee Appendix E9 for the complete enhanced version!\n\n\n\n\n\n\n\nWe’ve implemented the folding algorithm, but why does it work? Why does iteratively reflecting guarantee we reach the fundamental domain? The answer lies in group theory.\n\n\nEach reflection \\(r_i\\) across a half-space boundary is an isometry of the Euclidean plane—it preserves distances and angles. Composing reflections gives us more isometries. The set of all compositions of our reflections forms a group under composition:\n\nIdentity: Reflecting twice across the same line returns to the original point (\\(r_i \\circ r_i = \\text{id}\\))\nClosure: Composing reflections gives another isometry (which might be a reflection, rotation, or glide reflection)\nInverses: Every isometry has an inverse (just reflect again)\nAssociativity: Composition is associative\n\nThis group, generated by reflections across the boundaries of our fundamental domain, is called a reflection group or Coxeter group.\n\n\n\nOur fundamental domain \\(F\\) (the square \\([0,1]^2\\) or triangle) is a fundamental domain for the group action. This means:\n\nEvery point in the plane is equivalent to exactly one point in \\(F\\) (modulo boundary points)\nThe orbit of \\(F\\) under the group (all images \\(g(F)\\) for \\(g\\) in the group) tiles the entire plane\nDifferent tiles \\(g(F)\\) and \\(h(F)\\) only overlap on their boundaries\n\nWhen we start with a point \\(p\\) outside \\(F\\), there exists a sequence of group elements (reflections) that maps \\(p\\) into \\(F\\). Our algorithm finds this sequence!\n\n\n\nHere’s the key insight: each reflection across a boundary of \\(F\\) either: - Keeps the point inside \\(F\\) (if it’s already on the correct side) - Moves the point strictly closer to \\(F\\) (if it’s on the wrong side)\n“Closer” here means we reduce some discrete measure—like the number of boundaries we’re on the wrong side of. Since this number is finite and decreases with each reflection, the algorithm must terminate.\nFormally, we can define a height function \\(h(p)\\) that counts how many half-space boundaries \\(p\\) violates. Initially \\(h(p) \\geq 0\\). Each reflection that actually moves the point decreases \\(h(p)\\) by at least 1. When \\(h(p) = 0\\), the point is inside \\(F\\) and the algorithm stops.\n\n\n\n\n\n\nImportantThe Pattern Across Days\n\n\n\nThis is the same fundamental principle we’ve seen throughout:\nDay 2 (Apollonian gasket): - Group: Iterated circle inversions - Fundamental domain: The gaps between circles - Algorithm: Invert until inside the domain\nDay 3 (Euclidean tilings): - Group: Reflections across boundaries - Fundamental domain: The square/triangle - Algorithm: Reflect until inside the domain\nDay 3 (Hyperbolic, coming soon): - Group: Hyperbolic reflections (same structure!) - Fundamental domain: Hyperbolic triangle - Algorithm: Reflect until inside the domain (identical code!)\nThe unifying theme is group actions and fundamental domains. We’re always finding the unique representative of an orbit that lies in the fundamental domain.\n\n\n\n\n\nUnderstanding the group theory gives us insight into the computation:\nConvergence rate: For a viewport of size \\(V\\) and fundamental domain of size \\(F\\), we need at most \\(O(\\log(V/F))\\) reflections per coordinate axis. This is why small iteration limits (20-30) work well.\nParallelism: Each pixel’s orbit is independent—perfect for GPU parallelism. Millions of pixels computing orbits simultaneously with no communication needed.\nThreshold choice: The 0.0001 threshold for detecting convergence balances precision and performance. Smaller thresholds catch more subtle movements but risk floating-point noise; larger thresholds might terminate early but rarely matter for visualization.\nWhy it’s efficient: Most tiles are “nearby” in the group—they’re reached by short sequences of reflections. Only tiles far from the origin require many reflections, and these appear very small on screen (contributing few pixels).\nThis completes our Euclidean foundation. We now understand: 1. The folding algorithm in concrete examples 2. The half-space abstraction that makes it general 3. Why it works: reflection groups and fundamental domains 4. Computational properties: convergence, parallelism, efficiency\nNext, we’ll take this exact algorithmic structure into hyperbolic geometry!"
  },
  {
    "objectID": "OLD/lectures/day3.html#part-2-hyperbolic-geometry",
    "href": "OLD/lectures/day3.html#part-2-hyperbolic-geometry",
    "title": "1 Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "Hyperbolic geometry is one of the three classical geometries (Euclidean, spherical, and hyperbolic), characterized by constant negative curvature. For over two millennia, mathematicians believed Euclidean geometry was the only logically consistent geometry—Euclid’s parallel postulate seemed necessary. The discovery of hyperbolic geometry in the early 19th century revolutionized mathematics.\n\n\nThe story of hyperbolic geometry is one of the great dramas in mathematical history. For centuries, mathematicians tried to prove Euclid’s fifth postulate (the parallel postulate) from the other four axioms. What if you could have multiple parallel lines through a point?\nThree mathematicians independently discovered that this “impossible” geometry was actually perfectly consistent:\nJános Bolyai (1802-1860), a Hungarian mathematician, developed hyperbolic geometry in the 1820s. His father, a mathematician himself, warned him: “For God’s sake, I beseech you, give it up. Fear it no less than sensual passions because it too may take all your time and deprive you of your health, peace of mind and happiness in life.” But János persisted, publishing his work in 1832 as an appendix to his father’s book.\nNikolai Lobachevsky (1792-1856), a Russian mathematician, published the first account of hyperbolic geometry in 1829. He called it “imaginary geometry” and faced considerable resistance from the mathematical establishment. His work was largely ignored during his lifetime.\nCarl Friedrich Gauss (1777-1855), the “Prince of Mathematicians,” had discovered hyperbolic geometry even earlier but never published it. In his private correspondence, he revealed he’d been working on non-Euclidean geometry since the 1790s but feared the “clamor of the Boeotians” (his term for mathematical philistines). When he read Bolyai’s work in 1832, he wrote that he could not praise it “because to praise it would be to praise myself”—he’d discovered the same results years earlier but kept them private.\nThe discovery had profound implications: geometry was not a single truth about space but a family of possible consistent systems. This philosophical shift influenced everything from Einstein’s general relativity (which uses non-Euclidean geometry for curved spacetime) to modern physics and mathematics.\n\n\n\nHyperbolic geometry appears throughout modern mathematics and physics:\n\nComplex analysis: The upper half-plane model is fundamental to the theory of modular forms, elliptic curves, and the Riemann mapping theorem\nNumber theory: The action of \\(SL(2,\\mathbb{Z})\\) on \\(\\mathbb{H}^2\\) produces modular forms—functions crucial to the proof of Fermat’s Last Theorem\nTopology: The study of 3-manifolds and knot theory often requires understanding hyperbolic structures\nTeichmüller theory: Moduli spaces of Riemann surfaces have natural hyperbolic metrics\nKleinian groups: Discrete subgroups of hyperbolic isometries produce fractal limit sets (like we saw with the Apollonian gasket!)\nGeneral relativity: Anti-de Sitter space has constant negative curvature—hyperbolic geometry in spacetime\nMachine learning: Recent work uses hyperbolic embeddings to represent hierarchical data efficiently\n\n\n\n\nWhat makes hyperbolic geometry different from Euclidean geometry?\nParallel lines: Given a line and a point not on it, there are infinitely many lines through the point that don’t intersect the given line (all parallel to it). This is the defining feature that distinguishes hyperbolic geometry.\nTriangle angles: The sum of angles in a triangle is less than \\(\\pi\\). In fact, the area of a hyperbolic triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) is exactly: \\[\\text{Area} = \\pi - (\\alpha + \\beta + \\gamma)\\] This is the Gauss-Bonnet theorem for hyperbolic triangles—a beautiful connection between geometry (angles) and topology (area).\nExponential growth: In Euclidean geometry, the circumference of a circle grows linearly with radius (\\(C = 2\\pi r\\)). In hyperbolic geometry, it grows exponentially: \\(C \\sim e^r\\) for large \\(r\\). This means hyperbolic space has “more room” than Euclidean space—there’s exponentially more area at distance \\(r\\) from a point.\nNo similarity: In Euclidean geometry, you can scale any shape—a small triangle and a large triangle with the same angles are similar. In hyperbolic geometry, there’s an absolute unit of length built into the curvature. All triangles with angles \\((\\pi/2, \\pi/3, \\pi/7)\\) are congruent—there’s no “scaled version.” This makes hyperbolic geometry richer but more rigid.\nThese properties create the “extra room” that allows much richer tiling structures than Euclidean geometry.\n\n\n\n\n\nWe’ll work in the upper half-plane model of hyperbolic geometry, denoted \\(\\mathbb{H}^2\\):\n\\[\\mathbb{H}^2 = \\{z = x + iy \\in \\mathbb{C} : y &gt; 0\\}\\]\nThis is just complex numbers with positive imaginary part—the upper half of the complex plane. The real axis \\(\\{y = 0\\}\\) forms the boundary “at infinity”—it’s not actually part of \\(\\mathbb{H}^2\\), but represents points infinitely far away in hyperbolic distance.\n\n\nThe hyperbolic metric is what makes \\(\\mathbb{H}^2\\) a hyperbolic space:\n\\[ds^2 = \\frac{dx^2 + dy^2}{y^2}\\]\nThis gives \\(\\mathbb{H}^2\\) the structure of a complete Riemannian manifold with constant curvature \\(-1\\).\nWhat does this mean? The factor \\(1/y^2\\) is a conformal factor that scales the Euclidean metric. As \\(y \\to 0\\) (approaching the boundary), this scaling factor blows up—distances that look small Euclidean-wise are enormous hyperbolically. As \\(y \\to \\infty\\) (going “up” in the upper half-plane), the scaling factor goes to zero—large Euclidean distances are actually finite hyperbolically.\nThe metric is conformal to the Euclidean metric—it preserves angles but not lengths. If two curves meet at angle \\(\\theta\\) in the Euclidean sense, they also meet at angle \\(\\theta\\) in the hyperbolic sense! This is why you can trust your eyes when looking at pictures—angles are what they appear to be.\n\n\n\nIntegrating the metric along paths gives the hyperbolic distance between two points \\(z_1 = x_1 + iy_1\\) and \\(z_2 = x_2 + iy_2\\):\n\\[d_{\\mathbb{H}^2}(z_1, z_2) = \\text{arcosh}\\left(1 + \\frac{|z_1 - z_2|^2}{2y_1 y_2}\\right)\\]\nwhere \\(|z_1 - z_2| = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\\) is the usual Euclidean distance.\nNotice the \\(1/y_1 y_2\\) factor—points near the boundary (\\(y\\) small) are very far apart hyperbolically even if they’re close Euclidean-wise.\nDerivation sketch: For a vertical line from \\(z_1 = x + iy_1\\) to \\(z_2 = x + iy_2\\), the hyperbolic length is: \\[\\int_{y_1}^{y_2} \\frac{dy}{y} = \\log(y_2) - \\log(y_1) = \\log(y_2/y_1)\\]\nFor a general path, you need to integrate along the geodesic connecting the points (which might not be a straight Euclidean line), giving the arcosh formula above.\n\n\n\nLet’s make this concrete with an interactive shader. We’ll start with Euclidean distance, then switch to hyperbolic to see the difference.\nEuclidean distance circles:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);  // Shift up so we're in y &gt; 0\n    \n    // Mouse position as center (or default)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);  // Default if no click\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Euclidean distance\n    float dist = length(p - center);\n    \n    // Draw a disk of radius 0.5 using two circles\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer circle (slightly larger)\n    if(dist &lt; radius + 0.02) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner circle (slightly smaller) - \"cuts out\" interior\n    if(dist &lt; radius - 0.02) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center point\n    if(length(p - center) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nClick and drag around—the circle stays the same size everywhere. This is Euclidean distance: uniform across the plane. Notice how we draw the boundary: we draw a filled circle at radius \\(r + \\epsilon\\) (outer edge), then draw another filled circle at radius \\(r - \\epsilon\\) (inner edge) in a different color. The ring between them is our boundary!\nHyperbolic distance circles:\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // arccosh(arg)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Mouse position as center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Hyperbolic distance\n    float dist = hyperbolicDistance(p, center);\n    \n    // Draw a hyperbolic disk using two \"circles\"\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer boundary\n    if(dist &lt; radius + 0.05) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner region\n    if(dist &lt; radius - 0.05) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center\n    if(hyperbolicDistance(p, center) &lt; 0.1) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow drag the center around! Notice how the “circle” changes shape as you move it. Near the bottom (\\(y \\to 0\\)), the circle appears huge Euclidean-wise—that’s because we’re near the boundary where hyperbolic distances blow up. Higher up (\\(y\\) large), the circle appears smaller.\nThis visualization makes the \\(1/y^2\\) conformal factor visceral: hyperbolic space is compressed near the boundary.\n\n\n\n\n\nThe real axis \\(\\{y = 0\\}\\) is not part of \\(\\mathbb{H}^2\\), but we can think of it as the boundary at infinity—points infinitely far away in hyperbolic distance.\nIdeal points as equivalence classes: An ideal point on the boundary can be defined as an equivalence class of geodesics that asymptotically approach each other. Two geodesics are equivalent if the hyperbolic distance between them goes to zero as you go to infinity along them.\nFor example, the vertical line \\(\\{x = 0\\}\\) and the vertical line \\(\\{x = \\epsilon\\}\\) (for small \\(\\epsilon\\)) both approach the point \\(0\\) on the real axis. As you go up (\\(y \\to \\infty\\)), the hyperbolic distance between corresponding points goes to zero—they’re asymptotically parallel.\nGeometric intuition: In the Poincaré disk model (which we’ll see soon), the boundary at infinity is literally the unit circle \\(|z| = 1\\). Points on this circle are infinitely far away from any interior point, but they still have geometric meaning—they represent directions or “points at infinity.”\nWhy this matters: When we define hyperbolic triangles, we can have vertices “at infinity” on the boundary. These are called ideal vertices or ideal triangles. For instance, our \\((2,3,\\infty)\\) triangle has one vertex at the point \\(\\infty\\) in the upper half-plane (straight up the imaginary axis). The angle at an ideal vertex is zero—the sides become asymptotically parallel as they approach the boundary.\nThe Gauss-Bonnet theorem still works: for a triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\), the area is \\(\\pi - (\\alpha + \\beta + \\gamma)\\). If one angle is zero (ideal vertex), the area is \\(\\pi - \\alpha - \\beta &gt; 0\\)—ideal triangles have finite area!\n\n\n\n\n\n\nGeodesics (the “straight lines” of hyperbolic geometry—curves that locally minimize distance) in \\(\\mathbb{H}^2\\) have exactly two forms:\n\nVertical lines: \\(\\{x = c\\}\\) for any constant \\(c \\in \\mathbb{R}\\)\nSemicircles: Centered on the real axis, perpendicular to it\n\nThese curves meet the boundary at right angles—this is the characterizing property of geodesics in this model.\nWhy these are geodesics: Reflections across these curves are isometries (they preserve the hyperbolic metric \\(ds^2 = \\frac{dx^2+dy^2}{y^2}\\)). An isometry’s fixed point set is always a geodesic! So we just need to verify that reflection across vertical lines and semicircles preserves the metric.\nFor vertical lines, this is obvious: reflecting across \\(x = c\\) sends \\((x,y) \\mapsto (2c-x, y)\\), which preserves both the Euclidean distance \\(dx^2 + dy^2\\) and the \\(y\\)-coordinate, hence preserves \\(\\frac{dx^2+dy^2}{y^2}\\).\nFor semicircles, we use circle inversion from Day 2! A semicircle centered at \\((c, 0)\\) with radius \\(R\\) is preserved by the inversion: \\[z \\mapsto c + R^2 \\frac{z - c}{|z - c|^2}\\]\nCircle inversion is conformal (preserves angles) and scales distances by exactly \\(1/y^2\\) near the boundary—precisely the conformal factor in the hyperbolic metric! So inversions through semicircles are hyperbolic isometries. Their fixed point sets (the semicircles themselves) are therefore geodesics.\n\n\n\n\n\n\nImportantConnection to Day 2: Circle Inversion is a Hyperbolic Isometry!\n\n\n\nThis is a profound connection: the circle inversions we used on Day 2 for the Apollonian gasket were actually hyperbolic isometries all along! The Apollonian gasket lives in hyperbolic space—the gaps between circles are hyperbolic regions, and the inversions are reflections across hyperbolic geodesics (semicircles).\nWhen we iterated inversions on Day 2, we were doing exactly what we’re doing today—finding the fundamental domain of a group action! The Apollonian gasket is a hyperbolic object, just like our triangle tilings. The same group-theoretic principles apply.\nThis is why the techniques work across days: we’re always working with group actions, whether we realize it or not. The mathematics unifies everything.\n\n\n\n\n\nFor vertical lines (like \\(x = c\\)), reflection is simple—flip the \\(x\\)-coordinate:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    // Check if we're on the correct side\n    if((z.x - x_pos) * side &lt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Reflect: (x,y) ↦ (2c - x, y)\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\nFor semicircles (geodesics from point \\(p\\) to point \\(q\\) on the real axis), we use circle inversion. The semicircle has center \\((c, 0)\\) where \\(c = (p+q)/2\\) and radius \\(R = |p-q|/2\\):\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    \n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);  // Squared distance from center\n    \n    // Check if we're on the correct side\n    if((dist2 - radius * radius) * side &gt; 0.0) {\n        return z;  // Already on correct side\n    }\n    \n    // Circle inversion (from Day 2!)\n    vec2 inverted = vec2(center, 0.0) + (radius * radius) * rel / dist2;\n    return inverted;\n}\nNote: We’re inverting through a circle in the Euclidean sense (using Euclidean distance dist2), but this operation is actually a hyperbolic isometry! The magic is that circle inversion’s conformal properties exactly match the hyperbolic metric’s requirements.\n\n\n\n\n\n\nNoteWhy Two Types of Reflections?\n\n\n\nIn Euclidean geometry, all reflections across lines look the same—just the orientation changes. Why do we need two different functions in hyperbolic geometry?\nThe answer is that we’re working in a model of hyperbolic geometry (the upper half-plane). The vertical lines and semicircles are the images of geodesics in this model. In the intrinsic hyperbolic geometry, all reflections across geodesics are the same—there’s only one type of reflection.\nBut when we represent hyperbolic geometry in the Euclidean upper half-plane, geodesics appear as two different types of curves (vertical lines and semicircles), so we need two different formulas. This is an artifact of the model, not the geometry itself.\nIn the Poincaré disk model (coming soon), ALL geodesics are circular arcs perpendicular to the boundary circle, so we’d only need one reflection function there!\n\n\n\n\n\n\n\nLet’s build our first hyperbolic triangle tiling. The notation \\((p, q, r)\\) means the triangle has angles \\(\\pi/p\\), \\(\\pi/q\\), and \\(\\pi/r\\) at its three vertices. So \\((2,3,\\infty)\\) means angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(0\\) (an ideal vertex at infinity).\nWhy this triangle exists in hyperbolic geometry: The Gauss-Bonnet theorem tells us the area of a hyperbolic triangle with angles \\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\) is: \\[\\text{Area} = \\pi - (\\alpha + \\beta + \\gamma)\\]\nFor a \\((2,3,\\infty)\\) triangle: \\[\\text{Area} = \\pi - \\left(\\frac{\\pi}{2} + \\frac{\\pi}{3} + 0\\right) = \\pi - \\frac{5\\pi}{6} = \\frac{\\pi}{6} &gt; 0\\]\nSo this triangle has finite positive area and can tile the hyperbolic plane. In Euclidean geometry, \\(\\pi/2 + \\pi/3 = 5\\pi/6 &lt; \\pi\\), but that’s not enough—we’d need the sum to equal exactly \\(\\pi\\) to get zero curvature. Since \\(5\\pi/6 &lt; \\pi\\), there’s negative curvature left over, making this a hyperbolic triangle.\nConfiguration: We’ll use a particularly nice setup in the upper half-plane: - Left boundary: Vertical line at \\(x = -1\\) - Right boundary: Vertical line at \\(x = 1\\)\n- Bottom boundary: Unit semicircle from \\(-1\\) to \\(1\\) (centered at origin, radius \\(1\\))\nThis creates a triangle with: - Two finite vertices at approximately \\((-1, 0)\\) and \\((1, 0)\\) (technically infinitesimally above the real axis) - One ideal vertex at \\(\\infty\\) (straight up the imaginary axis) - Angles of \\(\\pi/2\\) at the bottom two vertices (vertical line meets semicircle at right angles) - Angle of \\(\\pi/3\\) between the two vertical lines when measured hyperbolically - Angle of \\(0\\) at the ideal vertex \\(\\infty\\)\n\n\nHere’s the complete shader:\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful hyperbolic tiling! Notice how the triangles appear to get smaller near the bottom of the screen (approaching the real axis \\(y = 0\\))—they’re all the same hyperbolic size, but Euclidean distances compress due to the \\(1/y^2\\) metric.\nThe alternating colors show which tiles are orientation-preserving vs orientation-reversing reflections of the fundamental domain.\n\n\n\n\n\n\nNoteCompare to Euclidean\n\n\n\nLook at the structure of this shader compared to the Euclidean triangle tiling:\nEuclidean:\np = reflectInto(p, hs1);\np = reflectInto(p, hs2);\np = reflectInto(p, hs3);\nHyperbolic:\nz = reflectIntoVertical(z, -1.0, -1.0);\nz = reflectIntoVertical(z, 1.0, 1.0);\nz = reflectIntoCircular(z, -1.0, 1.0, 1.0);\nThe algorithm is identical! We just have two types of reflection operations instead of one. This is the power of recognizing the pattern.\n\n\n\n\n\n\n\n\nTipComputational Analysis\n\n\n\nGPU Parallelism: Just like Days 1 and 2, this algorithm is embarrassingly parallel. Each pixel computes independently—no communication, no shared state, perfect for GPU architecture.\nConvergence: The folding algorithm works for the same group-theoretic reasons as the Euclidean case. The three reflections generate a discrete group of hyperbolic isometries, and our fundamental triangle is a fundamental domain for this group’s action on \\(\\mathbb{H}^2\\).\nPrecision issues: Near \\(y \\to 0\\), floating-point precision degrades. The large conformal factor \\(1/y^2\\) amplifies small errors in distance calculations. This is why we darken the region \\(y &lt; 0\\)—technically it’s not part of the hyperbolic plane, but also our numerics become unreliable there.\nThreshold \\(0.0001\\): This convergence threshold balances precision and performance. Smaller thresholds catch more subtle movements but risk getting stuck in floating-point noise; larger thresholds might terminate early. For visualization purposes, \\(0.0001\\) is a good sweet spot.\nMemory efficiency: Each pixel only needs to store its current position z (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures—just stateless iteration. This is as memory-efficient as you can get!\n\n\n\n\n\n\n\n\nTipExercise: Visualizing Hyperbolic Triangle Structure\n\n\n\nWant to see the edges and vertices of your hyperbolic triangles? This requires computing hyperbolic distances.\nFor hyperbolic distance:\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\nFor drawing edges (vertical lines):\n// Distance to vertical line x = c\nfloat distToVertical = abs(z.x - c);\nif(distToVertical &lt; 0.02) color = vec3(1.0);\nFor drawing edges (semicircular geodesics):\n// Distance to semicircle from p to q\nfloat center = (p + q) / 2.0;\nfloat radius = abs(p - q) / 2.0;\nfloat distToCircle = abs(length(z - vec2(center, 0.0)) - radius);\n// Only draw if above real axis\nif(z.y &gt; 0.0 && distToCircle &lt; 0.02) color = vec3(1.0);\nFor vertices:\n// Check hyperbolic distance to vertices after folding\nvec2 v1 = vec2(-1.0, 0.01);  // Left vertex (slightly above axis)\nvec2 v2 = vec2(1.0, 0.01);   // Right vertex\nif(hyperbolicDistance(z, v1) &lt; 0.1 || hyperbolicDistance(z, v2) &lt; 0.1) {\n    color = vec3(1.0, 0.0, 0.0);  // Red vertices\n}\nSee Appendix H5 for the complete enhanced implementation!\n\n\n\n\n\n\n\nThe upper half-plane is just one way to represent hyperbolic geometry. There are several other models, each with advantages:\n\n\nThe Poincaré disk model represents all of \\(\\mathbb{H}^2\\) as the interior of the unit disk \\(\\{z \\in \\mathbb{C} : |z| &lt; 1\\}\\). The boundary circle \\(|z| = 1\\) represents points at infinity.\nGeodesics in this model are: - Diameters of the disk (straight lines through the origin) - Circular arcs perpendicular to the boundary circle\nThe conformal factor here is \\(\\frac{4}{(1-|z|^2)^2}\\), which blows up as \\(|z| \\to 1\\) (approaching the boundary).\nAdvantages: - The entire hyperbolic plane fits in a bounded region (the disk) - All geodesics look similar (circular arcs)—no distinction between vertical and circular - Visually intuitive for understanding the full structure at once\nDisadvantages: - Harder to compute distances - More complex reflection formulas\n\n\n\nWe can convert between the upper half-plane and Poincaré disk using the Cayley transform (also called the Möbius transformation):\n\\[w = \\frac{z - i}{z + i}\\]\nThis maps: - Upper half-plane \\(\\{z : \\operatorname{Im}(z) &gt; 0\\}\\) → Poincaré disk \\(\\{w : |w| &lt; 1\\}\\) - Real axis \\(\\{z : \\operatorname{Im}(z) = 0\\}\\) → Unit circle \\(\\{w : |w| = 1\\}\\) - Point \\(i\\) in the upper half-plane → origin \\(0\\) in the disk\nThe inverse transform is: \\[z = i\\frac{1 + w}{1 - w}\\]\nHere’s the implementation:\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 uhpToDisk(vec2 z) {\n    // w = (z - i) / (z + i)\n    vec2 i = vec2(0.0, 1.0);\n    return cdiv(z - i, z + i);\n}\n\nvec2 diskToUhp(vec2 w) {\n    // z = i(1 + w) / (1 - w)\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\nTo display your tiling in the Poincaré disk:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;  // Fit disk in viewport\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Convert disk coordinates to upper half-plane\n    vec2 z = diskToUhp(uv);\n    \n    // Run your tiling algorithm in UHP\n    // ... (fold into (2,3,∞) triangle as before)\n    \n    // Color and render\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nThe Klein model (also called the Beltrami-Klein model or projective disk model) is another disk representation. Its defining feature: geodesics are Euclidean straight lines! This makes some geometric properties clearer but sacrifices the conformal property—angles are distorted.\nConverting from Poincaré disk to Klein disk:\n\\[\\text{Klein}(w) = \\frac{2w}{1 + |w|^2}\\]\nvec2 poincareToKlein(vec2 w) {\n    float denom = 1.0 + dot(w, w);\n    return 2.0 * w / denom;\n}\nThe inverse:\n\\[w = \\frac{\\text{Klein}(w)}{1 + \\sqrt{1 - |\\text{Klein}(w)|^2}}\\]\nvec2 kleinToPoincare(vec2 k) {\n    float k2 = dot(k, k);\n    float denom = 1.0 + sqrt(1.0 - k2);\n    return k / denom;\n}\nAdvantages of Klein: - Geodesics are straight lines (simplest to compute) - Great for understanding incidence relationships\nDisadvantages: - Not conformal—angles are distorted - Harder to see hyperbolic distances\n\n\n\n\n\nThe \\((2,3,\\infty)\\) triangle is just the beginning. Many other hyperbolic triangles can tile the plane! The most famous is the \\((2,3,7)\\) triangle.\n\n\nThis triangle has angles \\(\\pi/2\\), \\(\\pi/3\\), and \\(\\pi/7\\). Its area is: \\[\\text{Area} = \\pi - \\left(\\frac{\\pi}{2} + \\frac{\\pi}{3} + \\frac{\\pi}{7}\\right) = \\frac{\\pi}{42}\\]\nThis is one of the smallest compact hyperbolic triangles! It produces incredibly dense tilings—the \\((2,3,7)\\) tiling has a 7-fold symmetry that creates intricate patterns reminiscent of M.C. Escher’s work.\nIn fact, Escher’s famous Circle Limit prints (especially Circle Limit III with the fish) are based on tilings by \\((2,3,7)\\) and related triangle groups. The hyperbolic geometry creates the exponential compression toward the boundary that gives these prints their distinctive character.\nClassification of hyperbolic triangles: Not every combination \\((p,q,r)\\) gives a hyperbolic triangle. The Gauss-Bonnet formula tells us we need: \\[\\frac{1}{p} + \\frac{1}{q} + \\frac{1}{r} &lt; 1\\]\nfor a hyperbolic triangle (negative curvature). If the sum equals exactly \\(1\\), we get a Euclidean triangle. If the sum is greater than \\(1\\), we get a spherical triangle (positive curvature).\nExamples: - \\((2,3,7)\\): \\(\\frac{1}{2} + \\frac{1}{3} + \\frac{1}{7} = \\frac{41}{42} &lt; 1\\) ✓ Hyperbolic - \\((2,3,\\infty)\\): \\(\\frac{1}{2} + \\frac{1}{3} + 0 = \\frac{5}{6} &lt; 1\\) ✓ Hyperbolic - \\((3,3,3)\\): \\(\\frac{1}{3} + \\frac{1}{3} + \\frac{1}{3} = 1\\) ✓ Euclidean (equilateral triangle) - \\((2,3,5)\\): \\(\\frac{1}{2} + \\frac{1}{3} + \\frac{1}{5} = \\frac{31}{30} &gt; 1\\) ✓ Spherical (icosahedron face)\nImplementing other triangle groups requires computing where the third geodesic should be, given the angle constraints. This is non-trivial and involves hyperbolic trigonometry—we leave this as an advanced homework exercise!"
  },
  {
    "objectID": "OLD/lectures/day3.html#summary",
    "href": "OLD/lectures/day3.html#summary",
    "title": "1 Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "Today we learned:\n\nThe folding algorithm: Iteratively reflect across boundaries until reaching the fundamental domain—works in any geometry\nHalf-space structure: Boundary + side gives a unified way to encode regions in Euclidean geometry\nWhy it works: Reflection groups and fundamental domains—the group-theoretic perspective that unifies all our iterative algorithms across Days 2 and 3\nHyperbolic geometry: Negative curvature space with two types of geodesics (vertical lines and semicircles in the UHP model)\nConnection to Day 2: Circle inversion is a hyperbolic isometry! The Apollonian gasket is actually a hyperbolic object\nTwo reflection functions: reflectIntoVertical and reflectIntoCircular parallel the Euclidean reflectInto\nMultiple models: Converting between upper half-plane and Poincaré disk using the Cayley transform\nHistorical context: The dramatic discovery of hyperbolic geometry by Gauss, Bolyai, and Lobachevsky in the 19th century\nComputational perspective: GPU parallelism, convergence rates, precision issues, iteration count tuning\n\nKey insight: Clean mathematical abstraction lets us write geometry-independent algorithms. The folding algorithm stays identical; only the reflection operations change. This is the power of recognizing patterns and building flexible abstractions!\nThe universal pattern: - Day 1: Distance fields and implicit curves—visualizing mathematics on the GPU - Day 2: Iterating circle inversions to create the Apollonian gasket—first group action - Day 3 (Euclidean): Iterating reflections to create tilings—reflection groups make it work - Day 3 (Hyperbolic): Same algorithm, different geometry—circle inversion reappears as hyperbolic isometry!\nThe through-line is geometric transformations and their groups. When we iterate a group action to reach a fundamental domain, we create tilings, fractals, and beautiful mathematical art."
  },
  {
    "objectID": "OLD/lectures/day3.html#homework",
    "href": "OLD/lectures/day3.html#homework",
    "title": "1 Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "Goal: Build geometric intuition for how hyperbolic distance works before implementing tilings.\nTasks:\n\nEuclidean distance visualization: Implement the shader showing Euclidean distance circles (provided in lecture). Drag the center around and observe that circles stay the same size everywhere.\nHyperbolic distance visualization: Implement the hyperbolic version (provided in lecture). Drag the center and observe how the “circle” changes shape—growing huge near \\(y \\to 0\\) and shrinking as \\(y\\) increases.\nObservations: Write 2-3 sentences describing what you observe about how hyperbolic “circles” behave compared to Euclidean ones. Why does the shape change as you drag the center?\n\nExpected output: Two working shaders demonstrating the difference between Euclidean and hyperbolic distance.\n\n\n\n\nGoal: Create a beautiful Euclidean triangle tiling that clearly shows the tiling structure.\nTasks:\n\nStart with the basic triangle tiling from lecture\nAdd edge visualization using distance to half-spaces\nAdd vertex markers at the three triangle vertices\nCreate an attractive color scheme\n\nExpected output: A clear triangle tiling where you can see individual triangles, their edges, and vertices. Experiment with colors to create an aesthetically pleasing result.\nSee Appendix E9 for reference implementation.\nBonus: Try different triangles! An isosceles right triangle, a 30-60-90 triangle, etc. Just compute new half-spaces for the edges.\n\n\n\n\nGoal: Create a beautiful hyperbolic triangle tiling with visible structure.\nTasks:\n\nStart with the basic \\((2,3,\\infty)\\) tiling from lecture\nImplement hyperbolic distance functions (see hints in lecture)\nDraw geodesic edges using hyperbolic distance to geodesics\nDraw vertices using hyperbolic distance to vertex points\nCreate an attractive color scheme\n\nExpected output: A clear hyperbolic tiling in the upper half-plane showing triangle edges and vertices.\nSee Appendix H5 for complete reference implementation.\nBonus: Display the same tiling in the Poincaré disk model and compare how edges and vertices appear in the two models.\n\n\n\n\nGoal: See the same tiling in different representations of hyperbolic space.\nTasks:\n\nPoincaré Disk (already provided in lecture): Verify it works with your tiling code\nKlein Model: Implement the transformation from Poincaré disk to Klein disk (see lecture for formula)\nIn the Klein model, geodesics become Euclidean straight lines! Display your tiling and observe this property.\nComparison: Show your \\((2,3,\\infty)\\) tiling in both the Poincaré disk and Klein model side-by-side. Write a few sentences about what you observe.\n\nDeliverable: Screenshots of your tiling in at least two models, with brief observations.\nSee Appendix H7 for Klein model reference.\n\n\n\n\nGoal: Explore other hyperbolic tilings by implementing different triangle groups.\nThe Challenge: This is the hardest homework problem! Computing where the third geodesic should be, given angle constraints, requires hyperbolic trigonometry.\nSuggested triangles to try: - (2, 3, 7): Creates Escher-like tilings with 7-fold symmetry - (2, 4, 6): Different symmetry pattern - (3, 3, 3): Equilateral hyperbolic triangle\nApproach: Use the hyperbolic law of cosines (see lecture for formula) to compute geodesic positions.\nDeliverable: Working tiling for at least one triangle group other than \\((2,3,\\infty)\\). Include screenshots and document your approach.\n\n\n\n\nOptional #1: Unified Abstractions - Create structs that work for both Euclidean and hyperbolic geometry\nOptional #2: Decorated Tiles - Add Escher-style patterns within fundamental domains\nOptional #3: Pentagon Tilings - Right-angled pentagons can tile hyperbolic space!\nSee lecture for details on these optional exercises."
  },
  {
    "objectID": "OLD/lectures/day3.html#looking-ahead",
    "href": "OLD/lectures/day3.html#looking-ahead",
    "title": "1 Day 3: Geometric Tilings in Euclidean and Hyperbolic Space",
    "section": "",
    "text": "We’ve now seen three days of geometric iteration: - Day 1: Distance fields and implicit functions - Day 2: Circle inversion and the Apollonian gasket - Day 3: Reflection groups in Euclidean and hyperbolic geometry\nThe common thread: group actions on geometric spaces. Iteratively applying transformations to reach a desired region, whether it’s the fundamental domain of a tiling or the gap structure of a fractal.\nThe techniques you’ve learned—GPU parallelism, iterative algorithms, group theory, geometric transformations—apply across a huge landscape of mathematical visualization!"
  },
  {
    "objectID": "OLD/lectures/day4.html",
    "href": "OLD/lectures/day4.html",
    "title": "1 Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "Today we enter the third dimension! We’ll learn how to cast rays from a camera and test for intersections with 3D objects. We’ll start with analytical methods (solving equations directly) for spheres and tori, then transition to raymarching with signed distance functions—a more flexible approach that enables complex procedural scenes.\nBy the end of today, you’ll understand: - How to set up a camera and generate rays for each pixel - Analytical ray-object intersection for simple surfaces - Why analytical methods become challenging for complex geometry - Signed distance functions as an alternative representation - The raymarching algorithm (sphere tracing) - How to compose multiple objects and assign materials\n\n\n\n\n\n\n\n\nFor each pixel, we need to: 1. Generate a ray from the camera through that pixel 2. Find where (if anywhere) the ray intersects scene geometry 3. Compute color based on surface properties and lighting\n\n\n\nWe’ll use the standard graphics convention: - Y-axis points up - Z-axis points toward the camera (out of the screen) - X-axis points right - Right-handed coordinate system\n\n\n\nOur camera sits at the origin looking down the negative Z-axis. For a pixel at normalized coordinates \\((u, v) \\in [-1, 1]^2\\), we generate a ray:\nRay origin: \\(\\mathbf{o} = (0, 0, 0)\\) (camera position)\nRay direction: \\(\\mathbf{d} = \\text{normalize}(u, v, -f)\\)\nwhere \\(f\\) is the focal length, related to field of view by: \\(f = 1/\\tan(\\text{FOV}/2)\\).\n\n\n\nA ray can be written as: \\[\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(t \\geq 0\\) is the parameter. Points along the ray correspond to different values of \\(t\\).\n\n\n\nLet’s start by visualizing our rays without any intersections:\nShader 1: Ray Visualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates to [-1, 1]\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Field of view\n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    // Ray direction (camera at origin, looking down -Z)\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Color based on ray direction (visualize the rays)\n    vec3 color = rayDir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a colorful gradient showing the direction of each ray. This confirms our camera setup is working!\n\n\n\n\n\n\n\nA sphere of radius \\(r\\) centered at position \\(\\mathbf{c}\\) is defined by: \\[|\\mathbf{p} - \\mathbf{c}|^2 = r^2\\]\nAll points \\(\\mathbf{p}\\) satisfying this equation lie on the sphere’s surface.\n\n\n\nWe want to find where our ray \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) intersects the sphere. Substituting the ray equation into the sphere equation: \\[|\\mathbf{o} + t\\mathbf{d} - \\mathbf{c}|^2 = r^2\\]\nLet \\(\\mathbf{oc} = \\mathbf{o} - \\mathbf{c}\\) (vector from sphere center to ray origin). Expanding: \\[|\\mathbf{oc} + t\\mathbf{d}|^2 = r^2\\] \\[|\\mathbf{oc}|^2 + 2t(\\mathbf{oc} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nThis is a quadratic equation in \\(t\\): \\[at^2 + bt + c = 0\\]\nwhere: - \\(a = |\\mathbf{d}|^2\\) (equals 1 if direction is normalized) - \\(b = 2(\\mathbf{oc} \\cdot \\mathbf{d})\\) - \\(c = |\\mathbf{oc}|^2 - r^2\\)\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us: - \\(\\Delta &lt; 0\\): no intersection (ray misses sphere) - \\(\\Delta = 0\\): one intersection (ray grazes sphere) - \\(\\Delta &gt; 0\\): two intersections (ray enters and exits)\nWe want the smaller positive \\(t\\) (the entry point).\n\n\n\nShader 2: Basic Sphere\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);  // Should be 1.0 if rayDir is normalized\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    // Return the closer intersection\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    // Return closest positive t\n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;  // Both behind camera\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere parameters\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    // Test intersection\n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit the sphere\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    } else {\n        // Background\n        color = vec3(0.1, 0.1, 0.2);  // Dark blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a flat red disk! It looks 2D because we don’t have lighting yet—we can’t see the sphere’s curvature.\n\n\n\n\n\nTo see the 3D structure, we need to compute lighting based on the surface normal.\n\n\nFor a sphere centered at \\(\\mathbf{c}\\), the outward normal at surface point \\(\\mathbf{p}\\) is: \\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the vector from center to surface, normalized.\n\n\n\nThe simplest lighting model: Lambertian diffuse shading. Surface brightness depends on the angle between the normal \\(\\mathbf{n}\\) and light direction \\(\\mathbf{l}\\): \\[\\text{brightness} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max(0, \\cdots)\\) ensures surfaces facing away from the light remain dark.\nShader 3: Sphere with Lighting\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) return -1.0;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvec3 sphereNormal(vec3 hitPoint, vec3 sphereCenter, float radius) {\n    return (hitPoint - sphereCenter) / radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit point\n        vec3 hitPoint = rayOrigin + t * rayDir;\n        \n        // Surface normal\n        vec3 normal = sphereNormal(hitPoint, sphereCenter, sphereRadius);\n        \n        // Light direction (from above and to the right)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        \n        // Diffuse lighting\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Sphere color\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);  // Red\n        color = sphereColor * diffuse;\n        \n        // Add ambient light so dark side isn't completely black\n        color += sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow the sphere looks 3D! The lighting reveals its curvature. Beautiful!\n\n\n\n\n\n\n\nA torus with major radius \\(R\\) (distance from center to tube center) and minor radius \\(r\\) (tube thickness) has the implicit equation: \\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nOr in vector form: \\[\\left(|\\mathbf{p}_{xz}| - R\\right)^2 + p_y^2 = r^2\\]\nwhere \\(\\mathbf{p}_{xz} = (p_x, p_z)\\) is the projection onto the XZ-plane.\n\n\n\nSubstituting our ray equation into this gives a quartic polynomial (degree 4): \\[at^4 + bt^3 + ct^2 + dt + e = 0\\]\nUnlike quadratics (which have a simple formula), quartic equations require sophisticated algebraic methods. Here’s what solving it actually looks like:\nShader 4: Analytical Torus\n// From Inigo Quilez - https://www.shadertoy.com/view/XdSGWy\n// Analytical quartic solver for torus intersection\nfloat intersectTorus(vec3 ro, vec3 rd, vec2 tor)\n{\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01)\n    {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0)\n    {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4)\n    {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    return result;\n}\n\nvec3 torusNormal(vec3 pos, vec2 tor)\n{\n    return normalize(pos * (dot(pos,pos) - tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Torus parameters\n    vec2 torus = vec2(1.0, 0.4);  // (major radius, minor radius)\n    vec3 torusCenter = vec3(0.0, 0.0, -3.5);\n    \n    // Adjust ray for torus position\n    vec3 ro = rayOrigin - torusCenter;\n    \n    float t = intersectTorus(ro, rayDir, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ro + t * rayDir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = torusColor * diffuse + torusColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nLook at that intersection code! Over 80 lines of complex algebra just to render one torus. And this is still a relatively simple surface—imagine arbitrary algebraic varieties, or trying to combine multiple objects with boolean operations.\nAnalytical methods work beautifully for simple geometry, but we need a more flexible approach for complex scenes.\n\n\n\n\n\n\n\n\nA signed distance function (SDF) gives the distance from any point in space to the nearest surface:\n\\[d(\\mathbf{p}) = \\begin{cases}\n&gt; 0 & \\text{outside surface} \\\\\n= 0 & \\text{on surface} \\\\\n&lt; 0 & \\text{inside surface}\n\\end{cases}\\]\nCrucially, \\(|d(\\mathbf{p})|\\) is the actual Euclidean distance to the surface.\n\n\nSDFs have a powerful property: if we’re at point \\(\\mathbf{p}\\) and the surface is distance \\(d\\) away, we can safely move \\(d\\) units in any direction without hitting anything. This enables sphere tracing—we march along the ray taking steps proportional to the SDF value.\n\n\n\nLet’s see SDFs for shapes we’ve already rendered analytically:\nSphere:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nCompare this to our 30+ line analytical intersection! Much simpler.\nTorus:\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\nAgain, dramatically simpler than the quartic solver!\nOther Primitives\nMany more SDFs exist: boxes, cylinders, capsules, cones, pyramids, etc. See Inigo Quilez’s comprehensive library for a complete reference. Each SDF is typically just a few lines of code.\n\n\n\n\n\nSphere tracing works like this:\n\nStart at the ray origin\nEvaluate the SDF at current position\nMarch forward along the ray by that distance (safe step!)\nRepeat until:\n\nVery close to surface (SDF ≈ 0) → hit!\nToo far away → miss\nToo many steps → give up\n\n\nHere’s the algorithm:\nfloat sceneSDF(vec3 p) {\n    // Define scene geometry (we'll implement this)\n    return 0.0;\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out float hitDist, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        // Close enough to surface?\n        if(abs(d) &lt; 0.001) {\n            hitDist = t;\n            hitPos = pos;\n            return true;\n        }\n        \n        // March forward\n        t += d;\n        \n        // Too far?\n        if(t &gt; 100.0) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n\nFor an SDF \\(d(\\mathbf{p})\\), the gradient \\(\\nabla d\\) points perpendicular to the surface (it’s the normal direction). We estimate it using finite differences:\n\\[\\frac{\\partial d}{\\partial x} \\approx \\frac{d(x + \\epsilon, y, z) - d(x - \\epsilon, y, z)}{2\\epsilon}\\]\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\n\n\nShader 5: Single Sphere with Raymarching\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        \n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Raymarch\n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        color = sphereColor * diffuse + sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nSame result as the analytical sphere, but now we have a flexible framework!\n\n\n\n\n\nHere’s where SDFs shine: changing shapes is trivial. Just swap out one SDF for another!\nShader 6: Shapeshifting\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdBox(vec3 p, vec3 center, vec3 halfExtents) {\n    vec3 q = abs(p - center) - halfExtents;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    // Uncomment ONE of these to see different shapes!\n    // Everything else stays the same - same raymarch, same lighting, same normal calculation\n    \n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n    //return sdTorus(p, vec3(0.0, 0.0, -3.0), 1.0, 0.4);\n    //return sdBox(p, vec3(0.0, 0.0, -3.0), vec3(0.8, 0.8, 0.8));\n    \n    // Try any SDF from https://iquilezles.org/articles/distfunctions/\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nComment/uncomment different SDFs in sceneSDF() to instantly see different shapes! Try adding more from Quilez’s library. The raymarching algorithm doesn’t care what shape you use—it just follows the distance field.\n\n\n\n\nTo combine multiple objects, we simply take the minimum distance to any object. The closest surface wins!\nShader 7: Multiple Objects with Materials\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Global variable to track which object we hit\nfloat gMaterialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;  // Start with very large distance\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.2, 0.0, -3.5), 0.8);\n    if(sphere &lt; d) {\n        d = sphere;\n        gMaterialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p, vec3(1.2, 0.0, -3.5), 1.0, 0.3);\n    if(torus &lt; d) {\n        d = torus;\n        gMaterialID = 2.0;\n    }\n    \n    // Ground plane\n    float plane = sdPlane(p, -1.0);\n    if(plane &lt; d) {\n        d = plane;\n        gMaterialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float matID) {\n    if(matID &lt; 1.5) return vec3(1.0, 0.0, 0.0);      // Sphere: red\n    if(matID &lt; 2.5) return vec3(0.0, 0.7, 1.0);      // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                       // Plane: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos, out float matID) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            matID = gMaterialID;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    float matID;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos, matID);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = getMaterialColor(matID);\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThree objects with different colors! Adding more objects is trivial—just add another SDF check in sceneSDF(). Compare this to analytical methods where combining objects requires sophisticated CSG (constructive solid geometry) techniques.\n\n\n\n\n\nToday we learned two approaches to 3D rendering:\nAnalytical Ray Tracing: - Solve equations directly for ray-surface intersection - Exact solutions, very efficient for simple geometry - Sphere: straightforward quadratic equation - Torus: complex quartic equation requiring sophisticated algebra - Becomes increasingly difficult for complex surfaces - Standard in production ray tracers for well-defined geometry\nSDF-Based Raymarching: - Represent surfaces as distance fields - March along rays using sphere tracing - Simple, uniform code for any geometry - Easy composition: just take minimum distance - Flexible—works for procedural, implicit, or arbitrary surfaces - Slightly slower than analytical, but much more versatile\nKey Concepts: - Camera setup and ray generation - Parametric ray equation: \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) - Surface normals for lighting - Diffuse (Lambertian) shading - Signed distance functions (SDFs) - Sphere tracing algorithm - Normal estimation via gradient (finite differences) - Material tracking for multiple objects\nTomorrow we’ll explore advanced raymarching: domain operations for infinite repetition, boolean operations for smooth blending, and 3D fractals!\n\n\n\n\n\n\nImplement analytical ray tracing for an interesting polynomial implicit surface.\nGoal: Experience the challenges of analytical methods firsthand, then appreciate SDFs even more!\nSuggested surfaces: - Degree 3: Saddle surfaces, cubic varieties - Degree 4: Klein bottle projections, quartic surfaces with interesting topology - Cassini ovals in 3D: \\((x^2 + y^2 + z^2)^2 - 2a^2(x^2 - y^2) = b^4 - a^4\\)\nImplementation steps:\n\nDefine your implicit function \\(F(x,y,z) = 0\\)\n\nExample—a quartic surface:\nfloat implicitFunction(vec3 p) {\n    float r2 = dot(p, p);\n    return r2 * r2 - (p.x*p.x + p.y*p.y - 2.0*p.z*p.z);\n}\n\nImplement root finding (bisection method)\n\nfloat intersectImplicit(vec3 rayOrigin, vec3 rayDir) {\n    float tMin = 0.0;\n    float tMax = 10.0;\n    \n    // Check for sign change\n    float fMin = implicitFunction(rayOrigin + tMin * rayDir);\n    float fMax = implicitFunction(rayOrigin + tMax * rayDir);\n    \n    if(fMin * fMax &gt; 0.0) return -1.0;  // No root\n    \n    // Bisection\n    for(int i = 0; i &lt; 50; i++) {\n        float tMid = (tMin + tMax) / 2.0;\n        float fMid = implicitFunction(rayOrigin + tMid * rayDir);\n        \n        if(abs(fMid) &lt; 0.001) return tMid;\n        \n        if(fMin * fMid &lt; 0.0) {\n            tMax = tMid;\n            fMax = fMid;\n        } else {\n            tMin = tMid;\n            fMin = fMid;\n        }\n    }\n    \n    return (tMin + tMax) / 2.0;\n}\n\nCompute normal via gradient\n\nvec3 implicitNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = implicitFunction(p + vec3(eps, 0, 0)) - implicitFunction(p - vec3(eps, 0, 0));\n    float dy = implicitFunction(p + vec3(0, eps, 0)) - implicitFunction(p - vec3(0, eps, 0));\n    float dz = implicitFunction(p + vec3(0, 0, eps)) - implicitFunction(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nOptimization: Bounding volume (optional but recommended)\n\nUse a bounding sphere to avoid checking the entire ray:\n// First check if ray intersects bounding sphere\n// Only compute implicit function if inside bounds\nExpected output: A rendered algebraic surface with proper lighting showing its geometric features.\nReflection question: After implementing this, compare the effort to using SDFs. Which approach would you prefer for a complex scene with many objects?\n\n\n\n\n\n\nAdd shiny highlights using the Phong reflection model:\n\\[\\text{specular} = (R \\cdot V)^n\\]\nwhere \\(R\\) is reflected light direction, \\(V\\) is view direction, \\(n\\) is shininess.\nvec3 R = reflect(-lightDir, normal);  // Reflected light\nvec3 V = -rayDir;                      // View direction\nfloat spec = pow(max(0.0, dot(R, V)), 32.0);\ncolor += vec3(1.0) * spec * 0.5;  // White specular highlight\nTry different shininess values (8, 16, 32, 64, 128) to see the effect!\n\n\n\nImplement an orbiting camera using time:\nfloat angle = iTime * 0.5;\nvec3 rayOrigin = vec3(3.0 * cos(angle), 1.0, 3.0 * sin(angle));\n\n// Look-at matrix\nvec3 target = vec3(0.0, 0.0, -3.0);\nvec3 forward = normalize(target - rayOrigin);\nvec3 right = normalize(cross(vec3(0, 1, 0), forward));\nvec3 up = cross(forward, right);\n\n// Transform ray direction\nvec3 rd = normalize(uv.x * right + uv.y * up + focalLength * forward);\n\n\n\nCreate a scene with 5+ objects using different SDFs from Quilez’s library: - Mix primitives: spheres, boxes, cylinders, tori, cones - Position them creatively - Use different materials - Add interesting lighting\n\n\n\nCast rays from the surface toward the light to check for occlusion:\nfloat softShadow(vec3 pos, vec3 lightDir) {\n    float t = 0.01;  // Start slightly above surface\n    float shadow = 1.0;\n    \n    for(int i = 0; i &lt; 50; i++) {\n        float d = sceneSDF(pos + lightDir * t);\n        shadow = min(shadow, 8.0 * d / t);  // Penumbra factor\n        t += d;\n        if(t &gt; 10.0 || d &lt; 0.001) break;\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\nApply this to your diffuse lighting for more realistic shadows!\n\n\n\n\n\n\nTomorrow we’ll explore advanced raymarching techniques that would be nearly impossible with analytical methods:\n\nDomain operations: Infinite repetition, symmetry, twisting\nBoolean operations: Union, intersection, smooth blending\n3D fractals: Menger sponge, Mandelbulb via iterated transformations\nAdvanced lighting: Ambient occlusion, global illumination\n\nMake sure you’re comfortable with: - The raymarching algorithm (it’s the foundation) - How SDFs compose (taking minimum/maximum) - Normal estimation via gradients - The material tracking pattern we developed\nSee you tomorrow!"
  },
  {
    "objectID": "OLD/lectures/day4.html#overview",
    "href": "OLD/lectures/day4.html#overview",
    "title": "1 Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "Today we enter the third dimension! We’ll learn how to cast rays from a camera and test for intersections with 3D objects. We’ll start with analytical methods (solving equations directly) for spheres and tori, then transition to raymarching with signed distance functions—a more flexible approach that enables complex procedural scenes.\nBy the end of today, you’ll understand: - How to set up a camera and generate rays for each pixel - Analytical ray-object intersection for simple surfaces - Why analytical methods become challenging for complex geometry - Signed distance functions as an alternative representation - The raymarching algorithm (sphere tracing) - How to compose multiple objects and assign materials"
  },
  {
    "objectID": "OLD/lectures/day4.html#part-1-analytical-ray-tracing",
    "href": "OLD/lectures/day4.html#part-1-analytical-ray-tracing",
    "title": "1 Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "For each pixel, we need to: 1. Generate a ray from the camera through that pixel 2. Find where (if anywhere) the ray intersects scene geometry 3. Compute color based on surface properties and lighting\n\n\n\nWe’ll use the standard graphics convention: - Y-axis points up - Z-axis points toward the camera (out of the screen) - X-axis points right - Right-handed coordinate system\n\n\n\nOur camera sits at the origin looking down the negative Z-axis. For a pixel at normalized coordinates \\((u, v) \\in [-1, 1]^2\\), we generate a ray:\nRay origin: \\(\\mathbf{o} = (0, 0, 0)\\) (camera position)\nRay direction: \\(\\mathbf{d} = \\text{normalize}(u, v, -f)\\)\nwhere \\(f\\) is the focal length, related to field of view by: \\(f = 1/\\tan(\\text{FOV}/2)\\).\n\n\n\nA ray can be written as: \\[\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\]\nwhere \\(t \\geq 0\\) is the parameter. Points along the ray correspond to different values of \\(t\\).\n\n\n\nLet’s start by visualizing our rays without any intersections:\nShader 1: Ray Visualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates to [-1, 1]\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    // Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Field of view\n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    // Ray direction (camera at origin, looking down -Z)\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Color based on ray direction (visualize the rays)\n    vec3 color = rayDir * 0.5 + 0.5;\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a colorful gradient showing the direction of each ray. This confirms our camera setup is working!\n\n\n\n\n\n\n\nA sphere of radius \\(r\\) centered at position \\(\\mathbf{c}\\) is defined by: \\[|\\mathbf{p} - \\mathbf{c}|^2 = r^2\\]\nAll points \\(\\mathbf{p}\\) satisfying this equation lie on the sphere’s surface.\n\n\n\nWe want to find where our ray \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) intersects the sphere. Substituting the ray equation into the sphere equation: \\[|\\mathbf{o} + t\\mathbf{d} - \\mathbf{c}|^2 = r^2\\]\nLet \\(\\mathbf{oc} = \\mathbf{o} - \\mathbf{c}\\) (vector from sphere center to ray origin). Expanding: \\[|\\mathbf{oc} + t\\mathbf{d}|^2 = r^2\\] \\[|\\mathbf{oc}|^2 + 2t(\\mathbf{oc} \\cdot \\mathbf{d}) + t^2|\\mathbf{d}|^2 = r^2\\]\nThis is a quadratic equation in \\(t\\): \\[at^2 + bt + c = 0\\]\nwhere: - \\(a = |\\mathbf{d}|^2\\) (equals 1 if direction is normalized) - \\(b = 2(\\mathbf{oc} \\cdot \\mathbf{d})\\) - \\(c = |\\mathbf{oc}|^2 - r^2\\)\nThe discriminant \\(\\Delta = b^2 - 4ac\\) tells us: - \\(\\Delta &lt; 0\\): no intersection (ray misses sphere) - \\(\\Delta = 0\\): one intersection (ray grazes sphere) - \\(\\Delta &gt; 0\\): two intersections (ray enters and exits)\nWe want the smaller positive \\(t\\) (the entry point).\n\n\n\nShader 2: Basic Sphere\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);  // Should be 1.0 if rayDir is normalized\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) {\n        return -1.0;  // No intersection\n    }\n    \n    // Return the closer intersection\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    // Return closest positive t\n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;  // Both behind camera\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere parameters\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    // Test intersection\n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit the sphere\n        color = vec3(1.0, 0.0, 0.0);  // Red\n    } else {\n        // Background\n        color = vec3(0.1, 0.1, 0.2);  // Dark blue\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a flat red disk! It looks 2D because we don’t have lighting yet—we can’t see the sphere’s curvature.\n\n\n\n\n\nTo see the 3D structure, we need to compute lighting based on the surface normal.\n\n\nFor a sphere centered at \\(\\mathbf{c}\\), the outward normal at surface point \\(\\mathbf{p}\\) is: \\[\\mathbf{n} = \\frac{\\mathbf{p} - \\mathbf{c}}{r}\\]\nThis is just the vector from center to surface, normalized.\n\n\n\nThe simplest lighting model: Lambertian diffuse shading. Surface brightness depends on the angle between the normal \\(\\mathbf{n}\\) and light direction \\(\\mathbf{l}\\): \\[\\text{brightness} = \\max(0, \\mathbf{n} \\cdot \\mathbf{l})\\]\nThe \\(\\max(0, \\cdots)\\) ensures surfaces facing away from the light remain dark.\nShader 3: Sphere with Lighting\nfloat intersectSphere(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &lt; 0.0) return -1.0;\n    \n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    \n    if (t1 &gt; 0.0) return t1;\n    if (t2 &gt; 0.0) return t2;\n    return -1.0;\n}\n\nvec3 sphereNormal(vec3 hitPoint, vec3 sphereCenter, float radius) {\n    return (hitPoint - sphereCenter) / radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, -3.0);\n    float sphereRadius = 1.0;\n    \n    float t = intersectSphere(rayOrigin, rayDir, sphereCenter, sphereRadius);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        // Hit point\n        vec3 hitPoint = rayOrigin + t * rayDir;\n        \n        // Surface normal\n        vec3 normal = sphereNormal(hitPoint, sphereCenter, sphereRadius);\n        \n        // Light direction (from above and to the right)\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        \n        // Diffuse lighting\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Sphere color\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);  // Red\n        color = sphereColor * diffuse;\n        \n        // Add ambient light so dark side isn't completely black\n        color += sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nNow the sphere looks 3D! The lighting reveals its curvature. Beautiful!\n\n\n\n\n\n\n\nA torus with major radius \\(R\\) (distance from center to tube center) and minor radius \\(r\\) (tube thickness) has the implicit equation: \\[\\left(\\sqrt{x^2 + z^2} - R\\right)^2 + y^2 = r^2\\]\nOr in vector form: \\[\\left(|\\mathbf{p}_{xz}| - R\\right)^2 + p_y^2 = r^2\\]\nwhere \\(\\mathbf{p}_{xz} = (p_x, p_z)\\) is the projection onto the XZ-plane.\n\n\n\nSubstituting our ray equation into this gives a quartic polynomial (degree 4): \\[at^4 + bt^3 + ct^2 + dt + e = 0\\]\nUnlike quadratics (which have a simple formula), quartic equations require sophisticated algebraic methods. Here’s what solving it actually looks like:\nShader 4: Analytical Torus\n// From Inigo Quilez - https://www.shadertoy.com/view/XdSGWy\n// Analytical quartic solver for torus intersection\nfloat intersectTorus(vec3 ro, vec3 rd, vec2 tor)\n{\n    float po = 1.0;\n    float Ra2 = tor.x * tor.x;\n    float ra2 = tor.y * tor.y;\n    \n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n    \n    // Bounding sphere check\n    float h = n*n - m + (tor.x + tor.y) * (tor.x + tor.y);\n    if(h &lt; 0.0) return -1.0;\n    \n    // Find quartic coefficients\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n    \n    // Prevent numerical issues\n    if(abs(k3*(k3*k3 - k2) + k1) &lt; 0.01)\n    {\n        po = -1.0;\n        float tmp = k1; k1 = k3; k3 = tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n    float h2 = R*R - Q*Q*Q;\n    float z = 0.0;\n    \n    if(h2 &lt; 0.0)\n    {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow(sqrt(h2) + abs(R), 1.0/3.0);\n        z = sign(R)*abs(sQ + Q/sQ);\n    }\n    \n    z = c2 - z;\n    \n    float d1 = z - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    \n    if(abs(d1) &lt; 1.0e-4)\n    {\n        if(d2 &lt; 0.0) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if(d1 &lt; 0.0) return -1.0;\n        d1 = sqrt(d1/2.0);\n        d2 = c1/d1;\n    }\n    \n    float result = 1e20;\n    \n    h2 = d1*d1 - z + d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = -d1 - h2 - k3;\n        float t2 = -d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = t1;\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    h2 = d1*d1 - z - d2;\n    if(h2 &gt; 0.0)\n    {\n        h2 = sqrt(h2);\n        float t1 = d1 - h2 - k3;\n        float t2 = d1 + h2 - k3;\n        t1 = (po &lt; 0.0) ? 2.0/t1 : t1;\n        t2 = (po &lt; 0.0) ? 2.0/t2 : t2;\n        if(t1 &gt; 0.0) result = min(result, t1);\n        if(t2 &gt; 0.0) result = min(result, t2);\n    }\n    \n    return result;\n}\n\nvec3 torusNormal(vec3 pos, vec2 tor)\n{\n    return normalize(pos * (dot(pos,pos) - tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Torus parameters\n    vec2 torus = vec2(1.0, 0.4);  // (major radius, minor radius)\n    vec3 torusCenter = vec3(0.0, 0.0, -3.5);\n    \n    // Adjust ray for torus position\n    vec3 ro = rayOrigin - torusCenter;\n    \n    float t = intersectTorus(ro, rayDir, torus);\n    \n    vec3 color;\n    if (t &gt; 0.0) {\n        vec3 hitPoint = ro + t * rayDir;\n        vec3 normal = torusNormal(hitPoint, torus);\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 torusColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = torusColor * diffuse + torusColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nLook at that intersection code! Over 80 lines of complex algebra just to render one torus. And this is still a relatively simple surface—imagine arbitrary algebraic varieties, or trying to combine multiple objects with boolean operations.\nAnalytical methods work beautifully for simple geometry, but we need a more flexible approach for complex scenes."
  },
  {
    "objectID": "OLD/lectures/day4.html#part-2-signed-distance-functions-and-raymarching",
    "href": "OLD/lectures/day4.html#part-2-signed-distance-functions-and-raymarching",
    "title": "1 Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "A signed distance function (SDF) gives the distance from any point in space to the nearest surface:\n\\[d(\\mathbf{p}) = \\begin{cases}\n&gt; 0 & \\text{outside surface} \\\\\n= 0 & \\text{on surface} \\\\\n&lt; 0 & \\text{inside surface}\n\\end{cases}\\]\nCrucially, \\(|d(\\mathbf{p})|\\) is the actual Euclidean distance to the surface.\n\n\nSDFs have a powerful property: if we’re at point \\(\\mathbf{p}\\) and the surface is distance \\(d\\) away, we can safely move \\(d\\) units in any direction without hitting anything. This enables sphere tracing—we march along the ray taking steps proportional to the SDF value.\n\n\n\nLet’s see SDFs for shapes we’ve already rendered analytically:\nSphere:\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\nCompare this to our 30+ line analytical intersection! Much simpler.\nTorus:\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\nAgain, dramatically simpler than the quartic solver!\nOther Primitives\nMany more SDFs exist: boxes, cylinders, capsules, cones, pyramids, etc. See Inigo Quilez’s comprehensive library for a complete reference. Each SDF is typically just a few lines of code.\n\n\n\n\n\nSphere tracing works like this:\n\nStart at the ray origin\nEvaluate the SDF at current position\nMarch forward along the ray by that distance (safe step!)\nRepeat until:\n\nVery close to surface (SDF ≈ 0) → hit!\nToo far away → miss\nToo many steps → give up\n\n\nHere’s the algorithm:\nfloat sceneSDF(vec3 p) {\n    // Define scene geometry (we'll implement this)\n    return 0.0;\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out float hitDist, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        // Close enough to surface?\n        if(abs(d) &lt; 0.001) {\n            hitDist = t;\n            hitPos = pos;\n            return true;\n        }\n        \n        // March forward\n        t += d;\n        \n        // Too far?\n        if(t &gt; 100.0) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n\n\nFor an SDF \\(d(\\mathbf{p})\\), the gradient \\(\\nabla d\\) points perpendicular to the surface (it’s the normal direction). We estimate it using finite differences:\n\\[\\frac{\\partial d}{\\partial x} \\approx \\frac{d(x + \\epsilon, y, z) - d(x - \\epsilon, y, z)}{2\\epsilon}\\]\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\n\n\nShader 5: Single Sphere with Raymarching\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        \n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    // Raymarch\n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        color = sphereColor * diffuse + sphereColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nSame result as the analytical sphere, but now we have a flexible framework!\n\n\n\n\n\nHere’s where SDFs shine: changing shapes is trivial. Just swap out one SDF for another!\nShader 6: Shapeshifting\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdBox(vec3 p, vec3 center, vec3 halfExtents) {\n    vec3 q = abs(p - center) - halfExtents;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    // Uncomment ONE of these to see different shapes!\n    // Everything else stays the same - same raymarch, same lighting, same normal calculation\n    \n    return sdSphere(p, vec3(0.0, 0.0, -3.0), 1.0);\n    //return sdTorus(p, vec3(0.0, 0.0, -3.0), 1.0, 0.4);\n    //return sdBox(p, vec3(0.0, 0.0, -3.0), vec3(0.8, 0.8, 0.8));\n    \n    // Try any SDF from https://iquilezles.org/articles/distfunctions/\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = vec3(0.0, 0.7, 1.0);  // Cyan\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nComment/uncomment different SDFs in sceneSDF() to instantly see different shapes! Try adding more from Quilez’s library. The raymarching algorithm doesn’t care what shape you use—it just follows the distance field.\n\n\n\n\nTo combine multiple objects, we simply take the minimum distance to any object. The closest surface wins!\nShader 7: Multiple Objects with Materials\nfloat sdSphere(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat sdTorus(vec3 p, vec3 center, float majorRadius, float minorRadius) {\n    vec3 q = p - center;\n    vec2 pxz = vec2(q.x, q.z);\n    float d = length(pxz) - majorRadius;\n    return length(vec2(d, q.y)) - minorRadius;\n}\n\nfloat sdPlane(vec3 p, float height) {\n    return p.y - height;\n}\n\n// Global variable to track which object we hit\nfloat gMaterialID;\n\nfloat sceneSDF(vec3 p) {\n    float d = 1e10;  // Start with very large distance\n    \n    // Sphere\n    float sphere = sdSphere(p, vec3(-1.2, 0.0, -3.5), 0.8);\n    if(sphere &lt; d) {\n        d = sphere;\n        gMaterialID = 1.0;\n    }\n    \n    // Torus\n    float torus = sdTorus(p, vec3(1.2, 0.0, -3.5), 1.0, 0.3);\n    if(torus &lt; d) {\n        d = torus;\n        gMaterialID = 2.0;\n    }\n    \n    // Ground plane\n    float plane = sdPlane(p, -1.0);\n    if(plane &lt; d) {\n        d = plane;\n        gMaterialID = 3.0;\n    }\n    \n    return d;\n}\n\nvec3 getMaterialColor(float matID) {\n    if(matID &lt; 1.5) return vec3(1.0, 0.0, 0.0);      // Sphere: red\n    if(matID &lt; 2.5) return vec3(0.0, 0.7, 1.0);      // Torus: cyan\n    return vec3(0.5, 0.5, 0.5);                       // Plane: gray\n}\n\nvec3 estimateNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = sceneSDF(p + vec3(eps, 0, 0)) - sceneSDF(p - vec3(eps, 0, 0));\n    float dy = sceneSDF(p + vec3(0, eps, 0)) - sceneSDF(p - vec3(0, eps, 0));\n    float dz = sceneSDF(p + vec3(0, 0, eps)) - sceneSDF(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool raymarch(vec3 rayOrigin, vec3 rayDir, out vec3 hitPos, out float matID) {\n    float t = 0.0;\n    \n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float d = sceneSDF(pos);\n        \n        if(abs(d) &lt; 0.001) {\n            hitPos = pos;\n            matID = gMaterialID;\n            return true;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float fov = 45.0;\n    float focalLength = 1.0 / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, -focalLength));\n    \n    vec3 hitPos;\n    float matID;\n    bool hit = raymarch(rayOrigin, rayDir, hitPos, matID);\n    \n    vec3 color;\n    if(hit) {\n        vec3 normal = estimateNormal(hitPos);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        vec3 objectColor = getMaterialColor(matID);\n        color = objectColor * diffuse + objectColor * 0.1;\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThree objects with different colors! Adding more objects is trivial—just add another SDF check in sceneSDF(). Compare this to analytical methods where combining objects requires sophisticated CSG (constructive solid geometry) techniques."
  },
  {
    "objectID": "OLD/lectures/day4.html#summary",
    "href": "OLD/lectures/day4.html#summary",
    "title": "1 Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "Today we learned two approaches to 3D rendering:\nAnalytical Ray Tracing: - Solve equations directly for ray-surface intersection - Exact solutions, very efficient for simple geometry - Sphere: straightforward quadratic equation - Torus: complex quartic equation requiring sophisticated algebra - Becomes increasingly difficult for complex surfaces - Standard in production ray tracers for well-defined geometry\nSDF-Based Raymarching: - Represent surfaces as distance fields - March along rays using sphere tracing - Simple, uniform code for any geometry - Easy composition: just take minimum distance - Flexible—works for procedural, implicit, or arbitrary surfaces - Slightly slower than analytical, but much more versatile\nKey Concepts: - Camera setup and ray generation - Parametric ray equation: \\(\\mathbf{r}(t) = \\mathbf{o} + t\\mathbf{d}\\) - Surface normals for lighting - Diffuse (Lambertian) shading - Signed distance functions (SDFs) - Sphere tracing algorithm - Normal estimation via gradient (finite differences) - Material tracking for multiple objects\nTomorrow we’ll explore advanced raymarching: domain operations for infinite repetition, boolean operations for smooth blending, and 3D fractals!"
  },
  {
    "objectID": "OLD/lectures/day4.html#homework",
    "href": "OLD/lectures/day4.html#homework",
    "title": "1 Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "Implement analytical ray tracing for an interesting polynomial implicit surface.\nGoal: Experience the challenges of analytical methods firsthand, then appreciate SDFs even more!\nSuggested surfaces: - Degree 3: Saddle surfaces, cubic varieties - Degree 4: Klein bottle projections, quartic surfaces with interesting topology - Cassini ovals in 3D: \\((x^2 + y^2 + z^2)^2 - 2a^2(x^2 - y^2) = b^4 - a^4\\)\nImplementation steps:\n\nDefine your implicit function \\(F(x,y,z) = 0\\)\n\nExample—a quartic surface:\nfloat implicitFunction(vec3 p) {\n    float r2 = dot(p, p);\n    return r2 * r2 - (p.x*p.x + p.y*p.y - 2.0*p.z*p.z);\n}\n\nImplement root finding (bisection method)\n\nfloat intersectImplicit(vec3 rayOrigin, vec3 rayDir) {\n    float tMin = 0.0;\n    float tMax = 10.0;\n    \n    // Check for sign change\n    float fMin = implicitFunction(rayOrigin + tMin * rayDir);\n    float fMax = implicitFunction(rayOrigin + tMax * rayDir);\n    \n    if(fMin * fMax &gt; 0.0) return -1.0;  // No root\n    \n    // Bisection\n    for(int i = 0; i &lt; 50; i++) {\n        float tMid = (tMin + tMax) / 2.0;\n        float fMid = implicitFunction(rayOrigin + tMid * rayDir);\n        \n        if(abs(fMid) &lt; 0.001) return tMid;\n        \n        if(fMin * fMid &lt; 0.0) {\n            tMax = tMid;\n            fMax = fMid;\n        } else {\n            tMin = tMid;\n            fMin = fMid;\n        }\n    }\n    \n    return (tMin + tMax) / 2.0;\n}\n\nCompute normal via gradient\n\nvec3 implicitNormal(vec3 p) {\n    float eps = 0.001;\n    float dx = implicitFunction(p + vec3(eps, 0, 0)) - implicitFunction(p - vec3(eps, 0, 0));\n    float dy = implicitFunction(p + vec3(0, eps, 0)) - implicitFunction(p - vec3(0, eps, 0));\n    float dz = implicitFunction(p + vec3(0, 0, eps)) - implicitFunction(p - vec3(0, 0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nOptimization: Bounding volume (optional but recommended)\n\nUse a bounding sphere to avoid checking the entire ray:\n// First check if ray intersects bounding sphere\n// Only compute implicit function if inside bounds\nExpected output: A rendered algebraic surface with proper lighting showing its geometric features.\nReflection question: After implementing this, compare the effort to using SDFs. Which approach would you prefer for a complex scene with many objects?\n\n\n\n\n\n\nAdd shiny highlights using the Phong reflection model:\n\\[\\text{specular} = (R \\cdot V)^n\\]\nwhere \\(R\\) is reflected light direction, \\(V\\) is view direction, \\(n\\) is shininess.\nvec3 R = reflect(-lightDir, normal);  // Reflected light\nvec3 V = -rayDir;                      // View direction\nfloat spec = pow(max(0.0, dot(R, V)), 32.0);\ncolor += vec3(1.0) * spec * 0.5;  // White specular highlight\nTry different shininess values (8, 16, 32, 64, 128) to see the effect!\n\n\n\nImplement an orbiting camera using time:\nfloat angle = iTime * 0.5;\nvec3 rayOrigin = vec3(3.0 * cos(angle), 1.0, 3.0 * sin(angle));\n\n// Look-at matrix\nvec3 target = vec3(0.0, 0.0, -3.0);\nvec3 forward = normalize(target - rayOrigin);\nvec3 right = normalize(cross(vec3(0, 1, 0), forward));\nvec3 up = cross(forward, right);\n\n// Transform ray direction\nvec3 rd = normalize(uv.x * right + uv.y * up + focalLength * forward);\n\n\n\nCreate a scene with 5+ objects using different SDFs from Quilez’s library: - Mix primitives: spheres, boxes, cylinders, tori, cones - Position them creatively - Use different materials - Add interesting lighting\n\n\n\nCast rays from the surface toward the light to check for occlusion:\nfloat softShadow(vec3 pos, vec3 lightDir) {\n    float t = 0.01;  // Start slightly above surface\n    float shadow = 1.0;\n    \n    for(int i = 0; i &lt; 50; i++) {\n        float d = sceneSDF(pos + lightDir * t);\n        shadow = min(shadow, 8.0 * d / t);  // Penumbra factor\n        t += d;\n        if(t &gt; 10.0 || d &lt; 0.001) break;\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\nApply this to your diffuse lighting for more realistic shadows!"
  },
  {
    "objectID": "OLD/lectures/day4.html#looking-ahead-to-day-5",
    "href": "OLD/lectures/day4.html#looking-ahead-to-day-5",
    "title": "1 Day 4: Introduction to 3D Rendering",
    "section": "",
    "text": "Tomorrow we’ll explore advanced raymarching techniques that would be nearly impossible with analytical methods:\n\nDomain operations: Infinite repetition, symmetry, twisting\nBoolean operations: Union, intersection, smooth blending\n3D fractals: Menger sponge, Mandelbulb via iterated transformations\nAdvanced lighting: Ambient occlusion, global illumination\n\nMake sure you’re comfortable with: - The raymarching algorithm (it’s the foundation) - How SDFs compose (taking minimum/maximum) - Normal estimation via gradients - The material tracking pattern we developed\nSee you tomorrow!"
  },
  {
    "objectID": "OLD/lectures/day5b.html",
    "href": "OLD/lectures/day5b.html",
    "title": "1 Day 5bs",
    "section": "",
    "text": "1 Day 5bs"
  },
  {
    "objectID": "OLD/appendices/day3-shaders.html",
    "href": "OLD/appendices/day3-shaders.html",
    "title": "1 Appendix: Complete Shader Code for Day 3",
    "section": "",
    "text": "This appendix provides complete, standalone Shadertoy code for each shader program presented in Day 3. Each listing includes all necessary helper functions and can be copied directly into Shadertoy (https://www.shadertoy.com/new) and run immediately.\n\n\n\n\n\nSimple horizontal strip tiling showing the folding algorithm in one dimension.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n2D square tiling extending the folding algorithm to both dimensions.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);\n    \n    // Circle at center\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSquare tiling colored by the number of reflections needed to reach the fundamental domain.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizes one side of a line (a half-space).\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1 (left side of vertical line at x=1)\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame as E4a but with the boundary line drawn.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the boundary line\n    float d = distToHalfSpace(p, hs);\n    if(d &lt; 0.02) color = vec3(1.0);  // White boundary\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nIntersecting four half-spaces to create a square using additive coloring.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Additive coloring - each half-space adds brightness\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, left))   color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, right))  color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, bottom)) color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, top))    color += vec3(0.1, 0.15, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nEnhanced version with binary coloring and boundary lines.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Binary coloring: inside domain or not\n    bool in_square = inside(p, left) && inside(p, right) && \n                     inside(p, bottom) && inside(p, top);\n    vec3 color = in_square ? vec3(0.4, 0.6, 0.8) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw boundaries\n    float d1 = distToHalfSpace(p, left);\n    float d2 = distToHalfSpace(p, right);\n    float d3 = distToHalfSpace(p, bottom);\n    float d4 = distToHalfSpace(p, top);\n    float d = min(min(d1, d2), min(d3, d4));\n    \n    if(d &lt; 0.02) color = vec3(1.0);  // White boundaries\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizing three half-spaces defining an equilateral triangle.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, hs1)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs2)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs3)) color += vec3(0.15, 0.2, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nFull triangle tiling using half-space reflections.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle\n    for(int i = 0; i &lt; 20; i++) {\n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n    }\n    \n    // Simple coloring\n    vec3 color = vec3(0.3, 0.5, 0.7);\n    \n    // Draw a circle in fundamental domain\n    float d = length(p - vec2(0.0, -0.3));\n    if(d &lt; 0.2) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nTriangle tiling colored by reflection count with convergence check.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle with iteration count\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete triangle tiling with visible structure (reference implementation for homework).\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle with parity tracking\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by parity (alternating pattern)\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Draw edges\n    float d1 = distToHalfSpace(p, hs1);\n    float d2 = distToHalfSpace(p, hs2);\n    float d3 = distToHalfSpace(p, hs3);\n    float d_edge = min(min(d1, d2), d3);\n    \n    if(d_edge &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);  // White edges\n    }\n    \n    // Draw vertices (approximate positions)\n    vec2 v1 = vec2(-0.577, -0.333);\n    vec2 v2 = vec2(0.577, -0.333);\n    vec2 v3 = vec2(0.0, 0.667);\n    \n    float d_v1 = length(p - v1);\n    float d_v2 = length(p - v2);\n    float d_v3 = length(p - v3);\n    float d_vert = min(min(d_v1, d_v2), d_v3);\n    \n    if(d_vert &lt; 0.08) {\n        color = vec3(1.0, 0.0, 0.0);  // Red vertices\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nShows standard Euclidean distance circles for comparison with hyperbolic.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);  // Shift up so we're in y &gt; 0\n    \n    // Mouse position as center (or default)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);  // Default if no click\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Euclidean distance\n    float dist = length(p - center);\n    \n    // Draw a disk of radius 0.5 using two circles\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer circle (slightly larger)\n    if(dist &lt; radius + 0.02) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner circle (slightly smaller) - \"cuts out\" interior\n    if(dist &lt; radius - 0.02) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center point\n    if(length(p - center) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nShows hyperbolic distance “circles” in the upper half-plane model.\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // arccosh(arg)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Mouse position as center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Hyperbolic distance\n    float dist = hyperbolicDistance(p, center);\n    \n    // Draw a hyperbolic disk using two \"circles\"\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer boundary\n    if(dist &lt; radius + 0.05) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner region\n    if(dist &lt; radius - 0.05) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center\n    if(hyperbolicDistance(p, center) &lt; 0.1) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizes one side of a vertical geodesic (hyperbolic “line”).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Vertical geodesic at x = 0, showing right side (x &gt; 0)\n    float x_pos = 0.0;\n    float side = -1.0;  // side = -1.0 means x &gt; x_pos\n    \n    // Check which side we're on\n    bool on_right_side = (z.x - x_pos) * side &lt; 0.0;\n    \n    vec3 color = on_right_side ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the geodesic (vertical line)\n    if(abs(z.x - x_pos) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizes one side of a semicircular geodesic.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Semicircular geodesic from p to q on real axis\n    float p = -1.0;\n    float q = 1.0;\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    \n    // Distance from center\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    // side = 1.0 means outside the circle\n    float side = 1.0;\n    bool outside_circle = (dist2 - radius * radius) * side &gt; 0.0;\n    \n    vec3 color = outside_circle ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the geodesic (semicircle)\n    float dist_to_circle = abs(length(rel) - radius);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nShows the three geodesics of the (2,3,∞) triangle using additive coloring.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Three geodesics of (2,3,∞) triangle\n    // Left vertical line: x = -1, want x &gt; -1\n    bool inside_left = (z.x - (-1.0)) * (-1.0) &lt; 0.0;\n    \n    // Right vertical line: x = 1, want x &lt; 1\n    bool inside_right = (z.x - 1.0) * 1.0 &lt; 0.0;\n    \n    // Semicircle from -1 to 1, want outside (above)\n    float center = 0.0;\n    float radius = 1.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    bool inside_circle = (dist2 - radius * radius) * 1.0 &gt; 0.0;\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside_left)   color += vec3(0.15, 0.2, 0.25);\n    if(inside_right)  color += vec3(0.15, 0.2, 0.25);\n    if(inside_circle) color += vec3(0.15, 0.2, 0.25);\n    \n    // Draw the three geodesics\n    if(abs(z.x - (-1.0)) &lt; 0.02) color = vec3(1.0);  // Left line\n    if(abs(z.x - 1.0) &lt; 0.02) color = vec3(1.0);     // Right line\n    \n    float dist_to_circle = abs(length(rel) - radius);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) color = vec3(1.0);  // Semicircle\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete hyperbolic triangle tiling with simple coloring.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n    }\n    \n    // Simple coloring\n    vec3 color = vec3(0.6, 0.7, 0.9);\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nHyperbolic tiling colored by iteration count showing alternating pattern.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete hyperbolic tiling with visible structure (reference for homework).\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Draw geodesic edges\n    // Left vertical line (x = -1)\n    if(abs(z.x - (-1.0)) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Right vertical line (x = 1)\n    if(abs(z.x - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Semicircle from -1 to 1\n    vec2 rel = z - vec2(0.0, 0.0);\n    float dist_to_circle = abs(length(rel) - 1.0);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Draw vertices using hyperbolic distance\n    vec2 v1 = vec2(-1.0, 0.01);  // Left vertex (slightly above axis)\n    vec2 v2 = vec2(1.0, 0.01);   // Right vertex\n    \n    if(hyperbolicDistance(z, v1) &lt; 0.15 || hyperbolicDistance(z, v2) &lt; 0.15) {\n        color = vec3(1.0, 0.0, 0.0);  // Red vertices\n    }\n    \n    // Darken if below the real axis\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame (2,3,∞) tiling displayed in the Poincaré disk using the Cayley transform.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\n// Cayley transform: Poincaré disk -&gt; Upper half-plane\nvec2 cayleyDiskToUHP(vec2 w) {\n    // z = i(1-w)/(1+w)\n    vec2 numer = vec2(-w.y, 1.0 - w.x);  // i(1-w) = i - iw\n    vec2 denom = vec2(1.0 + w.x, w.y);    // 1 + w\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\n// Inverse Cayley: Upper half-plane -&gt; Poincaré disk\nvec2 cayleyUHPToDisk(vec2 z) {\n    // w = (z-i)/(z+i)\n    vec2 numer = vec2(z.x, z.y - 1.0);    // z - i\n    vec2 denom = vec2(z.x, z.y + 1.0);    // z + i\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for Poincaré disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 w = uv;  // Point in Poincaré disk\n    \n    // Convert to upper half-plane\n    vec2 z = cayleyDiskToUHP(w);\n    \n    // Fold into the (2,3,∞) triangle (in UHP)\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken outside unit disk\n    if(length(w) &gt; 1.0) {\n        color *= 0.3;\n    }\n    \n    // Draw boundary circle\n    if(abs(length(w) - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 0.0);  // Yellow boundary\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame tiling in the Klein model where geodesics appear as straight lines.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\n// Poincaré disk -&gt; Klein disk\nvec2 poincareToKlein(vec2 w) {\n    float w_mag2 = dot(w, w);\n    return 2.0 * w / (1.0 + w_mag2);\n}\n\n// Klein disk -&gt; Poincaré disk\nvec2 kleinToPoincare(vec2 p) {\n    float p_mag2 = dot(p, p);\n    float denom = 1.0 + sqrt(1.0 - p_mag2);\n    return p / denom;\n}\n\n// Cayley transform: Poincaré disk -&gt; Upper half-plane\nvec2 cayleyDiskToUHP(vec2 w) {\n    vec2 numer = vec2(-w.y, 1.0 - w.x);\n    vec2 denom = vec2(1.0 + w.x, w.y);\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for Klein disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 k = uv;  // Point in Klein disk\n    \n    // Convert Klein -&gt; Poincaré -&gt; Upper half-plane\n    vec2 w = kleinToPoincare(k);\n    vec2 z = cayleyDiskToUHP(w);\n    \n    // Fold into the (2,3,∞) triangle (in UHP)\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken outside unit disk\n    if(length(k) &gt; 1.0) {\n        color *= 0.3;\n    }\n    \n    // Draw boundary circle\n    if(abs(length(k) - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 0.0);  // Yellow boundary\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\n\nGo to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\n\nEuclidean Tilings: - Adjust fold iteration count (20 is conservative, 10 often sufficient) - Change fundamental domain by modifying half-space parameters - Experiment with different shapes (triangles, pentagons, hexagons) - Try different color palettes\nHyperbolic Tilings: - Mouse interaction in H1/H2 (click and drag to move center) - Adjust the shift in z = uv + vec2(0.0, 1.5) to change visible region - Increase iteration count (50) for more precision near boundaries - Try different triangle configurations (requires computing new geodesics)\n\n\n\nIf a shader runs slowly: - Reduce iteration count - Lower resolution in Shadertoy settings - Simplify edge/vertex drawing code\n\n\n\nEuclidean extensions: - Implement other regular tilings (hexagons, pentagons) - Add animations by making half-spaces time-dependent - Create compound patterns with multiple fundamental domains\nHyperbolic extensions: - Implement (2,3,7) or (2,4,6) triangles - Decorate fundamental domains with patterns (Escher-style) - Explore pentagon tilings - Animate between different models\n\n\n\nEuclidean vs Hyperbolic: Compare E7 and H4 - notice how the algorithm structure is identical but the reflection operations differ. This demonstrates the power of mathematical abstraction!\nModel Comparisons: Run H4 (upper half-plane), H7 (Poincaré disk), and H8 (Klein disk) side by side. The same mathematical object looks dramatically different depending on the model, but the underlying hyperbolic geometry is identical.\nEdge Behavior: In H6, notice how triangle edges near the boundary (y → 0) appear more compressed. This visualizes the 1/y² conformal factor in the hyperbolic metric."
  },
  {
    "objectID": "OLD/appendices/day3-shaders.html#part-1-euclidean-tilings",
    "href": "OLD/appendices/day3-shaders.html#part-1-euclidean-tilings",
    "title": "1 Appendix: Complete Shader Code for Day 3",
    "section": "",
    "text": "Simple horizontal strip tiling showing the folding algorithm in one dimension.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the strip [0, 1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);  // Dark background\n    \n    // A circle in the strip\n    float d = length(p - vec2(0.5, 0.0));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);  // Yellow circle\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n2D square tiling extending the folding algorithm to both dimensions.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    for(int i = 0; i &lt; 20; i++) {\n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    // Draw something in the fundamental domain\n    vec3 color = vec3(0.2, 0.2, 0.3);\n    \n    // Circle at center\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSquare tiling colored by the number of reflections needed to reach the fundamental domain.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Fold into the square [0,1] × [0,1]\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        if(p.x &lt; 0.0) p.x = -p.x;\n        if(p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if(p.y &lt; 0.0) p.y = -p.y;\n        if(p.y &gt; 1.0) p.y = 2.0 - p.y;\n        \n        // If point didn't move, we're done\n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color based on fold count\n    float t = float(foldCount) / 8.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    // Draw something in the fundamental domain\n    float d = length(p - vec2(0.5, 0.5));\n    if(d &lt; 0.3) {\n        color = mix(color, vec3(1.0, 1.0, 0.3), smoothstep(0.3, 0.25, d));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizes one side of a line (a half-space).\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1 (left side of vertical line at x=1)\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame as E4a but with the boundary line drawn.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define a half-space: x &lt; 1\n    HalfSpace hs = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    // Color based on whether we're inside\n    vec3 color = inside(p, hs) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the boundary line\n    float d = distToHalfSpace(p, hs);\n    if(d &lt; 0.02) color = vec3(1.0);  // White boundary\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nIntersecting four half-spaces to create a square using additive coloring.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Additive coloring - each half-space adds brightness\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, left))   color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, right))  color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, bottom)) color += vec3(0.1, 0.15, 0.2);\n    if(inside(p, top))    color += vec3(0.1, 0.15, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nEnhanced version with binary coloring and boundary lines.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define the four half-spaces for [0,1] × [0,1]\n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);  // x &gt; 0\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);  // x &lt; 1\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);  // y &gt; 0\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);  // y &lt; 1\n    \n    // Binary coloring: inside domain or not\n    bool in_square = inside(p, left) && inside(p, right) && \n                     inside(p, bottom) && inside(p, top);\n    vec3 color = in_square ? vec3(0.4, 0.6, 0.8) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw boundaries\n    float d1 = distToHalfSpace(p, left);\n    float d2 = distToHalfSpace(p, right);\n    float d3 = distToHalfSpace(p, bottom);\n    float d4 = distToHalfSpace(p, top);\n    float d = min(min(d1, d2), min(d3, d4));\n    \n    if(d &lt; 0.02) color = vec3(1.0);  // White boundaries\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizing three half-spaces defining an equilateral triangle.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    return (value - hs.c) * hs.side &lt; 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside(p, hs1)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs2)) color += vec3(0.15, 0.2, 0.25);\n    if(inside(p, hs3)) color += vec3(0.15, 0.2, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nFull triangle tiling using half-space reflections.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle\n    for(int i = 0; i &lt; 20; i++) {\n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n    }\n    \n    // Simple coloring\n    vec3 color = vec3(0.3, 0.5, 0.7);\n    \n    // Draw a circle in fundamental domain\n    float d = length(p - vec2(0.0, -0.3));\n    if(d &lt; 0.2) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nTriangle tiling colored by reflection count with convergence check.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle with iteration count\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count\n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (vec3(1.0) * t + vec3(0.0, 0.33, 0.67)));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete triangle tiling with visible structure (reference implementation for homework).\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace hs) {\n    float value = hs.a * p.x + hs.b * p.y;\n    \n    if((value - hs.c) * hs.side &lt; 0.0) {\n        return p;\n    }\n    \n    vec2 normal = vec2(hs.a, hs.b);\n    float norm = length(normal);\n    normal = normal / norm;\n    \n    float signedDist = (value - hs.c) / norm;\n    return p - 2.0 * signedDist * normal;\n}\n\nfloat distToHalfSpace(vec2 p, HalfSpace hs) {\n    return abs(hs.a * p.x + hs.b * p.y - hs.c) / length(vec2(hs.a, hs.b));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv;\n    \n    // Define three half-spaces for equilateral triangle\n    HalfSpace hs1 = HalfSpace(1.5, -0.866, -0.866, -1.0);\n    HalfSpace hs2 = HalfSpace(0.0, 1.732, -0.866, -1.0);\n    HalfSpace hs3 = HalfSpace(-1.5, -0.866, -0.866, -1.0);\n    \n    // Fold into triangle with parity tracking\n    int foldCount = 0;\n    for(int i = 0; i &lt; 20; i++) {\n        vec2 p_old = p;\n        \n        p = reflectInto(p, hs1);\n        p = reflectInto(p, hs2);\n        p = reflectInto(p, hs3);\n        \n        if(length(p - p_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by parity (alternating pattern)\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Draw edges\n    float d1 = distToHalfSpace(p, hs1);\n    float d2 = distToHalfSpace(p, hs2);\n    float d3 = distToHalfSpace(p, hs3);\n    float d_edge = min(min(d1, d2), d3);\n    \n    if(d_edge &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);  // White edges\n    }\n    \n    // Draw vertices (approximate positions)\n    vec2 v1 = vec2(-0.577, -0.333);\n    vec2 v2 = vec2(0.577, -0.333);\n    vec2 v3 = vec2(0.0, 0.667);\n    \n    float d_v1 = length(p - v1);\n    float d_v2 = length(p - v2);\n    float d_v3 = length(p - v3);\n    float d_vert = min(min(d_v1, d_v2), d_v3);\n    \n    if(d_vert &lt; 0.08) {\n        color = vec3(1.0, 0.0, 0.0);  // Red vertices\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day3-shaders.html#part-2-hyperbolic-tilings",
    "href": "OLD/appendices/day3-shaders.html#part-2-hyperbolic-tilings",
    "title": "1 Appendix: Complete Shader Code for Day 3",
    "section": "",
    "text": "Shows standard Euclidean distance circles for comparison with hyperbolic.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);  // Shift up so we're in y &gt; 0\n    \n    // Mouse position as center (or default)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);  // Default if no click\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Euclidean distance\n    float dist = length(p - center);\n    \n    // Draw a disk of radius 0.5 using two circles\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer circle (slightly larger)\n    if(dist &lt; radius + 0.02) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner circle (slightly smaller) - \"cuts out\" interior\n    if(dist &lt; radius - 0.02) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center point\n    if(length(p - center) &lt; 0.05) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nShows hyperbolic distance “circles” in the upper half-plane model.\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // arccosh(arg)\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv + vec2(0.0, 1.5);\n    \n    // Mouse position as center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(iMouse.z &lt; 0.5) mouse = vec2(0.5, 0.7);\n    mouse = (mouse - 0.5) * 4.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec2 center = mouse + vec2(0.0, 1.5);\n    \n    // Hyperbolic distance\n    float dist = hyperbolicDistance(p, center);\n    \n    // Draw a hyperbolic disk using two \"circles\"\n    float radius = 0.5;\n    vec3 color = vec3(0.1, 0.1, 0.2);  // Background\n    \n    // Outer boundary\n    if(dist &lt; radius + 0.05) {\n        color = vec3(1.0, 1.0, 0.3);  // Yellow ring\n    }\n    \n    // Inner region\n    if(dist &lt; radius - 0.05) {\n        color = vec3(0.4, 0.6, 0.8);  // Blue interior\n    }\n    \n    // Draw center\n    if(hyperbolicDistance(p, center) &lt; 0.1) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(p.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizes one side of a vertical geodesic (hyperbolic “line”).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Vertical geodesic at x = 0, showing right side (x &gt; 0)\n    float x_pos = 0.0;\n    float side = -1.0;  // side = -1.0 means x &gt; x_pos\n    \n    // Check which side we're on\n    bool on_right_side = (z.x - x_pos) * side &lt; 0.0;\n    \n    vec3 color = on_right_side ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the geodesic (vertical line)\n    if(abs(z.x - x_pos) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nVisualizes one side of a semicircular geodesic.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Semicircular geodesic from p to q on real axis\n    float p = -1.0;\n    float q = 1.0;\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    \n    // Distance from center\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    // side = 1.0 means outside the circle\n    float side = 1.0;\n    bool outside_circle = (dist2 - radius * radius) * side &gt; 0.0;\n    \n    vec3 color = outside_circle ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.2);\n    \n    // Draw the geodesic (semicircle)\n    float dist_to_circle = abs(length(rel) - radius);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nShows the three geodesics of the (2,3,∞) triangle using additive coloring.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Three geodesics of (2,3,∞) triangle\n    // Left vertical line: x = -1, want x &gt; -1\n    bool inside_left = (z.x - (-1.0)) * (-1.0) &lt; 0.0;\n    \n    // Right vertical line: x = 1, want x &lt; 1\n    bool inside_right = (z.x - 1.0) * 1.0 &lt; 0.0;\n    \n    // Semicircle from -1 to 1, want outside (above)\n    float center = 0.0;\n    float radius = 1.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    bool inside_circle = (dist2 - radius * radius) * 1.0 &gt; 0.0;\n    \n    // Additive coloring\n    vec3 color = vec3(0.0);\n    \n    if(inside_left)   color += vec3(0.15, 0.2, 0.25);\n    if(inside_right)  color += vec3(0.15, 0.2, 0.25);\n    if(inside_circle) color += vec3(0.15, 0.2, 0.25);\n    \n    // Draw the three geodesics\n    if(abs(z.x - (-1.0)) &lt; 0.02) color = vec3(1.0);  // Left line\n    if(abs(z.x - 1.0) &lt; 0.02) color = vec3(1.0);     // Right line\n    \n    float dist_to_circle = abs(length(rel) - radius);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) color = vec3(1.0);  // Semicircle\n    \n    // Darken outside upper half-plane\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete hyperbolic triangle tiling with simple coloring.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n    }\n    \n    // Simple coloring\n    vec3 color = vec3(0.6, 0.7, 0.9);\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nHyperbolic tiling colored by iteration count showing alternating pattern.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        // Reflect across left vertical line (x = -1, want x &gt; -1)\n        z = reflectIntoVertical(z, -1.0, -1.0);\n        \n        // Reflect across right vertical line (x = 1, want x &lt; 1)\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        \n        // Reflect across semicircle (from -1 to 1, want outside/above)\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        // If point didn't move, we're inside\n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken if below the real axis (outside hyperbolic space)\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete hyperbolic tiling with visible structure (reference for homework).\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\nfloat hyperbolicDistance(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float diff2 = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + diff2 / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 4.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift to upper half-plane (need y &gt; 0)\n    vec2 z = uv + vec2(0.0, 1.5);\n    \n    // Fold into the (2,3,∞) triangle\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Draw geodesic edges\n    // Left vertical line (x = -1)\n    if(abs(z.x - (-1.0)) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Right vertical line (x = 1)\n    if(abs(z.x - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Semicircle from -1 to 1\n    vec2 rel = z - vec2(0.0, 0.0);\n    float dist_to_circle = abs(length(rel) - 1.0);\n    if(z.y &gt; 0.0 && dist_to_circle &lt; 0.02) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Draw vertices using hyperbolic distance\n    vec2 v1 = vec2(-1.0, 0.01);  // Left vertex (slightly above axis)\n    vec2 v2 = vec2(1.0, 0.01);   // Right vertex\n    \n    if(hyperbolicDistance(z, v1) &lt; 0.15 || hyperbolicDistance(z, v2) &lt; 0.15) {\n        color = vec3(1.0, 0.0, 0.0);  // Red vertices\n    }\n    \n    // Darken if below the real axis\n    if(z.y &lt; 0.0) {\n        color *= 0.3;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame (2,3,∞) tiling displayed in the Poincaré disk using the Cayley transform.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\n// Cayley transform: Poincaré disk -&gt; Upper half-plane\nvec2 cayleyDiskToUHP(vec2 w) {\n    // z = i(1-w)/(1+w)\n    vec2 numer = vec2(-w.y, 1.0 - w.x);  // i(1-w) = i - iw\n    vec2 denom = vec2(1.0 + w.x, w.y);    // 1 + w\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\n// Inverse Cayley: Upper half-plane -&gt; Poincaré disk\nvec2 cayleyUHPToDisk(vec2 z) {\n    // w = (z-i)/(z+i)\n    vec2 numer = vec2(z.x, z.y - 1.0);    // z - i\n    vec2 denom = vec2(z.x, z.y + 1.0);    // z + i\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for Poincaré disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 w = uv;  // Point in Poincaré disk\n    \n    // Convert to upper half-plane\n    vec2 z = cayleyDiskToUHP(w);\n    \n    // Fold into the (2,3,∞) triangle (in UHP)\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken outside unit disk\n    if(length(w) &gt; 1.0) {\n        color *= 0.3;\n    }\n    \n    // Draw boundary circle\n    if(abs(length(w) - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 0.0);  // Yellow boundary\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame tiling in the Klein model where geodesics appear as straight lines.\nvec2 reflectIntoVertical(vec2 z, float x_pos, float side) {\n    if((z.x - x_pos) * side &lt; 0.0) return z;\n    z.x = 2.0 * x_pos - z.x;\n    return z;\n}\n\nvec2 reflectIntoCircular(vec2 z, float p, float q, float side) {\n    float center = (p + q) / 2.0;\n    float radius = abs(p - q) / 2.0;\n    vec2 rel = z - vec2(center, 0.0);\n    float dist2 = dot(rel, rel);\n    if((dist2 - radius * radius) * side &gt; 0.0) return z;\n    \n    return vec2(center, 0.0) + (radius * radius) * rel / dist2;\n}\n\n// Poincaré disk -&gt; Klein disk\nvec2 poincareToKlein(vec2 w) {\n    float w_mag2 = dot(w, w);\n    return 2.0 * w / (1.0 + w_mag2);\n}\n\n// Klein disk -&gt; Poincaré disk\nvec2 kleinToPoincare(vec2 p) {\n    float p_mag2 = dot(p, p);\n    float denom = 1.0 + sqrt(1.0 - p_mag2);\n    return p / denom;\n}\n\n// Cayley transform: Poincaré disk -&gt; Upper half-plane\nvec2 cayleyDiskToUHP(vec2 w) {\n    vec2 numer = vec2(-w.y, 1.0 - w.x);\n    vec2 denom = vec2(1.0 + w.x, w.y);\n    \n    float denom_mag2 = dot(denom, denom);\n    return vec2(\n        (numer.x * denom.x + numer.y * denom.y) / denom_mag2,\n        (numer.y * denom.x - numer.x * denom.y) / denom_mag2\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup for Klein disk\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 k = uv;  // Point in Klein disk\n    \n    // Convert Klein -&gt; Poincaré -&gt; Upper half-plane\n    vec2 w = kleinToPoincare(k);\n    vec2 z = cayleyDiskToUHP(w);\n    \n    // Fold into the (2,3,∞) triangle (in UHP)\n    int foldCount = 0;\n    for(int i = 0; i &lt; 50; i++) {\n        vec2 z_old = z;\n        \n        z = reflectIntoVertical(z, -1.0, -1.0);\n        z = reflectIntoVertical(z, 1.0, 1.0);\n        z = reflectIntoCircular(z, -1.0, 1.0, 1.0);\n        \n        if(length(z - z_old) &lt; 0.0001) break;\n        foldCount++;\n    }\n    \n    // Color by fold count parity\n    float parity = mod(float(foldCount), 2.0);\n    vec3 color;\n    if(parity &lt; 0.5) {\n        color = vec3(0.7, 0.8, 0.9);  // Light blue\n    } else {\n        color = vec3(0.5, 0.6, 0.8);  // Darker blue\n    }\n    \n    // Darken outside unit disk\n    if(length(k) &gt; 1.0) {\n        color *= 0.3;\n    }\n    \n    // Draw boundary circle\n    if(abs(length(k) - 1.0) &lt; 0.02) {\n        color = vec3(1.0, 1.0, 0.0);  // Yellow boundary\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day3-shaders.html#notes-on-using-these-shaders",
    "href": "OLD/appendices/day3-shaders.html#notes-on-using-these-shaders",
    "title": "1 Appendix: Complete Shader Code for Day 3",
    "section": "",
    "text": "Go to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\n\nEuclidean Tilings: - Adjust fold iteration count (20 is conservative, 10 often sufficient) - Change fundamental domain by modifying half-space parameters - Experiment with different shapes (triangles, pentagons, hexagons) - Try different color palettes\nHyperbolic Tilings: - Mouse interaction in H1/H2 (click and drag to move center) - Adjust the shift in z = uv + vec2(0.0, 1.5) to change visible region - Increase iteration count (50) for more precision near boundaries - Try different triangle configurations (requires computing new geodesics)\n\n\n\nIf a shader runs slowly: - Reduce iteration count - Lower resolution in Shadertoy settings - Simplify edge/vertex drawing code\n\n\n\nEuclidean extensions: - Implement other regular tilings (hexagons, pentagons) - Add animations by making half-spaces time-dependent - Create compound patterns with multiple fundamental domains\nHyperbolic extensions: - Implement (2,3,7) or (2,4,6) triangles - Decorate fundamental domains with patterns (Escher-style) - Explore pentagon tilings - Animate between different models\n\n\n\nEuclidean vs Hyperbolic: Compare E7 and H4 - notice how the algorithm structure is identical but the reflection operations differ. This demonstrates the power of mathematical abstraction!\nModel Comparisons: Run H4 (upper half-plane), H7 (Poincaré disk), and H8 (Klein disk) side by side. The same mathematical object looks dramatically different depending on the model, but the underlying hyperbolic geometry is identical.\nEdge Behavior: In H6, notice how triangle edges near the boundary (y → 0) appear more compressed. This visualizes the 1/y² conformal factor in the hyperbolic metric."
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html",
    "href": "OLD/appendices/day1-shaders.html",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "This appendix provides complete, standalone Shadertoy code for each shader program presented in Day 1. Each listing includes all necessary setup and can be copied directly into Shadertoy (https://www.shadertoy.com/new) and run immediately.\n\n\n\nThe simplest possible shader - every pixel is red.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\n\n\n\nUsing iTime to animate the red channel.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\n\n\n\n\nVisualizing the coordinate system by mapping position to color.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\n\n\n\n\nDividing the plane into two regions based on a linear function.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame as above but using step() and mix().\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float s = step(0.0, p.x);  // 0 on left, 1 on right\n    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDividing along an arbitrary line \\(ax + by + c = 0\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.0, b = 1.0, c = 0.0;\n    float L = a * p.x + b * p.y + c;\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nUsing distance from origin to create a disk.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nUsing distance value itself to create a gradient.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\n    intensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\n    \n    vec3 color = vec3(intensity);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDrawing just the boundary of a circle with hard threshold.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float thickness = 0.05;\n    \n    float circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\n    vec3 color = vec3(circle_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nAnti-aliased circle outline using smoothstep().\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float thickness = 0.05;\n    \n    float circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\n    vec3 color = vec3(circle_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nUsing mod() to create repeating circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nCreating a checkerboard pattern behind the circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nFull example combining grid cells, checkerboard, and circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDrawing a parabola using the implicit equation \\(y = x^2\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.y - p.x * p.x;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDrawing a circle using the implicit equation \\(x^2 + y^2 = r^2\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float r = 1.0;\n    float F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDrawing a hyperbola \\(xy = 1\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.x * p.y - 1.0;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDrawing an ellipse \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 2.0, b = 1.0;\n    float F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nTemplate for the required homework assignment.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // TODO: Draw x-axis (|y| &lt; thickness)\n    // TODO: Draw y-axis (|x| &lt; thickness)\n    // TODO: Draw parabola (|y - (ax² + bx + c)| &lt; thickness)\n\n    //ToDO: DRAW circles around the roots\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete implementation of the required homework.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Axes\n    float axis_thickness = 0.02;\n    float x_axis_mask = abs(p.y) &lt; axis_thickness ? 1.0 : 0.0;\n    float y_axis_mask = abs(p.x) &lt; axis_thickness ? 1.0 : 0.0;\n    vec3 axis_color = vec3(0.3, 0.3, 0.3);\n    \n    // Parabola: F(x,y) = y - (ax² + bx + c) = 0\n    float F = p.y - (a * p.x * p.x + b * p.x + c);\n    float curve_thickness = 0.08;\n    float parabola_mask = abs(F) &lt; curve_thickness ? 1.0 : 0.0;\n    vec3 parabola_color = vec3(1.0, 0.8, 0.0);\n    \n    // Combine (axes behind parabola)\n    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\n    color = mix(color, parabola_color, parabola_mask);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nAnimating through different circle radii.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Animated radius\n    float r = 1.0 + 0.5 * sin(iTime);\n    \n    float F = dot(p, p) - r * r;\n    float thickness = 0.08;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nEllipse that rotates over time.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Rotation angle from time\n    float theta = iTime * 0.5;\n    \n    // Rotate coordinates\n    vec2 p_rot = vec2(\n        p.x * cos(theta) + p.y * sin(theta),\n        -p.x * sin(theta) + p.y * cos(theta)\n    );\n    \n    // Ellipse in rotated coordinates\n    float a = 2.0, b = 1.0;\n    float F = (p_rot.x * p_rot.x) / (a * a) + (p_rot.y * p_rot.y) / (b * b) - 1.0;\n    float thickness = 0.08;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nExample of a custom tiling pattern using circles and symmetry.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Use symmetry within each cell\n    cell_p = abs(cell_p);  // 4-fold symmetry\n    \n    // Multiple circles at different positions\n    float d1 = length(cell_p - vec2(0.2, 0.2));\n    float d2 = length(cell_p - vec2(0.4, 0.0));\n    float d3 = length(cell_p - vec2(0.0, 0.4));\n    \n    float r = 0.15;\n    float mask = (d1 &lt; r || d2 &lt; r || d3 &lt; r) ? 1.0 : 0.0;\n    \n    // Vary color by cell position\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 color1 = vec3(0.2, 0.4, 0.6);\n    vec3 color2 = vec3(0.6, 0.2, 0.4);\n    vec3 bg = mix(color1, color2, checker);\n    \n    vec3 circle_color = vec3(1.0, 0.9, 0.7);\n    vec3 color = mix(bg, circle_color, mask);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nPattern that pulses based on time and distance.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Distance from cell center\n    float d = length(cell_p);\n    \n    // Distance from origin (in cell coordinates)\n    float cell_dist = length(cell_id);\n    \n    // Animated radius that propagates outward\n    float r = 0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5);\n    \n    float mask = smoothstep(r + 0.05, r - 0.05, d);\n    \n    // Color based on cell distance\n    vec3 color1 = vec3(0.2, 0.3, 0.5);\n    vec3 color2 = vec3(0.8, 0.3, 0.4);\n    float t = fract(cell_dist * 0.2);\n    vec3 circle_color = mix(color1, color2, t);\n    \n    vec3 bg = vec3(0.1, 0.1, 0.15);\n    vec3 color = mix(bg, circle_color, mask);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDrawing a lemniscate using naive |F| &lt; thickness. Notice the non-uniform visual thickness—especially near the origin where the curve self-intersects and the gradient approaches zero.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)\n    float a = 1.0;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n    // Naive threshold - thickness varies!\n    float thickness = 0.15;\n    vec3 color = (abs(F) &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSame curve, but now we divide by the gradient magnitude to approximate the signed distance function. This gives uniform visual thickness even near the singular point at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)\n    float a = 1.0;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n    // Compute gradient analytically:\n    // ∂F/∂x = 4x(x² + y²) - 2a²x = 2x(2r² - a²)\n    // ∂F/∂y = 4y(x² + y²) + 2a²y = 2y(2r² + a²)\n    vec2 grad = vec2(\n        2.0 * p.x * (2.0 * r2 - a * a),\n        2.0 * p.y * (2.0 * r2 + a * a)\n    );\n\n    // Approximate signed distance: |F| / |∇F|\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);  // avoid division by zero\n\n    // Uniform thickness\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nCassini ovals are curves defined by the product of distances from two foci being constant. The implicit form is \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). By animating the parameter \\(a\\), we see the phase transition: two separate loops when \\(a &lt; c\\), a lemniscate when \\(a = c\\), and a single oval when \\(a &gt; c\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Cassini oval parameters\n    float c = 1.0;  // half-distance between foci\n    float a = 0.8 + 0.4 * sin(iTime * 0.5);  // animate through phase transition\n\n    // Implicit equation: (x² + y²)² - 2c²(x² - y²) = a⁴ - c⁴\n    float r2 = dot(p, p);\n    float c2 = c * c;\n    float a4 = a * a * a * a;\n    float c4 = c2 * c2;\n    float F = r2 * r2 - 2.0 * c2 * (p.x * p.x - p.y * p.y) - (a4 - c4);\n\n    // Gradient: ∂F/∂x = 4x(r²) - 4c²x = 4x(r² - c²)\n    //           ∂F/∂y = 4y(r²) + 4c²y = 4y(r² + c²)\n    vec2 grad = vec2(\n        4.0 * p.x * (r2 - c2),\n        4.0 * p.y * (r2 + c2)\n    );\n\n    // Approximate signed distance\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);\n\n    // Draw curve with uniform thickness\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nElliptic curves in Weierstrass form: \\(y^2 = x^3 + ax + b\\). The discriminant \\(\\Delta = 4a^3 + 27b^2\\) determines smoothness. We animate along a circle in \\((a,b)\\) parameter space of radius \\(\\sqrt{13}\\), which passes through the singular points \\((-3, \\pm 2)\\) where the curve develops a node (self-intersection).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Circle in (a,b) parameter space passing through singularities at (-3, ±2)\n    float r = sqrt(13.0);\n    float a = r * cos(iTime * 0.3);\n    float b = r * sin(iTime * 0.3);\n\n    // Elliptic curve: y² = x³ + ax + b\n    // Implicit form: F = y² - x³ - ax - b = 0\n    float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n\n    // Gradient: ∂F/∂x = -3x² - a, ∂F/∂y = 2y\n    vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);\n\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nGo to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\n\nAll shaders (except A1 and A2) use the standard coordinate transformation:\nvec2 uv = fragCoord / iResolution.xy;  // Normalize to [0,1]\nuv = uv - 0.5;                          // Center at origin\nuv.x *= iResolution.x / iResolution.y; // Aspect ratio correction\nvec2 p = uv * 4.0;                      // Scale viewing window\nThis gives you coordinates centered at the origin with equal scaling in x and y.\n\n\n\nCoordinate scaling: - Change uv * 4.0 to zoom in/out (smaller number = zoom in)\nColors: - Modify vec3(r, g, b) values (each in range [0, 1]) - Red: vec3(1.0, 0.0, 0.0) - Green: vec3(0.0, 1.0, 0.0) - Blue: vec3(0.0, 0.0, 1.0) - Yellow: vec3(1.0, 1.0, 0.0) - Cyan: vec3(0.0, 1.0, 1.0) - Magenta: vec3(1.0, 0.0, 1.0)\nDistance and thickness: - thickness parameters control line width - Larger thickness = thicker lines/curves\nGrid patterns: - spacing controls grid cell size - Smaller spacing = more cells\nAnimation: - Use iTime for time-based animation - sin(iTime) oscillates between -1 and 1 - 0.5 + 0.5 * sin(iTime) oscillates between 0 and 1\n\n\n\nMake circles pulse:\nfloat r = 0.3 + 0.1 * sin(iTime);\nMake grid spacing animate:\nfloat spacing = 1.0 + 0.3 * sin(iTime * 0.5);\nAdd mouse interaction:\nvec2 mouse = iMouse.xy / iResolution.xy;\nmouse = mouse - 0.5;\nmouse.x *= iResolution.x / iResolution.y;\n// Use mouse position to control parameters\nCombine techniques: - Put implicit curves on a grid using mod() - Add animation to any parameter with iTime - Use distance fields to create smooth transitions\n\n\n\nShader won’t compile: - Check for missing semicolons - Make sure all numbers are floats: 1.0 not 1 - Verify parentheses and braces are balanced\nNothing shows up: - Check your coordinate scaling - might be zoomed too far in/out - Verify colors are in [0, 1] range - Make sure alpha channel is 1.0: vec4(color, 1.0)\nCircles look like ellipses: - Make sure you include the aspect ratio correction: uv.x *= iResolution.x / iResolution.y;\n\n\n\nOnce you’re comfortable with these basics: - Combine multiple techniques in one shader - Create your own implicit curves - Design custom tiling patterns - Add animation and interactivity - Experiment with color palettes and smooth transitions\nThe goal is to understand how coordinate transformations, distance functions, and conditionals work together to create mathematical visualizations on the GPU!"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a1.-basic-red-screen",
    "href": "OLD/appendices/day1-shaders.html#a1.-basic-red-screen",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "The simplest possible shader - every pixel is red.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a2.-animated-color-pulsing-red",
    "href": "OLD/appendices/day1-shaders.html#a2.-animated-color-pulsing-red",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Using iTime to animate the red channel.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a3.-coordinate-visualization",
    "href": "OLD/appendices/day1-shaders.html#a3.-coordinate-visualization",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Visualizing the coordinate system by mapping position to color.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a4.-half-plane-coloring-ternary-operator",
    "href": "OLD/appendices/day1-shaders.html#a4.-half-plane-coloring-ternary-operator",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Dividing the plane into two regions based on a linear function.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a5.-half-plane-with-step-function",
    "href": "OLD/appendices/day1-shaders.html#a5.-half-plane-with-step-function",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Same as above but using step() and mix().\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float s = step(0.0, p.x);  // 0 on left, 1 on right\n    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a6.-arbitrary-half-plane",
    "href": "OLD/appendices/day1-shaders.html#a6.-arbitrary-half-plane",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Dividing along an arbitrary line \\(ax + by + c = 0\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.0, b = 1.0, c = 0.0;\n    float L = a * p.x + b * p.y + c;\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a7.-filled-circle",
    "href": "OLD/appendices/day1-shaders.html#a7.-filled-circle",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Using distance from origin to create a disk.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a8.-distance-based-coloring-radial-gradient",
    "href": "OLD/appendices/day1-shaders.html#a8.-distance-based-coloring-radial-gradient",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Using distance value itself to create a gradient.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\n    intensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\n    \n    vec3 color = vec3(intensity);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a9.-circle-outline-hard-edge",
    "href": "OLD/appendices/day1-shaders.html#a9.-circle-outline-hard-edge",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Drawing just the boundary of a circle with hard threshold.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float thickness = 0.05;\n    \n    float circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\n    vec3 color = vec3(circle_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a10.-circle-outline-smooth-with-smoothstep",
    "href": "OLD/appendices/day1-shaders.html#a10.-circle-outline-smooth-with-smoothstep",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Anti-aliased circle outline using smoothstep().\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float thickness = 0.05;\n    \n    float circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\n    vec3 color = vec3(circle_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a11.-grid-of-circles",
    "href": "OLD/appendices/day1-shaders.html#a11.-grid-of-circles",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Using mod() to create repeating circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a12.-grid-with-alternating-background",
    "href": "OLD/appendices/day1-shaders.html#a12.-grid-with-alternating-background",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Creating a checkerboard pattern behind the circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a13.-complete-grid-pattern",
    "href": "OLD/appendices/day1-shaders.html#a13.-complete-grid-pattern",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Full example combining grid cells, checkerboard, and circles.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a14.-implicit-curve-parabola",
    "href": "OLD/appendices/day1-shaders.html#a14.-implicit-curve-parabola",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Drawing a parabola using the implicit equation \\(y = x^2\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.y - p.x * p.x;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a15.-implicit-curve-circle",
    "href": "OLD/appendices/day1-shaders.html#a15.-implicit-curve-circle",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Drawing a circle using the implicit equation \\(x^2 + y^2 = r^2\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float r = 1.0;\n    float F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a16.-implicit-curve-hyperbola",
    "href": "OLD/appendices/day1-shaders.html#a16.-implicit-curve-hyperbola",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Drawing a hyperbola \\(xy = 1\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.x * p.y - 1.0;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a17.-implicit-curve-ellipse",
    "href": "OLD/appendices/day1-shaders.html#a17.-implicit-curve-ellipse",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Drawing an ellipse \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 2.0, b = 1.0;\n    float F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;\n    float thickness = 0.1;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a18.-parabola-graphing-calculator-homework-template",
    "href": "OLD/appendices/day1-shaders.html#a18.-parabola-graphing-calculator-homework-template",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Template for the required homework assignment.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // TODO: Draw x-axis (|y| &lt; thickness)\n    // TODO: Draw y-axis (|x| &lt; thickness)\n    // TODO: Draw parabola (|y - (ax² + bx + c)| &lt; thickness)\n\n    //ToDO: DRAW circles around the roots\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a19.-parabola-graphing-calculator-complete-solution",
    "href": "OLD/appendices/day1-shaders.html#a19.-parabola-graphing-calculator-complete-solution",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Complete implementation of the required homework.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Axes\n    float axis_thickness = 0.02;\n    float x_axis_mask = abs(p.y) &lt; axis_thickness ? 1.0 : 0.0;\n    float y_axis_mask = abs(p.x) &lt; axis_thickness ? 1.0 : 0.0;\n    vec3 axis_color = vec3(0.3, 0.3, 0.3);\n    \n    // Parabola: F(x,y) = y - (ax² + bx + c) = 0\n    float F = p.y - (a * p.x * p.x + b * p.x + c);\n    float curve_thickness = 0.08;\n    float parabola_mask = abs(F) &lt; curve_thickness ? 1.0 : 0.0;\n    vec3 parabola_color = vec3(1.0, 0.8, 0.0);\n    \n    // Combine (axes behind parabola)\n    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\n    color = mix(color, parabola_color, parabola_mask);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a20.-animated-curve-family-circle",
    "href": "OLD/appendices/day1-shaders.html#a20.-animated-curve-family-circle",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Animating through different circle radii.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Animated radius\n    float r = 1.0 + 0.5 * sin(iTime);\n    \n    float F = dot(p, p) - r * r;\n    float thickness = 0.08;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a21.-animated-curve-family-rotating-ellipse",
    "href": "OLD/appendices/day1-shaders.html#a21.-animated-curve-family-rotating-ellipse",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Ellipse that rotates over time.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Rotation angle from time\n    float theta = iTime * 0.5;\n    \n    // Rotate coordinates\n    vec2 p_rot = vec2(\n        p.x * cos(theta) + p.y * sin(theta),\n        -p.x * sin(theta) + p.y * cos(theta)\n    );\n    \n    // Ellipse in rotated coordinates\n    float a = 2.0, b = 1.0;\n    float F = (p_rot.x * p_rot.x) / (a * a) + (p_rot.y * p_rot.y) / (b * b) - 1.0;\n    float thickness = 0.08;\n    float curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n    \n    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a22.-beautiful-tiling-geometric-pattern",
    "href": "OLD/appendices/day1-shaders.html#a22.-beautiful-tiling-geometric-pattern",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Example of a custom tiling pattern using circles and symmetry.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Use symmetry within each cell\n    cell_p = abs(cell_p);  // 4-fold symmetry\n    \n    // Multiple circles at different positions\n    float d1 = length(cell_p - vec2(0.2, 0.2));\n    float d2 = length(cell_p - vec2(0.4, 0.0));\n    float d3 = length(cell_p - vec2(0.0, 0.4));\n    \n    float r = 0.15;\n    float mask = (d1 &lt; r || d2 &lt; r || d3 &lt; r) ? 1.0 : 0.0;\n    \n    // Vary color by cell position\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 color1 = vec3(0.2, 0.4, 0.6);\n    vec3 color2 = vec3(0.6, 0.2, 0.4);\n    vec3 bg = mix(color1, color2, checker);\n    \n    vec3 circle_color = vec3(1.0, 0.9, 0.7);\n    vec3 color = mix(bg, circle_color, mask);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a23.-beautiful-tiling-distance-based-animation",
    "href": "OLD/appendices/day1-shaders.html#a23.-beautiful-tiling-distance-based-animation",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Pattern that pulses based on time and distance.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Distance from cell center\n    float d = length(cell_p);\n    \n    // Distance from origin (in cell coordinates)\n    float cell_dist = length(cell_id);\n    \n    // Animated radius that propagates outward\n    float r = 0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5);\n    \n    float mask = smoothstep(r + 0.05, r - 0.05, d);\n    \n    // Color based on cell distance\n    vec3 color1 = vec3(0.2, 0.3, 0.5);\n    vec3 color2 = vec3(0.8, 0.3, 0.4);\n    float t = fract(cell_dist * 0.2);\n    vec3 circle_color = mix(color1, color2, t);\n    \n    vec3 bg = vec3(0.1, 0.1, 0.15);\n    vec3 color = mix(bg, circle_color, mask);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a24.-lemniscate-of-bernoulli-naive-threshold",
    "href": "OLD/appendices/day1-shaders.html#a24.-lemniscate-of-bernoulli-naive-threshold",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Drawing a lemniscate using naive |F| &lt; thickness. Notice the non-uniform visual thickness—especially near the origin where the curve self-intersects and the gradient approaches zero.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)\n    float a = 1.0;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n    // Naive threshold - thickness varies!\n    float thickness = 0.15;\n    vec3 color = (abs(F) &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a25.-lemniscate-of-bernoulli-gradient-corrected",
    "href": "OLD/appendices/day1-shaders.html#a25.-lemniscate-of-bernoulli-gradient-corrected",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Same curve, but now we divide by the gradient magnitude to approximate the signed distance function. This gives uniform visual thickness even near the singular point at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)\n    float a = 1.0;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n    // Compute gradient analytically:\n    // ∂F/∂x = 4x(x² + y²) - 2a²x = 2x(2r² - a²)\n    // ∂F/∂y = 4y(x² + y²) + 2a²y = 2y(2r² + a²)\n    vec2 grad = vec2(\n        2.0 * p.x * (2.0 * r2 - a * a),\n        2.0 * p.y * (2.0 * r2 + a * a)\n    );\n\n    // Approximate signed distance: |F| / |∇F|\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);  // avoid division by zero\n\n    // Uniform thickness\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a26.-cassini-ovals-animated",
    "href": "OLD/appendices/day1-shaders.html#a26.-cassini-ovals-animated",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Cassini ovals are curves defined by the product of distances from two foci being constant. The implicit form is \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). By animating the parameter \\(a\\), we see the phase transition: two separate loops when \\(a &lt; c\\), a lemniscate when \\(a = c\\), and a single oval when \\(a &gt; c\\).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Cassini oval parameters\n    float c = 1.0;  // half-distance between foci\n    float a = 0.8 + 0.4 * sin(iTime * 0.5);  // animate through phase transition\n\n    // Implicit equation: (x² + y²)² - 2c²(x² - y²) = a⁴ - c⁴\n    float r2 = dot(p, p);\n    float c2 = c * c;\n    float a4 = a * a * a * a;\n    float c4 = c2 * c2;\n    float F = r2 * r2 - 2.0 * c2 * (p.x * p.x - p.y * p.y) - (a4 - c4);\n\n    // Gradient: ∂F/∂x = 4x(r²) - 4c²x = 4x(r² - c²)\n    //           ∂F/∂y = 4y(r²) + 4c²y = 4y(r² + c²)\n    vec2 grad = vec2(\n        4.0 * p.x * (r2 - c2),\n        4.0 * p.y * (r2 + c2)\n    );\n\n    // Approximate signed distance\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);\n\n    // Draw curve with uniform thickness\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#a27.-elliptic-curves-animated",
    "href": "OLD/appendices/day1-shaders.html#a27.-elliptic-curves-animated",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Elliptic curves in Weierstrass form: \\(y^2 = x^3 + ax + b\\). The discriminant \\(\\Delta = 4a^3 + 27b^2\\) determines smoothness. We animate along a circle in \\((a,b)\\) parameter space of radius \\(\\sqrt{13}\\), which passes through the singular points \\((-3, \\pm 2)\\) where the curve develops a node (self-intersection).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n\n    // Circle in (a,b) parameter space passing through singularities at (-3, ±2)\n    float r = sqrt(13.0);\n    float a = r * cos(iTime * 0.3);\n    float b = r * sin(iTime * 0.3);\n\n    // Elliptic curve: y² = x³ + ax + b\n    // Implicit form: F = y² - x³ - ax - b = 0\n    float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n\n    // Gradient: ∂F/∂x = -3x² - a, ∂F/∂y = 2y\n    vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n\n    float gradLen = length(grad);\n    float dist = abs(F) / max(gradLen, 0.01);\n\n    float thickness = 0.05;\n    vec3 color = (dist &lt; thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n\n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day1-shaders.html#notes-on-using-these-shaders",
    "href": "OLD/appendices/day1-shaders.html#notes-on-using-these-shaders",
    "title": "1 Appendix: Complete Shader Code for Day 1",
    "section": "",
    "text": "Go to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\n\nAll shaders (except A1 and A2) use the standard coordinate transformation:\nvec2 uv = fragCoord / iResolution.xy;  // Normalize to [0,1]\nuv = uv - 0.5;                          // Center at origin\nuv.x *= iResolution.x / iResolution.y; // Aspect ratio correction\nvec2 p = uv * 4.0;                      // Scale viewing window\nThis gives you coordinates centered at the origin with equal scaling in x and y.\n\n\n\nCoordinate scaling: - Change uv * 4.0 to zoom in/out (smaller number = zoom in)\nColors: - Modify vec3(r, g, b) values (each in range [0, 1]) - Red: vec3(1.0, 0.0, 0.0) - Green: vec3(0.0, 1.0, 0.0) - Blue: vec3(0.0, 0.0, 1.0) - Yellow: vec3(1.0, 1.0, 0.0) - Cyan: vec3(0.0, 1.0, 1.0) - Magenta: vec3(1.0, 0.0, 1.0)\nDistance and thickness: - thickness parameters control line width - Larger thickness = thicker lines/curves\nGrid patterns: - spacing controls grid cell size - Smaller spacing = more cells\nAnimation: - Use iTime for time-based animation - sin(iTime) oscillates between -1 and 1 - 0.5 + 0.5 * sin(iTime) oscillates between 0 and 1\n\n\n\nMake circles pulse:\nfloat r = 0.3 + 0.1 * sin(iTime);\nMake grid spacing animate:\nfloat spacing = 1.0 + 0.3 * sin(iTime * 0.5);\nAdd mouse interaction:\nvec2 mouse = iMouse.xy / iResolution.xy;\nmouse = mouse - 0.5;\nmouse.x *= iResolution.x / iResolution.y;\n// Use mouse position to control parameters\nCombine techniques: - Put implicit curves on a grid using mod() - Add animation to any parameter with iTime - Use distance fields to create smooth transitions\n\n\n\nShader won’t compile: - Check for missing semicolons - Make sure all numbers are floats: 1.0 not 1 - Verify parentheses and braces are balanced\nNothing shows up: - Check your coordinate scaling - might be zoomed too far in/out - Verify colors are in [0, 1] range - Make sure alpha channel is 1.0: vec4(color, 1.0)\nCircles look like ellipses: - Make sure you include the aspect ratio correction: uv.x *= iResolution.x / iResolution.y;\n\n\n\nOnce you’re comfortable with these basics: - Combine multiple techniques in one shader - Create your own implicit curves - Design custom tiling patterns - Add animation and interactivity - Experiment with color palettes and smooth transitions\nThe goal is to understand how coordinate transformations, distance functions, and conditionals work together to create mathematical visualizations on the GPU!"
  },
  {
    "objectID": "OLD/appendices/schottky.html",
    "href": "OLD/appendices/schottky.html",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "A (classical) Schottky group of rank \\(g\\) is built from \\(2g\\) disjoint Jordan curves (we use circles) on the Riemann sphere. We pair them up \\((C_1, C_1'), \\dots, (C_g, C_g')\\), and for each pair we choose a Möbius map that sends the exterior of \\(C_i\\) to the interior of \\(C_i'\\). The group generated by these \\(g\\) maps is free and discrete.\nSo the fundamental move is:\n\npick two circles,\nsend exterior of the first to interior of the second,\n(optionally) rotate inside the second.\n\nThat is exactly the move we will encode in GLSL.\n\n\n\nMapping the exterior of one circle to the interior of another\n\n\n\n\n\n\nLet\n\nCircle 1: center \\(c_1 \\in \\mathbb C\\), radius \\(r_1 &gt; 0\\)\nCircle 2: center \\(c_2 \\in \\mathbb C\\), radius \\(r_2 &gt; 0\\)\n\nWe want a Möbius map \\(f\\) with the property\n\nif \\(|z - c_1| &gt; r_1\\) (outside circle 1) then \\(|f(z) - c_2| &lt; r_2\\) (inside circle 2).\n\nThere is a standard 3-step recipe:\n\nNormalize circle 1 to the unit circle: \\[\nT_1(z) = \\frac{z - c_1}{r_1}.\n\\]\nInvert in the unit circle (this swaps inside and outside): \\[\nJ(w) = \\frac{1}{w}.\n\\]\nDenormalize to circle 2: \\[\nT_2^{-1}(w) = c_2 + r_2 w.\n\\]\n\nSo the Möbius map is \\[\nf(z) = T_2^{-1}( J( T_1(z) ) ) = c_2 + \\frac{r_1 r_2}{z - c_1}.\n\\]\nThis is already in closed form:\n\\[\n\\boxed{ f(z) = c_2 + \\frac{r_1 r_2}{z - c_1} }.\n\\]\nYou can check: if \\(|z - c_1| &gt; r_1\\) then \\(\\left| \\frac{r_1}{z - c_1} \\right| &lt; 1\\) so \\(|f(z) - c_2| = r_2 \\left|\\frac{r_1}{z - c_1}\\right| &lt; r_2\\).\n\n\n\n\nGLSL doesn’t have complex numbers, so we’ll use vec2 everywhere. We do want to write things in complex style (multiply, divide, take sqrt), so let’s define those once.\n// -----------------------------------------\n// complex helpers\n// -----------------------------------------\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\n\nvec2 cmul(vec2 a, vec2 b) {\n    // (a.x + i a.y)(b.x + i b.y)\n    return vec2(a.x*b.x - a.y*b.y,\n                a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    // a / b = a * conj(b) / |b|^2\n    float d = dot(b, b);\n    return vec2( (a.x*b.x + a.y*b.y) / d,\n                 (a.y*b.x - a.x*b.y) / d );\n}\n\nvec2 cfloat(float x) {\n    return vec2(x, 0.0);\n}\nLet’s also define a circle struct:\n// -----------------------------------------\n// circle data\n// -----------------------------------------\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nWe will carry this struct through the whole document.\n\n\n\n\nLet’s translate the exact 3-step recipe:\n\ncircle → unit circle,\ninvert in unit circle,\nunit circle → circle.\n\nWe also add a rotation at the end (useful in Schottky generators).\n// map arbitrary circle to unit circle\nvec2 toUnitCircle(vec2 z, Circle c) {\n    return (z - c.center) / c.radius;\n}\n\n// map unit circle to arbitrary circle\nvec2 fromUnitCircle(vec2 w, Circle c) {\n    return c.radius * w + c.center;\n}\n\n// inversion in unit circle\nvec2 invertUnit(vec2 w) {\n    return cdiv(vec2(1.0, 0.0), w);\n}\nNow the Schottky generator:\n// schottky-like map: exterior(A) -&gt; interior(B)\n// rotation is angle in radians applied INSIDE B\n// scale is an inout used for distance estimation later\nvec2 schottkyMap(vec2 z, Circle A, Circle B, float rotation, inout float scale) {\n    // step 1: normalize to A\n    vec2 zA = toUnitCircle(z, A);\n\n    // derivative of inversion: |d(1/z)| = 1/|z|^2\n    float inversionScale = 1.0 / dot(zA, zA);\n\n    // step 2: invert\n    vec2 inv = invertUnit(zA);\n\n    // step 3: map to B\n    vec2 inB = fromUnitCircle(inv, B);\n\n    // total radius scale = r2 / r1\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    // step 4: rotate inside B\n    vec2 unitB = (inB - B.center) / B.radius;\n    float c = cos(rotation);\n    float s = sin(rotation);\n    vec2 rotated = vec2(c*unitB.x - s*unitB.y,\n                        s*unitB.x + c*unitB.y);\n\n    return B.center + B.radius * rotated;\n}\nThis is the pedagogical version: each line corresponds to something we can draw on the board.\n\n\n\n\nGiven \\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\] solve \\(f(z) = z\\):\n[ (z - c_1)(z - c_2) = r_1 r_2] [ z^2 - (c_1 + c_2)z + c_1 c_2 - r_1 r_2 = 0.]\nSo \\[\nz = \\frac{c_1 + c_2 \\pm \\sqrt{(c_1 - c_2)^2 + 4 r_1 r_2}}{2}.\n\\]\nThose two solutions are the endpoints of the axis — in \\(\\widehat{\\mathbb C}\\) these are just two points, but in \\(\\mathbb H^3\\) they determine the unique geodesic the map acts along.\nWe need a complex sqrt:\n// principal complex square root\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float t = sqrt(0.5*(r + z.x));\n    float s = (z.y &gt;= 0.0)\n        ? sqrt(0.5*(r - z.x))\n        : -sqrt(0.5*(r - z.x));\n    return vec2(t, s);\n}\nNow the fixed points:\nvoid schottkyEndpoints(Circle A, Circle B,\n                       out vec2 zPlus, out vec2 zMinus, out vec2 Delta)\n{\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n\n    vec2 sum   = c1 + c2;\n    vec2 diff  = c1 - c2;\n    vec2 diff2 = cmul(diff, diff);\n\n    Delta = csqrt( diff2 + cfloat(4.0 * r1 * r2) );\n\n    zPlus  = 0.5 * (sum + Delta);\n    zMinus = 0.5 * (sum - Delta);\n}\nWe’ll call these pPlus and pMinus or p_+, p_-.\n\n\n\n\nEvery loxodromic Möbius transformation with fixed points \\(p_-\\) and \\(p_+\\) can be conjugated to \\(w \\mapsto \\lambda w\\), i.e. a pure dilation/spiral fixing \\(0\\) and \\(\\infty\\).\nDefine \\[\nh(z) = \\frac{z - p_-}{z - p_+}.\n\\]\nThen \\[\ng = h \\circ f \\circ h^{-1}\n\\] fixes \\(0\\) and \\(\\infty\\), so \\(g(w) = \\lambda w\\) for some \\(\\lambda \\in \\mathbb C^\\times\\).\nTo animate, define \\[\ng_t(w) = \\lambda^t w, \\quad f_t = h^{-1} \\circ g_t \\circ h.\n\\]\nSo the movie is \\[\nf_t(z) = h^{-1}( \\lambda^t h(z) ).\n\\]\nWe already wrote csqrt. Now write the conjugators and complex log/exp:\nvec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {\n    return cdiv(z - pMinus, z - pPlus);\n}\n\nvec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {\n    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));\n}\n\n// complex log\nvec2 clogc(vec2 z) {\n    float r = length(z);\n    float th = atan(z.y, z.x);\n    return vec2(log(r), th);\n}\n\n// complex exp\nvec2 cexpc(vec2 z) {\n    float ex = exp(z.x);\n    return vec2(ex * cos(z.y), ex * sin(z.y));\n}\nWe also need the multiplier. From the derivation:\n\\[\n\\lambda = - \\frac{4 r_1 r_2}{(c_2 - c_1 - \\Delta)^2}\n\\]\nso\nvec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n\n    vec2 denom  = (c2 - c1) - Delta;\n    vec2 denom2 = cmul(denom, denom);\n    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);\n    return cdiv(num, denom2);\n}\nFinally the flow:\nvec2 schottkyFlow(vec2 z,\n                  vec2 pPlus, vec2 pMinus,\n                  vec2 lambda,\n                  float t)\n{\n    // lambda^t = exp(t * log(lambda))\n    vec2 loglam = clogc(lambda);\n    vec2 lam_t  = cexpc(t * loglam);\n\n    vec2 w  = hMap(z, pPlus, pMinus);\n    vec2 w2 = cmul(lam_t, w);\n    return hInv(w2, pPlus, pMinus);\n}\nSo now we have every mathematical piece.\n\n\n\n\nThis is a complete Shadertoy-style fragment shader that:\n\ndefines two circles;\ncomputes their loxodromic map;\nfinds the fixed points;\nanimates the identification by applying \\(f_t\\) to sample points on circle 1;\ndraws the circles and the fixed points.\n\nYou can paste this as-is into Shadertoy.\n// =========================================\n// Shader 1: animated Schottky identification\n// =========================================\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2((a.x*b.x + a.y*b.y)/d,\n                (a.y*b.x - a.x*b.y)/d);\n}\nvec2 cfloat(float x) { return vec2(x,0.0); }\n\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float t = sqrt(0.5*(r + z.x));\n    float s = (z.y &gt;= 0.0) ? sqrt(0.5*(r - z.x)) : -sqrt(0.5*(r - z.x));\n    return vec2(t, s);\n}\n\nvoid schottkyEndpoints(Circle A, Circle B,\n                       out vec2 pPlus, out vec2 pMinus, out vec2 Delta)\n{\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n    vec2 sum   = c1 + c2;\n    vec2 diff  = c1 - c2;\n    vec2 diff2 = cmul(diff, diff);\n    Delta  = csqrt( diff2 + cfloat(4.0 * r1 * r2) );\n    pPlus  = 0.5 * (sum + Delta);\n    pMinus = 0.5 * (sum - Delta);\n}\n\nvec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n    vec2 denom  = (c2 - c1) - Delta;\n    vec2 denom2 = cmul(denom, denom);\n    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);\n    return cdiv(num, denom2);\n}\n\nvec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {\n    return cdiv(z - pMinus, z - pPlus);\n}\nvec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {\n    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));\n}\nvec2 clogc(vec2 z) {\n    float r = length(z);\n    float th = atan(z.y, z.x);\n    return vec2(log(r), th);\n}\nvec2 cexpc(vec2 z) {\n    float ex = exp(z.x);\n    return vec2(ex * cos(z.y), ex * sin(z.y));\n}\nvec2 schottkyFlow(vec2 z, vec2 pPlus, vec2 pMinus, vec2 lambda, float t) {\n    vec2 loglam = clogc(lambda);\n    vec2 lam_t  = cexpc(t * loglam);\n    vec2 w  = hMap(z, pPlus, pMinus);\n    vec2 w2 = cmul(lam_t, w);\n    return hInv(w2, pPlus, pMinus);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // map screen to complex plane\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    float zoom = 1.8;\n    vec2 z = vec2(\n        (uv.x - 0.5) * 2.0 * zoom * aspect,\n        (uv.y - 0.5) * 2.0 * zoom\n    );\n\n    // define two circles\n    Circle A;\n    A.center = vec2(-0.6, 0.1);\n    A.radius = 0.35;\n\n    Circle B;\n    B.center = vec2(0.7, -0.15);\n    B.radius = 0.45;\n\n    // fixed points and lambda\n    vec2 pPlus, pMinus, Delta;\n    schottkyEndpoints(A, B, pPlus, pMinus, Delta);\n    vec2 lambda = schottkyLambda(A, B, Delta);\n\n    // time parameter in [0,1]\n    float t = 0.5 + 0.5 * sin(iTime * 0.7);\n\n    // background\n    vec3 col = vec3(0.95);\n\n    // draw circles\n    float dA = abs(length(z - A.center) - A.radius);\n    float dB = abs(length(z - B.center) - B.radius);\n    col = mix(col, vec3(0.1,0.3,0.9), smoothstep(0.005, 0.0, dA));\n    col = mix(col, vec3(0.9,0.2,0.2), smoothstep(0.005, 0.0, dB));\n\n    // draw fixed points\n    float f1 = smoothstep(0.03, 0.0, length(z - pPlus));\n    float f2 = smoothstep(0.03, 0.0, length(z - pMinus));\n    col = mix(col, vec3(1.0,0.8,0.0), f1);\n    col = mix(col, vec3(0.0,0.8,0.2), f2);\n\n    // draw moving image of circle A as dots\n    float imgMask = 0.0;\n    const int N = 80;\n    for (int i = 0; i &lt; N; i++) {\n        float ang = 6.2831853 * float(i) / float(N);\n        vec2 pt = A.center + A.radius * vec2(cos(ang), sin(ang));\n        vec2 imgPt = schottkyFlow(pt, pPlus, pMinus, lambda, t);\n        float m = smoothstep(0.03, 0.0, length(z - imgPt));\n        imgMask = max(imgMask, m);\n    }\n    col = mix(col, vec3(0.35, 0.05, 0.6), imgMask);\n\n    fragColor = vec4(col, 1.0);\n}\nThat’s a complete first shader.\n\n\n\nThese notes continue our exploration of Möbius transformations in GLSL, now focusing on Schottky groups—the simplest discrete groups of Möbius transformations—and how to visualize their limit sets using shader iteration.\nOur audience is assumed to know hyperbolic geometry and group theory but to be new to GPU programming. We’ll therefore explain everything twice: once mathematically, and once as a computational recipe.\n\n\n\nLet \\(\\Gamma \\subset \\mathrm{PSL}(2,\\mathbb{C})\\) be a finitely generated group of Möbius transformations. For any point \\(z_0 \\in \\widehat{\\mathbb{C}}\\), its orbit under \\(\\Gamma\\) is\n\\[\n\\Gamma z_0 = \\{ g(z_0) : g \\in \\Gamma \\}.\n\\]\nThe limit set of \\(\\Gamma\\) is the closure of this orbit:\n\\[\n\\Lambda(\\Gamma) = \\overline{ \\Gamma z_0 }.\n\\]\nFor a classical Schottky group—generated by finitely many loxodromic Möbius transformations each identifying two disjoint circles—the limit set \\(\\Lambda(\\Gamma)\\) is a Cantor-like subset of the sphere at infinity. The complement \\(\\Omega = \\widehat{\\mathbb{C}} \\setminus \\Lambda(\\Gamma)\\) is the domain of discontinuity, on which \\(\\Gamma\\) acts properly discontinuously.\nWe can visualize \\(\\Lambda(\\Gamma)\\) by testing points in the complex plane: points that escape the system of circles belong to \\(\\Omega\\), while points that never escape approximate the limit set.\n\n\n\nFigure: Two pairs of disjoint circles generate a rank-2 Schottky group. Arrows indicate how each pair is identified by a loxodromic Möbius transformation.\n\n\nFigure 1\n\n\n\n\n\n\n\nImagine throwing a dart at the complex plane: you hit a point \\(z\\). We now repeatedly apply the Schottky generators to fold the plane back into the fundamental domain.\nIf \\(z\\) lands inside one of the paired circles \\(C_i\\) (say the “interior” circle of generator \\(A_i\\)), we apply the Möbius transformation \\(A_i\\) to move it to the paired exterior circle \\(C_i'\\). If it lands inside \\(C_i'\\), we apply \\(A_i^{-1}\\) instead.\nIf after a few steps the point leaves all circles, we say it escaped (it lies in \\(\\Omega\\)). If it never escapes, it’s likely in or near the limit set.\n\n\nfor each pixel z:\n    scale = 1\n    color = white\n    for k = 1..N:\n        if z inside A.interior:   z = A(z)\n        elif z inside A.exterior: z = A^{-1}(z)\n        elif z inside B.interior: z = B(z)\n        elif z inside B.exterior: z = B^{-1}(z)\n        else: break\nThe loop terminates when the point leaves all circles, or after a fixed number of steps.\nThe color records which generator acted last; the scale tracks the cumulative derivative \\(|f'(z)|\\) and will later give us a distance estimate.\n\n\n\n\n\nEach pixel on screen represents a complex number \\(z = x + iy\\).\nThe shader’s main loop implements exactly the pseudocode above. It repeatedly applies the Möbius generators and their inverses to test how the orbit of \\(z\\) behaves.\n\nIf \\(z\\) escapes, it belongs to the bright background (domain of discontinuity).\nIf \\(z\\) stays trapped, it’s near the dark filigree of the limit set.\n\n\n\n\nFigure: Each pixel represents a complex point \\(z\\). The shader iterates Möbius generators to decide whether it escapes (white) or remains trapped (black).\n\n\nFigure 2\n\n\n\nWe color pixels by which generator last acted, creating the characteristic red-blue pattern of a two-generator Schottky group.\n\n\n\n\nIf we merely colored points as “in” or “out,” the boundary would look jagged. To smooth it, we use distance estimation.\nFor a Möbius map \\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\] the derivative is \\[\nf'(z) = -\\frac{r_1 r_2}{(z - c_1)^2}, \\qquad |f'(z)| = \\frac{r_1 r_2}{|z - c_1|^2}.\n\\]\nAfter \\(n\\) iterations the total contraction factor is\n\\[\nS_n = \\prod_{k=0}^{n-1} |f'_k(z_k)|.\n\\]\nThis \\(S_n\\) tells us how much a small neighborhood around \\(z\\) has been rescaled by the group action. The smaller \\(S_n\\), the closer we are to the limit set.\nIn practice, we track a variable scale such that scale *= 1/|z|^2 each time we invert a circle, then multiply by the ratio of circle radii. The estimated distance to the limit set is\n\\[\nd \\approx \\frac{ \\text{distance to nearest circle} }{ S_n }.\n\\]\nThis gives a smooth measure of proximity, allowing us to use smoothstep to render crisp boundaries.\n\n\n\n\nWe now translate this logic into GLSL, one piece at a time.\n\n\nEach generator pairs two circles—an “interior” and an “exterior”—and carries a rotation angle for the twist in the identification.\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3 color;\n};\n\n\n\nbool isInsideCircle(vec2 z, Circle c) {\n    return length(z - c.center) &lt; c.radius;\n}\n\nfloat distanceToCircle(vec2 z, Circle c) {\n    return length(z - c.center) - c.radius;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;\n}\n\n\n\nWe now implement the map that sends the exterior of one circle to the interior of another.\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    vec2 zA = (z - A.center) / A.radius;\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    vec2 inv = complexDiv(vec2(1.0,0.0), zA);\n    vec2 inB = B.center + B.radius * inv;\n\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n\n    return B.center + B.radius * unitB;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n\n    vec2 zB = (pre - B.center) / B.radius;\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n\n    vec2 inv = complexDiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\n\n\nTo start, we perform a few iterations and color by the last generator used.\nvec3 iterateColors(vec2 z, Generator A, Generator B) {\n    vec3 color = vec3(1.0);\n    float scale = 1.0;\n\n    for (int i = 0; i &lt; 12; i++) {\n        bool moved = false;\n\n        if (isInsideCircle(z, A.interior)) {\n            z = schottkyMap(z, A, scale);\n            color = A.color; moved = true;\n        }\n        else if (isInsideCircle(z, A.exterior)) {\n            z = inverseSchottkyMap(z, A, scale);\n            color = A.color; moved = true;\n        }\n        else if (isInsideCircle(z, B.interior)) {\n            z = schottkyMap(z, B, scale);\n            color = B.color; moved = true;\n        }\n        else if (isInsideCircle(z, B.exterior)) {\n            z = inverseSchottkyMap(z, B, scale);\n            color = B.color; moved = true;\n        }\n\n        if (!moved) break;\n    }\n\n    return color;\n}\nThis already shows the rough outline of the limit set.\n\n\n\n\n\nWe now compute the minimal distance to all circles and divide by the accumulated scale factor.\nfloat distanceToGenerator(vec2 z, Generator gen) {\n    float d1 = abs(distanceToCircle(z, gen.interior));\n    float d2 = abs(distanceToCircle(z, gen.exterior));\n    return min(d1, d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator A, Generator B) {\n    return min(distanceToGenerator(z, A), distanceToGenerator(z, B));\n}\n\nfloat correctedDistance(vec2 z, float scale, Generator A, Generator B) {\n    float d = distanceToSchottkyCircles(z, A, B);\n    float positionCorrection = 1.0 / (10.0 + length(z));\n    return d / (scale * positionCorrection);\n}\nThe corrected distance gives a scalar field that is small near the limit set. We convert it to a smooth boundary using smoothstep.\n\n\n\n\nThis final program combines everything above into a complete, runnable shader that draws the limit set dynamically.\n// ============================================\n// Schottky Group Renderer (Two Generators)\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\nstruct Circle { vec2 center; float radius; };\nstruct Generator { Circle interior; Circle exterior; float rotation; vec3 color; };\n\nbool isInsideCircle(vec2 z, Circle c) { return length(z - c.center) &lt; c.radius; }\nfloat distanceToCircle(vec2 z, Circle c) { return length(z - c.center) - c.radius; }\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta); float s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;\n}\n\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior; Circle B = gen.exterior;\n    vec2 zA = (z - A.center) / A.radius;\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n    vec2 inv = complexDiv(vec2(1.0,0.0), zA);\n    vec2 inB = B.center + B.radius * inv;\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n    return B.center + B.radius * unitB;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior; Circle B = gen.exterior;\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n    vec2 zB = (pre - B.center) / B.radius;\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n    vec2 inv = complexDiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\nvec3 renderSchottky(vec2 z, Generator A, Generator B) {\n    vec3 color = vec3(1.0); float scale = 1.0;\n    for (int i=0;i&lt;MAX_ITERATIONS;i++) {\n        bool moved=false;\n        if (isInsideCircle(z,A.interior)) { z=schottkyMap(z,A,scale); color=A.color; moved=true; }\n        else if (isInsideCircle(z,A.exterior)) { z=inverseSchottkyMap(z,A,scale); color=A.color; moved=true; }\n        else if (isInsideCircle(z,B.interior)) { z=schottkyMap(z,B,scale); color=B.color; moved=true; }\n        else if (isInsideCircle(z,B.exterior)) { z=inverseSchottkyMap(z,B,scale); color=B.color; moved=true; }\n        if (!moved) break;\n    }\n    float d = distanceToCircle(z, A.interior);\n    d = min(d, distanceToCircle(z, A.exterior));\n    d = min(d, distanceToCircle(z, B.interior));\n    d = min(d, distanceToCircle(z, B.exterior));\n    float pixel = 1.0 / iResolution.y;\n    float boundary = smoothstep(0.0, 5.5*pixel, abs(d) - 5.5*pixel);\n    return mix(vec3(0.0), color, boundary);\n}\n\nvoid setupGenerators(out Generator A, out Generator B, float time) {\n    float t = 3.0 * time; float s = 1.05 + 0.05 * cos(t);\n    A.interior.center = vec2(0.55, 0.55) * s;\n    A.interior.radius = 0.55;\n    A.exterior.center = vec2(-0.55, -0.55) * s;\n    A.exterior.radius = 0.55;\n    A.rotation = -PI/2.0; A.color = vec3(0.95,0.2,0.2);\n    B.interior.center = vec2(0.45,-0.45) * s;\n    B.interior.radius = 0.45;\n    B.exterior.center = vec2(-0.45, 0.45) * s;\n    B.exterior.radius = 0.45;\n    B.rotation = PI/2.0; B.color = vec3(0.2,0.3,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Generator A,B; setupGenerators(A,B,iTime);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n    vec3 col = renderSchottky(uv,A,B);\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\nEvery pixel corresponds to a point on the Riemann sphere, and each iteration applies one of the generators of \\(\\Gamma\\). Points that forever remain in the union of fundamental disks approximate the limit set \\(\\Lambda(\\Gamma)\\).\nIn hyperbolic terms, each generator corresponds to a loxodromic isometry of \\(\\mathbb{H}^3\\), acting by a translation and rotation along its geodesic axis. The limit set we see on the screen is the ideal boundary of the handlebody \\(\\mathbb{H}^3 / \\Gamma\\).\nThe parameter \\(\\lambda\\) of each loxodromic element encodes both the translation length \\(L = 2\\log|\\lambda|\\) and the rotation angle \\(\\arg(\\lambda)\\), which together determine how the paired circles are glued in 3D.\n\n\n\nFigure: The Schottky group defines a handlebody in \\(\\mathbb{H}^3\\). Its limit set is the fractal boundary seen in the shader.\n\n\nFigure 3\n\n\n\n\nPerfect — here’s the final optional section written in Quarto-ready Markdown style (no YAML front matter, standard LaTeX math, fenced GLSL code). You can paste it directly at the end of your existing .qmd file.\n\n\n\n\nUp to now, our emphasis has been on getting the geometry right: the correct Möbius transformations, iteration rules, and distance estimators that reveal the limit set of a Schottky group. But if you’ve ever run the simple version of the shader, you may have noticed that the picture looks fuzzy: the black circle boundaries are uneven, and their thickness changes with screen resolution.\nTo produce publication-quality limit sets, we must teach the shader to think like a cartographer — to measure in screen space, not world space, and to correct for the distortions of the Möbius maps. This section develops the refined version of the renderer that does just that.\n\n\n\nIn the mathematical world, our circles are perfect. But on a screen, a “circle” is made of pixels. When you zoom or change resolution, the physical thickness of the black border changes unless we explicitly tell the shader what a pixel means in world coordinates.\nThe base shader also ignored how much each Möbius map contracts or expands space. If a point has been contracted by a factor of 10⁶ after several iterations, its Euclidean distance to a circle means something very different than it did at the start. We need to correct by the product of derivative magnitudes — that’s our scale variable.\n\n\n\n\nFor the Schottky map\n\\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\]\nwe know\n\\[\nf'(z) = -\\frac{r_1 r_2}{(z - c_1)^2}, \\qquad |f'(z)| = \\frac{r_1 r_2}{|z - c_1|^2}.\n\\]\nSo each time we apply a generator, we update\nscale *= (r1 * r2) / dot(z - c1, z - c1);\nAt the end of the iteration, dividing by this scale converts the raw circle distance into a true hyperbolic-style distance that measures how close we are to the limit set.\n\n\n\n\nA pixel on the screen has a definite height in normalized coordinates:\nfloat pixelSize = 1.0 / iResolution.y;\nTo make the black borders a consistent width across displays, we choose a fixed multiple:\nfloat boundaryThickness = 5.5 * pixelSize;\nThat means “make the border about five pixels thick,” regardless of zoom or monitor size. Using smoothstep with that value ensures an anti-aliased transition rather than a hard cutoff.\n\n\n\n\nPoints far from the origin tend to have large coordinate values. Without correction, their distances become exaggerated, and black borders vanish in those regions. A simple damping factor\nfloat positionCorrection = 1.0 / (10.0 + length(result.finalPosition));\ntames this effect by decreasing the apparent distance when the point is far away.\n\n\n\n\nPutting these refinements together gives the version below, which produces smooth, consistent outlines and a crisp fractal limit set.\n// ============================================\n// SCHOTTKY GROUP RENDERER - With Distance Estimation\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\n// ---------- Complex arithmetic ----------\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y,\n                a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta), s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\n\n// ---------- Circles ----------\nstruct Circle { vec2 center; float radius; };\nbool  isInsideCircle(vec2 z, Circle c){return length(z-c.center)&lt;c.radius;}\nfloat distanceToCircle(vec2 z, Circle c){return length(z-c.center)-c.radius;}\n\n// ---------- Generator ----------\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3  color;\n};\n\n// ---------- Möbius and inverse ----------\nvec2 schottkyMap(vec2 z, Generator g, inout float scale){\n    vec2 c1=g.interior.center, c2=g.exterior.center;\n    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;\n    float denom=max(dot(z-c1,z-c1),1e-6);\n    scale*=(k/denom);\n    vec2 base=c2+complexDiv(vec2(k,0.0),z-c1);\n    vec2 unit=(base-c2)/r2;\n    unit=complexRotate(unit,g.rotation);\n    return c2+r2*unit;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator g, inout float scale){\n    vec2 c1=g.interior.center, c2=g.exterior.center;\n    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;\n    float denom=max(dot(z-c2,z-c2),1e-6);\n    scale*=(k/denom);\n    vec2 unit=(z-c2)/r2;\n    unit=complexRotate(unit,-g.rotation);\n    vec2 baseOut=c2+r2*unit;\n    return c1+complexDiv(vec2(k,0.0),baseOut-c2);\n}\n\n// ---------- Iteration ----------\nstruct IterationResult{vec3 color; vec2 finalPosition; float scale;};\n\nIterationResult iterateSchottky(vec2 z, Generator A, Generator B){\n    vec3 color=vec3(1.0); float scale=1.0;\n    for(int i=0;i&lt;MAX_ITERATIONS;i++){\n        bool moved=false;\n        if(isInsideCircle(z,A.interior)){z=schottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}\n        else if(isInsideCircle(z,A.exterior)){z=inverseSchottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}\n        else if(isInsideCircle(z,B.interior)){z=schottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}\n        else if(isInsideCircle(z,B.exterior)){z=inverseSchottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}\n        if(!moved)break;\n    }\n    return IterationResult(color,z,scale);\n}\n\n// ---------- Distance estimation ----------\nfloat distanceToGenerator(vec2 z, Generator g){\n    float d1=abs(distanceToCircle(z,g.interior));\n    float d2=abs(distanceToCircle(z,g.exterior));\n    return min(d1,d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator A, Generator B){\n    return min(distanceToGenerator(z,A),distanceToGenerator(z,B));\n}\n\nfloat correctedDistance(IterationResult r, Generator A, Generator B){\n    float d=distanceToSchottkyCircles(r.finalPosition,A,B);\n    float positionCorrection=1.0/(10.0+length(r.finalPosition));\n    return d/(r.scale*positionCorrection);\n}\n\n// ---------- Rendering ----------\nvec3 renderSchottky(IterationResult r, Generator A, Generator B){\n    float d=correctedDistance(r,A,B);\n    float pixelSize=1.0/iResolution.y;\n    float boundaryThickness=5.5*pixelSize;\n    float boundary=smoothstep(0.0,boundaryThickness,abs(d)-boundaryThickness);\n    return mix(vec3(0.0),r.color,boundary);\n}\n\n// ---------- Scene setup ----------\nvoid setupGenerators(out Generator A,out Generator B,float time){\n    float t=3.0*time, s=1.05+0.05*cos(t);\n    A.interior.center=vec2(0.55,0.55)*s; A.interior.radius=0.55;\n    A.exterior.center=vec2(-0.55,-0.55)*s; A.exterior.radius=0.55;\n    A.rotation=-PI/2.0; A.color=vec3(0.95,0.2,0.2);\n    B.interior.center=vec2(0.45,-0.45)*s; B.interior.radius=0.45;\n    B.exterior.center=vec2(-0.45,0.45)*s; B.exterior.radius=0.45;\n    B.rotation=PI/2.0; B.color=vec3(0.2,0.3,1.0);\n}\n\n// ---------- Main ----------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    Generator A,B; setupGenerators(A,B,iTime);\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*=2.0;\n    IterationResult r=iterateSchottky(uv,A,B);\n    vec3 color=renderSchottky(r,A,B);\n    fragColor=vec4(color,1.0);\n}\nThis shader is functionally identical to the simpler pedagogical one but with:\n\nMöbius-formula correctness rather than a three-step normalize/invert/denormalize approach.\nDerivative-based scaling for accurate distance estimation.\nScreen-space boundary control (5.5 * pixelSize) for consistent black borders.\nStabilized far-field correction so the picture remains uniform everywhere.\n\nThe result is a crisp, visually stable limit set—mathematically faithful and aesthetically satisfying.\n\n\n\n\n\nChange boundaryThickness from 5.5 to 3.0 or 8.0 to feel how border width changes.\nTry different radii or centers for the generators to see how the limit set morphs.\nReplace smoothstep with a hard threshold to understand aliasing artifacts.\nAnimate the rotations genA.rotation and genB.rotation to see how the twists deform the pattern.\n\n\nThis “advanced” version closes the loop between mathematical fidelity and graphical clarity. Students who have followed the whole derivation will now appreciate that the small extra factors—scale, pixelSize, and positionCorrection—are what make a shader image mathematically precise and visually beautiful at the same time.\n\n\n\n\nThis is a complete, self-contained version of your group renderer, but rewritten in the geometric style we developed:\n// ============================================\n// Shader 2: Schottky group with two generators\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\n// ------------------------------\n// complex helpers\n// ------------------------------\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y,\n                a.y*b.x - a.x*b.y) / d;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2(c*z.x - s*z.y,\n                s*z.x + c*z.y);\n}\n\n// ------------------------------\n// circle + generator structs\n// ------------------------------\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3 color;\n};\n\nbool isInsideCircle(vec2 z, Circle c) {\n    return length(z - c.center) &lt; c.radius;\n}\n\nfloat distanceToCircle(vec2 z, Circle c) {\n    return length(z - c.center) - c.radius;\n}\n\n// ------------------------------\n// geometric schottky map (factored)\n// maps exterior(interiorCircle) -&gt; interior(exteriorCircle)\n// ------------------------------\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    // normalize to A\n    vec2 zA = (z - A.center) / A.radius;\n\n    // inversion derivative\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale    = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    // invert\n    vec2 inv = cdiv(vec2(1.0,0.0), zA);\n\n    // to B\n    vec2 inB = B.center + B.radius * inv;\n\n    // rotate in B\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n    return B.center + B.radius * unitB;\n}\n\n// inverse map: undo rotation, normalize to B, invert, go to A\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    // undo rotation in B\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n\n    // normalize to B\n    vec2 zB = (pre - B.center) / B.radius;\n\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale    = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n\n    // invert and go to A\n    vec2 inv = cdiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\n// ------------------------------\n// iteration\n// ------------------------------\nstruct IterationResult {\n    vec3 color;\n    vec2 finalPosition;\n    float scale;\n};\n\nIterationResult iterateSchottky(vec2 z, Generator genA, Generator genB) {\n    vec3 color = vec3(1.0);\n    float scale = 1.0;\n\n    for (int i = 0; i &lt; MAX_ITERATIONS; i++) {\n        bool moved = false;\n\n        if (isInsideCircle(z, genA.interior)) {\n            z = schottkyMap(z, genA, scale);\n            color = mix(color, genA.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genA.exterior)) {\n            z = inverseSchottkyMap(z, genA, scale);\n            color = mix(color, genA.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genB.interior)) {\n            z = schottkyMap(z, genB, scale);\n            color = mix(color, genB.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genB.exterior)) {\n            z = inverseSchottkyMap(z, genB, scale);\n            color = mix(color, genB.color, 0.5);\n            moved = true;\n        }\n\n        if (!moved) break;\n    }\n\n    IterationResult result;\n    result.color = color;\n    result.finalPosition = z;\n    result.scale = scale;\n    return result;\n}\n\n// ------------------------------\n// distance estimation (same idea as your program)\n// ------------------------------\nfloat distanceToGenerator(vec2 z, Generator gen) {\n    float d1 = abs(distanceToCircle(z, gen.interior));\n    float d2 = abs(distanceToCircle(z, gen.exterior));\n    return min(d1, d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator genA, Generator genB) {\n    return min(distanceToGenerator(z, genA),\n               distanceToGenerator(z, genB));\n}\n\nfloat correctedDistance(IterationResult result, Generator genA, Generator genB) {\n    float d = distanceToSchottkyCircles(result.finalPosition, genA, genB);\n    float positionCorrection = 1.0 / (10.0 + length(result.finalPosition));\n    return d / (result.scale * positionCorrection);\n}\n\n// ------------------------------\n// rendering\n// ------------------------------\nvec3 renderSchottky(IterationResult result, Generator genA, Generator genB) {\n    float d = correctedDistance(result, genA, genB);\n    float pixel = 1.0 / iResolution.y;\n    float thickness = 5.5 * pixel;\n    float boundary = smoothstep(0.0, thickness, abs(d) - thickness);\n    return mix(vec3(0.0), result.color, boundary);\n}\n\n// ------------------------------\n// generator setup\n// ------------------------------\nvoid setupGenerators(out Generator genA, out Generator genB, float time) {\n    float t = 3.0 * time;\n    float s = 1.05 + 0.05 * cos(t);\n\n    genA.interior.center = vec2(0.55, 0.55) * s;\n    genA.interior.radius = 0.55;\n    genA.exterior.center = vec2(-0.55, -0.55) * s;\n    genA.exterior.radius = 0.55;\n    genA.rotation = -PI / 2.0;\n    genA.color = vec3(0.95, 0.2, 0.2);\n\n    genB.interior.center = vec2(0.45, -0.45) * s;\n    genB.interior.radius = 0.45;\n    genB.exterior.center = vec2(-0.45, 0.45) * s;\n    genB.exterior.radius = 0.45;\n    genB.rotation = PI / 2.0;\n    genB.color = vec3(0.2, 0.3, 1.0);\n}\n\n// ------------------------------\n// main\n// ------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Generator genA, genB;\n    setupGenerators(genA, genB, iTime);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n\n    IterationResult result = iterateSchottky(uv, genA, genB);\n    vec3 color = renderSchottky(result, genA, genB);\n\n    fragColor = vec4(color, 1.0);\n}\nThat’s the full group shader, expressed the way we described the geometry."
  },
  {
    "objectID": "OLD/appendices/schottky.html#schottky-groups-in-one-picture",
    "href": "OLD/appendices/schottky.html#schottky-groups-in-one-picture",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "A (classical) Schottky group of rank \\(g\\) is built from \\(2g\\) disjoint Jordan curves (we use circles) on the Riemann sphere. We pair them up \\((C_1, C_1'), \\dots, (C_g, C_g')\\), and for each pair we choose a Möbius map that sends the exterior of \\(C_i\\) to the interior of \\(C_i'\\). The group generated by these \\(g\\) maps is free and discrete.\nSo the fundamental move is:\n\npick two circles,\nsend exterior of the first to interior of the second,\n(optionally) rotate inside the second.\n\nThat is exactly the move we will encode in GLSL.\n\n\n\nMapping the exterior of one circle to the interior of another"
  },
  {
    "objectID": "OLD/appendices/schottky.html#the-geometry-from-two-circles-to-a-möbius-map",
    "href": "OLD/appendices/schottky.html#the-geometry-from-two-circles-to-a-möbius-map",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Let\n\nCircle 1: center \\(c_1 \\in \\mathbb C\\), radius \\(r_1 &gt; 0\\)\nCircle 2: center \\(c_2 \\in \\mathbb C\\), radius \\(r_2 &gt; 0\\)\n\nWe want a Möbius map \\(f\\) with the property\n\nif \\(|z - c_1| &gt; r_1\\) (outside circle 1) then \\(|f(z) - c_2| &lt; r_2\\) (inside circle 2).\n\nThere is a standard 3-step recipe:\n\nNormalize circle 1 to the unit circle: \\[\nT_1(z) = \\frac{z - c_1}{r_1}.\n\\]\nInvert in the unit circle (this swaps inside and outside): \\[\nJ(w) = \\frac{1}{w}.\n\\]\nDenormalize to circle 2: \\[\nT_2^{-1}(w) = c_2 + r_2 w.\n\\]\n\nSo the Möbius map is \\[\nf(z) = T_2^{-1}( J( T_1(z) ) ) = c_2 + \\frac{r_1 r_2}{z - c_1}.\n\\]\nThis is already in closed form:\n\\[\n\\boxed{ f(z) = c_2 + \\frac{r_1 r_2}{z - c_1} }.\n\\]\nYou can check: if \\(|z - c_1| &gt; r_1\\) then \\(\\left| \\frac{r_1}{z - c_1} \\right| &lt; 1\\) so \\(|f(z) - c_2| = r_2 \\left|\\frac{r_1}{z - c_1}\\right| &lt; r_2\\)."
  },
  {
    "objectID": "OLD/appendices/schottky.html#complex-numbers-and-circles-in-glsl",
    "href": "OLD/appendices/schottky.html#complex-numbers-and-circles-in-glsl",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "GLSL doesn’t have complex numbers, so we’ll use vec2 everywhere. We do want to write things in complex style (multiply, divide, take sqrt), so let’s define those once.\n// -----------------------------------------\n// complex helpers\n// -----------------------------------------\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\n\nvec2 cmul(vec2 a, vec2 b) {\n    // (a.x + i a.y)(b.x + i b.y)\n    return vec2(a.x*b.x - a.y*b.y,\n                a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    // a / b = a * conj(b) / |b|^2\n    float d = dot(b, b);\n    return vec2( (a.x*b.x + a.y*b.y) / d,\n                 (a.y*b.x - a.x*b.y) / d );\n}\n\nvec2 cfloat(float x) {\n    return vec2(x, 0.0);\n}\nLet’s also define a circle struct:\n// -----------------------------------------\n// circle data\n// -----------------------------------------\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nWe will carry this struct through the whole document."
  },
  {
    "objectID": "OLD/appendices/schottky.html#the-geometric-schottky-map-in-glsl",
    "href": "OLD/appendices/schottky.html#the-geometric-schottky-map-in-glsl",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Let’s translate the exact 3-step recipe:\n\ncircle → unit circle,\ninvert in unit circle,\nunit circle → circle.\n\nWe also add a rotation at the end (useful in Schottky generators).\n// map arbitrary circle to unit circle\nvec2 toUnitCircle(vec2 z, Circle c) {\n    return (z - c.center) / c.radius;\n}\n\n// map unit circle to arbitrary circle\nvec2 fromUnitCircle(vec2 w, Circle c) {\n    return c.radius * w + c.center;\n}\n\n// inversion in unit circle\nvec2 invertUnit(vec2 w) {\n    return cdiv(vec2(1.0, 0.0), w);\n}\nNow the Schottky generator:\n// schottky-like map: exterior(A) -&gt; interior(B)\n// rotation is angle in radians applied INSIDE B\n// scale is an inout used for distance estimation later\nvec2 schottkyMap(vec2 z, Circle A, Circle B, float rotation, inout float scale) {\n    // step 1: normalize to A\n    vec2 zA = toUnitCircle(z, A);\n\n    // derivative of inversion: |d(1/z)| = 1/|z|^2\n    float inversionScale = 1.0 / dot(zA, zA);\n\n    // step 2: invert\n    vec2 inv = invertUnit(zA);\n\n    // step 3: map to B\n    vec2 inB = fromUnitCircle(inv, B);\n\n    // total radius scale = r2 / r1\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    // step 4: rotate inside B\n    vec2 unitB = (inB - B.center) / B.radius;\n    float c = cos(rotation);\n    float s = sin(rotation);\n    vec2 rotated = vec2(c*unitB.x - s*unitB.y,\n                        s*unitB.x + c*unitB.y);\n\n    return B.center + B.radius * rotated;\n}\nThis is the pedagogical version: each line corresponds to something we can draw on the board."
  },
  {
    "objectID": "OLD/appendices/schottky.html#fixed-points-and-the-loxodromic-axis",
    "href": "OLD/appendices/schottky.html#fixed-points-and-the-loxodromic-axis",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Given \\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\] solve \\(f(z) = z\\):\n[ (z - c_1)(z - c_2) = r_1 r_2] [ z^2 - (c_1 + c_2)z + c_1 c_2 - r_1 r_2 = 0.]\nSo \\[\nz = \\frac{c_1 + c_2 \\pm \\sqrt{(c_1 - c_2)^2 + 4 r_1 r_2}}{2}.\n\\]\nThose two solutions are the endpoints of the axis — in \\(\\widehat{\\mathbb C}\\) these are just two points, but in \\(\\mathbb H^3\\) they determine the unique geodesic the map acts along.\nWe need a complex sqrt:\n// principal complex square root\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float t = sqrt(0.5*(r + z.x));\n    float s = (z.y &gt;= 0.0)\n        ? sqrt(0.5*(r - z.x))\n        : -sqrt(0.5*(r - z.x));\n    return vec2(t, s);\n}\nNow the fixed points:\nvoid schottkyEndpoints(Circle A, Circle B,\n                       out vec2 zPlus, out vec2 zMinus, out vec2 Delta)\n{\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n\n    vec2 sum   = c1 + c2;\n    vec2 diff  = c1 - c2;\n    vec2 diff2 = cmul(diff, diff);\n\n    Delta = csqrt( diff2 + cfloat(4.0 * r1 * r2) );\n\n    zPlus  = 0.5 * (sum + Delta);\n    zMinus = 0.5 * (sum - Delta);\n}\nWe’ll call these pPlus and pMinus or p_+, p_-."
  },
  {
    "objectID": "OLD/appendices/schottky.html#conjugation-and-the-1-parameter-flow",
    "href": "OLD/appendices/schottky.html#conjugation-and-the-1-parameter-flow",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Every loxodromic Möbius transformation with fixed points \\(p_-\\) and \\(p_+\\) can be conjugated to \\(w \\mapsto \\lambda w\\), i.e. a pure dilation/spiral fixing \\(0\\) and \\(\\infty\\).\nDefine \\[\nh(z) = \\frac{z - p_-}{z - p_+}.\n\\]\nThen \\[\ng = h \\circ f \\circ h^{-1}\n\\] fixes \\(0\\) and \\(\\infty\\), so \\(g(w) = \\lambda w\\) for some \\(\\lambda \\in \\mathbb C^\\times\\).\nTo animate, define \\[\ng_t(w) = \\lambda^t w, \\quad f_t = h^{-1} \\circ g_t \\circ h.\n\\]\nSo the movie is \\[\nf_t(z) = h^{-1}( \\lambda^t h(z) ).\n\\]\nWe already wrote csqrt. Now write the conjugators and complex log/exp:\nvec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {\n    return cdiv(z - pMinus, z - pPlus);\n}\n\nvec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {\n    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));\n}\n\n// complex log\nvec2 clogc(vec2 z) {\n    float r = length(z);\n    float th = atan(z.y, z.x);\n    return vec2(log(r), th);\n}\n\n// complex exp\nvec2 cexpc(vec2 z) {\n    float ex = exp(z.x);\n    return vec2(ex * cos(z.y), ex * sin(z.y));\n}\nWe also need the multiplier. From the derivation:\n\\[\n\\lambda = - \\frac{4 r_1 r_2}{(c_2 - c_1 - \\Delta)^2}\n\\]\nso\nvec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n\n    vec2 denom  = (c2 - c1) - Delta;\n    vec2 denom2 = cmul(denom, denom);\n    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);\n    return cdiv(num, denom2);\n}\nFinally the flow:\nvec2 schottkyFlow(vec2 z,\n                  vec2 pPlus, vec2 pMinus,\n                  vec2 lambda,\n                  float t)\n{\n    // lambda^t = exp(t * log(lambda))\n    vec2 loglam = clogc(lambda);\n    vec2 lam_t  = cexpc(t * loglam);\n\n    vec2 w  = hMap(z, pPlus, pMinus);\n    vec2 w2 = cmul(lam_t, w);\n    return hInv(w2, pPlus, pMinus);\n}\nSo now we have every mathematical piece."
  },
  {
    "objectID": "OLD/appendices/schottky.html#full-shader-1-animated-single-identification",
    "href": "OLD/appendices/schottky.html#full-shader-1-animated-single-identification",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "This is a complete Shadertoy-style fragment shader that:\n\ndefines two circles;\ncomputes their loxodromic map;\nfinds the fixed points;\nanimates the identification by applying \\(f_t\\) to sample points on circle 1;\ndraws the circles and the fixed points.\n\nYou can paste this as-is into Shadertoy.\n// =========================================\n// Shader 1: animated Schottky identification\n// =========================================\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 cadd(vec2 a, vec2 b) { return a + b; }\nvec2 csub(vec2 a, vec2 b) { return a - b; }\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2((a.x*b.x + a.y*b.y)/d,\n                (a.y*b.x - a.x*b.y)/d);\n}\nvec2 cfloat(float x) { return vec2(x,0.0); }\n\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float t = sqrt(0.5*(r + z.x));\n    float s = (z.y &gt;= 0.0) ? sqrt(0.5*(r - z.x)) : -sqrt(0.5*(r - z.x));\n    return vec2(t, s);\n}\n\nvoid schottkyEndpoints(Circle A, Circle B,\n                       out vec2 pPlus, out vec2 pMinus, out vec2 Delta)\n{\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n    vec2 sum   = c1 + c2;\n    vec2 diff  = c1 - c2;\n    vec2 diff2 = cmul(diff, diff);\n    Delta  = csqrt( diff2 + cfloat(4.0 * r1 * r2) );\n    pPlus  = 0.5 * (sum + Delta);\n    pMinus = 0.5 * (sum - Delta);\n}\n\nvec2 schottkyLambda(Circle A, Circle B, vec2 Delta) {\n    vec2 c1 = A.center;\n    vec2 c2 = B.center;\n    float r1 = A.radius;\n    float r2 = B.radius;\n    vec2 denom  = (c2 - c1) - Delta;\n    vec2 denom2 = cmul(denom, denom);\n    vec2 num    = vec2(-4.0 * r1 * r2, 0.0);\n    return cdiv(num, denom2);\n}\n\nvec2 hMap(vec2 z, vec2 pPlus, vec2 pMinus) {\n    return cdiv(z - pMinus, z - pPlus);\n}\nvec2 hInv(vec2 w, vec2 pPlus, vec2 pMinus) {\n    return cdiv(cmul(w, pPlus) - pMinus, w - vec2(1.0, 0.0));\n}\nvec2 clogc(vec2 z) {\n    float r = length(z);\n    float th = atan(z.y, z.x);\n    return vec2(log(r), th);\n}\nvec2 cexpc(vec2 z) {\n    float ex = exp(z.x);\n    return vec2(ex * cos(z.y), ex * sin(z.y));\n}\nvec2 schottkyFlow(vec2 z, vec2 pPlus, vec2 pMinus, vec2 lambda, float t) {\n    vec2 loglam = clogc(lambda);\n    vec2 lam_t  = cexpc(t * loglam);\n    vec2 w  = hMap(z, pPlus, pMinus);\n    vec2 w2 = cmul(lam_t, w);\n    return hInv(w2, pPlus, pMinus);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // map screen to complex plane\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    float zoom = 1.8;\n    vec2 z = vec2(\n        (uv.x - 0.5) * 2.0 * zoom * aspect,\n        (uv.y - 0.5) * 2.0 * zoom\n    );\n\n    // define two circles\n    Circle A;\n    A.center = vec2(-0.6, 0.1);\n    A.radius = 0.35;\n\n    Circle B;\n    B.center = vec2(0.7, -0.15);\n    B.radius = 0.45;\n\n    // fixed points and lambda\n    vec2 pPlus, pMinus, Delta;\n    schottkyEndpoints(A, B, pPlus, pMinus, Delta);\n    vec2 lambda = schottkyLambda(A, B, Delta);\n\n    // time parameter in [0,1]\n    float t = 0.5 + 0.5 * sin(iTime * 0.7);\n\n    // background\n    vec3 col = vec3(0.95);\n\n    // draw circles\n    float dA = abs(length(z - A.center) - A.radius);\n    float dB = abs(length(z - B.center) - B.radius);\n    col = mix(col, vec3(0.1,0.3,0.9), smoothstep(0.005, 0.0, dA));\n    col = mix(col, vec3(0.9,0.2,0.2), smoothstep(0.005, 0.0, dB));\n\n    // draw fixed points\n    float f1 = smoothstep(0.03, 0.0, length(z - pPlus));\n    float f2 = smoothstep(0.03, 0.0, length(z - pMinus));\n    col = mix(col, vec3(1.0,0.8,0.0), f1);\n    col = mix(col, vec3(0.0,0.8,0.2), f2);\n\n    // draw moving image of circle A as dots\n    float imgMask = 0.0;\n    const int N = 80;\n    for (int i = 0; i &lt; N; i++) {\n        float ang = 6.2831853 * float(i) / float(N);\n        vec2 pt = A.center + A.radius * vec2(cos(ang), sin(ang));\n        vec2 imgPt = schottkyFlow(pt, pPlus, pMinus, lambda, t);\n        float m = smoothstep(0.03, 0.0, length(z - imgPt));\n        imgMask = max(imgMask, m);\n    }\n    col = mix(col, vec3(0.35, 0.05, 0.6), imgMask);\n\n    fragColor = vec4(col, 1.0);\n}\nThat’s a complete first shader."
  },
  {
    "objectID": "OLD/appendices/schottky.html#drawing-the-limit-set-of-a-schottky-group",
    "href": "OLD/appendices/schottky.html#drawing-the-limit-set-of-a-schottky-group",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "These notes continue our exploration of Möbius transformations in GLSL, now focusing on Schottky groups—the simplest discrete groups of Möbius transformations—and how to visualize their limit sets using shader iteration.\nOur audience is assumed to know hyperbolic geometry and group theory but to be new to GPU programming. We’ll therefore explain everything twice: once mathematically, and once as a computational recipe."
  },
  {
    "objectID": "OLD/appendices/schottky.html#what-we-are-drawing-mathematically",
    "href": "OLD/appendices/schottky.html#what-we-are-drawing-mathematically",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Let \\(\\Gamma \\subset \\mathrm{PSL}(2,\\mathbb{C})\\) be a finitely generated group of Möbius transformations. For any point \\(z_0 \\in \\widehat{\\mathbb{C}}\\), its orbit under \\(\\Gamma\\) is\n\\[\n\\Gamma z_0 = \\{ g(z_0) : g \\in \\Gamma \\}.\n\\]\nThe limit set of \\(\\Gamma\\) is the closure of this orbit:\n\\[\n\\Lambda(\\Gamma) = \\overline{ \\Gamma z_0 }.\n\\]\nFor a classical Schottky group—generated by finitely many loxodromic Möbius transformations each identifying two disjoint circles—the limit set \\(\\Lambda(\\Gamma)\\) is a Cantor-like subset of the sphere at infinity. The complement \\(\\Omega = \\widehat{\\mathbb{C}} \\setminus \\Lambda(\\Gamma)\\) is the domain of discontinuity, on which \\(\\Gamma\\) acts properly discontinuously.\nWe can visualize \\(\\Lambda(\\Gamma)\\) by testing points in the complex plane: points that escape the system of circles belong to \\(\\Omega\\), while points that never escape approximate the limit set.\n\n\n\nFigure: Two pairs of disjoint circles generate a rank-2 Schottky group. Arrows indicate how each pair is identified by a loxodromic Möbius transformation.\n\n\nFigure 1"
  },
  {
    "objectID": "OLD/appendices/schottky.html#thinking-algorithmically",
    "href": "OLD/appendices/schottky.html#thinking-algorithmically",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Imagine throwing a dart at the complex plane: you hit a point \\(z\\). We now repeatedly apply the Schottky generators to fold the plane back into the fundamental domain.\nIf \\(z\\) lands inside one of the paired circles \\(C_i\\) (say the “interior” circle of generator \\(A_i\\)), we apply the Möbius transformation \\(A_i\\) to move it to the paired exterior circle \\(C_i'\\). If it lands inside \\(C_i'\\), we apply \\(A_i^{-1}\\) instead.\nIf after a few steps the point leaves all circles, we say it escaped (it lies in \\(\\Omega\\)). If it never escapes, it’s likely in or near the limit set.\n\n\nfor each pixel z:\n    scale = 1\n    color = white\n    for k = 1..N:\n        if z inside A.interior:   z = A(z)\n        elif z inside A.exterior: z = A^{-1}(z)\n        elif z inside B.interior: z = B(z)\n        elif z inside B.exterior: z = B^{-1}(z)\n        else: break\nThe loop terminates when the point leaves all circles, or after a fixed number of steps.\nThe color records which generator acted last; the scale tracks the cumulative derivative \\(|f'(z)|\\) and will later give us a distance estimate."
  },
  {
    "objectID": "OLD/appendices/schottky.html#from-mathematics-to-pixels",
    "href": "OLD/appendices/schottky.html#from-mathematics-to-pixels",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Each pixel on screen represents a complex number \\(z = x + iy\\).\nThe shader’s main loop implements exactly the pseudocode above. It repeatedly applies the Möbius generators and their inverses to test how the orbit of \\(z\\) behaves.\n\nIf \\(z\\) escapes, it belongs to the bright background (domain of discontinuity).\nIf \\(z\\) stays trapped, it’s near the dark filigree of the limit set.\n\n\n\n\nFigure: Each pixel represents a complex point \\(z\\). The shader iterates Möbius generators to decide whether it escapes (white) or remains trapped (black).\n\n\nFigure 2\n\n\n\nWe color pixels by which generator last acted, creating the characteristic red-blue pattern of a two-generator Schottky group."
  },
  {
    "objectID": "OLD/appendices/schottky.html#distance-estimation-and-smooth-boundaries",
    "href": "OLD/appendices/schottky.html#distance-estimation-and-smooth-boundaries",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "If we merely colored points as “in” or “out,” the boundary would look jagged. To smooth it, we use distance estimation.\nFor a Möbius map \\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\] the derivative is \\[\nf'(z) = -\\frac{r_1 r_2}{(z - c_1)^2}, \\qquad |f'(z)| = \\frac{r_1 r_2}{|z - c_1|^2}.\n\\]\nAfter \\(n\\) iterations the total contraction factor is\n\\[\nS_n = \\prod_{k=0}^{n-1} |f'_k(z_k)|.\n\\]\nThis \\(S_n\\) tells us how much a small neighborhood around \\(z\\) has been rescaled by the group action. The smaller \\(S_n\\), the closer we are to the limit set.\nIn practice, we track a variable scale such that scale *= 1/|z|^2 each time we invert a circle, then multiply by the ratio of circle radii. The estimated distance to the limit set is\n\\[\nd \\approx \\frac{ \\text{distance to nearest circle} }{ S_n }.\n\\]\nThis gives a smooth measure of proximity, allowing us to use smoothstep to render crisp boundaries."
  },
  {
    "objectID": "OLD/appendices/schottky.html#implementing-the-algorithm-step-by-step",
    "href": "OLD/appendices/schottky.html#implementing-the-algorithm-step-by-step",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "We now translate this logic into GLSL, one piece at a time.\n\n\nEach generator pairs two circles—an “interior” and an “exterior”—and carries a rotation angle for the twist in the identification.\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3 color;\n};\n\n\n\nbool isInsideCircle(vec2 z, Circle c) {\n    return length(z - c.center) &lt; c.radius;\n}\n\nfloat distanceToCircle(vec2 z, Circle c) {\n    return length(z - c.center) - c.radius;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\n\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;\n}\n\n\n\nWe now implement the map that sends the exterior of one circle to the interior of another.\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    vec2 zA = (z - A.center) / A.radius;\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    vec2 inv = complexDiv(vec2(1.0,0.0), zA);\n    vec2 inB = B.center + B.radius * inv;\n\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n\n    return B.center + B.radius * unitB;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n\n    vec2 zB = (pre - B.center) / B.radius;\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n\n    vec2 inv = complexDiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\n\n\nTo start, we perform a few iterations and color by the last generator used.\nvec3 iterateColors(vec2 z, Generator A, Generator B) {\n    vec3 color = vec3(1.0);\n    float scale = 1.0;\n\n    for (int i = 0; i &lt; 12; i++) {\n        bool moved = false;\n\n        if (isInsideCircle(z, A.interior)) {\n            z = schottkyMap(z, A, scale);\n            color = A.color; moved = true;\n        }\n        else if (isInsideCircle(z, A.exterior)) {\n            z = inverseSchottkyMap(z, A, scale);\n            color = A.color; moved = true;\n        }\n        else if (isInsideCircle(z, B.interior)) {\n            z = schottkyMap(z, B, scale);\n            color = B.color; moved = true;\n        }\n        else if (isInsideCircle(z, B.exterior)) {\n            z = inverseSchottkyMap(z, B, scale);\n            color = B.color; moved = true;\n        }\n\n        if (!moved) break;\n    }\n\n    return color;\n}\nThis already shows the rough outline of the limit set."
  },
  {
    "objectID": "OLD/appendices/schottky.html#adding-distance-estimation",
    "href": "OLD/appendices/schottky.html#adding-distance-estimation",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "We now compute the minimal distance to all circles and divide by the accumulated scale factor.\nfloat distanceToGenerator(vec2 z, Generator gen) {\n    float d1 = abs(distanceToCircle(z, gen.interior));\n    float d2 = abs(distanceToCircle(z, gen.exterior));\n    return min(d1, d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator A, Generator B) {\n    return min(distanceToGenerator(z, A), distanceToGenerator(z, B));\n}\n\nfloat correctedDistance(vec2 z, float scale, Generator A, Generator B) {\n    float d = distanceToSchottkyCircles(z, A, B);\n    float positionCorrection = 1.0 / (10.0 + length(z));\n    return d / (scale * positionCorrection);\n}\nThe corrected distance gives a scalar field that is small near the limit set. We convert it to a smooth boundary using smoothstep."
  },
  {
    "objectID": "OLD/appendices/schottky.html#full-shader-two-generator-schottky-group",
    "href": "OLD/appendices/schottky.html#full-shader-two-generator-schottky-group",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "This final program combines everything above into a complete, runnable shader that draws the limit set dynamically.\n// ============================================\n// Schottky Group Renderer (Two Generators)\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\nstruct Circle { vec2 center; float radius; };\nstruct Generator { Circle interior; Circle exterior; float rotation; vec3 color; };\n\nbool isInsideCircle(vec2 z, Circle c) { return length(z - c.center) &lt; c.radius; }\nfloat distanceToCircle(vec2 z, Circle c) { return length(z - c.center) - c.radius; }\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta); float s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / denom;\n}\n\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior; Circle B = gen.exterior;\n    vec2 zA = (z - A.center) / A.radius;\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n    vec2 inv = complexDiv(vec2(1.0,0.0), zA);\n    vec2 inB = B.center + B.radius * inv;\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n    return B.center + B.radius * unitB;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior; Circle B = gen.exterior;\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n    vec2 zB = (pre - B.center) / B.radius;\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n    vec2 inv = complexDiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\nvec3 renderSchottky(vec2 z, Generator A, Generator B) {\n    vec3 color = vec3(1.0); float scale = 1.0;\n    for (int i=0;i&lt;MAX_ITERATIONS;i++) {\n        bool moved=false;\n        if (isInsideCircle(z,A.interior)) { z=schottkyMap(z,A,scale); color=A.color; moved=true; }\n        else if (isInsideCircle(z,A.exterior)) { z=inverseSchottkyMap(z,A,scale); color=A.color; moved=true; }\n        else if (isInsideCircle(z,B.interior)) { z=schottkyMap(z,B,scale); color=B.color; moved=true; }\n        else if (isInsideCircle(z,B.exterior)) { z=inverseSchottkyMap(z,B,scale); color=B.color; moved=true; }\n        if (!moved) break;\n    }\n    float d = distanceToCircle(z, A.interior);\n    d = min(d, distanceToCircle(z, A.exterior));\n    d = min(d, distanceToCircle(z, B.interior));\n    d = min(d, distanceToCircle(z, B.exterior));\n    float pixel = 1.0 / iResolution.y;\n    float boundary = smoothstep(0.0, 5.5*pixel, abs(d) - 5.5*pixel);\n    return mix(vec3(0.0), color, boundary);\n}\n\nvoid setupGenerators(out Generator A, out Generator B, float time) {\n    float t = 3.0 * time; float s = 1.05 + 0.05 * cos(t);\n    A.interior.center = vec2(0.55, 0.55) * s;\n    A.interior.radius = 0.55;\n    A.exterior.center = vec2(-0.55, -0.55) * s;\n    A.exterior.radius = 0.55;\n    A.rotation = -PI/2.0; A.color = vec3(0.95,0.2,0.2);\n    B.interior.center = vec2(0.45,-0.45) * s;\n    B.interior.radius = 0.45;\n    B.exterior.center = vec2(-0.45, 0.45) * s;\n    B.exterior.radius = 0.45;\n    B.rotation = PI/2.0; B.color = vec3(0.2,0.3,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Generator A,B; setupGenerators(A,B,iTime);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    uv *= 2.0;\n    vec3 col = renderSchottky(uv,A,B);\n    fragColor = vec4(col,1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/schottky.html#mathematical-commentary",
    "href": "OLD/appendices/schottky.html#mathematical-commentary",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Every pixel corresponds to a point on the Riemann sphere, and each iteration applies one of the generators of \\(\\Gamma\\). Points that forever remain in the union of fundamental disks approximate the limit set \\(\\Lambda(\\Gamma)\\).\nIn hyperbolic terms, each generator corresponds to a loxodromic isometry of \\(\\mathbb{H}^3\\), acting by a translation and rotation along its geodesic axis. The limit set we see on the screen is the ideal boundary of the handlebody \\(\\mathbb{H}^3 / \\Gamma\\).\nThe parameter \\(\\lambda\\) of each loxodromic element encodes both the translation length \\(L = 2\\log|\\lambda|\\) and the rotation angle \\(\\arg(\\lambda)\\), which together determine how the paired circles are glued in 3D.\n\n\n\nFigure: The Schottky group defines a handlebody in \\(\\mathbb{H}^3\\). Its limit set is the fractal boundary seen in the shader.\n\n\nFigure 3\n\n\n\n\nPerfect — here’s the final optional section written in Quarto-ready Markdown style (no YAML front matter, standard LaTeX math, fenced GLSL code). You can paste it directly at the end of your existing .qmd file."
  },
  {
    "objectID": "OLD/appendices/schottky.html#optional-making-the-limit-set-look-good",
    "href": "OLD/appendices/schottky.html#optional-making-the-limit-set-look-good",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "Up to now, our emphasis has been on getting the geometry right: the correct Möbius transformations, iteration rules, and distance estimators that reveal the limit set of a Schottky group. But if you’ve ever run the simple version of the shader, you may have noticed that the picture looks fuzzy: the black circle boundaries are uneven, and their thickness changes with screen resolution.\nTo produce publication-quality limit sets, we must teach the shader to think like a cartographer — to measure in screen space, not world space, and to correct for the distortions of the Möbius maps. This section develops the refined version of the renderer that does just that.\n\n\n\nIn the mathematical world, our circles are perfect. But on a screen, a “circle” is made of pixels. When you zoom or change resolution, the physical thickness of the black border changes unless we explicitly tell the shader what a pixel means in world coordinates.\nThe base shader also ignored how much each Möbius map contracts or expands space. If a point has been contracted by a factor of 10⁶ after several iterations, its Euclidean distance to a circle means something very different than it did at the start. We need to correct by the product of derivative magnitudes — that’s our scale variable.\n\n\n\n\nFor the Schottky map\n\\[\nf(z) = c_2 + \\frac{r_1 r_2}{z - c_1},\n\\]\nwe know\n\\[\nf'(z) = -\\frac{r_1 r_2}{(z - c_1)^2}, \\qquad |f'(z)| = \\frac{r_1 r_2}{|z - c_1|^2}.\n\\]\nSo each time we apply a generator, we update\nscale *= (r1 * r2) / dot(z - c1, z - c1);\nAt the end of the iteration, dividing by this scale converts the raw circle distance into a true hyperbolic-style distance that measures how close we are to the limit set.\n\n\n\n\nA pixel on the screen has a definite height in normalized coordinates:\nfloat pixelSize = 1.0 / iResolution.y;\nTo make the black borders a consistent width across displays, we choose a fixed multiple:\nfloat boundaryThickness = 5.5 * pixelSize;\nThat means “make the border about five pixels thick,” regardless of zoom or monitor size. Using smoothstep with that value ensures an anti-aliased transition rather than a hard cutoff.\n\n\n\n\nPoints far from the origin tend to have large coordinate values. Without correction, their distances become exaggerated, and black borders vanish in those regions. A simple damping factor\nfloat positionCorrection = 1.0 / (10.0 + length(result.finalPosition));\ntames this effect by decreasing the apparent distance when the point is far away.\n\n\n\n\nPutting these refinements together gives the version below, which produces smooth, consistent outlines and a crisp fractal limit set.\n// ============================================\n// SCHOTTKY GROUP RENDERER - With Distance Estimation\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\n// ---------- Complex arithmetic ----------\nvec2 complexDiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y,\n                a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta), s = sin(theta);\n    return vec2(c*z.x - s*z.y, s*z.x + c*z.y);\n}\n\n// ---------- Circles ----------\nstruct Circle { vec2 center; float radius; };\nbool  isInsideCircle(vec2 z, Circle c){return length(z-c.center)&lt;c.radius;}\nfloat distanceToCircle(vec2 z, Circle c){return length(z-c.center)-c.radius;}\n\n// ---------- Generator ----------\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3  color;\n};\n\n// ---------- Möbius and inverse ----------\nvec2 schottkyMap(vec2 z, Generator g, inout float scale){\n    vec2 c1=g.interior.center, c2=g.exterior.center;\n    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;\n    float denom=max(dot(z-c1,z-c1),1e-6);\n    scale*=(k/denom);\n    vec2 base=c2+complexDiv(vec2(k,0.0),z-c1);\n    vec2 unit=(base-c2)/r2;\n    unit=complexRotate(unit,g.rotation);\n    return c2+r2*unit;\n}\n\nvec2 inverseSchottkyMap(vec2 z, Generator g, inout float scale){\n    vec2 c1=g.interior.center, c2=g.exterior.center;\n    float r1=g.interior.radius, r2=g.exterior.radius, k=r1*r2;\n    float denom=max(dot(z-c2,z-c2),1e-6);\n    scale*=(k/denom);\n    vec2 unit=(z-c2)/r2;\n    unit=complexRotate(unit,-g.rotation);\n    vec2 baseOut=c2+r2*unit;\n    return c1+complexDiv(vec2(k,0.0),baseOut-c2);\n}\n\n// ---------- Iteration ----------\nstruct IterationResult{vec3 color; vec2 finalPosition; float scale;};\n\nIterationResult iterateSchottky(vec2 z, Generator A, Generator B){\n    vec3 color=vec3(1.0); float scale=1.0;\n    for(int i=0;i&lt;MAX_ITERATIONS;i++){\n        bool moved=false;\n        if(isInsideCircle(z,A.interior)){z=schottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}\n        else if(isInsideCircle(z,A.exterior)){z=inverseSchottkyMap(z,A,scale);color=mix(color,A.color,0.5);moved=true;}\n        else if(isInsideCircle(z,B.interior)){z=schottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}\n        else if(isInsideCircle(z,B.exterior)){z=inverseSchottkyMap(z,B,scale);color=mix(color,B.color,0.5);moved=true;}\n        if(!moved)break;\n    }\n    return IterationResult(color,z,scale);\n}\n\n// ---------- Distance estimation ----------\nfloat distanceToGenerator(vec2 z, Generator g){\n    float d1=abs(distanceToCircle(z,g.interior));\n    float d2=abs(distanceToCircle(z,g.exterior));\n    return min(d1,d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator A, Generator B){\n    return min(distanceToGenerator(z,A),distanceToGenerator(z,B));\n}\n\nfloat correctedDistance(IterationResult r, Generator A, Generator B){\n    float d=distanceToSchottkyCircles(r.finalPosition,A,B);\n    float positionCorrection=1.0/(10.0+length(r.finalPosition));\n    return d/(r.scale*positionCorrection);\n}\n\n// ---------- Rendering ----------\nvec3 renderSchottky(IterationResult r, Generator A, Generator B){\n    float d=correctedDistance(r,A,B);\n    float pixelSize=1.0/iResolution.y;\n    float boundaryThickness=5.5*pixelSize;\n    float boundary=smoothstep(0.0,boundaryThickness,abs(d)-boundaryThickness);\n    return mix(vec3(0.0),r.color,boundary);\n}\n\n// ---------- Scene setup ----------\nvoid setupGenerators(out Generator A,out Generator B,float time){\n    float t=3.0*time, s=1.05+0.05*cos(t);\n    A.interior.center=vec2(0.55,0.55)*s; A.interior.radius=0.55;\n    A.exterior.center=vec2(-0.55,-0.55)*s; A.exterior.radius=0.55;\n    A.rotation=-PI/2.0; A.color=vec3(0.95,0.2,0.2);\n    B.interior.center=vec2(0.45,-0.45)*s; B.interior.radius=0.45;\n    B.exterior.center=vec2(-0.45,0.45)*s; B.exterior.radius=0.45;\n    B.rotation=PI/2.0; B.color=vec3(0.2,0.3,1.0);\n}\n\n// ---------- Main ----------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    Generator A,B; setupGenerators(A,B,iTime);\n    vec2 uv=(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*=2.0;\n    IterationResult r=iterateSchottky(uv,A,B);\n    vec3 color=renderSchottky(r,A,B);\n    fragColor=vec4(color,1.0);\n}\nThis shader is functionally identical to the simpler pedagogical one but with:\n\nMöbius-formula correctness rather than a three-step normalize/invert/denormalize approach.\nDerivative-based scaling for accurate distance estimation.\nScreen-space boundary control (5.5 * pixelSize) for consistent black borders.\nStabilized far-field correction so the picture remains uniform everywhere.\n\nThe result is a crisp, visually stable limit set—mathematically faithful and aesthetically satisfying.\n\n\n\n\n\nChange boundaryThickness from 5.5 to 3.0 or 8.0 to feel how border width changes.\nTry different radii or centers for the generators to see how the limit set morphs.\nReplace smoothstep with a hard threshold to understand aliasing artifacts.\nAnimate the rotations genA.rotation and genB.rotation to see how the twists deform the pattern.\n\n\nThis “advanced” version closes the loop between mathematical fidelity and graphical clarity. Students who have followed the whole derivation will now appreciate that the small extra factors—scale, pixelSize, and positionCorrection—are what make a shader image mathematically precise and visually beautiful at the same time."
  },
  {
    "objectID": "OLD/appendices/schottky.html#full-shader-2-two-generator-schottky-group",
    "href": "OLD/appendices/schottky.html#full-shader-2-two-generator-schottky-group",
    "title": "1 Schottky Groups, Möbius Maps, and GLSL",
    "section": "",
    "text": "This is a complete, self-contained version of your group renderer, but rewritten in the geometric style we developed:\n// ============================================\n// Shader 2: Schottky group with two generators\n// ============================================\n\nconst float PI = 3.14159265359;\nconst int MAX_ITERATIONS = 20;\n\n// ------------------------------\n// complex helpers\n// ------------------------------\nvec2 cdiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2(a.x*b.x + a.y*b.y,\n                a.y*b.x - a.x*b.y) / d;\n}\n\nvec2 complexRotate(vec2 z, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2(c*z.x - s*z.y,\n                s*z.x + c*z.y);\n}\n\n// ------------------------------\n// circle + generator structs\n// ------------------------------\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nstruct Generator {\n    Circle interior;\n    Circle exterior;\n    float rotation;\n    vec3 color;\n};\n\nbool isInsideCircle(vec2 z, Circle c) {\n    return length(z - c.center) &lt; c.radius;\n}\n\nfloat distanceToCircle(vec2 z, Circle c) {\n    return length(z - c.center) - c.radius;\n}\n\n// ------------------------------\n// geometric schottky map (factored)\n// maps exterior(interiorCircle) -&gt; interior(exteriorCircle)\n// ------------------------------\nvec2 schottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    // normalize to A\n    vec2 zA = (z - A.center) / A.radius;\n\n    // inversion derivative\n    float inversionScale = 1.0 / dot(zA, zA);\n    float radiusScale    = B.radius / A.radius;\n    scale *= inversionScale * radiusScale;\n\n    // invert\n    vec2 inv = cdiv(vec2(1.0,0.0), zA);\n\n    // to B\n    vec2 inB = B.center + B.radius * inv;\n\n    // rotate in B\n    vec2 unitB = (inB - B.center) / B.radius;\n    unitB = complexRotate(unitB, gen.rotation);\n    return B.center + B.radius * unitB;\n}\n\n// inverse map: undo rotation, normalize to B, invert, go to A\nvec2 inverseSchottkyMap(vec2 z, Generator gen, inout float scale) {\n    Circle A = gen.interior;\n    Circle B = gen.exterior;\n\n    // undo rotation in B\n    vec2 unitB = (z - B.center) / B.radius;\n    unitB = complexRotate(unitB, -gen.rotation);\n    vec2 pre = B.center + B.radius * unitB;\n\n    // normalize to B\n    vec2 zB = (pre - B.center) / B.radius;\n\n    float inversionScale = 1.0 / dot(zB, zB);\n    float radiusScale    = A.radius / B.radius;\n    scale *= inversionScale * radiusScale;\n\n    // invert and go to A\n    vec2 inv = cdiv(vec2(1.0,0.0), zB);\n    return A.center + A.radius * inv;\n}\n\n// ------------------------------\n// iteration\n// ------------------------------\nstruct IterationResult {\n    vec3 color;\n    vec2 finalPosition;\n    float scale;\n};\n\nIterationResult iterateSchottky(vec2 z, Generator genA, Generator genB) {\n    vec3 color = vec3(1.0);\n    float scale = 1.0;\n\n    for (int i = 0; i &lt; MAX_ITERATIONS; i++) {\n        bool moved = false;\n\n        if (isInsideCircle(z, genA.interior)) {\n            z = schottkyMap(z, genA, scale);\n            color = mix(color, genA.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genA.exterior)) {\n            z = inverseSchottkyMap(z, genA, scale);\n            color = mix(color, genA.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genB.interior)) {\n            z = schottkyMap(z, genB, scale);\n            color = mix(color, genB.color, 0.5);\n            moved = true;\n        }\n        else if (isInsideCircle(z, genB.exterior)) {\n            z = inverseSchottkyMap(z, genB, scale);\n            color = mix(color, genB.color, 0.5);\n            moved = true;\n        }\n\n        if (!moved) break;\n    }\n\n    IterationResult result;\n    result.color = color;\n    result.finalPosition = z;\n    result.scale = scale;\n    return result;\n}\n\n// ------------------------------\n// distance estimation (same idea as your program)\n// ------------------------------\nfloat distanceToGenerator(vec2 z, Generator gen) {\n    float d1 = abs(distanceToCircle(z, gen.interior));\n    float d2 = abs(distanceToCircle(z, gen.exterior));\n    return min(d1, d2);\n}\n\nfloat distanceToSchottkyCircles(vec2 z, Generator genA, Generator genB) {\n    return min(distanceToGenerator(z, genA),\n               distanceToGenerator(z, genB));\n}\n\nfloat correctedDistance(IterationResult result, Generator genA, Generator genB) {\n    float d = distanceToSchottkyCircles(result.finalPosition, genA, genB);\n    float positionCorrection = 1.0 / (10.0 + length(result.finalPosition));\n    return d / (result.scale * positionCorrection);\n}\n\n// ------------------------------\n// rendering\n// ------------------------------\nvec3 renderSchottky(IterationResult result, Generator genA, Generator genB) {\n    float d = correctedDistance(result, genA, genB);\n    float pixel = 1.0 / iResolution.y;\n    float thickness = 5.5 * pixel;\n    float boundary = smoothstep(0.0, thickness, abs(d) - thickness);\n    return mix(vec3(0.0), result.color, boundary);\n}\n\n// ------------------------------\n// generator setup\n// ------------------------------\nvoid setupGenerators(out Generator genA, out Generator genB, float time) {\n    float t = 3.0 * time;\n    float s = 1.05 + 0.05 * cos(t);\n\n    genA.interior.center = vec2(0.55, 0.55) * s;\n    genA.interior.radius = 0.55;\n    genA.exterior.center = vec2(-0.55, -0.55) * s;\n    genA.exterior.radius = 0.55;\n    genA.rotation = -PI / 2.0;\n    genA.color = vec3(0.95, 0.2, 0.2);\n\n    genB.interior.center = vec2(0.45, -0.45) * s;\n    genB.interior.radius = 0.45;\n    genB.exterior.center = vec2(-0.45, 0.45) * s;\n    genB.exterior.radius = 0.45;\n    genB.rotation = PI / 2.0;\n    genB.color = vec3(0.2, 0.3, 1.0);\n}\n\n// ------------------------------\n// main\n// ------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Generator genA, genB;\n    setupGenerators(genA, genB, iTime);\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n\n    IterationResult result = iterateSchottky(uv, genA, genB);\n    vec3 color = renderSchottky(result, genA, genB);\n\n    fragColor = vec4(color, 1.0);\n}\nThat’s the full group shader, expressed the way we described the geometry."
  },
  {
    "objectID": "OLD/appendices/glsl-reference.html",
    "href": "OLD/appendices/glsl-reference.html",
    "title": "1 GLSL",
    "section": "",
    "text": "1 GLSL"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html",
    "href": "OLD/appendices/day2-shaders.html",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "This appendix provides complete, standalone Shadertoy code for each shader program presented in Day 2. Each listing includes all necessary helper functions and can be copied directly into Shadertoy (https://www.shadertoy.com/new) and run immediately.\n\n\n\nThis is the simplest Mandelbrot renderer, showing just the escape-time iteration count in grayscale.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Grayscale coloring\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nThis adds smooth coloring and a cosine-based color palette for much better visual quality.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        // Smooth iteration count\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        // Inside the set: black\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nTemplate for Julia set implementation. Students fill in the iteration code based on Mandelbrot.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // HOMEWORK: Initialize z from pixel position\n    // HOMEWORK: Iterate z_{n+1} = z_n^2 + c\n    // HOMEWORK: Use smooth coloring like Mandelbrot\n    \n    // Placeholder color (replace with your implementation)\n    vec3 color = vec3(0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nHere’s a complete working Julia set for reference:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // Initialize z from pixel position (key difference from Mandelbrot!)\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nFor interactive exploration of parameter space:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // c controlled by mouse position\n    vec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 c = mouse_uv * 3.0;\n    \n    // Fallback if mouse hasn't been clicked\n    if(iMouse.z &lt; 0.5) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Initialize z from pixel position\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAnimating through parameter space:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Animate c around a circle in parameter space\n    float angle = iTime * 0.3;\n    float radius = 0.7885;\n    vec2 c = vec2(radius * cos(angle), radius * sin(angle));\n    \n    // Initialize z from pixel position\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\nVisualizes circle inversion by showing how it deforms a grid.\n// Circle inversion function\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);\n    float gridLine = step(0.95, max(grid.x, grid.y));\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle itself (for reference)\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nComplete Apollonian gasket implementation with iteration coloring.\n// Circle struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n// Circle inversion\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\n// Setup four mutually tangent circles (three inner + one outer)\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\n\n// Iterate inversions through four circles (three inner + one outer)\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by iteration count\n    float t = float(finalIter) / float(maxIter);\n    vec3 color = palette(t);\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nAlternative coloring showing which circle’s basin each point falls into:\n// Circle struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n// Circle inversion\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\n// Setup four mutually tangent circles (three inner + one outer)\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\n\n// Iterate inversions through four circles (three inner + one outer)\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by which circle we last hit\n    vec3 colors[4];\n    colors[0] = vec3(1.0, 0.0, 0.0);  // Circle 1: Red\n    colors[1] = vec3(0.0, 1.0, 0.0);  // Circle 2: Green\n    colors[2] = vec3(0.0, 0.0, 1.0);  // Circle 3: Blue\n    colors[3] = vec3(1.0, 1.0, 0.0);  // Outer circle: Yellow\n    \n    vec3 color = colors[lastCircle];\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\nShows many Julia sets in a grid, revealing the Mandelbrot set structure.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv ;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Divide screen into grid cells\n    float grid_size = 50.0;  // 8×8 grid\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;  // Local coordinates within cell\n    \n    // Map cell_id to parameter c\n    vec2 c = (cell_id / grid_size) * 3.0 - vec2(2.5, 1.5);\n    c.x -= 0.5;  // Center on Mandelbrot set\n    \n    // Run Julia set iteration\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    // Draw grid lines\n    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);\n    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nGo to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\n\nEach shader has parameters you can adjust at the top of mainImage():\nMandelbrot/Julia: - max_iter - More iterations reveal finer detail (try 200) - Color scale factor in uv * 3.5 - Zoom in/out - Offset c.x -= 0.5 - Pan the view\nJulia specific: - vec2 c = ... - Change the parameter to see different Julia sets - Try values from the homework section\nCircle Inversion: - circleCenter - Move the inversion circle - circleRadius - Change the size - Grid frequency in p_inverted * 2.0 - Denser or sparser grid\nApollonian Gasket: - maxIter - More iterations show deeper nesting - R and r in setup function - Change circle sizes - Color palette parameters in palette() function\n\n\n\nIf a shader runs slowly: - Reduce max_iter (try 50 instead of 100) - Lower the resolution (bottom right resolution dropdown in Shadertoy) - Some computers may struggle with smooth coloring - remove it for speed\n\n\n\nAll of these shaders are starting points! Try: - Combining techniques (Julia set with Apollonian coloring scheme) - Animating parameters with iTime - Adding mouse interaction with iMouse - Creating your own color palettes - Experimenting with different circle configurations\nThe goal is to understand how simple iterative processes create complex fractals, and how to implement them efficiently on the GPU!"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html#a1.-basic-mandelbrot-set-grayscale",
    "href": "OLD/appendices/day2-shaders.html#a1.-basic-mandelbrot-set-grayscale",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "This is the simplest Mandelbrot renderer, showing just the escape-time iteration count in grayscale.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Grayscale coloring\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html#a2.-mandelbrot-set-with-smooth-coloring",
    "href": "OLD/appendices/day2-shaders.html#a2.-mandelbrot-set-with-smooth-coloring",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "This adds smooth coloring and a cosine-based color palette for much better visual quality.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        // Smooth iteration count\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        // Inside the set: black\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html#a3.-julia-set-explorer",
    "href": "OLD/appendices/day2-shaders.html#a3.-julia-set-explorer",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "Template for Julia set implementation. Students fill in the iteration code based on Mandelbrot.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // HOMEWORK: Initialize z from pixel position\n    // HOMEWORK: Iterate z_{n+1} = z_n^2 + c\n    // HOMEWORK: Use smooth coloring like Mandelbrot\n    \n    // Placeholder color (replace with your implementation)\n    vec3 color = vec3(0.5);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nHere’s a complete working Julia set for reference:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);\n    \n    // Initialize z from pixel position (key difference from Mandelbrot!)\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nFor interactive exploration of parameter space:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // c controlled by mouse position\n    vec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;\n    mouse_uv.x *= iResolution.x / iResolution.y;\n    vec2 c = mouse_uv * 3.0;\n    \n    // Fallback if mouse hasn't been clicked\n    if(iMouse.z &lt; 0.5) {\n        c = vec2(-0.7, 0.27015);\n    }\n    \n    // Initialize z from pixel position\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nAnimating through parameter space:\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;\n    \n    // Animate c around a circle in parameter space\n    float angle = iTime * 0.3;\n    float radius = 0.7885;\n    vec2 c = vec2(radius * cos(angle), radius * sin(angle));\n    \n    // Initialize z from pixel position\n    vec2 z = p;\n    \n    // Julia set iteration\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Smooth coloring\n    vec3 color;\n    if(iter &lt; max_iter) {\n        float log_zn = log(cabs2(z)) / 2.0;\n        float nu = log(log_zn / log(2.0)) / log(2.0);\n        float smooth_iter = float(iter) + 1.0 - nu;\n        \n        float t = smooth_iter / float(max_iter);\n        color = palette(t);\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html#a4.-circle-inversion-visualization",
    "href": "OLD/appendices/day2-shaders.html#a4.-circle-inversion-visualization",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "Visualizes circle inversion by showing how it deforms a grid.\n// Circle inversion function\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);\n    float gridLine = step(0.95, max(grid.x, grid.y));\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle itself (for reference)\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html#a5.-apollonian-gasket",
    "href": "OLD/appendices/day2-shaders.html#a5.-apollonian-gasket",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "Complete Apollonian gasket implementation with iteration coloring.\n// Circle struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n// Circle inversion\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\n// Setup four mutually tangent circles (three inner + one outer)\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\n\n// Iterate inversions through four circles (three inner + one outer)\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by iteration count\n    float t = float(finalIter) / float(maxIter);\n    vec3 color = palette(t);\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nAlternative coloring showing which circle’s basin each point falls into:\n// Circle struct\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\n// Circle inversion\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);\n    \n    if(r2 &lt; 0.0001) return vec2(1000.0);\n    \n    return center + (radius * radius) * diff / r2;\n}\n\n// Setup four mutually tangent circles (three inner + one outer)\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\n\n// Iterate inversions through four circles (three inner + one outer)\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by which circle we last hit\n    vec3 colors[4];\n    colors[0] = vec3(1.0, 0.0, 0.0);  // Circle 1: Red\n    colors[1] = vec3(0.0, 1.0, 0.0);  // Circle 2: Green\n    colors[2] = vec3(0.0, 0.0, 1.0);  // Circle 3: Blue\n    colors[3] = vec3(1.0, 1.0, 0.0);  // Outer circle: Yellow\n    \n    vec3 color = colors[lastCircle];\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html#a6.-grid-of-julia-sets-optional-homework",
    "href": "OLD/appendices/day2-shaders.html#a6.-grid-of-julia-sets-optional-homework",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "Shows many Julia sets in a grid, revealing the Mandelbrot set structure.\n// Complex number operations\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\n// Cosine-based color palette\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv ;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Divide screen into grid cells\n    float grid_size = 50.0;  // 8×8 grid\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;  // Local coordinates within cell\n    \n    // Map cell_id to parameter c\n    vec2 c = (cell_id / grid_size) * 3.0 - vec2(2.5, 1.5);\n    c.x -= 0.5;  // Center on Mandelbrot set\n    \n    // Run Julia set iteration\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);\n    \n    // Draw grid lines\n    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);\n    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/day2-shaders.html#notes-on-using-these-shaders",
    "href": "OLD/appendices/day2-shaders.html#notes-on-using-these-shaders",
    "title": "1 Appendix: Complete Shader Code for Day 2",
    "section": "",
    "text": "Go to https://www.shadertoy.com/new\nDelete the default code\nCopy and paste any of the above listings\nClick the play button (▶) or press Alt+Enter\n\n\n\n\nEach shader has parameters you can adjust at the top of mainImage():\nMandelbrot/Julia: - max_iter - More iterations reveal finer detail (try 200) - Color scale factor in uv * 3.5 - Zoom in/out - Offset c.x -= 0.5 - Pan the view\nJulia specific: - vec2 c = ... - Change the parameter to see different Julia sets - Try values from the homework section\nCircle Inversion: - circleCenter - Move the inversion circle - circleRadius - Change the size - Grid frequency in p_inverted * 2.0 - Denser or sparser grid\nApollonian Gasket: - maxIter - More iterations show deeper nesting - R and r in setup function - Change circle sizes - Color palette parameters in palette() function\n\n\n\nIf a shader runs slowly: - Reduce max_iter (try 50 instead of 100) - Lower the resolution (bottom right resolution dropdown in Shadertoy) - Some computers may struggle with smooth coloring - remove it for speed\n\n\n\nAll of these shaders are starting points! Try: - Combining techniques (Julia set with Apollonian coloring scheme) - Animating parameters with iTime - Adding mouse interaction with iMouse - Creating your own color palettes - Experimenting with different circle configurations\nThe goal is to understand how simple iterative processes create complex fractals, and how to implement them efficiently on the GPU!"
  },
  {
    "objectID": "OLD/appendices/debug-reference.html",
    "href": "OLD/appendices/debug-reference.html",
    "title": "1 Debugging",
    "section": "",
    "text": "1 Debugging"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html",
    "href": "OLD/appendices/folding-fractals.html",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "This appendix explores a fascinating technique for generating fractals: iterated folding with scaling. While reflection-based tiling (Days 2-3) fills space with copies of a fundamental domain, folding fractals add scaling at each iteration, creating self-similar structures that exhibit fractal geometry.\nWe’ll explore three classic examples: 1. Sierpinski Triangle (2D, triangle-based) 2. Sierpinski Carpet (2D, square-based) 3. Menger Sponge (3D, cube-based)\nThese connect naturally to course content: the folding operations use techniques from Day 2-3 (reflection, abs()), and the Menger sponge extends to 3D using Day 4’s coordinate systems.\n\n\n\n\n\n\nAll folding fractals follow this pattern:\n\nFold: Use geometric operations (reflection, abs()) to bring the point into a fundamental region\nScale: Zoom in by some factor (typically 2 or 3)\nRepeat: Iterate this process\nClassify: After \\(n\\) iterations, check if the point is in a “removed” region or “kept” region\n\nAfter \\(n\\) iterations: - We’ve zoomed in by factor \\(s^n\\) (where \\(s\\) is the scale factor) - The fractal structure emerges from the removal pattern - The result is self-similar: zooming in reveals the same pattern\n\n\n\nRecall from Day 3: - Tiling: Fold → repeat (fills space with copies) - Fractal: Fold → scale → repeat (creates self-similar structure with removed regions)\nThe key difference is the scaling step!\n\n\n\n\n\n\n\nThe Sierpinski triangle is constructed by: 1. Start with an equilateral triangle 2. Remove the middle triangle (formed by connecting edge midpoints) 3. Recursively repeat on each remaining sub-triangle\nEquivalently: iteratively fold into the triangle and scale by 2.\n\n\n\nBefore implementing the fractal, we need the correct reflection formula.\nA line in the plane can be written as \\(ax + by = c\\), with normal vector \\(\\mathbf{n} = (a, b)\\).\nReflection formula: For a point \\(\\mathbf{p} = (x, y)\\), the reflection \\(\\mathbf{p}'\\) across the line is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere: - \\(d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\) is the signed distance to the line - \\(\\hat{\\mathbf{n}} = \\frac{(a,b)}{\\sqrt{a^2 + b^2}}\\) is the unit normal\nCombining these: \\[\\mathbf{p}' = \\mathbf{p} - \\frac{2(ax + by - c)}{a^2 + b^2}(a, b)\\]\n\n\n\nLet’s organize line data properly:\nstruct Line {\n    float a, b, c;  // Line equation: ax + by = c\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    // Signed distance from point to line (unnormalized)\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    \n    // Normal vector squared length\n    float normSq = line.a * line.a + line.b * line.b;\n    \n    // Reflection formula\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\n\n\nFor an equilateral triangle with vertices: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nWe need the three edge lines:\nEdge from \\(v_0\\) to \\(v_1\\): Direction vector: \\(v_1 - v_0 = (-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2})\\) Normal (perpendicular): \\((\\frac{3}{2}, -\\frac{\\sqrt{3}}{2})\\) or simplified: \\((3, -\\sqrt{3})\\) Line equation: \\(3x - \\sqrt{3}y = c\\), passing through \\(v_0 = (0,1)\\): \\(c = -\\sqrt{3}\\)\nEdge from \\(v_1\\) to \\(v_2\\): This is horizontal: \\(y = -\\frac{1}{2}\\) Line equation: \\(0x + 1y = -\\frac{1}{2}\\) or \\((0, 1, -0.5)\\)\nEdge from \\(v_2\\) to \\(v_0\\): By symmetry: \\(-3x - \\sqrt{3}y = -\\sqrt{3}\\)\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    \n    // Edge v0 to v1\n    e1.a = 3.0;\n    e1.b = -sqrt3;\n    e1.c = -sqrt3;\n    \n    // Edge v1 to v2 (horizontal)\n    e2.a = 0.0;\n    e2.b = 1.0;\n    e2.c = -0.5;\n    \n    // Edge v2 to v0\n    e3.a = -3.0;\n    e3.b = -sqrt3;\n    e3.c = -sqrt3;\n}\n\n\n\nNow we can properly fold into the triangle:\n\n\n\nNow we can properly fold into the triangle:\nvec2 foldIntoTriangle(vec2 p, Line e1, Line e2, Line e3, int maxIter) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        vec2 p_old = p;\n        \n        // Reflect across each edge if we're on the wrong side\n        // Check sign of distance: if negative, we're on wrong side\n        float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n        if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n        \n        float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n        if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n        \n        float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n        if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        \n        // Converged? (no more reflections)\n        if(length(p - p_old) &lt; 0.0001) break;\n    }\n    \n    return p;\n}\n\n\n\nFor the Sierpinski fractal, we fold and then scale:\nvec2 sierpinskiTriangle(vec2 p, int iterations, out int depth) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    depth = 0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into fundamental triangle\n        p = foldIntoTriangle(p, e1, e2, e3, 10);\n        \n        // Scale by 2 toward center\n        vec2 center = vec2(0.0, 0.0);  // Approximate center\n        p = (p - center) * 2.0 + center;\n        \n        depth++;\n        \n        // Optional: early exit if escaped\n        if(length(p) &gt; 100.0) break;\n    }\n    \n    return p;\n}\n\n\n\nAfter folding, we need to check if we’re in the “removed” middle triangle. Using barycentric coordinates:\n\n### Determining if Point is in Fractal\n\nAfter folding, we need to check if we're in the \"removed\" middle triangle. The middle triangle has vertices at the midpoints of the original triangle's edges.\n\nFor an equilateral triangle with vertices $v_0, v_1, v_2$, the midpoints are:\n$$m_{01} = \\frac{v_0 + v_1}{2}, \\quad m_{12} = \\frac{v_1 + v_2}{2}, \\quad m_{20} = \\frac{v_2 + v_0}{2}$$\n\nWe can check if point $p$ is inside this middle triangle using barycentric coordinates:\n\n```glsl\nbool inMiddleTriangle(vec2 p) {\n    // Vertices of original triangle\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    // Midpoints (vertices of removed triangle)\n    vec2 m01 = (v0 + v1) * 0.5;\n    vec2 m12 = (v1 + v2) * 0.5;\n    vec2 m20 = (v2 + v0) * 0.5;\n    \n    // Check if p is inside triangle m01-m12-m20\n    // Using sign of cross products\n    vec2 e0 = m12 - m01;\n    vec2 e1 = m20 - m12;\n    vec2 e2 = m01 - m20;\n    \n    vec2 p0 = p - m01;\n    vec2 p1 = p - m12;\n    vec2 p2 = p - m20;\n    \n    float s0 = e0.x * p0.y - e0.y * p0.x;\n    float s1 = e1.x * p1.y - e1.y * p1.x;\n    float s2 = e2.x * p2.y - e2.y * p2.x;\n    \n    // All same sign means inside\n    return (s0 &gt;= 0.0 && s1 &gt;= 0.0 && s2 &gt;= 0.0) || \n           (s0 &lt;= 0.0 && s1 &lt;= 0.0 && s2 &lt;= 0.0);\n}\n\n\n\nstruct Line {\n    float a, b, c;\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    float normSq = line.a * line.a + line.b * line.b;\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    e1 = Line(3.0, -sqrt3, -sqrt3);\n    e2 = Line(0.0, 1.0, -0.5);\n    e3 = Line(-3.0, -sqrt3, -sqrt3);\n}\n\nvec2 sierpinskiTriangle(vec2 p, int iterations, out bool inFractal) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into triangle\n        for(int j = 0; j &lt; 10; j++) {\n            float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n            if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n            \n            float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n            if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n            \n            float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n            if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        }\n        \n        // Check if in removed region\n        if(inMiddleTriangle(p)) {\n            inFractal = false;\n        }\n        \n        // Scale by 2\n        p = p * 2.0;\n    }\n    \n    return p;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 3.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal;\n    vec2 p_final = sierpinskiTriangle(uv, 6, inFractal);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color by final position\n        float t = length(p_final) * 0.1;\n        color = palette(t);\n    } else {\n        // Removed region\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Sierpinski triangle should now render with mathematically correct reflections!\n\n\n\n\n\n\n\nThe Sierpinski carpet is the square analog: 1. Start with a square 2. Divide into a 3×3 grid of sub-squares 3. Remove the central sub-square 4. Recursively repeat on each remaining sub-square\nNote: Unlike the triangle, the carpet uses axis-aligned divisions, so the implementation is both simpler AND mathematically exact—no approximations needed!\n\n\n\nMuch simpler than the triangle because we can use axis-aligned operations!\nAt each iteration: 1. Fold using abs() to create 4-fold symmetry (all quadrants map to first quadrant) 2. Scale by factor of 3 3. Check if we’re in the removed middle region\n\n\n\nbool sierpinskiCarpet(vec2 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant (creates 4-fold symmetry)\n        p = abs(p);\n        \n        // Scale by 3 and recenter\n        p = p * 3.0 - vec2(1.0);\n        \n        // After this transformation, the \"removed\" region is\n        // approximately where both |p.x| &lt; 1 and |p.y| &lt; 1\n    }\n    \n    // Check if in removed region\n    // After n iterations, if we're in the central square, we're removed\n    return (abs(p.x) &lt; 1.0 && abs(p.y) &lt; 1.0);\n}\n\n\n\nvec2 carpetFold(vec2 p, int iterations, out bool inFractal) {\n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Check if in middle third in both dimensions\n        // In normalized [0,1] space, middle third is [1/3, 2/3]\n        vec2 normalizedP = fract(p);  // Get fractional part\n        \n        bool inMiddleX = (normalizedP.x &gt; 0.33 && normalizedP.x &lt; 0.67);\n        bool inMiddleY = (normalizedP.y &gt; 0.33 && normalizedP.y &lt; 0.67);\n        \n        if(inMiddleX && inMiddleY) {\n            inFractal = false;\n        }\n        \n        // Scale by 3\n        p = p * 3.0;\n    }\n    \n    return p;\n}\n\n\n\nA cleaner approach using the subdivision pattern:\nbool inSierpinskiCarpet(vec2 p, int iterations) {\n    // Normalize to [0, 1]\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Which cell of 3×3 grid are we in?\n        vec2 cell = floor(p * 3.0);\n        \n        // Middle cell (1,1) is removed\n        if(cell.x == 1.0 && cell.y == 1.0) {\n            return false;  // In removed region\n        }\n        \n        // Zoom into current cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;  // In fractal\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal = inSierpinskiCarpet(uv, 6);\n    \n    vec3 color = inFractal ? vec3(1.0, 1.0, 0.8) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nThe Menger sponge is the 3D analog of the Sierpinski carpet: 1. Start with a cube 2. Divide into a 3×3×3 grid of sub-cubes (27 total) 3. Remove the central sub-cube and the 6 face-centered sub-cubes (7 removed, 20 remain) 4. Recursively repeat on each remaining sub-cube\nNote: Like the carpet, the sponge uses axis-aligned divisions, giving us an exact, mathematically precise implementation.\n\n\n\nSame pattern as the carpet, but in 3D!\n\nFold using abs(p) to create octahedral symmetry\nScale by factor of 3\nCheck if we’re in a removed region (middle cross pattern)\n\n\n\n\nbool inMengerSponge(vec3 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        p = abs(p);\n        \n        // Which cell of 3×3×3 grid?\n        vec3 cell = floor(p * 3.0);\n        \n        // Removed regions: center cube and face centers\n        // Center: (1,1,1)\n        // Face centers: (1,1,0), (1,1,2), (1,0,1), (1,2,1), (0,1,1), (2,1,1)\n        // Pattern: at least 2 coordinates equal to 1\n        \n        float ones = 0.0;\n        if(cell.x == 1.0) ones += 1.0;\n        if(cell.y == 1.0) ones += 1.0;\n        if(cell.z == 1.0) ones += 1.0;\n        \n        if(ones &gt;= 2.0) {\n            return false;  // Removed region\n        }\n        \n        // Zoom into cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;\n}\n\n\n\nWe can also implement the Menger sponge as a signed distance function for use with Day 4’s raymarching:\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdMengerSponge(vec3 p, int iterations) {\n    float d = sdBox(p, vec3(1.0));  // Start with unit cube\n    \n    float scale = 1.0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        vec3 a = mod(p * scale, 2.0) - 1.0;\n        scale *= 3.0;\n        \n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        \n        // Distance to cross (removed region)\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / scale;\n        \n        d = max(d, c);\n    }\n    \n    return d;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray (using Day 4 techniques)\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Raymarch\n    float t = 0.0;\n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = ray.origin + t * ray.direction;\n        float d = sdMengerSponge(pos, 4);\n        \n        if(abs(d) &lt; 0.001) {\n            // Hit!\n            vec3 normal = estimateNormal(pos);  // Day 4 technique\n            \n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            float diffuse = max(0.0, dot(normal, lightDir));\n            \n            vec3 color = vec3(1.0, 0.8, 0.6) * diffuse + vec3(0.1);\n            fragColor = vec4(color, 1.0);\n            return;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) break;\n    }\n    \n    // Miss\n    fragColor = vec4(0.1, 0.1, 0.2, 1.0);\n}\n\n\n\n\n\n\n\n\nSymmetry operations:\n\nabs() for axis-aligned symmetry\nReflections for arbitrary symmetry\n\nScaling factor:\n\nFactor of 2: Sierpinski triangle\nFactor of 3: Sierpinski carpet, Menger sponge\nGeneral factor \\(s\\): determines fractal dimension\n\nRemoval pattern:\n\nWhich regions get removed at each level\nDefines the fractal’s structure\n\nIteration:\n\nMore iterations = more detail\nComputational cost grows linearly\nVisual complexity grows exponentially\n\n\n\n\n\nThe fractal dimension \\(D\\) can be computed from the scaling factor \\(s\\) and the number of remaining pieces \\(N\\):\n\\[D = \\frac{\\log N}{\\log s}\\]\nExamples: - Sierpinski triangle: \\(N = 3\\) pieces, scale factor \\(s = 2\\) \\[D = \\frac{\\log 3}{\\log 2} \\approx 1.585\\]\n\nSierpinski carpet: \\(N = 8\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 8}{\\log 3} \\approx 1.893\\]\nMenger sponge: \\(N = 20\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 20}{\\log 3} \\approx 2.727\\]\n\nThe fractal dimension is between the topological dimension and the embedding dimension, reflecting the fractal’s “in-between” nature!\n\n\n\n\n\n\n\nTrack which iteration first identifies a point as removed:\nint firstRemovedIter = -1;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    // [Folding and scaling]\n    \n    if([in removed region] && firstRemovedIter &lt; 0) {\n        firstRemovedIter = i;\n    }\n}\n\nfloat t = float(firstRemovedIter) / float(iterations);\nvec3 color = palette(t);\n\n\n\nvec2 p_final = [after all folding];\nfloat d = length(p_final);\nvec3 color = vec3(d * 0.5);  // Grayscale by distance\n\n\n\nFor grid-based fractals (carpet, sponge), color by which sub-cell the point lands in:\nvec3 cell = floor(p * 3.0);\nvec3 color = cell / 3.0;  // RGB from cell coordinates\n\n\n\nFor 3D fractals, combine distance estimation with fractal membership:\nfloat d = sdMengerSponge(p, iterations);\nvec3 color;\n\nif(d &lt; 0.0) {\n    // Inside sponge\n    color = vec3(1.0, 0.8, 0.6);\n} else {\n    // Outside, but show distance\n    color = vec3(0.1) + vec3(0.2) / (1.0 + d);\n}\n\n\n\n\n\n\n\nTry different symmetry groups: - Hexagonal symmetry (6-fold) - Octahedral symmetry (for 3D) - Custom reflection patterns\n\n\n\n\nScale by 4: sparser fractal\nScale by 1.5: denser fractal\nNon-integer scales: unusual structures\n\n\n\n\nfloat scale = 2.0 + 0.5 * sin(iTime);\np = p * scale;\nWatch the fractal morph as the scale factor changes!\n\n\n\nTrack the “orbit” of the point through the folding process:\nfloat orbit = 0.0;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    orbit += length(p);  // Accumulate total distance traveled\n    // [Folding operations]\n}\n\nvec3 color = palette(orbit / 10.0);\n\n\n\n\nCross-Menger: Different removal pattern (only center)\nJerusalem Cube: Variation with different symmetry\nHybrid fractals: Combine different removal patterns at different scales\n\n\n\n\n\n\n\n\nBoth folding fractals and the Mandelbrot set/Apollonian gasket share the principle: simple operations iterated create complex structure.\n\nMandelbrot: \\(z \\to z^2 + c\\) (complex arithmetic iteration)\nApollonian: Repeated circle inversions (geometric iteration)\nSierpinski: Fold + scale (geometric iteration with scaling)\n\n\n\n\nEuclidean and hyperbolic tilings use folding without scaling: - Reflection brings points into fundamental domain - No scaling → fills space with copies - With scaling → creates fractal structure\n\n\n\nThe Menger sponge naturally extends to 3D: - Can be rendered as SDF (raymarching) - Can be rendered as boolean test (simple ray casting) - Demonstrates 3D coordinate folding\n\n\n\n\n\n\n\nCreate a Sierpinski gasket based on a hexagon instead of a triangle: - Use 6-fold symmetry - Scale by factor of 3 - Remove appropriate regions\n\n\n\nModify the Sierpinski carpet to have a time-varying scale factor:\nfloat scale = 3.0 + sin(iTime);\nWatch how the fractal structure changes!\n\n\n\nImplement a 3D fractal using only cross-shaped removal (remove only the center cube, not the face centers). Compare to the standard Menger sponge.\n\n\n\nCombine two different fractals: - First 3 iterations: Sierpinski triangle folding - Next 3 iterations: Sierpinski carpet folding - Observe the unusual resulting structure\n\n\n\nRender the Menger sponge with colors based on distance from the surface: - Use sdMengerSponge as a distance field - Color by distance for points outside - Different color for points inside\n\n\n\n\n\n\n\n\nHausdorff dimension and box-counting dimension\nIterated function systems (IFS)\nSelf-similar sets and scaling symmetries\n\n\n\n\n\nEscape-time algorithms\nDistance estimation for fractals\nEfficient rendering of fractal geometry\n\n\n\n\n\nProcedural generation in games/graphics\nAntenna design (fractal antennas)\nModeling natural phenomena (coastlines, plants)\nCompression algorithms\n\n\n\n\n\n\nFolding fractals demonstrate: 1. Iteration + scaling creates self-similar structure 2. Simple operations produce complex results 3. GPU parallelism enables real-time fractal rendering 4. Fractals connect to many course topics (iteration, symmetry, 3D)\nThe techniques here—folding, scaling, iteration—are fundamental to both mathematical fractals and computer graphics. These methods extend naturally from 2D to 3D, and from static to animated, making them powerful tools for mathematical visualization.\nKey takeaway: Fractals aren’t just beautiful—they’re computationally accessible. A few dozen lines of shader code can generate infinite complexity!\n\n\n\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nbool inCarpet(vec2 p, int iterations) {\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        vec2 cell = floor(p * 3.0);\n        if(cell.x == 1.0 && cell.y == 1.0) return false;\n        p = fract(p * 3.0);\n    }\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom animation\n    float zoom = exp(sin(iTime * 0.3) * 2.0);\n    uv *= zoom;\n    \n    // Rotation animation\n    float angle = iTime * 0.2;\n    float c = cos(angle), s = sin(angle);\n    uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n    \n    int iterations = 6;\n    bool inFractal = inCarpet(uv, iterations);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color based on distance from center\n        float d = length(uv);\n        color = palette(d * 0.5 + iTime * 0.1);\n    } else {\n        color = vec3(0.05, 0.05, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis creates a beautiful, animated Sierpinski carpet that zooms and rotates, with colors flowing through the fractal structure!"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#overview",
    "href": "OLD/appendices/folding-fractals.html#overview",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "This appendix explores a fascinating technique for generating fractals: iterated folding with scaling. While reflection-based tiling (Days 2-3) fills space with copies of a fundamental domain, folding fractals add scaling at each iteration, creating self-similar structures that exhibit fractal geometry.\nWe’ll explore three classic examples: 1. Sierpinski Triangle (2D, triangle-based) 2. Sierpinski Carpet (2D, square-based) 3. Menger Sponge (3D, cube-based)\nThese connect naturally to course content: the folding operations use techniques from Day 2-3 (reflection, abs()), and the Menger sponge extends to 3D using Day 4’s coordinate systems."
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#fundamental-concept-folding-scaling-fractals",
    "href": "OLD/appendices/folding-fractals.html#fundamental-concept-folding-scaling-fractals",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "All folding fractals follow this pattern:\n\nFold: Use geometric operations (reflection, abs()) to bring the point into a fundamental region\nScale: Zoom in by some factor (typically 2 or 3)\nRepeat: Iterate this process\nClassify: After \\(n\\) iterations, check if the point is in a “removed” region or “kept” region\n\nAfter \\(n\\) iterations: - We’ve zoomed in by factor \\(s^n\\) (where \\(s\\) is the scale factor) - The fractal structure emerges from the removal pattern - The result is self-similar: zooming in reveals the same pattern\n\n\n\nRecall from Day 3: - Tiling: Fold → repeat (fills space with copies) - Fractal: Fold → scale → repeat (creates self-similar structure with removed regions)\nThe key difference is the scaling step!"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#sierpinski-triangle",
    "href": "OLD/appendices/folding-fractals.html#sierpinski-triangle",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "The Sierpinski triangle is constructed by: 1. Start with an equilateral triangle 2. Remove the middle triangle (formed by connecting edge midpoints) 3. Recursively repeat on each remaining sub-triangle\nEquivalently: iteratively fold into the triangle and scale by 2.\n\n\n\nBefore implementing the fractal, we need the correct reflection formula.\nA line in the plane can be written as \\(ax + by = c\\), with normal vector \\(\\mathbf{n} = (a, b)\\).\nReflection formula: For a point \\(\\mathbf{p} = (x, y)\\), the reflection \\(\\mathbf{p}'\\) across the line is:\n\\[\\mathbf{p}' = \\mathbf{p} - 2d\\hat{\\mathbf{n}}\\]\nwhere: - \\(d = \\frac{ax + by - c}{\\sqrt{a^2 + b^2}}\\) is the signed distance to the line - \\(\\hat{\\mathbf{n}} = \\frac{(a,b)}{\\sqrt{a^2 + b^2}}\\) is the unit normal\nCombining these: \\[\\mathbf{p}' = \\mathbf{p} - \\frac{2(ax + by - c)}{a^2 + b^2}(a, b)\\]\n\n\n\nLet’s organize line data properly:\nstruct Line {\n    float a, b, c;  // Line equation: ax + by = c\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    // Signed distance from point to line (unnormalized)\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    \n    // Normal vector squared length\n    float normSq = line.a * line.a + line.b * line.b;\n    \n    // Reflection formula\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\n\n\nFor an equilateral triangle with vertices: \\[v_0 = (0, 1), \\quad v_1 = \\left(-\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right), \\quad v_2 = \\left(\\frac{\\sqrt{3}}{2}, -\\frac{1}{2}\\right)\\]\nWe need the three edge lines:\nEdge from \\(v_0\\) to \\(v_1\\): Direction vector: \\(v_1 - v_0 = (-\\frac{\\sqrt{3}}{2}, -\\frac{3}{2})\\) Normal (perpendicular): \\((\\frac{3}{2}, -\\frac{\\sqrt{3}}{2})\\) or simplified: \\((3, -\\sqrt{3})\\) Line equation: \\(3x - \\sqrt{3}y = c\\), passing through \\(v_0 = (0,1)\\): \\(c = -\\sqrt{3}\\)\nEdge from \\(v_1\\) to \\(v_2\\): This is horizontal: \\(y = -\\frac{1}{2}\\) Line equation: \\(0x + 1y = -\\frac{1}{2}\\) or \\((0, 1, -0.5)\\)\nEdge from \\(v_2\\) to \\(v_0\\): By symmetry: \\(-3x - \\sqrt{3}y = -\\sqrt{3}\\)\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    \n    // Edge v0 to v1\n    e1.a = 3.0;\n    e1.b = -sqrt3;\n    e1.c = -sqrt3;\n    \n    // Edge v1 to v2 (horizontal)\n    e2.a = 0.0;\n    e2.b = 1.0;\n    e2.c = -0.5;\n    \n    // Edge v2 to v0\n    e3.a = -3.0;\n    e3.b = -sqrt3;\n    e3.c = -sqrt3;\n}\n\n\n\nNow we can properly fold into the triangle:\n\n\n\nNow we can properly fold into the triangle:\nvec2 foldIntoTriangle(vec2 p, Line e1, Line e2, Line e3, int maxIter) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        vec2 p_old = p;\n        \n        // Reflect across each edge if we're on the wrong side\n        // Check sign of distance: if negative, we're on wrong side\n        float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n        if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n        \n        float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n        if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n        \n        float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n        if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        \n        // Converged? (no more reflections)\n        if(length(p - p_old) &lt; 0.0001) break;\n    }\n    \n    return p;\n}\n\n\n\nFor the Sierpinski fractal, we fold and then scale:\nvec2 sierpinskiTriangle(vec2 p, int iterations, out int depth) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    depth = 0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into fundamental triangle\n        p = foldIntoTriangle(p, e1, e2, e3, 10);\n        \n        // Scale by 2 toward center\n        vec2 center = vec2(0.0, 0.0);  // Approximate center\n        p = (p - center) * 2.0 + center;\n        \n        depth++;\n        \n        // Optional: early exit if escaped\n        if(length(p) &gt; 100.0) break;\n    }\n    \n    return p;\n}\n\n\n\nAfter folding, we need to check if we’re in the “removed” middle triangle. Using barycentric coordinates:\n\n### Determining if Point is in Fractal\n\nAfter folding, we need to check if we're in the \"removed\" middle triangle. The middle triangle has vertices at the midpoints of the original triangle's edges.\n\nFor an equilateral triangle with vertices $v_0, v_1, v_2$, the midpoints are:\n$$m_{01} = \\frac{v_0 + v_1}{2}, \\quad m_{12} = \\frac{v_1 + v_2}{2}, \\quad m_{20} = \\frac{v_2 + v_0}{2}$$\n\nWe can check if point $p$ is inside this middle triangle using barycentric coordinates:\n\n```glsl\nbool inMiddleTriangle(vec2 p) {\n    // Vertices of original triangle\n    vec2 v0 = vec2(0.0, 1.0);\n    vec2 v1 = vec2(-0.866, -0.5);\n    vec2 v2 = vec2(0.866, -0.5);\n    \n    // Midpoints (vertices of removed triangle)\n    vec2 m01 = (v0 + v1) * 0.5;\n    vec2 m12 = (v1 + v2) * 0.5;\n    vec2 m20 = (v2 + v0) * 0.5;\n    \n    // Check if p is inside triangle m01-m12-m20\n    // Using sign of cross products\n    vec2 e0 = m12 - m01;\n    vec2 e1 = m20 - m12;\n    vec2 e2 = m01 - m20;\n    \n    vec2 p0 = p - m01;\n    vec2 p1 = p - m12;\n    vec2 p2 = p - m20;\n    \n    float s0 = e0.x * p0.y - e0.y * p0.x;\n    float s1 = e1.x * p1.y - e1.y * p1.x;\n    float s2 = e2.x * p2.y - e2.y * p2.x;\n    \n    // All same sign means inside\n    return (s0 &gt;= 0.0 && s1 &gt;= 0.0 && s2 &gt;= 0.0) || \n           (s0 &lt;= 0.0 && s1 &lt;= 0.0 && s2 &lt;= 0.0);\n}\n\n\n\nstruct Line {\n    float a, b, c;\n};\n\nvec2 reflectAcrossLine(vec2 p, Line line) {\n    float dist = line.a * p.x + line.b * p.y - line.c;\n    float normSq = line.a * line.a + line.b * line.b;\n    vec2 normal = vec2(line.a, line.b);\n    return p - (2.0 * dist / normSq) * normal;\n}\n\nvoid setupTriangleEdges(out Line e1, out Line e2, out Line e3) {\n    float sqrt3 = 1.732;\n    e1 = Line(3.0, -sqrt3, -sqrt3);\n    e2 = Line(0.0, 1.0, -0.5);\n    e3 = Line(-3.0, -sqrt3, -sqrt3);\n}\n\nvec2 sierpinskiTriangle(vec2 p, int iterations, out bool inFractal) {\n    Line e1, e2, e3;\n    setupTriangleEdges(e1, e2, e3);\n    \n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold into triangle\n        for(int j = 0; j &lt; 10; j++) {\n            float d1 = e1.a * p.x + e1.b * p.y - e1.c;\n            if(d1 &lt; 0.0) p = reflectAcrossLine(p, e1);\n            \n            float d2 = e2.a * p.x + e2.b * p.y - e2.c;\n            if(d2 &lt; 0.0) p = reflectAcrossLine(p, e2);\n            \n            float d3 = e3.a * p.x + e3.b * p.y - e3.c;\n            if(d3 &lt; 0.0) p = reflectAcrossLine(p, e3);\n        }\n        \n        // Check if in removed region\n        if(inMiddleTriangle(p)) {\n            inFractal = false;\n        }\n        \n        // Scale by 2\n        p = p * 2.0;\n    }\n    \n    return p;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 3.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal;\n    vec2 p_final = sierpinskiTriangle(uv, 6, inFractal);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color by final position\n        float t = length(p_final) * 0.1;\n        color = palette(t);\n    } else {\n        // Removed region\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThe Sierpinski triangle should now render with mathematically correct reflections!"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#sierpinski-carpet",
    "href": "OLD/appendices/folding-fractals.html#sierpinski-carpet",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "The Sierpinski carpet is the square analog: 1. Start with a square 2. Divide into a 3×3 grid of sub-squares 3. Remove the central sub-square 4. Recursively repeat on each remaining sub-square\nNote: Unlike the triangle, the carpet uses axis-aligned divisions, so the implementation is both simpler AND mathematically exact—no approximations needed!\n\n\n\nMuch simpler than the triangle because we can use axis-aligned operations!\nAt each iteration: 1. Fold using abs() to create 4-fold symmetry (all quadrants map to first quadrant) 2. Scale by factor of 3 3. Check if we’re in the removed middle region\n\n\n\nbool sierpinskiCarpet(vec2 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant (creates 4-fold symmetry)\n        p = abs(p);\n        \n        // Scale by 3 and recenter\n        p = p * 3.0 - vec2(1.0);\n        \n        // After this transformation, the \"removed\" region is\n        // approximately where both |p.x| &lt; 1 and |p.y| &lt; 1\n    }\n    \n    // Check if in removed region\n    // After n iterations, if we're in the central square, we're removed\n    return (abs(p.x) &lt; 1.0 && abs(p.y) &lt; 1.0);\n}\n\n\n\nvec2 carpetFold(vec2 p, int iterations, out bool inFractal) {\n    inFractal = true;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first quadrant\n        p = abs(p);\n        \n        // Check if in middle third in both dimensions\n        // In normalized [0,1] space, middle third is [1/3, 2/3]\n        vec2 normalizedP = fract(p);  // Get fractional part\n        \n        bool inMiddleX = (normalizedP.x &gt; 0.33 && normalizedP.x &lt; 0.67);\n        bool inMiddleY = (normalizedP.y &gt; 0.33 && normalizedP.y &lt; 0.67);\n        \n        if(inMiddleX && inMiddleY) {\n            inFractal = false;\n        }\n        \n        // Scale by 3\n        p = p * 3.0;\n    }\n    \n    return p;\n}\n\n\n\nA cleaner approach using the subdivision pattern:\nbool inSierpinskiCarpet(vec2 p, int iterations) {\n    // Normalize to [0, 1]\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Which cell of 3×3 grid are we in?\n        vec2 cell = floor(p * 3.0);\n        \n        // Middle cell (1,1) is removed\n        if(cell.x == 1.0 && cell.y == 1.0) {\n            return false;  // In removed region\n        }\n        \n        // Zoom into current cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;  // In fractal\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool inFractal = inSierpinskiCarpet(uv, 6);\n    \n    vec3 color = inFractal ? vec3(1.0, 1.0, 0.8) : vec3(0.1, 0.1, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#menger-sponge-3d-extension",
    "href": "OLD/appendices/folding-fractals.html#menger-sponge-3d-extension",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "The Menger sponge is the 3D analog of the Sierpinski carpet: 1. Start with a cube 2. Divide into a 3×3×3 grid of sub-cubes (27 total) 3. Remove the central sub-cube and the 6 face-centered sub-cubes (7 removed, 20 remain) 4. Recursively repeat on each remaining sub-cube\nNote: Like the carpet, the sponge uses axis-aligned divisions, giving us an exact, mathematically precise implementation.\n\n\n\nSame pattern as the carpet, but in 3D!\n\nFold using abs(p) to create octahedral symmetry\nScale by factor of 3\nCheck if we’re in a removed region (middle cross pattern)\n\n\n\n\nbool inMengerSponge(vec3 p, int iterations) {\n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        p = abs(p);\n        \n        // Which cell of 3×3×3 grid?\n        vec3 cell = floor(p * 3.0);\n        \n        // Removed regions: center cube and face centers\n        // Center: (1,1,1)\n        // Face centers: (1,1,0), (1,1,2), (1,0,1), (1,2,1), (0,1,1), (2,1,1)\n        // Pattern: at least 2 coordinates equal to 1\n        \n        float ones = 0.0;\n        if(cell.x == 1.0) ones += 1.0;\n        if(cell.y == 1.0) ones += 1.0;\n        if(cell.z == 1.0) ones += 1.0;\n        \n        if(ones &gt;= 2.0) {\n            return false;  // Removed region\n        }\n        \n        // Zoom into cell\n        p = fract(p * 3.0);\n    }\n    \n    return true;\n}\n\n\n\nWe can also implement the Menger sponge as a signed distance function for use with Day 4’s raymarching:\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdMengerSponge(vec3 p, int iterations) {\n    float d = sdBox(p, vec3(1.0));  // Start with unit cube\n    \n    float scale = 1.0;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        // Fold to first octant\n        vec3 a = mod(p * scale, 2.0) - 1.0;\n        scale *= 3.0;\n        \n        vec3 r = abs(1.0 - 3.0 * abs(a));\n        \n        // Distance to cross (removed region)\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / scale;\n        \n        d = max(d, c);\n    }\n    \n    return d;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Setup ray (using Day 4 techniques)\n    Ray ray = getRay(fragCoord, iResolution.xy, 45.0);\n    \n    // Raymarch\n    float t = 0.0;\n    for(int i = 0; i &lt; 100; i++) {\n        vec3 pos = ray.origin + t * ray.direction;\n        float d = sdMengerSponge(pos, 4);\n        \n        if(abs(d) &lt; 0.001) {\n            // Hit!\n            vec3 normal = estimateNormal(pos);  // Day 4 technique\n            \n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            float diffuse = max(0.0, dot(normal, lightDir));\n            \n            vec3 color = vec3(1.0, 0.8, 0.6) * diffuse + vec3(0.1);\n            fragColor = vec4(color, 1.0);\n            return;\n        }\n        \n        t += d;\n        if(t &gt; 100.0) break;\n    }\n    \n    // Miss\n    fragColor = vec4(0.1, 0.1, 0.2, 1.0);\n}"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#general-principles-of-folding-fractals",
    "href": "OLD/appendices/folding-fractals.html#general-principles-of-folding-fractals",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "Symmetry operations:\n\nabs() for axis-aligned symmetry\nReflections for arbitrary symmetry\n\nScaling factor:\n\nFactor of 2: Sierpinski triangle\nFactor of 3: Sierpinski carpet, Menger sponge\nGeneral factor \\(s\\): determines fractal dimension\n\nRemoval pattern:\n\nWhich regions get removed at each level\nDefines the fractal’s structure\n\nIteration:\n\nMore iterations = more detail\nComputational cost grows linearly\nVisual complexity grows exponentially\n\n\n\n\n\nThe fractal dimension \\(D\\) can be computed from the scaling factor \\(s\\) and the number of remaining pieces \\(N\\):\n\\[D = \\frac{\\log N}{\\log s}\\]\nExamples: - Sierpinski triangle: \\(N = 3\\) pieces, scale factor \\(s = 2\\) \\[D = \\frac{\\log 3}{\\log 2} \\approx 1.585\\]\n\nSierpinski carpet: \\(N = 8\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 8}{\\log 3} \\approx 1.893\\]\nMenger sponge: \\(N = 20\\) pieces, scale factor \\(s = 3\\) \\[D = \\frac{\\log 20}{\\log 3} \\approx 2.727\\]\n\nThe fractal dimension is between the topological dimension and the embedding dimension, reflecting the fractal’s “in-between” nature!"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#coloring-strategies",
    "href": "OLD/appendices/folding-fractals.html#coloring-strategies",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "Track which iteration first identifies a point as removed:\nint firstRemovedIter = -1;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    // [Folding and scaling]\n    \n    if([in removed region] && firstRemovedIter &lt; 0) {\n        firstRemovedIter = i;\n    }\n}\n\nfloat t = float(firstRemovedIter) / float(iterations);\nvec3 color = palette(t);\n\n\n\nvec2 p_final = [after all folding];\nfloat d = length(p_final);\nvec3 color = vec3(d * 0.5);  // Grayscale by distance\n\n\n\nFor grid-based fractals (carpet, sponge), color by which sub-cell the point lands in:\nvec3 cell = floor(p * 3.0);\nvec3 color = cell / 3.0;  // RGB from cell coordinates\n\n\n\nFor 3D fractals, combine distance estimation with fractal membership:\nfloat d = sdMengerSponge(p, iterations);\nvec3 color;\n\nif(d &lt; 0.0) {\n    // Inside sponge\n    color = vec3(1.0, 0.8, 0.6);\n} else {\n    // Outside, but show distance\n    color = vec3(0.1) + vec3(0.2) / (1.0 + d);\n}"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#variations-and-experiments",
    "href": "OLD/appendices/folding-fractals.html#variations-and-experiments",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "Try different symmetry groups: - Hexagonal symmetry (6-fold) - Octahedral symmetry (for 3D) - Custom reflection patterns\n\n\n\n\nScale by 4: sparser fractal\nScale by 1.5: denser fractal\nNon-integer scales: unusual structures\n\n\n\n\nfloat scale = 2.0 + 0.5 * sin(iTime);\np = p * scale;\nWatch the fractal morph as the scale factor changes!\n\n\n\nTrack the “orbit” of the point through the folding process:\nfloat orbit = 0.0;\n\nfor(int i = 0; i &lt; iterations; i++) {\n    orbit += length(p);  // Accumulate total distance traveled\n    // [Folding operations]\n}\n\nvec3 color = palette(orbit / 10.0);\n\n\n\n\nCross-Menger: Different removal pattern (only center)\nJerusalem Cube: Variation with different symmetry\nHybrid fractals: Combine different removal patterns at different scales"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#connection-to-course-topics",
    "href": "OLD/appendices/folding-fractals.html#connection-to-course-topics",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "Both folding fractals and the Mandelbrot set/Apollonian gasket share the principle: simple operations iterated create complex structure.\n\nMandelbrot: \\(z \\to z^2 + c\\) (complex arithmetic iteration)\nApollonian: Repeated circle inversions (geometric iteration)\nSierpinski: Fold + scale (geometric iteration with scaling)\n\n\n\n\nEuclidean and hyperbolic tilings use folding without scaling: - Reflection brings points into fundamental domain - No scaling → fills space with copies - With scaling → creates fractal structure\n\n\n\nThe Menger sponge naturally extends to 3D: - Can be rendered as SDF (raymarching) - Can be rendered as boolean test (simple ray casting) - Demonstrates 3D coordinate folding"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#exercises",
    "href": "OLD/appendices/folding-fractals.html#exercises",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "Create a Sierpinski gasket based on a hexagon instead of a triangle: - Use 6-fold symmetry - Scale by factor of 3 - Remove appropriate regions\n\n\n\nModify the Sierpinski carpet to have a time-varying scale factor:\nfloat scale = 3.0 + sin(iTime);\nWatch how the fractal structure changes!\n\n\n\nImplement a 3D fractal using only cross-shaped removal (remove only the center cube, not the face centers). Compare to the standard Menger sponge.\n\n\n\nCombine two different fractals: - First 3 iterations: Sierpinski triangle folding - Next 3 iterations: Sierpinski carpet folding - Observe the unusual resulting structure\n\n\n\nRender the Menger sponge with colors based on distance from the surface: - Use sdMengerSponge as a distance field - Color by distance for points outside - Different color for points inside"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#further-reading",
    "href": "OLD/appendices/folding-fractals.html#further-reading",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "Hausdorff dimension and box-counting dimension\nIterated function systems (IFS)\nSelf-similar sets and scaling symmetries\n\n\n\n\n\nEscape-time algorithms\nDistance estimation for fractals\nEfficient rendering of fractal geometry\n\n\n\n\n\nProcedural generation in games/graphics\nAntenna design (fractal antennas)\nModeling natural phenomena (coastlines, plants)\nCompression algorithms"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#summary",
    "href": "OLD/appendices/folding-fractals.html#summary",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "Folding fractals demonstrate: 1. Iteration + scaling creates self-similar structure 2. Simple operations produce complex results 3. GPU parallelism enables real-time fractal rendering 4. Fractals connect to many course topics (iteration, symmetry, 3D)\nThe techniques here—folding, scaling, iteration—are fundamental to both mathematical fractals and computer graphics. These methods extend naturally from 2D to 3D, and from static to animated, making them powerful tools for mathematical visualization.\nKey takeaway: Fractals aren’t just beautiful—they’re computationally accessible. A few dozen lines of shader code can generate infinite complexity!"
  },
  {
    "objectID": "OLD/appendices/folding-fractals.html#complete-example-animated-sierpinski-carpet",
    "href": "OLD/appendices/folding-fractals.html#complete-example-animated-sierpinski-carpet",
    "title": "1 Folding Fractals",
    "section": "",
    "text": "vec3 palette(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nbool inCarpet(vec2 p, int iterations) {\n    p = p * 0.5 + 0.5;\n    \n    for(int i = 0; i &lt; iterations; i++) {\n        vec2 cell = floor(p * 3.0);\n        if(cell.x == 1.0 && cell.y == 1.0) return false;\n        p = fract(p * 3.0);\n    }\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Zoom animation\n    float zoom = exp(sin(iTime * 0.3) * 2.0);\n    uv *= zoom;\n    \n    // Rotation animation\n    float angle = iTime * 0.2;\n    float c = cos(angle), s = sin(angle);\n    uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n    \n    int iterations = 6;\n    bool inFractal = inCarpet(uv, iterations);\n    \n    vec3 color;\n    if(inFractal) {\n        // Color based on distance from center\n        float d = length(uv);\n        color = palette(d * 0.5 + iTime * 0.1);\n    } else {\n        color = vec3(0.05, 0.05, 0.1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nThis creates a beautiful, animated Sierpinski carpet that zooms and rotates, with colors flowing through the fractal structure!"
  },
  {
    "objectID": "OLD/lectures/day5a.html",
    "href": "OLD/lectures/day5a.html",
    "title": "1 Day 5a",
    "section": "",
    "text": "1 Day 5a"
  },
  {
    "objectID": "OLD/lectures/day2.html",
    "href": "OLD/lectures/day2.html",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Today we explore the power of iteration to generate fractals. We’ll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set, then understand its companion, the Julia set. After that, we shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We’ll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles.\nBy the end of today, you’ll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.\n\n\n\n\n\n\nNoteRoadmap for Today\n\n\n\nWe’ll explore iteration in two different mathematical settings:\n\nComplex dynamics: Iterating holomorphic maps (Mandelbrot and Julia sets)\nGeometric dynamics: Iterating circle inversions (Apollonian gasket)\n\nBoth produce fractals through the same fundamental mechanism: simple rules applied repeatedly reveal infinite complexity. The common thread is conformality—both complex multiplication and circle inversion preserve angles, and this angle preservation is key to the beautiful structures we’ll see.\nAlong the way, we’ll learn shader programming techniques for organizing data (structs), implementing mathematical operations efficiently, and creating sophisticated coloring schemes.\n\n\n\n\n\n\n\n\nA complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). This is the natural representation—complex numbers are the 2D plane with a particular multiplication structure! In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part. You already know complex numbers geometrically as rotations and scalings in the plane—here we’re just implementing that algebra in shader code.\n\n\n\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations. Some of these are trivial, others require a bit more work:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nAddition of complex numbers is just vector addition—componentwise! You might not even need this function since you can just write z + w directly, but it’s here for completeness.\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nThis implements the familiar FOIL pattern with \\(i^2 = -1\\), giving us that minus sign in the real part.\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nThe squared magnitude is just the dot product with itself. This is computationally cheaper than taking the square root, so when we just need to check if \\(|z| &gt; 2\\), we’ll check if \\(|z|^2 &gt; 4\\) instead—millions of avoided square roots per frame!\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nThe magnitude is the Euclidean distance from the origin—exactly what length() computes!\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nThe conjugate flips the sign of the imaginary part—reflection across the real axis.\nDivision: \\(\\frac{a + bi}{c + di} = \\frac{(a + bi)(c - di)}{c^2 + d^2}\\)\nvec2 cdiv(vec2 z, vec2 w) {\n    float denom = dot(w, w);  // c² + d²\n    return vec2(\n        (z.x * w.x + z.y * w.y) / denom,  // Real part\n        (z.y * w.x - z.x * w.y) / denom   // Imaginary part\n    );\n}\nDivision multiplies numerator and denominator by the conjugate of \\(w\\) to rationalize. The denominator becomes real (\\(c^2 + d^2\\)), and the numerator becomes a new complex number we can compute directly.\n\n\n\n\n\n\nTipComputational Efficiency in Complex Arithmetic\n\n\n\nNotice we use dot(z, z) for magnitude squared—this is a single GPU operation rather than component-wise multiplication and addition. Similarly, dot(w, w) in the division routine. For operations you’ll compute millions of times per frame, these micro-optimizations add up!\nWe’re also using helper functions rather than inlining the formulas everywhere. This makes the code much more readable (cmul(z, z) vs vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)) and easier to debug. If you make a sign error once in cmul, you fix it once. If you inline the formula fifty times, you’ll hunt for bugs forever!\n\n\nThese are the building blocks we need for complex dynamics. Let’s put them to work!\n\n\n\n\n\n\n\nThe Mandelbrot set \\(\\mathcal{M}\\) is one of the most famous objects in mathematics—and for good reason! It’s defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nThat’s it! Just iterate this simple quadratic map starting from \\(z_0 = 0\\), and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.\n\n\n\nIn practice, we can’t iterate to infinity, so we need a criterion to detect escape. Fortunately, there’s a beautiful theorem that tells us exactly when to stop:\nTheorem (Escape Radius). If \\(|z_n| &gt; 2\\) for any \\(n\\), then \\(|z_n| \\to \\infty\\) as \\(n \\to \\infty\\).\nThis means: once the orbit leaves the disk of radius 2, it’s definitely escaping to infinity. Points that escape are not in the Mandelbrot set, while points that remain bounded after many iterations are (likely) in the set or very close to its boundary.\nProof. Suppose \\(|z_n| &gt; 2\\) and write \\(|z_n| = 2 + \\epsilon\\) for some \\(\\epsilon &gt; 0\\). Then \\[\\begin{align*}\n|z_{n+1}| &= |z_n^2 + c|\\\\\n&\\geq |z_n^2| - |c|\\\\\n&= |z_n|^2 - |c|\\\\\n&&gt; |z_n|^2 - 2 \\quad \\text{(since $c$ is in or near $\\mathcal{M}$, which fits in $|z| \\leq 2$)}\\\\\n&= (2 + \\epsilon)^2 - 2\\\\\n&= 4 + 4\\epsilon + \\epsilon^2 - 2\\\\\n&= 2 + 4\\epsilon + \\epsilon^2\\\\\n&&gt; 2 + 2\\epsilon = |z_n| + \\epsilon\n\\end{align*}\\]\nSo once \\(|z_n| &gt; 2\\), we have \\(|z_{n+1}| &gt; |z_n| + \\epsilon\\), meaning the magnitude grows by at least \\(\\epsilon\\) each iteration. This linear growth accelerates: if \\(|z_{n+1}| &gt; 2 + \\epsilon\\), then \\(|z_{n+2}| &gt; |z_{n+1}| + \\epsilon' &gt; 2 + 2\\epsilon\\), and so on. More carefully, the orbit actually grows exponentially (roughly like \\(|z_n| \\sim 2^{2^n}\\) for large \\(n\\)), but the key point is: it definitely escapes to infinity.\nComputational Implication: We only need to check if \\(|z_n| &gt; 2\\). The moment this happens, we can stop iterating—this point will never be in the Mandelbrot set. This single theorem makes efficient rendering possible!\n\n\n\nThe Mandelbrot set was discovered remarkably recently—1980! Benoit Mandelbrot, working at IBM, was among the first to have access to computers powerful enough to visualize iterative processes in the complex plane. Before computers, studying these sets was nearly impossible—you’d need to manually iterate complex arithmetic hundreds of times for millions of points.\nInterestingly, the mathematical theory predates visualization by over 60 years. Gaston Julia and Pierre Fatou studied iterative complex dynamics extensively in 1918, but without computers, they could only reason about these sets abstractly. They knew Julia sets existed and had deep properties, but had never seen one! When Mandelbrot generated the first images in 1980, it revolutionized the field—suddenly the intricate structure of these sets was visible, creating an explosion of interest in fractal geometry and complex dynamics.\nThe Mandelbrot set became iconic partly because it’s so accessible: anyone can understand the definition (iterate \\(z \\mapsto z^2 + c\\)), yet it produces infinitely intricate beauty. It also sparked broader interest in fractals, chaos theory, and the idea that simple rules can generate complex behavior—themes that would influence everything from physics to economics to art.\n\n\n\nLet’s code it up:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\nThat’s the entire Mandelbrot set renderer! The coordinate scaling is tuned to show the “interesting part”—the main cardioid body and its surrounding bulbs. The set extends roughly from \\(-2.5\\) to \\(0.5\\) on the real axis, so we shift our coordinate system accordingly.\n\n\n\n\n\n\nNoteWhy This Is Perfect for GPUs\n\n\n\nNotice what’s happening computationally: every pixel performs its own independent calculation. There’s no communication between pixels, no shared data structures, no synchronization needed. Each pixel just iterates its own complex number and decides when to stop.\nThis is embarrassingly parallel—the ideal workload for GPU architecture. A modern GPU has thousands of small processors, and they can all work on different pixels simultaneously. No pixel needs to wait for another pixel’s result. The entire screen (potentially millions of pixels) is computed in parallel, which is why we can render the Mandelbrot set at 60fps even with 100+ iterations per pixel.\nMemory-wise, this is also very efficient: each pixel only needs to store its current \\(z\\) value (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures. The computation is stateless—we only care about the current iterate, not the full orbit.\nThis contrasts sharply with sequential CPU code, where you’d iterate over pixels one at a time. Even with clever optimizations and SIMD vectorization, you’d be orders of magnitude slower than a GPU shader doing the same work.\n\n\n\n\n\nThe grayscale rendering shows the structure of the set, but it has harsh banding—sudden transitions between integer iteration counts create visible stripes. We can do much better by interpolating between iteration steps!\nThe key insight is that near escape, the orbit grows exponentially. Specifically, once \\(|z_n|\\) is large, we have approximately \\(|z_{n+1}| \\approx |z_n|^2\\), which means \\(\\log |z_{n+1}| \\approx 2\\log|z_n|\\). Taking logs repeatedly, we get \\[\\log\\log|z_{n+1}| \\approx \\log(2\\log|z_n|) = \\log 2 + \\log\\log|z_n|\\]\nThis suggests that \\(\\log\\log|z_n|\\) grows approximately linearly near escape, increasing by \\(\\log 2\\) per iteration. We can use this to compute a fractional iteration count!\nHere’s the formula:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;  // = log|z_n|\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nThe variable nu represents how far we’ve progressed toward the next integer iteration. When \\(|z_n| = 2\\) exactly (just hitting the escape threshold), \\(nu = 0\\) and we get the integer iteration count. When \\(|z_n|\\) is large (deep into escape), \\(nu\\) approaches 1. Subtracting nu from iter + 1 gives us a continuous, smooth value that transitions gradually between iteration levels.\nThis eliminates banding entirely! The result is smooth, continuous color gradients that look much more professional and reveal the fractal structure more clearly.\n\n\n\n\n\n\nTipSmooth Coloring as Anti-Aliasing\n\n\n\nSmooth coloring is fundamentally an anti-aliasing technique. Without it, nearby pixels with iteration counts of, say, 45 and 46 get completely different colors—creating harsh edges. With smooth coloring, these pixels get nearly identical colors (say, iteration 45.3 and 45.8), producing a smooth gradient.\nThis is especially important at high zoom levels, where tiny changes in position lead to different integer iteration counts. The smooth interpolation ensures that small changes in \\(c\\) produce small changes in color, which is exactly what we want for a continuous mathematical function.\n\n\n\n\n\nNow we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:\nvec3 palette(float t) {\n    // Create a cyclic color palette using cosines\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters control different aspects:\n\na and b control the range and center of the colors (here, mapping to \\([0,1]\\))\nc controls the frequency of color cycling\nd controls the phase offset, shifting the entire palette\n\nPlay with these parameters to get different color schemes! Try d = vec3(0.0, 0.1, 0.2) for a blue-purple palette, or d = vec3(0.3, 0.2, 0.2) for warmer tones. You can also adjust c to make the colors cycle faster or slower through the iteration range.\nThe beauty of this cosine approach is that it’s smooth (continuous derivatives), cyclic (no seams), and efficient (just a few trig operations). Other approaches exist—hand-picked color stops with interpolation, HSV color spaces, perceptually uniform LAB spaces—but cosine palettes are a great default for fractal visualization.\n\n\n\n\n\nThe Julia set is the natural companion to the Mandelbrot set, and understanding their relationship is key to understanding complex dynamics. Where the Mandelbrot set varies \\(c\\) and fixes \\(z_0 = 0\\), the Julia set does the opposite: it fixes \\(c\\) and varies \\(z_0\\).\n\n\nFor a fixed complex number \\(c\\), the filled Julia set \\(K_c\\) is the set of initial conditions \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded. The Julia set \\(J_c\\) is the boundary of \\(K_c\\)—the set where the dynamics are chaotic, neither definitely bounded nor definitely escaping.\nThink about what this means: every point \\(c\\) in the complex plane has an associated Julia set \\(J_c\\). The Mandelbrot set is telling us about the topology of these Julia sets! Specifically:\n\nIf \\(c \\in \\mathcal{M}\\) (inside the Mandelbrot set), then \\(J_c\\) is connected—a single, intricate curve\nIf \\(c \\notin \\mathcal{M}\\) (outside the Mandelbrot set), then \\(J_c\\) is totally disconnected—a Cantor-like dust of points\n\nThis is one of the most beautiful connections in mathematics: the Mandelbrot set is a map of parameter space, showing which values of \\(c\\) produce connected Julia sets. Julia and Fatou proved this in 1918 without ever seeing a picture—they understood these sets purely abstractly!\n\n\n\nYou’ll implement Julia set rendering in the homework. The algorithm is nearly identical to the Mandelbrot set—just swap what’s fixed and what varies! Instead of setting z = vec2(0.0) and varying c across pixels, you’ll set c to a fixed value and let z be the pixel coordinate.\nThe key changes: 1. Fix c to an interesting value (we’ll give suggestions) 2. Initialize z from the pixel position (that’s your \\(z_0\\)) 3. Iterate \\(z \\mapsto z^2 + c\\) exactly as before 4. Use the same escape criterion and coloring\nThis will give you a Julia set! Try different values of \\(c\\) to see how the topology changes. You can make c depend on time (iTime) for animation, or on mouse position (iMouse) for interactive exploration.\nSome interesting values to try: - \\(c = -0.7 + 0.27015i\\) — classic Julia set, intricate tendrils - \\(c = -0.4 + 0.6i\\) — dendrite-like fractal trees - \\(c = 0.285 + 0.01i\\) — beautiful spiral patterns - \\(c = -0.8 + 0.156i\\) — highly filamentary - \\(c = -0.70176 - 0.3842i\\) — “San Marco dragon”\nValues inside the Mandelbrot set give connected Julia sets (single curves), while values outside give disconnected Julia sets (dust). The most interesting Julia sets often come from values right near the boundary of \\(\\mathcal{M}\\)—this is where the transition between connected and disconnected happens!\n\n\n\n\n\n\nTipExploring Parameter Space\n\n\n\nWhen you implement Julia sets, try this: tie \\(c\\) to your mouse position. Move the mouse around and watch the Julia set morph in real time! This is an incredibly powerful way to build intuition for how the parameter \\(c\\) affects the dynamics.\nYou’ll notice that small changes in \\(c\\) can produce dramatic changes in the Julia set topology—this is the sensitive dependence on parameters that makes complex dynamics so rich. Near the boundary of the Mandelbrot set, tiny movements create entirely different structures.\n\n\n\n\n\n\n\nWe’ve been iterating algebraic functions in the complex plane: \\(z \\mapsto z^2 + c\\). Now we shift to iterating geometric transformations of the plane itself: circle inversion. The mathematical frameworks are different—holomorphic dynamics versus conformal geometry—but they share fundamental similarities.\nBoth complex multiplication and circle inversion are conformal maps: they preserve angles between curves. In complex dynamics, this comes from the Cauchy-Riemann equations and the geometric interpretation of multiplication as rotation and scaling. In circle inversion, it’s a theorem we’ll state shortly. This angle preservation is crucial—it’s what makes the fractal structures we generate geometrically coherent and visually beautiful.\nThere’s also a deep connection we’ll explore tomorrow: circle inversion is actually an isometry of hyperbolic space! The inversions we’re about to do are the same transformations that generate Kleinian groups and tessellate the hyperbolic plane. So in some sense, we’re already working in non-Euclidean geometry without realizing it. Tomorrow we’ll make this explicit when we explore hyperbolic tilings.\nFor now, let’s learn circle inversion and use it to build the Apollonian gasket—a fractal structure every bit as intricate as the Mandelbrot set, but generated through pure Euclidean geometry.\n\n\n\n\nCircle inversion is a beautiful geometric operation that will be the foundation for everything we do with geometric dynamics. It’s a transformation of the plane that turns inside into outside, maps circles to circles (or lines), and preserves angles—making it a powerful tool for creating fractal patterns.\n\n\nCircle inversion is a transformation with respect to a circle. For a circle of radius \\(R\\) centered at a point \\(\\mathbf{c}\\), inversion maps a point \\(\\mathbf{p} \\neq \\mathbf{c}\\) to: \\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nThe vector \\(\\mathbf{p} - \\mathbf{c}\\) points from the center to \\(\\mathbf{p}\\). We normalize this direction by dividing by its squared length, then scale by \\(R^2\\), and finally translate back by the center. Geometrically:\n\nPoints inside the circle map to points outside (and vice versa)\nPoints on the circle are fixed (they map to themselves)\nThe closer you are to the center, the farther away you go\nThe center itself maps to infinity, and infinity maps to the center\n\nHere’s another way to think about it: draw a ray from the center through \\(\\mathbf{p}\\). The inversion of \\(\\mathbf{p}\\) is the unique point on this ray such that the product of distances from the center is \\(R^2\\). If \\(\\mathbf{p}\\) is at distance \\(r\\) from the center, its image is at distance \\(R^2/r\\).\n\n\n\nCircle inversion has remarkable geometric properties. These aren’t obvious from the formula, but they’re all classical theorems:\n\nLines through the center remain lines through the center (they’re “flipped inside out” along the ray)\nLines not through the center become circles through the center\nCircles through the center become lines (not through the center)\nCircles not through the center generally remain circles, but with different center and radius\nAngles are preserved (conformal property)\n\nThe angle preservation is the deepest property. It’s not at all obvious from the formula, but it can be proved using the chain rule and careful calculation. The key insight is that inversion is locally similar to a complex conjugation-like operation, which preserves angles.\nWhy These Properties Matter for Iteration: When we iterate inversions through multiple circles, these properties ensure that the geometry remains coherent. Circles stay circles (or become lines), and the angles between curves are preserved. This means repeated inversion creates intricate but geometrically regular patterns—the hallmark of fractals generated by conformal maps.\nAnother key fact: inversion is involutive—applying it twice returns to the original point (assuming the point isn’t the center). Mathematically, \\(\\text{inv}(\\text{inv}(\\mathbf{p})) = \\mathbf{p}\\). This makes inversion a geometric reflection of sorts, which will be important when we think about symmetry groups tomorrow.\n\n\n\n\n\n\nNoteHistorical Context: Circle Inversion\n\n\n\nCircle inversion has ancient roots—Apollonius of Perga studied related problems involving tangent circles around 200 BCE. But the modern theory of inversion as a geometric transformation developed in the 19th century as part of projective and non-Euclidean geometry.\nA key insight was recognizing that circle inversion is related to stereographic projection: if you place a sphere on the plane, inversion in a circle corresponds to reflection through the sphere! This connection links circle inversion to spherical geometry and ultimately to hyperbolic geometry.\nIn the late 19th and early 20th centuries, mathematicians realized that groups of circle inversions (Kleinian groups) could tessellate hyperbolic space and create fractal limit sets. This anticipates the fractal geometry revolution of the 1970s-80s, though the connection wasn’t fully appreciated until computers made visualization possible.\n\n\n\n\n\nThe formula translates directly to GLSL:\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);  // squared distance from center\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);  // Map to \"infinity\"\n    \n    return center + (radius * radius) * diff / r2;\n}\nThe only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it’s effectively off-screen. The threshold 0.0001 is small enough to catch points numerically close to the center but large enough to avoid precision issues.\nComputationally, circle inversion is very cheap: just one dot product, a division, a multiplication, and some vector operations. This efficiency is important because we’ll be doing many inversions per pixel when generating fractals!\n\n\n\nLet’s see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);  // Create repeating cells\n    float gridLine = step(0.95, max(grid.x, grid.y));  // Draw grid lines\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle itself (for reference)\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou’ll see straight grid lines transform into beautiful circular arcs! Lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.\nThis visualization really helps build intuition. You can see: - The circle itself (in red) is unchanged—points on it are fixed - The grid inside the circle maps to a grid outside (and vice versa) - Lines become curves, but the angles where they intersect are preserved - The pattern has a pole singularity at the center (infinite distortion)\n\n\n\n\n\n\nTipExploring Circle Inversion\n\n\n\nHere are some experiments to try:\n\nMultiple circles: Create a grid of circles using mod() (like we did on Day 1) and invert through each cell’s circle independently. You’ll see beautiful overlapping patterns!\nAnimated radius: Make circleRadius = 1.0 + 0.5 * sin(iTime) to watch the grid breathe in and out. This helps you see how the inversion depends on the circle’s size.\nDifferent patterns: Instead of a grid, try drawing circles or other shapes in the inverted space. Circles become circles (or lines), creating intricate nested patterns.\nOff-center inversion: Move the inversion circle away from the origin. Watch how the asymmetry creates even more complex distortions.\n\nEach of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!\n\n\n\n\n\n\n\nBefore we build the Apollonian gasket, we need to talk about organizing our data. We’re about to deal with multiple circles, and passing around center1, radius1, center2, radius2, etc. gets unwieldy fast. GLSL provides structs (just like in C) for grouping related data together.\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nNow Circle is a type we can use just like vec2 or float. Creating and using structs is straightforward:\n// Declare and initialize\nCircle c1 = Circle(vec2(0.0, 0.0), 1.0);\n\n// Or declare first, set later\nCircle c2;\nc2.center = vec2(1.0, 0.5);\nc2.radius = 0.75;\n\n// Pass to functions\nvec2 invertThroughCircle(vec2 p, Circle circ) {\n    return invertCircle(p, circ.center, circ.radius);\n}\nThis makes the code dramatically more readable. Compare:\n// Without structs - messy!\nvec2 iterate(vec2 p, vec2 c1_cen, float c1_rad, vec2 c2_cen, float c2_rad, vec2 c3_cen, float c3_rad);\n\n// With structs - clean!\nvec2 iterate(vec2 p, Circle c1, Circle c2, Circle c3);\nFor the Apollonian gasket, we’ll have three circles we need to track and pass around. Structs make this much more manageable and semantically clear—we’re working with circles as geometric objects, not just pairs of vectors and floats.\n\n\n\n\n\nNow for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It’s named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles around 200 BCE, though the fractal interpretation is much more modern.\n\n\nTo understand the Apollonian gasket, we need to know about a beautiful theorem: Descartes Circle Theorem (1643).\nGiven four mutually tangent circles (each tangent to the other three), let their curvatures be \\(k_1, k_2, k_3, k_4\\) where curvature \\(k = 1/r\\) (positive for external tangency, negative for internal). Then: \\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\\]\nThis can be rearranged to solve for the fourth curvature given three: \\[k_4 = k_1 + k_2 + k_3 \\pm 2\\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}\\]\nThe \\(\\pm\\) gives two solutions—the two circles tangent to the original three (one inside the curvilinear triangle they form, one outside).\nWhat makes this magical for fractals: if you start with three mutually tangent circles with integer curvatures, then all circles in the Apollonian gasket have integer curvatures! This is the Apollonian gasket’s connection to number theory—it’s a fractal made entirely of circles with rational radii.\nWe won’t use this formula directly in our shader (we’ll set up circles geometrically), but it explains why certain configurations are special and why the patterns are so regular despite infinite nesting.\n\n\n\nWe start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For this to work, the distance between any two circle centers must be exactly twice the radius (so they touch edge-to-edge). The three centers form an equilateral triangle, and we’ll position this triangle symmetrically at the origin:\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\nWith \\(r = 0.5\\), the circumradius \\(d \\approx 0.577\\), and the outer circle has radius \\(R = d + r \\approx 1.077\\). All four circles are mutually tangent—each inner circle touches the other two inner circles and the outer circle.\nThis is just one possible configuration! You could use different radii (related by Descartes’ theorem), different arrangements, or even animated circles. The key is that they start mutually tangent—this ensures the iteration creates a proper Apollonian packing.\n\n\n\nThe algorithm is beautifully simple:\n\nStart with a point \\(p\\)\nCheck which circles contain \\(p\\)\nIf \\(p\\) is inside a circle, invert through that circle\nRepeat until \\(p\\) is outside all circles or we hit max iterations\nColor based on iteration behavior\n\nHere’s the implementation:\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        // If we didn't move, we're in the gaps - done!\n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\nWe also track which circle we last inverted through (lastCircle) and how many iterations we performed (finalIter). These will be useful for coloring!\nWhy This Creates a Fractal: Each time we invert through a circle, we “push” the point away from that circle’s center. But because the four circles are mutually tangent, pushing away from one circle might push us into another circle, triggering another inversion. The interplay between these four inversions (three inner circles plus the outer circle) creates a complex orbit.\nPoints in the “gaps” between the inner circles (the curvilinear triangles) escape quickly—they’re inside the outer circle but not inside any inner circle, so no inversion happens. But points near the tangency points get bounced back and forth between circles many times before escaping. And at the actual tangency points (where circles touch), the orbit never escapes—these are fixed points or periodic orbits of the iterated inversions.\nThe fractal structure emerges because these dynamics are self-similar: zooming in near any tangency point reveals the same pattern of nested circles and gaps. This self-similarity is a direct consequence of the conformal nature of circle inversion—the transformation preserves angles, so local geometry looks the same at all scales.\n\n\n\nThere are several interesting ways to color the Apollonian gasket:\nBy iteration count (like the Mandelbrot set):\nfloat t = float(finalIter) / float(maxIter);\nvec3 color = palette(t);\nThis shows the “depth” of the orbit—points that escape quickly are colored differently from points that bounce around many times.\nBy last circle hit:\nvec3 colors[4] = vec3[4](\n    vec3(1.0, 0.0, 0.0),  // Circle 1: red\n    vec3(0.0, 1.0, 0.0),  // Circle 2: green\n    vec3(0.0, 0.0, 1.0),  // Circle 3: blue\n    vec3(1.0, 1.0, 0.0)   // Outer circle: yellow\n);\nvec3 color = colors[lastCircle];\nThis shows the basin of attraction—which circle’s “influence” each point ultimately fell into. Yellow regions show points that escaped through the outer circle.\nBy final distance from circles:\nfloat d1 = abs(length(p - c1.center) - c1.radius);\nfloat d2 = abs(length(p - c2.center) - c2.radius);\nfloat d3 = abs(length(p - c3.center) - c3.radius);\nfloat d = min(d1, min(d2, d3));\nvec3 color = vec3(smoothstep(0.0, 0.05, d));\nThis highlights the circle boundaries themselves, making the geometric structure more apparent.\nEach coloring reveals different aspects of the fractal. Try combining them—for example, color by iteration count but modulate brightness by distance to circles.\n\n\n\nHere’s a complete Apollonian gasket renderer:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup the four circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by iteration count with palette\n    float t = float(finalIter) / float(maxIter);\n    vec3 color = palette(t);\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);  // White circle outlines\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful nested pattern of circles! The fractal structure is immediately apparent—circles within circles within circles, filling every gap with smaller circles.\nZoom in (by scaling p differently in the coordinate setup) to see the self-similarity. No matter how far you zoom, you’ll keep finding the same pattern repeated at smaller scales. This is true fractality—infinite detail that never runs out.\n\n\n\n\n\n\nNoteComputational Efficiency\n\n\n\nDespite the complexity of the output, this algorithm is remarkably efficient. Each iteration just checks three distances (cheap) and potentially does one inversion (also cheap—just a few arithmetic operations). With 50 iterations, we’re doing maybe 150 distance checks and 50 inversions per pixel.\nCompare this to raymarching (Day 4), where we might do hundreds of distance evaluations per pixel! The Apollonian gasket is very GPU-friendly.\nThe key is that we terminate early—most pixels escape in just a few iterations. Only points near the fractal boundary require many iterations. This is similar to the Mandelbrot set: most of the computational work focuses on the interesting regions (the boundary), while simple regions (deep inside or far outside) are handled quickly.\n\n\n\n\n\nThe Apollonian gasket connects several mathematical threads across millennia:\nAncient roots: Apollonius of Perga (~200 BCE) studied the problem of constructing circles tangent to three given circles (the “Problem of Apollonius”). He found geometric constructions but couldn’t have imagined the infinite fractal structure we’re visualizing.\nRenaissance mathematics: René Descartes (1643) discovered the circle theorem bearing his name, giving an algebraic formula for tangent circles. This turned Apollonius’s geometric problem into arithmetic.\n19th century: The connection to projective geometry and circle inversions was developed. Mathematicians realized that packing problems could be studied through group theory—the inversions form a discrete subgroup of the group of Möbius transformations.\n20th century: With computers, the fractal nature became visible. The Apollonian gasket was recognized as a limit set of a Kleinian group—a group of isometries of hyperbolic space. This connects to tomorrow’s material: the inversions we’re doing are actually hyperbolic isometries! In the Poincaré disk model (which we’ll see tomorrow), these inversions are reflections through hyperbolic geodesics.\nThe gasket also has connections to number theory: if the initial circles have integer curvatures, all circles in the packing do too (by Descartes’ theorem). This has led to deep questions about the distribution of integers in these packings, which remain active research areas today.\n\n\n\n\n\nToday we’ve explored two powerful iterative processes that generate fractals:\n\nComplex dynamics: The Mandelbrot and Julia sets emerge from iterating \\(z \\mapsto z^2 + c\\)\n\nImplemented complex arithmetic in GLSL efficiently\nLearned escape-time algorithms and the crucial escape radius theorem\nDeveloped smooth coloring techniques for anti-aliased rendering\nUnderstood the parameter space (Mandelbrot) vs dynamical space (Julia) distinction\nSaw how 1980s computational power revolutionized a 1918 theory\n\nGeometric dynamics: The Apollonian gasket emerges from iterating circle inversions\n\nCircle inversion as a conformal transformation preserving angles\nUsed structs to organize geometric data cleanly\nApplied Descartes Circle Theorem to understand tangent circle configurations\nIterated inversions through three circles to create fractal patterns\nConnected ancient Greek geometry to modern fractal theory\n\n\nBoth processes show how incredibly simple rules—a quadratic map, a geometric transformation—generate infinite complexity through iteration. The key in both cases is conformality: angle-preserving maps create geometrically coherent fractals. This is one of the core insights of fractal geometry and dynamical systems.\nThe computational perspective is also crucial: both algorithms are embarrassingly parallel, making them perfect for GPU rendering. Each pixel’s calculation is independent, and we can terminate early when orbits escape. The result is real-time rendering of infinitely detailed mathematical objects.\nTomorrow we’ll push geometric iteration further, moving from Euclidean to hyperbolic geometry. The circle inversions we’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space. We’ll explore the upper half-plane and Poincaré disk models, create \\((2,3,7)\\) and \\((2,3,\\infty)\\) triangle tilings, and see how the same algorithmic ideas (iterated geometric transformations) work in non-Euclidean geometry. The results will be even more intricate because hyperbolic space has “more room” than Euclidean space—triangles can have angle sums less than \\(\\pi\\), allowing denser tilings and more complex fractal structures.\n\n\n\n\n\n\nImplement a Julia set renderer starting from the Mandelbrot code. The algorithm is nearly identical—you just need to swap what’s fixed and what varies!\nRequirements:\n\nStart from the Mandelbrot implementation\nFix c to a constant value (see suggestions below)\nInitialize z from the pixel position instead of zero\nIterate \\(z_{n+1} = z_n^2 + c\\) exactly as before\nUse the same escape criterion and coloring\n\nSuggested structure:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;  // Scale for Julia set viewing\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // Classic Julia set\n    \n    // Initialize z from pixel position (this is the key change!)\n    vec2 z = p;  // z_0 = pixel position\n    \n    // [Rest of iteration exactly like Mandelbrot]\n}\nInteresting parameters to try: - vec2(-0.7, 0.27015) — classic Julia set, intricate tendrils - vec2(-0.4, 0.6) — dendrite-like fractal trees\n- vec2(0.285, 0.01) — beautiful spiral patterns - vec2(-0.8, 0.156) — highly filamentary structure - vec2(-0.70176, -0.3842) — “San Marco dragon” - vec2(-0.835, -0.2321) — another classic - vec2(-0.7269, 0.1889) — “Douady’s rabbit” (famous example)\nExtension Options (pick one or both):\nOption A: Animated Parameter Space\nMake \\(c\\) depend on time to watch the Julia set morph:\nfloat angle = iTime * 0.3;\nfloat radius = 0.7885;  // Distance from origin in parameter space\nvec2 c = vec2(radius * cos(angle), radius * sin(angle));\nWatch how the Julia set changes topology as you trace a circle in the complex plane! You’ll see it transition from connected to disconnected, develop tendrils, and create organic shapes.\nOption B: Mouse-Controlled Exploration\nTie \\(c\\) to mouse position for interactive exploration:\nvec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;\nmouse_uv.x *= iResolution.x / iResolution.y;\nvec2 c = mouse_uv * 3.0;  // Scale to cover interesting parameter range\nNow you can explore parameter space by moving the mouse! This really helps build intuition for how \\(c\\) affects the Julia set. Try finding the boundary of the Mandelbrot set—parameters right at the edge produce the most intricate Julia sets.\n\n\n\n\n\n\nTipUnderstanding Connected vs Disconnected\n\n\n\nAs you explore parameter space, pay attention to whether the Julia set appears as a single connected structure or as disconnected dust. Values of \\(c\\) inside the Mandelbrot set give connected Julia sets, while values outside give disconnected ones. The most beautiful Julia sets often come from values right near the boundary of \\(\\mathcal{M}\\)!\n\n\n\n\n\n\nCreate a grid where each cell shows the Julia set for that value of \\(c\\), revealing the Mandelbrot set as an emergent pattern!\nThe idea: The Mandelbrot set is a map of Julia set topology. If we draw a grid of Julia sets for different values of \\(c\\), we should see the Mandelbrot set emerge in the overall pattern—cells with connected Julia sets (solid regions) correspond to points in \\(\\mathcal{M}\\), while cells with disconnected Julia sets (dust) are outside.\nImplementation strategy:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Divide screen into grid cells\n    float grid_size = 8.0;  // 8×8 grid of Julia sets\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;  // Local coordinates within cell\n    \n    // Map cell_id to parameter c\n    vec2 c = (cell_id / grid_size) * 4.0 - vec2(2.5, 2.0);\n    c.x -= 0.5;  // Center on interesting region of Mandelbrot set\n    \n    // Run Julia set iteration with z = cell_p, fixed c\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Optional: draw grid lines to separate cells\n    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);\n    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a grid of tiny Julia sets! If you look carefully at the overall pattern, you’ll notice it resembles the Mandelbrot set—cells with connected Julia sets (solid colored regions) correspond to points inside \\(\\mathcal{M}\\), while cells with disconnected Julia sets (fine dust patterns) are outside.\nThis is one of the most beautiful visualizations in complex dynamics—the Mandelbrot set literally encodes the topology of all Julia sets!\nVariations to try: - Adjust grid_size (larger for more detail, smaller for clearer overview) - Change the parameter space region being sampled - Color cells based on whether the Julia set appears connected (black) or disconnected (white)—you’ll get a pixelated approximation of the Mandelbrot set!\n\n\n\n\nExplore variations on the Apollonian gasket theme! The key is setting up circles in interesting configurations and iterating inversions.\nDifferent circle arrangements:\nFour circles in a square:\nvoid setupSquareCircles(out Circle c1, out Circle c2, out Circle c3, out Circle c4) {\n    float r = 0.5;\n    float d = 1.5;  // Distance from center\n    c1 = Circle(vec2(d, 0.0), r);\n    c2 = Circle(vec2(0.0, d), r);\n    c3 = Circle(vec2(-d, 0.0), r);\n    c4 = Circle(vec2(0.0, -d), r);\n}\nModify the iteration loop to check four circles instead of three!\nNested circles:\n// One large circle containing several smaller ones\nc1 = Circle(vec2(0.0, 0.0), 2.0);  // Large outer circle\nc2 = Circle(vec2(-0.5, 0.0), 0.4);  // Small inner circles\nc3 = Circle(vec2(0.5, 0.0), 0.4);\nAnimated radii:\nMake the circles pulse:\nc1.radius = 0.5 + 0.2 * sin(iTime);\nc2.radius = 0.5 + 0.2 * sin(iTime + 2.0 * 3.14159 / 3.0);\nc3.radius = 0.5 + 0.2 * sin(iTime + 4.0 * 3.14159 / 3.0);\nWatch the fractal breathe!\nAlternating inversion patterns:\nInstead of inverting through whichever circle contains the point, try a fixed cycling pattern:\n// Cycle through circles in order\nint circle_index = i % 3;\nif(circle_index == 0) {\n    p = invertCircle(p, c1.center, c1.radius);\n} else if(circle_index == 1) {\n    p = invertCircle(p, c2.center, c2.radius);\n} else {\n    p = invertCircle(p, c3.center, c3.radius);\n}\nThis creates very different patterns—more regular and less space-filling than the gasket, but with interesting self-similarity.\nChallenge problems: - Can you create a configuration that tiles the plane with circular patterns? - What about spiraling structures? - Can you make a fractal that’s asymmetric (not rotationally symmetric)? - Try combining inversion with other transformations (rotation, scaling)\nThe key is experimentation—try different setups and see what emerges!\n\n\n\n\n\nTomorrow we continue with geometric transformations, but move from Euclidean to hyperbolic geometry. The circle inversions you’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space!\nWe’ll explore: - Multiple models of the hyperbolic plane (upper half-plane, Poincaré disk) - Geodesics (straight lines in hyperbolic geometry—they look like circles in our Euclidean view!) - Triangle tilings with \\((2,3,7)\\) and \\((2,3,\\infty)\\) symmetry groups - Why hyperbolic space is different: triangles with angle sum less than \\(\\pi\\), exponential growth of area\nThe same algorithmic ideas we’ve used today (iterated geometric transformations, escape-time coloring, distance-based rendering) will work in hyperbolic space. But the results will be even more intricate because hyperbolic space has “more room” than Euclidean space—allowing denser tilings and more complex fractal structures.\nMake sure you’re comfortable with: - Iteration and escape-time algorithms (we’ll use similar ideas for tiling) - Circle inversion (this becomes reflection through hyperbolic geodesics!) - Structs for organizing geometric data - Coloring strategies based on orbit behavior\nSee you tomorrow!"
  },
  {
    "objectID": "OLD/lectures/day2.html#overview",
    "href": "OLD/lectures/day2.html#overview",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Today we explore the power of iteration to generate fractals. We’ll implement complex arithmetic in GLSL and use it to render the iconic Mandelbrot set, then understand its companion, the Julia set. After that, we shift gears to geometric iteration: circle inversion, a beautiful conformal transformation that creates intricate nested patterns when applied repeatedly. We’ll see how the Apollonian gasket emerges from iterated inversions of three mutually tangent circles.\nBy the end of today, you’ll understand how simple iterative processes—whether in the complex plane or through geometric transformations—can generate infinitely detailed fractal structures from just a few lines of code.\n\n\n\n\n\n\nNoteRoadmap for Today\n\n\n\nWe’ll explore iteration in two different mathematical settings:\n\nComplex dynamics: Iterating holomorphic maps (Mandelbrot and Julia sets)\nGeometric dynamics: Iterating circle inversions (Apollonian gasket)\n\nBoth produce fractals through the same fundamental mechanism: simple rules applied repeatedly reveal infinite complexity. The common thread is conformality—both complex multiplication and circle inversion preserve angles, and this angle preservation is key to the beautiful structures we’ll see.\nAlong the way, we’ll learn shader programming techniques for organizing data (structs), implementing mathematical operations efficiently, and creating sophisticated coloring schemes."
  },
  {
    "objectID": "OLD/lectures/day2.html#complex-numbers-in-glsl",
    "href": "OLD/lectures/day2.html#complex-numbers-in-glsl",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "A complex number \\(z = a + bi\\) can be represented as a 2D vector with real part \\(a\\) and imaginary part \\(b\\). This is the natural representation—complex numbers are the 2D plane with a particular multiplication structure! In GLSL:\nvec2 z = vec2(a, b);  // Represents a + bi\nWe’ll consistently use the convention: z.x is the real part, z.y is the imaginary part. You already know complex numbers geometrically as rotations and scalings in the plane—here we’re just implementing that algebra in shader code.\n\n\n\nLet \\(z = a + bi\\) and \\(w = c + di\\). We need to implement the basic operations. Some of these are trivial, others require a bit more work:\nAddition: \\((a + bi) + (c + di) = (a + c) + (b + d)i\\)\nvec2 cadd(vec2 z, vec2 w) {\n    return z + w;  // Vector addition is sufficient!\n}\nAddition of complex numbers is just vector addition—componentwise! You might not even need this function since you can just write z + w directly, but it’s here for completeness.\nMultiplication: \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\)\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,  // Real part: ac - bd\n        z.x * w.y + z.y * w.x   // Imaginary part: ad + bc\n    );\n}\nThis implements the familiar FOIL pattern with \\(i^2 = -1\\), giving us that minus sign in the real part.\nMagnitude squared: \\(|z|^2 = a^2 + b^2\\)\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // z.x * z.x + z.y * z.y\n}\nThe squared magnitude is just the dot product with itself. This is computationally cheaper than taking the square root, so when we just need to check if \\(|z| &gt; 2\\), we’ll check if \\(|z|^2 &gt; 4\\) instead—millions of avoided square roots per frame!\nMagnitude: \\(|z| = \\sqrt{a^2 + b^2}\\)\nfloat cabs(vec2 z) {\n    return length(z);\n}\nThe magnitude is the Euclidean distance from the origin—exactly what length() computes!\nConjugate: \\(\\overline{z} = a - bi\\)\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\nThe conjugate flips the sign of the imaginary part—reflection across the real axis.\nDivision: \\(\\frac{a + bi}{c + di} = \\frac{(a + bi)(c - di)}{c^2 + d^2}\\)\nvec2 cdiv(vec2 z, vec2 w) {\n    float denom = dot(w, w);  // c² + d²\n    return vec2(\n        (z.x * w.x + z.y * w.y) / denom,  // Real part\n        (z.y * w.x - z.x * w.y) / denom   // Imaginary part\n    );\n}\nDivision multiplies numerator and denominator by the conjugate of \\(w\\) to rationalize. The denominator becomes real (\\(c^2 + d^2\\)), and the numerator becomes a new complex number we can compute directly.\n\n\n\n\n\n\nTipComputational Efficiency in Complex Arithmetic\n\n\n\nNotice we use dot(z, z) for magnitude squared—this is a single GPU operation rather than component-wise multiplication and addition. Similarly, dot(w, w) in the division routine. For operations you’ll compute millions of times per frame, these micro-optimizations add up!\nWe’re also using helper functions rather than inlining the formulas everywhere. This makes the code much more readable (cmul(z, z) vs vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y)) and easier to debug. If you make a sign error once in cmul, you fix it once. If you inline the formula fifty times, you’ll hunt for bugs forever!\n\n\nThese are the building blocks we need for complex dynamics. Let’s put them to work!"
  },
  {
    "objectID": "OLD/lectures/day2.html#the-mandelbrot-set",
    "href": "OLD/lectures/day2.html#the-mandelbrot-set",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "The Mandelbrot set \\(\\mathcal{M}\\) is one of the most famous objects in mathematics—and for good reason! It’s defined as the set of complex numbers \\(c\\) for which the iteration \\[z_{n+1} = z_n^2 + c, \\quad z_0 = 0\\] remains bounded as \\(n \\to \\infty\\).\nThat’s it! Just iterate this simple quadratic map starting from \\(z_0 = 0\\), and see if the orbit escapes to infinity or stays bounded. Points that stay bounded are in the set (traditionally colored black), while points that escape are colored based on how quickly they escape.\n\n\n\nIn practice, we can’t iterate to infinity, so we need a criterion to detect escape. Fortunately, there’s a beautiful theorem that tells us exactly when to stop:\nTheorem (Escape Radius). If \\(|z_n| &gt; 2\\) for any \\(n\\), then \\(|z_n| \\to \\infty\\) as \\(n \\to \\infty\\).\nThis means: once the orbit leaves the disk of radius 2, it’s definitely escaping to infinity. Points that escape are not in the Mandelbrot set, while points that remain bounded after many iterations are (likely) in the set or very close to its boundary.\nProof. Suppose \\(|z_n| &gt; 2\\) and write \\(|z_n| = 2 + \\epsilon\\) for some \\(\\epsilon &gt; 0\\). Then \\[\\begin{align*}\n|z_{n+1}| &= |z_n^2 + c|\\\\\n&\\geq |z_n^2| - |c|\\\\\n&= |z_n|^2 - |c|\\\\\n&&gt; |z_n|^2 - 2 \\quad \\text{(since $c$ is in or near $\\mathcal{M}$, which fits in $|z| \\leq 2$)}\\\\\n&= (2 + \\epsilon)^2 - 2\\\\\n&= 4 + 4\\epsilon + \\epsilon^2 - 2\\\\\n&= 2 + 4\\epsilon + \\epsilon^2\\\\\n&&gt; 2 + 2\\epsilon = |z_n| + \\epsilon\n\\end{align*}\\]\nSo once \\(|z_n| &gt; 2\\), we have \\(|z_{n+1}| &gt; |z_n| + \\epsilon\\), meaning the magnitude grows by at least \\(\\epsilon\\) each iteration. This linear growth accelerates: if \\(|z_{n+1}| &gt; 2 + \\epsilon\\), then \\(|z_{n+2}| &gt; |z_{n+1}| + \\epsilon' &gt; 2 + 2\\epsilon\\), and so on. More carefully, the orbit actually grows exponentially (roughly like \\(|z_n| \\sim 2^{2^n}\\) for large \\(n\\)), but the key point is: it definitely escapes to infinity.\nComputational Implication: We only need to check if \\(|z_n| &gt; 2\\). The moment this happens, we can stop iterating—this point will never be in the Mandelbrot set. This single theorem makes efficient rendering possible!\n\n\n\nThe Mandelbrot set was discovered remarkably recently—1980! Benoit Mandelbrot, working at IBM, was among the first to have access to computers powerful enough to visualize iterative processes in the complex plane. Before computers, studying these sets was nearly impossible—you’d need to manually iterate complex arithmetic hundreds of times for millions of points.\nInterestingly, the mathematical theory predates visualization by over 60 years. Gaston Julia and Pierre Fatou studied iterative complex dynamics extensively in 1918, but without computers, they could only reason about these sets abstractly. They knew Julia sets existed and had deep properties, but had never seen one! When Mandelbrot generated the first images in 1980, it revolutionized the field—suddenly the intricate structure of these sets was visible, creating an explosion of interest in fractal geometry and complex dynamics.\nThe Mandelbrot set became iconic partly because it’s so accessible: anyone can understand the definition (iterate \\(z \\mapsto z^2 + c\\)), yet it produces infinitely intricate beauty. It also sparked broader interest in fractals, chaos theory, and the idea that simple rules can generate complex behavior—themes that would influence everything from physics to economics to art.\n\n\n\nLet’s code it up:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup: center at origin, scale to show interesting region\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale to view the Mandelbrot set (roughly [-2.5, 1] × [-1.25, 1.25])\n    vec2 c = uv * 3.5;\n    c.x -= 0.5;  // Center on the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);  // z_0 = 0\n    int max_iter = 100;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        // Check if escaped\n        if(cabs2(z) &gt; 4.0) break;  // |z| &gt; 2, so |z|² &gt; 4\n        \n        // z_{n+1} = z_n² + c\n        z = cmul(z, z) + c;\n    }\n    \n    // Color based on iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = vec3(t);  // Grayscale for now\n    \n    fragColor = vec4(color, 1.0);\n}\nThat’s the entire Mandelbrot set renderer! The coordinate scaling is tuned to show the “interesting part”—the main cardioid body and its surrounding bulbs. The set extends roughly from \\(-2.5\\) to \\(0.5\\) on the real axis, so we shift our coordinate system accordingly.\n\n\n\n\n\n\nNoteWhy This Is Perfect for GPUs\n\n\n\nNotice what’s happening computationally: every pixel performs its own independent calculation. There’s no communication between pixels, no shared data structures, no synchronization needed. Each pixel just iterates its own complex number and decides when to stop.\nThis is embarrassingly parallel—the ideal workload for GPU architecture. A modern GPU has thousands of small processors, and they can all work on different pixels simultaneously. No pixel needs to wait for another pixel’s result. The entire screen (potentially millions of pixels) is computed in parallel, which is why we can render the Mandelbrot set at 60fps even with 100+ iterations per pixel.\nMemory-wise, this is also very efficient: each pixel only needs to store its current \\(z\\) value (two floats) and an iteration counter (one integer). No arrays, no history, no complex data structures. The computation is stateless—we only care about the current iterate, not the full orbit.\nThis contrasts sharply with sequential CPU code, where you’d iterate over pixels one at a time. Even with clever optimizations and SIMD vectorization, you’d be orders of magnitude slower than a GPU shader doing the same work.\n\n\n\n\n\nThe grayscale rendering shows the structure of the set, but it has harsh banding—sudden transitions between integer iteration counts create visible stripes. We can do much better by interpolating between iteration steps!\nThe key insight is that near escape, the orbit grows exponentially. Specifically, once \\(|z_n|\\) is large, we have approximately \\(|z_{n+1}| \\approx |z_n|^2\\), which means \\(\\log |z_{n+1}| \\approx 2\\log|z_n|\\). Taking logs repeatedly, we get \\[\\log\\log|z_{n+1}| \\approx \\log(2\\log|z_n|) = \\log 2 + \\log\\log|z_n|\\]\nThis suggests that \\(\\log\\log|z_n|\\) grows approximately linearly near escape, increasing by \\(\\log 2\\) per iteration. We can use this to compute a fractional iteration count!\nHere’s the formula:\nif(iter &lt; max_iter) {\n    // Smooth iteration count (accounts for continuous escape)\n    float log_zn = log(cabs2(z)) / 2.0;  // = log|z_n|\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    \n    float t = smooth_iter / float(max_iter);\n    vec3 color = palette(t);\n} else {\n    // Inside the set: black\n    vec3 color = vec3(0.0);\n}\nThe variable nu represents how far we’ve progressed toward the next integer iteration. When \\(|z_n| = 2\\) exactly (just hitting the escape threshold), \\(nu = 0\\) and we get the integer iteration count. When \\(|z_n|\\) is large (deep into escape), \\(nu\\) approaches 1. Subtracting nu from iter + 1 gives us a continuous, smooth value that transitions gradually between iteration levels.\nThis eliminates banding entirely! The result is smooth, continuous color gradients that look much more professional and reveal the fractal structure more clearly.\n\n\n\n\n\n\nTipSmooth Coloring as Anti-Aliasing\n\n\n\nSmooth coloring is fundamentally an anti-aliasing technique. Without it, nearby pixels with iteration counts of, say, 45 and 46 get completely different colors—creating harsh edges. With smooth coloring, these pixels get nearly identical colors (say, iteration 45.3 and 45.8), producing a smooth gradient.\nThis is especially important at high zoom levels, where tiny changes in position lead to different integer iteration counts. The smooth interpolation ensures that small changes in \\(c\\) produce small changes in color, which is exactly what we want for a continuous mathematical function.\n\n\n\n\n\nNow we need a good color mapping function. A classic approach uses cosines to create smooth, cyclic color palettes:\nvec3 palette(float t) {\n    // Create a cyclic color palette using cosines\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    \n    return a + b * cos(6.28318 * (c * t + d));\n}\nThis uses a cosine-based palette function that creates smooth, cyclic colors—perfect for the Mandelbrot set where we want colors to repeat as we zoom in to the fractal boundary. The parameters control different aspects:\n\na and b control the range and center of the colors (here, mapping to \\([0,1]\\))\nc controls the frequency of color cycling\nd controls the phase offset, shifting the entire palette\n\nPlay with these parameters to get different color schemes! Try d = vec3(0.0, 0.1, 0.2) for a blue-purple palette, or d = vec3(0.3, 0.2, 0.2) for warmer tones. You can also adjust c to make the colors cycle faster or slower through the iteration range.\nThe beauty of this cosine approach is that it’s smooth (continuous derivatives), cyclic (no seams), and efficient (just a few trig operations). Other approaches exist—hand-picked color stops with interpolation, HSV color spaces, perceptually uniform LAB spaces—but cosine palettes are a great default for fractal visualization."
  },
  {
    "objectID": "OLD/lectures/day2.html#julia-sets",
    "href": "OLD/lectures/day2.html#julia-sets",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "The Julia set is the natural companion to the Mandelbrot set, and understanding their relationship is key to understanding complex dynamics. Where the Mandelbrot set varies \\(c\\) and fixes \\(z_0 = 0\\), the Julia set does the opposite: it fixes \\(c\\) and varies \\(z_0\\).\n\n\nFor a fixed complex number \\(c\\), the filled Julia set \\(K_c\\) is the set of initial conditions \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded. The Julia set \\(J_c\\) is the boundary of \\(K_c\\)—the set where the dynamics are chaotic, neither definitely bounded nor definitely escaping.\nThink about what this means: every point \\(c\\) in the complex plane has an associated Julia set \\(J_c\\). The Mandelbrot set is telling us about the topology of these Julia sets! Specifically:\n\nIf \\(c \\in \\mathcal{M}\\) (inside the Mandelbrot set), then \\(J_c\\) is connected—a single, intricate curve\nIf \\(c \\notin \\mathcal{M}\\) (outside the Mandelbrot set), then \\(J_c\\) is totally disconnected—a Cantor-like dust of points\n\nThis is one of the most beautiful connections in mathematics: the Mandelbrot set is a map of parameter space, showing which values of \\(c\\) produce connected Julia sets. Julia and Fatou proved this in 1918 without ever seeing a picture—they understood these sets purely abstractly!\n\n\n\nYou’ll implement Julia set rendering in the homework. The algorithm is nearly identical to the Mandelbrot set—just swap what’s fixed and what varies! Instead of setting z = vec2(0.0) and varying c across pixels, you’ll set c to a fixed value and let z be the pixel coordinate.\nThe key changes: 1. Fix c to an interesting value (we’ll give suggestions) 2. Initialize z from the pixel position (that’s your \\(z_0\\)) 3. Iterate \\(z \\mapsto z^2 + c\\) exactly as before 4. Use the same escape criterion and coloring\nThis will give you a Julia set! Try different values of \\(c\\) to see how the topology changes. You can make c depend on time (iTime) for animation, or on mouse position (iMouse) for interactive exploration.\nSome interesting values to try: - \\(c = -0.7 + 0.27015i\\) — classic Julia set, intricate tendrils - \\(c = -0.4 + 0.6i\\) — dendrite-like fractal trees - \\(c = 0.285 + 0.01i\\) — beautiful spiral patterns - \\(c = -0.8 + 0.156i\\) — highly filamentary - \\(c = -0.70176 - 0.3842i\\) — “San Marco dragon”\nValues inside the Mandelbrot set give connected Julia sets (single curves), while values outside give disconnected Julia sets (dust). The most interesting Julia sets often come from values right near the boundary of \\(\\mathcal{M}\\)—this is where the transition between connected and disconnected happens!\n\n\n\n\n\n\nTipExploring Parameter Space\n\n\n\nWhen you implement Julia sets, try this: tie \\(c\\) to your mouse position. Move the mouse around and watch the Julia set morph in real time! This is an incredibly powerful way to build intuition for how the parameter \\(c\\) affects the dynamics.\nYou’ll notice that small changes in \\(c\\) can produce dramatic changes in the Julia set topology—this is the sensitive dependence on parameters that makes complex dynamics so rich. Near the boundary of the Mandelbrot set, tiny movements create entirely different structures."
  },
  {
    "objectID": "OLD/lectures/day2.html#interlude-from-complex-to-geometric-dynamics",
    "href": "OLD/lectures/day2.html#interlude-from-complex-to-geometric-dynamics",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "We’ve been iterating algebraic functions in the complex plane: \\(z \\mapsto z^2 + c\\). Now we shift to iterating geometric transformations of the plane itself: circle inversion. The mathematical frameworks are different—holomorphic dynamics versus conformal geometry—but they share fundamental similarities.\nBoth complex multiplication and circle inversion are conformal maps: they preserve angles between curves. In complex dynamics, this comes from the Cauchy-Riemann equations and the geometric interpretation of multiplication as rotation and scaling. In circle inversion, it’s a theorem we’ll state shortly. This angle preservation is crucial—it’s what makes the fractal structures we generate geometrically coherent and visually beautiful.\nThere’s also a deep connection we’ll explore tomorrow: circle inversion is actually an isometry of hyperbolic space! The inversions we’re about to do are the same transformations that generate Kleinian groups and tessellate the hyperbolic plane. So in some sense, we’re already working in non-Euclidean geometry without realizing it. Tomorrow we’ll make this explicit when we explore hyperbolic tilings.\nFor now, let’s learn circle inversion and use it to build the Apollonian gasket—a fractal structure every bit as intricate as the Mandelbrot set, but generated through pure Euclidean geometry."
  },
  {
    "objectID": "OLD/lectures/day2.html#circle-inversion",
    "href": "OLD/lectures/day2.html#circle-inversion",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Circle inversion is a beautiful geometric operation that will be the foundation for everything we do with geometric dynamics. It’s a transformation of the plane that turns inside into outside, maps circles to circles (or lines), and preserves angles—making it a powerful tool for creating fractal patterns.\n\n\nCircle inversion is a transformation with respect to a circle. For a circle of radius \\(R\\) centered at a point \\(\\mathbf{c}\\), inversion maps a point \\(\\mathbf{p} \\neq \\mathbf{c}\\) to: \\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nThe vector \\(\\mathbf{p} - \\mathbf{c}\\) points from the center to \\(\\mathbf{p}\\). We normalize this direction by dividing by its squared length, then scale by \\(R^2\\), and finally translate back by the center. Geometrically:\n\nPoints inside the circle map to points outside (and vice versa)\nPoints on the circle are fixed (they map to themselves)\nThe closer you are to the center, the farther away you go\nThe center itself maps to infinity, and infinity maps to the center\n\nHere’s another way to think about it: draw a ray from the center through \\(\\mathbf{p}\\). The inversion of \\(\\mathbf{p}\\) is the unique point on this ray such that the product of distances from the center is \\(R^2\\). If \\(\\mathbf{p}\\) is at distance \\(r\\) from the center, its image is at distance \\(R^2/r\\).\n\n\n\nCircle inversion has remarkable geometric properties. These aren’t obvious from the formula, but they’re all classical theorems:\n\nLines through the center remain lines through the center (they’re “flipped inside out” along the ray)\nLines not through the center become circles through the center\nCircles through the center become lines (not through the center)\nCircles not through the center generally remain circles, but with different center and radius\nAngles are preserved (conformal property)\n\nThe angle preservation is the deepest property. It’s not at all obvious from the formula, but it can be proved using the chain rule and careful calculation. The key insight is that inversion is locally similar to a complex conjugation-like operation, which preserves angles.\nWhy These Properties Matter for Iteration: When we iterate inversions through multiple circles, these properties ensure that the geometry remains coherent. Circles stay circles (or become lines), and the angles between curves are preserved. This means repeated inversion creates intricate but geometrically regular patterns—the hallmark of fractals generated by conformal maps.\nAnother key fact: inversion is involutive—applying it twice returns to the original point (assuming the point isn’t the center). Mathematically, \\(\\text{inv}(\\text{inv}(\\mathbf{p})) = \\mathbf{p}\\). This makes inversion a geometric reflection of sorts, which will be important when we think about symmetry groups tomorrow.\n\n\n\n\n\n\nNoteHistorical Context: Circle Inversion\n\n\n\nCircle inversion has ancient roots—Apollonius of Perga studied related problems involving tangent circles around 200 BCE. But the modern theory of inversion as a geometric transformation developed in the 19th century as part of projective and non-Euclidean geometry.\nA key insight was recognizing that circle inversion is related to stereographic projection: if you place a sphere on the plane, inversion in a circle corresponds to reflection through the sphere! This connection links circle inversion to spherical geometry and ultimately to hyperbolic geometry.\nIn the late 19th and early 20th centuries, mathematicians realized that groups of circle inversions (Kleinian groups) could tessellate hyperbolic space and create fractal limit sets. This anticipates the fractal geometry revolution of the 1970s-80s, though the connection wasn’t fully appreciated until computers made visualization possible.\n\n\n\n\n\nThe formula translates directly to GLSL:\nvec2 invertCircle(vec2 p, vec2 center, float radius) {\n    vec2 diff = p - center;\n    float r2 = dot(diff, diff);  // squared distance from center\n    \n    // Handle center (would be division by zero)\n    if(r2 &lt; 0.0001) return vec2(1000.0);  // Map to \"infinity\"\n    \n    return center + (radius * radius) * diff / r2;\n}\nThe only tricky part is handling the center point, which mathematically maps to infinity. We approximate this by mapping to a very large value—far enough away that it’s effectively off-screen. The threshold 0.0001 is small enough to catch points numerically close to the center but large enough to avoid precision issues.\nComputationally, circle inversion is very cheap: just one dot product, a division, a multiplication, and some vector operations. This efficiency is important because we’ll be doing many inversions per pixel when generating fractals!\n\n\n\nLet’s see what happens when we apply inversion to a grid. This is one of the best ways to understand the transformation visually:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Standard coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Inversion circle\n    vec2 circleCenter = vec2(0.0, 0.0);\n    float circleRadius = 1.0;\n    \n    // Apply inversion\n    vec2 p_inverted = invertCircle(p, circleCenter, circleRadius);\n    \n    // Draw a grid in the inverted space\n    vec2 grid = fract(p_inverted * 2.0);  // Create repeating cells\n    float gridLine = step(0.95, max(grid.x, grid.y));  // Draw grid lines\n    \n    vec3 color = vec3(gridLine);\n    \n    // Draw the inversion circle itself (for reference)\n    float circDist = abs(length(p) - circleRadius);\n    if(circDist &lt; 0.05) color = vec3(1.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou’ll see straight grid lines transform into beautiful circular arcs! Lines farther from the inversion circle get bent more dramatically, while lines near the circle stay relatively straight. Horizontal and vertical lines through the center remain horizontal and vertical (but swap inside/outside), while other lines become circles.\nThis visualization really helps build intuition. You can see: - The circle itself (in red) is unchanged—points on it are fixed - The grid inside the circle maps to a grid outside (and vice versa) - Lines become curves, but the angles where they intersect are preserved - The pattern has a pole singularity at the center (infinite distortion)\n\n\n\n\n\n\nTipExploring Circle Inversion\n\n\n\nHere are some experiments to try:\n\nMultiple circles: Create a grid of circles using mod() (like we did on Day 1) and invert through each cell’s circle independently. You’ll see beautiful overlapping patterns!\nAnimated radius: Make circleRadius = 1.0 + 0.5 * sin(iTime) to watch the grid breathe in and out. This helps you see how the inversion depends on the circle’s size.\nDifferent patterns: Instead of a grid, try drawing circles or other shapes in the inverted space. Circles become circles (or lines), creating intricate nested patterns.\nOff-center inversion: Move the inversion circle away from the origin. Watch how the asymmetry creates even more complex distortions.\n\nEach of these will give you geometric intuition for how inversion behaves, which will be crucial when we iterate multiple inversions!"
  },
  {
    "objectID": "OLD/lectures/day2.html#structs-in-glsl",
    "href": "OLD/lectures/day2.html#structs-in-glsl",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Before we build the Apollonian gasket, we need to talk about organizing our data. We’re about to deal with multiple circles, and passing around center1, radius1, center2, radius2, etc. gets unwieldy fast. GLSL provides structs (just like in C) for grouping related data together.\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nNow Circle is a type we can use just like vec2 or float. Creating and using structs is straightforward:\n// Declare and initialize\nCircle c1 = Circle(vec2(0.0, 0.0), 1.0);\n\n// Or declare first, set later\nCircle c2;\nc2.center = vec2(1.0, 0.5);\nc2.radius = 0.75;\n\n// Pass to functions\nvec2 invertThroughCircle(vec2 p, Circle circ) {\n    return invertCircle(p, circ.center, circ.radius);\n}\nThis makes the code dramatically more readable. Compare:\n// Without structs - messy!\nvec2 iterate(vec2 p, vec2 c1_cen, float c1_rad, vec2 c2_cen, float c2_rad, vec2 c3_cen, float c3_rad);\n\n// With structs - clean!\nvec2 iterate(vec2 p, Circle c1, Circle c2, Circle c3);\nFor the Apollonian gasket, we’ll have three circles we need to track and pass around. Structs make this much more manageable and semantically clear—we’re working with circles as geometric objects, not just pairs of vectors and floats."
  },
  {
    "objectID": "OLD/lectures/day2.html#the-apollonian-gasket",
    "href": "OLD/lectures/day2.html#the-apollonian-gasket",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Now for the main event! The Apollonian gasket is a fractal generated by iterating circle inversions through three mutually tangent circles. It’s named after Apollonius of Perga, who studied the problem of finding circles tangent to three given circles around 200 BCE, though the fractal interpretation is much more modern.\n\n\nTo understand the Apollonian gasket, we need to know about a beautiful theorem: Descartes Circle Theorem (1643).\nGiven four mutually tangent circles (each tangent to the other three), let their curvatures be \\(k_1, k_2, k_3, k_4\\) where curvature \\(k = 1/r\\) (positive for external tangency, negative for internal). Then: \\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\\]\nThis can be rearranged to solve for the fourth curvature given three: \\[k_4 = k_1 + k_2 + k_3 \\pm 2\\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}\\]\nThe \\(\\pm\\) gives two solutions—the two circles tangent to the original three (one inside the curvilinear triangle they form, one outside).\nWhat makes this magical for fractals: if you start with three mutually tangent circles with integer curvatures, then all circles in the Apollonian gasket have integer curvatures! This is the Apollonian gasket’s connection to number theory—it’s a fractal made entirely of circles with rational radii.\nWe won’t use this formula directly in our shader (we’ll set up circles geometrically), but it explains why certain configurations are special and why the patterns are so regular despite infinite nesting.\n\n\n\nWe start with three circles that are all tangent to each other—meaning each pair touches at exactly one point. For this to work, the distance between any two circle centers must be exactly twice the radius (so they touch edge-to-edge). The three centers form an equilateral triangle, and we’ll position this triangle symmetrically at the origin:\nvoid setupApollonianCircles(out Circle c1, out Circle c2, out Circle c3, out Circle outer) {\n    float r = 0.5;  // Radius of each inner circle\n    // For three circles to be mutually tangent: distance between centers = 2r\n    // Centers form equilateral triangle with circumradius = 2r/sqrt(3)\n    float d = 2.0 * r / sqrt(3.0);  // ≈ 0.577 for r = 0.5\n    \n    // Three inner circles\n    c1 = Circle(vec2(0.0, d), r);\n    c2 = Circle(vec2(-d * 0.866, -d * 0.5), r);  // 0.866 ≈ sqrt(3)/2\n    c3 = Circle(vec2(d * 0.866, -d * 0.5), r);\n    \n    // Outer circle tangent to all three, centered at origin\n    float R = d + r;  // ≈ 1.077 for r = 0.5\n    outer = Circle(vec2(0.0, 0.0), R);\n}\nWith \\(r = 0.5\\), the circumradius \\(d \\approx 0.577\\), and the outer circle has radius \\(R = d + r \\approx 1.077\\). All four circles are mutually tangent—each inner circle touches the other two inner circles and the outer circle.\nThis is just one possible configuration! You could use different radii (related by Descartes’ theorem), different arrangements, or even animated circles. The key is that they start mutually tangent—this ensures the iteration creates a proper Apollonian packing.\n\n\n\nThe algorithm is beautifully simple:\n\nStart with a point \\(p\\)\nCheck which circles contain \\(p\\)\nIf \\(p\\) is inside a circle, invert through that circle\nRepeat until \\(p\\) is outside all circles or we hit max iterations\nColor based on iteration behavior\n\nHere’s the implementation:\nvec2 iterateApollonian(vec2 p, Circle c1, Circle c2, Circle c3, Circle outer,\n                       int maxIter, out int finalIter, out int lastCircle) {\n    for(int i = 0; i &lt; maxIter; i++) {\n        bool moved = false;\n        \n        // Check the three inner circles\n        if(length(p - c1.center) &lt; c1.radius) {\n            p = invertCircle(p, c1.center, c1.radius);\n            lastCircle = 0;\n            moved = true;\n        } \n        else if(length(p - c2.center) &lt; c2.radius) {\n            p = invertCircle(p, c2.center, c2.radius);\n            lastCircle = 1;\n            moved = true;\n        }\n        else if(length(p - c3.center) &lt; c3.radius) {\n            p = invertCircle(p, c3.center, c3.radius);\n            lastCircle = 2;\n            moved = true;\n        }\n        // Check if outside the outer circle\n        else if(length(p - outer.center) &gt; outer.radius) {\n            p = invertCircle(p, outer.center, outer.radius);\n            lastCircle = 3;\n            moved = true;\n        }\n        \n        // If we didn't move, we're in the gaps - done!\n        if(!moved) {\n            finalIter = i;\n            return p;\n        }\n    }\n    \n    finalIter = maxIter;\n    return p;\n}\nWe also track which circle we last inverted through (lastCircle) and how many iterations we performed (finalIter). These will be useful for coloring!\nWhy This Creates a Fractal: Each time we invert through a circle, we “push” the point away from that circle’s center. But because the four circles are mutually tangent, pushing away from one circle might push us into another circle, triggering another inversion. The interplay between these four inversions (three inner circles plus the outer circle) creates a complex orbit.\nPoints in the “gaps” between the inner circles (the curvilinear triangles) escape quickly—they’re inside the outer circle but not inside any inner circle, so no inversion happens. But points near the tangency points get bounced back and forth between circles many times before escaping. And at the actual tangency points (where circles touch), the orbit never escapes—these are fixed points or periodic orbits of the iterated inversions.\nThe fractal structure emerges because these dynamics are self-similar: zooming in near any tangency point reveals the same pattern of nested circles and gaps. This self-similarity is a direct consequence of the conformal nature of circle inversion—the transformation preserves angles, so local geometry looks the same at all scales.\n\n\n\nThere are several interesting ways to color the Apollonian gasket:\nBy iteration count (like the Mandelbrot set):\nfloat t = float(finalIter) / float(maxIter);\nvec3 color = palette(t);\nThis shows the “depth” of the orbit—points that escape quickly are colored differently from points that bounce around many times.\nBy last circle hit:\nvec3 colors[4] = vec3[4](\n    vec3(1.0, 0.0, 0.0),  // Circle 1: red\n    vec3(0.0, 1.0, 0.0),  // Circle 2: green\n    vec3(0.0, 0.0, 1.0),  // Circle 3: blue\n    vec3(1.0, 1.0, 0.0)   // Outer circle: yellow\n);\nvec3 color = colors[lastCircle];\nThis shows the basin of attraction—which circle’s “influence” each point ultimately fell into. Yellow regions show points that escaped through the outer circle.\nBy final distance from circles:\nfloat d1 = abs(length(p - c1.center) - c1.radius);\nfloat d2 = abs(length(p - c2.center) - c2.radius);\nfloat d3 = abs(length(p - c3.center) - c3.radius);\nfloat d = min(d1, min(d2, d3));\nvec3 color = vec3(smoothstep(0.0, 0.05, d));\nThis highlights the circle boundaries themselves, making the geometric structure more apparent.\nEach coloring reveals different aspects of the fractal. Try combining them—for example, color by iteration count but modulate brightness by distance to circles.\n\n\n\nHere’s a complete Apollonian gasket renderer:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Setup the four circles\n    Circle c1, c2, c3, outer;\n    setupApollonianCircles(c1, c2, c3, outer);\n    \n    // Iterate\n    int maxIter = 50;\n    int finalIter, lastCircle;\n    vec2 final_p = iterateApollonian(p, c1, c2, c3, outer, maxIter, finalIter, lastCircle);\n    \n    // Color by iteration count with palette\n    float t = float(finalIter) / float(maxIter);\n    vec3 color = palette(t);\n    \n    // Draw all four circles for reference\n    float d1 = abs(length(p - c1.center) - c1.radius);\n    float d2 = abs(length(p - c2.center) - c2.radius);\n    float d3 = abs(length(p - c3.center) - c3.radius);\n    float d_outer = abs(length(p - outer.center) - outer.radius);\n    float d = min(min(d1, min(d2, d3)), d_outer);\n    \n    if(d &lt; 0.02) color = vec3(1.0);  // White circle outlines\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a beautiful nested pattern of circles! The fractal structure is immediately apparent—circles within circles within circles, filling every gap with smaller circles.\nZoom in (by scaling p differently in the coordinate setup) to see the self-similarity. No matter how far you zoom, you’ll keep finding the same pattern repeated at smaller scales. This is true fractality—infinite detail that never runs out.\n\n\n\n\n\n\nNoteComputational Efficiency\n\n\n\nDespite the complexity of the output, this algorithm is remarkably efficient. Each iteration just checks three distances (cheap) and potentially does one inversion (also cheap—just a few arithmetic operations). With 50 iterations, we’re doing maybe 150 distance checks and 50 inversions per pixel.\nCompare this to raymarching (Day 4), where we might do hundreds of distance evaluations per pixel! The Apollonian gasket is very GPU-friendly.\nThe key is that we terminate early—most pixels escape in just a few iterations. Only points near the fractal boundary require many iterations. This is similar to the Mandelbrot set: most of the computational work focuses on the interesting regions (the boundary), while simple regions (deep inside or far outside) are handled quickly.\n\n\n\n\n\nThe Apollonian gasket connects several mathematical threads across millennia:\nAncient roots: Apollonius of Perga (~200 BCE) studied the problem of constructing circles tangent to three given circles (the “Problem of Apollonius”). He found geometric constructions but couldn’t have imagined the infinite fractal structure we’re visualizing.\nRenaissance mathematics: René Descartes (1643) discovered the circle theorem bearing his name, giving an algebraic formula for tangent circles. This turned Apollonius’s geometric problem into arithmetic.\n19th century: The connection to projective geometry and circle inversions was developed. Mathematicians realized that packing problems could be studied through group theory—the inversions form a discrete subgroup of the group of Möbius transformations.\n20th century: With computers, the fractal nature became visible. The Apollonian gasket was recognized as a limit set of a Kleinian group—a group of isometries of hyperbolic space. This connects to tomorrow’s material: the inversions we’re doing are actually hyperbolic isometries! In the Poincaré disk model (which we’ll see tomorrow), these inversions are reflections through hyperbolic geodesics.\nThe gasket also has connections to number theory: if the initial circles have integer curvatures, all circles in the packing do too (by Descartes’ theorem). This has led to deep questions about the distribution of integers in these packings, which remain active research areas today."
  },
  {
    "objectID": "OLD/lectures/day2.html#summary",
    "href": "OLD/lectures/day2.html#summary",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Today we’ve explored two powerful iterative processes that generate fractals:\n\nComplex dynamics: The Mandelbrot and Julia sets emerge from iterating \\(z \\mapsto z^2 + c\\)\n\nImplemented complex arithmetic in GLSL efficiently\nLearned escape-time algorithms and the crucial escape radius theorem\nDeveloped smooth coloring techniques for anti-aliased rendering\nUnderstood the parameter space (Mandelbrot) vs dynamical space (Julia) distinction\nSaw how 1980s computational power revolutionized a 1918 theory\n\nGeometric dynamics: The Apollonian gasket emerges from iterating circle inversions\n\nCircle inversion as a conformal transformation preserving angles\nUsed structs to organize geometric data cleanly\nApplied Descartes Circle Theorem to understand tangent circle configurations\nIterated inversions through three circles to create fractal patterns\nConnected ancient Greek geometry to modern fractal theory\n\n\nBoth processes show how incredibly simple rules—a quadratic map, a geometric transformation—generate infinite complexity through iteration. The key in both cases is conformality: angle-preserving maps create geometrically coherent fractals. This is one of the core insights of fractal geometry and dynamical systems.\nThe computational perspective is also crucial: both algorithms are embarrassingly parallel, making them perfect for GPU rendering. Each pixel’s calculation is independent, and we can terminate early when orbits escape. The result is real-time rendering of infinitely detailed mathematical objects.\nTomorrow we’ll push geometric iteration further, moving from Euclidean to hyperbolic geometry. The circle inversions we’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space. We’ll explore the upper half-plane and Poincaré disk models, create \\((2,3,7)\\) and \\((2,3,\\infty)\\) triangle tilings, and see how the same algorithmic ideas (iterated geometric transformations) work in non-Euclidean geometry. The results will be even more intricate because hyperbolic space has “more room” than Euclidean space—triangles can have angle sums less than \\(\\pi\\), allowing denser tilings and more complex fractal structures."
  },
  {
    "objectID": "OLD/lectures/day2.html#homework",
    "href": "OLD/lectures/day2.html#homework",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Implement a Julia set renderer starting from the Mandelbrot code. The algorithm is nearly identical—you just need to swap what’s fixed and what varies!\nRequirements:\n\nStart from the Mandelbrot implementation\nFix c to a constant value (see suggestions below)\nInitialize z from the pixel position instead of zero\nIterate \\(z_{n+1} = z_n^2 + c\\) exactly as before\nUse the same escape criterion and coloring\n\nSuggested structure:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 3.0;  // Scale for Julia set viewing\n    \n    // Fix c to an interesting value\n    vec2 c = vec2(-0.7, 0.27015);  // Classic Julia set\n    \n    // Initialize z from pixel position (this is the key change!)\n    vec2 z = p;  // z_0 = pixel position\n    \n    // [Rest of iteration exactly like Mandelbrot]\n}\nInteresting parameters to try: - vec2(-0.7, 0.27015) — classic Julia set, intricate tendrils - vec2(-0.4, 0.6) — dendrite-like fractal trees\n- vec2(0.285, 0.01) — beautiful spiral patterns - vec2(-0.8, 0.156) — highly filamentary structure - vec2(-0.70176, -0.3842) — “San Marco dragon” - vec2(-0.835, -0.2321) — another classic - vec2(-0.7269, 0.1889) — “Douady’s rabbit” (famous example)\nExtension Options (pick one or both):\nOption A: Animated Parameter Space\nMake \\(c\\) depend on time to watch the Julia set morph:\nfloat angle = iTime * 0.3;\nfloat radius = 0.7885;  // Distance from origin in parameter space\nvec2 c = vec2(radius * cos(angle), radius * sin(angle));\nWatch how the Julia set changes topology as you trace a circle in the complex plane! You’ll see it transition from connected to disconnected, develop tendrils, and create organic shapes.\nOption B: Mouse-Controlled Exploration\nTie \\(c\\) to mouse position for interactive exploration:\nvec2 mouse_uv = (iMouse.xy / iResolution.xy) - 0.5;\nmouse_uv.x *= iResolution.x / iResolution.y;\nvec2 c = mouse_uv * 3.0;  // Scale to cover interesting parameter range\nNow you can explore parameter space by moving the mouse! This really helps build intuition for how \\(c\\) affects the Julia set. Try finding the boundary of the Mandelbrot set—parameters right at the edge produce the most intricate Julia sets.\n\n\n\n\n\n\nTipUnderstanding Connected vs Disconnected\n\n\n\nAs you explore parameter space, pay attention to whether the Julia set appears as a single connected structure or as disconnected dust. Values of \\(c\\) inside the Mandelbrot set give connected Julia sets, while values outside give disconnected ones. The most beautiful Julia sets often come from values right near the boundary of \\(\\mathcal{M}\\)!\n\n\n\n\n\n\nCreate a grid where each cell shows the Julia set for that value of \\(c\\), revealing the Mandelbrot set as an emergent pattern!\nThe idea: The Mandelbrot set is a map of Julia set topology. If we draw a grid of Julia sets for different values of \\(c\\), we should see the Mandelbrot set emerge in the overall pattern—cells with connected Julia sets (solid regions) correspond to points in \\(\\mathcal{M}\\), while cells with disconnected Julia sets (dust) are outside.\nImplementation strategy:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Divide screen into grid cells\n    float grid_size = 8.0;  // 8×8 grid of Julia sets\n    vec2 cell_id = floor(p * grid_size / 4.0);\n    vec2 cell_p = fract(p * grid_size / 4.0) - 0.5;\n    cell_p *= 4.0;  // Local coordinates within cell\n    \n    // Map cell_id to parameter c\n    vec2 c = (cell_id / grid_size) * 4.0 - vec2(2.5, 2.0);\n    c.x -= 0.5;  // Center on interesting region of Mandelbrot set\n    \n    // Run Julia set iteration with z = cell_p, fixed c\n    vec2 z = cell_p;\n    int max_iter = 50;\n    int iter;\n    \n    for(iter = 0; iter &lt; max_iter; iter++) {\n        if(cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Color\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Optional: draw grid lines to separate cells\n    vec2 grid_edge = abs(fract(p * grid_size / 4.0) - 0.5);\n    if(max(grid_edge.x, grid_edge.y) &gt; 0.48) color = vec3(0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nYou should see a grid of tiny Julia sets! If you look carefully at the overall pattern, you’ll notice it resembles the Mandelbrot set—cells with connected Julia sets (solid colored regions) correspond to points inside \\(\\mathcal{M}\\), while cells with disconnected Julia sets (fine dust patterns) are outside.\nThis is one of the most beautiful visualizations in complex dynamics—the Mandelbrot set literally encodes the topology of all Julia sets!\nVariations to try: - Adjust grid_size (larger for more detail, smaller for clearer overview) - Change the parameter space region being sampled - Color cells based on whether the Julia set appears connected (black) or disconnected (white)—you’ll get a pixelated approximation of the Mandelbrot set!\n\n\n\n\nExplore variations on the Apollonian gasket theme! The key is setting up circles in interesting configurations and iterating inversions.\nDifferent circle arrangements:\nFour circles in a square:\nvoid setupSquareCircles(out Circle c1, out Circle c2, out Circle c3, out Circle c4) {\n    float r = 0.5;\n    float d = 1.5;  // Distance from center\n    c1 = Circle(vec2(d, 0.0), r);\n    c2 = Circle(vec2(0.0, d), r);\n    c3 = Circle(vec2(-d, 0.0), r);\n    c4 = Circle(vec2(0.0, -d), r);\n}\nModify the iteration loop to check four circles instead of three!\nNested circles:\n// One large circle containing several smaller ones\nc1 = Circle(vec2(0.0, 0.0), 2.0);  // Large outer circle\nc2 = Circle(vec2(-0.5, 0.0), 0.4);  // Small inner circles\nc3 = Circle(vec2(0.5, 0.0), 0.4);\nAnimated radii:\nMake the circles pulse:\nc1.radius = 0.5 + 0.2 * sin(iTime);\nc2.radius = 0.5 + 0.2 * sin(iTime + 2.0 * 3.14159 / 3.0);\nc3.radius = 0.5 + 0.2 * sin(iTime + 4.0 * 3.14159 / 3.0);\nWatch the fractal breathe!\nAlternating inversion patterns:\nInstead of inverting through whichever circle contains the point, try a fixed cycling pattern:\n// Cycle through circles in order\nint circle_index = i % 3;\nif(circle_index == 0) {\n    p = invertCircle(p, c1.center, c1.radius);\n} else if(circle_index == 1) {\n    p = invertCircle(p, c2.center, c2.radius);\n} else {\n    p = invertCircle(p, c3.center, c3.radius);\n}\nThis creates very different patterns—more regular and less space-filling than the gasket, but with interesting self-similarity.\nChallenge problems: - Can you create a configuration that tiles the plane with circular patterns? - What about spiraling structures? - Can you make a fractal that’s asymmetric (not rotationally symmetric)? - Try combining inversion with other transformations (rotation, scaling)\nThe key is experimentation—try different setups and see what emerges!"
  },
  {
    "objectID": "OLD/lectures/day2.html#looking-ahead",
    "href": "OLD/lectures/day2.html#looking-ahead",
    "title": "1 Day 2: Complex Dynamics and Iterated Inversions",
    "section": "",
    "text": "Tomorrow we continue with geometric transformations, but move from Euclidean to hyperbolic geometry. The circle inversions you’ve learned today are actually hyperbolic isometries—transformations that preserve distances in hyperbolic space!\nWe’ll explore: - Multiple models of the hyperbolic plane (upper half-plane, Poincaré disk) - Geodesics (straight lines in hyperbolic geometry—they look like circles in our Euclidean view!) - Triangle tilings with \\((2,3,7)\\) and \\((2,3,\\infty)\\) symmetry groups - Why hyperbolic space is different: triangles with angle sum less than \\(\\pi\\), exponential growth of area\nThe same algorithmic ideas we’ve used today (iterated geometric transformations, escape-time coloring, distance-based rendering) will work in hyperbolic space. But the results will be even more intricate because hyperbolic space has “more room” than Euclidean space—allowing denser tilings and more complex fractal structures.\nMake sure you’re comfortable with: - Iteration and escape-time algorithms (we’ll use similar ideas for tiling) - Circle inversion (this becomes reflection through hyperbolic geodesics!) - Structs for organizing geometric data - Coloring strategies based on orbit behavior\nSee you tomorrow!"
  },
  {
    "objectID": "OLD/lectures/day1.html",
    "href": "OLD/lectures/day1.html",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Today we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.\nBy the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.\n\n\n\n\n\n\nNoteRoadmap for Today\n\n\n\nWe’ll build up shader programming in layers:\n\nCore concept: Shaders as parallel functions (What is a Shader?)\nSetup: Coordinate systems and GLSL syntax (First Shader, Coordinate Systems)\nBasic techniques: Conditional coloring and distance fields (Half-Planes, Distance Fields)\n\nRepetition: Grids via modular arithmetic (Grids and Repetition)\nApplication: Implicit curves (Implicit Curves)\n\nEach section builds on the previous, so if something feels unclear, it’s worth revisiting earlier material before moving forward.\n\n\n\n\n\n\n\n\nA shader is fundamentally a function \\[f: \\mathbb{R}^2 \\times \\mathbb{R} \\times \\cdots \\to [0,1]^4\\] that maps pixel coordinates \\((x,y)\\), time \\(t\\), and potentially other parameters to RGBA color values. For today, we’ll focus on the spatial dependence—thinking of the shader as a function \\(f: \\mathbb{R}^2 \\to [0,1]^4\\) that assigns a color to each point in the plane. The domain \\([0,1]^4\\) represents the red, green, blue, and alpha (transparency) channels, each normalized to the unit interval.\nHere’s the magic: modern GPUs can evaluate this function for all pixels simultaneously. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!\nThis is completely different from how you might write mathematical visualization code in, say, Python or MATLAB. There you’d have nested loops:\nfor x in range(width):\n    for y in range(height):\n        color[x,y] = f(x, y)\nWith shaders, there are no loops. You write the function \\(f\\), and the GPU just does it everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.\nThe computational model is fundamentally different: in traditional CPU programming you have sequential control flow with explicit loops, while in shader programming you express computation as a pure mathematical function that gets evaluated independently at every pixel. The GPU architecture is specifically designed for this kind of massively parallel workload—it has thousands of small processors that can each evaluate your function simultaneously. This is why a relatively modest GPU can outperform even a powerful CPU on graphics tasks by orders of magnitude.\n\n\n\n\n\n\nNoteWhy is this called a “shader”?\n\n\n\nHistorically, these programs were used for shading 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!\n\n\n\n\n\nShadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.\nShadertoy launched in 2013, created by Pol Jeremias-Vila and Íñigo Quílez (we’ll see more of Íñigo’s work throughout this week—he’s pioneered many shader techniques). Before platforms like Shadertoy, shader programming required managing the entire OpenGL or DirectX pipeline yourself—compiling shaders, linking programs, setting up vertex buffers, managing textures. It was the domain of graphics programmers, not mathematicians.\nThe genius of Shadertoy was recognizing that for many visualizations, you don’t need that complexity. Just give people a function to fill in, handle the boilerplate invisibly, and suddenly shaders become accessible to anyone. It’s democratized GPU programming in much the same way that Python notebooks democratized scientific computing—lower the barrier to entry, and a whole new community emerges.\nThe platform provides several built-in uniforms (read-only global variables that are the same for all pixels):\n\niResolution: screen resolution as a vec3 (width, height, pixel aspect ratio)\niTime: elapsed time in seconds since the shader started\niMouse: mouse position and click state as a vec4\n\nWe’ll use these throughout the week to create animated, interactive mathematical visualizations.\n\n\n\n\n\n\n\nEvery Shadertoy shader has the same entry point:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Your code here\n}\nParameters:\n\nfragCoord: the pixel coordinate we’re currently computing, as a vec2 giving the \\((x, y)\\) position\nfragColor: the output color we need to set, as a vec4 giving the \\((r, g, b, a)\\) color\n\nColors are represented in RGBA format with values in \\([0, 1]\\). So vec4(1.0, 0.0, 0.0, 1.0) represents opaque red, while vec4(0.5, 0.5, 0.5, 1.0) is middle gray.\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nThis sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on fragCoord, every pixel gets the same value. Not very exciting—but it’s a start!\n\n\n\nBefore we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:\n\n\n\n\n\n\nImportantGLSL Syntax Rules\n\n\n\nSemicolons are required. Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.\nFloating point literals: Write 1.0 not 1 for floating point values. GLSL is very picky about types—if you write 1, it’s an integer, and mixing types causes errors. Get in the habit of always writing the .0.\nVector types: GLSL has built-in types vec2, vec3, vec4 for 2D, 3D, and 4D vectors. You can construct them with:\nvec2 v = vec2(1.0, 2.0);\nvec3 w = vec3(1.0, 2.0, 3.0);\nvec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars\nSwizzling: You can access components by name: v.x, v.y or equivalently v.r, v.g (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: v.yx swaps the coordinates, v.xxx repeats the x-component three times. This is incredibly useful!\n\n\n\n\n\nLet’s make something that changes:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\nHere iTime grows continuously, sin(iTime) oscillates between \\(-1\\) and \\(1\\), and we remap this to \\([0, 1]\\) with the affine transformation \\(t \\mapsto \\frac{1}{2}(1 + t)\\). The screen now pulses between black and red!\nThis pattern—0.5 + 0.5 * sin(...)—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range \\([0,1]\\). You’ll use this so often it becomes second nature.\n\n\n\n\n\n\n\nBy default, fragCoord gives pixel coordinates with:\n\nOrigin \\((0, 0)\\) at the bottom-left\n\\(x\\) increases rightward to iResolution.x\n\\(y\\) increases upward to iResolution.y\n\nThis is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!\n\n\n\nHere’s the standard transformation we’ll use in every shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Center at origin: [-0.5, 0.5]\n    uv = uv - 0.5;\n    \n    // Scale to account for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Now uv is centered and aspect-corrected\n    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)\n    vec2 p = uv * 4.0;  \n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nLet’s understand this transformation rigorously. We’re composing four maps. Let’s write \\(w =\\) iResolution.x and \\(h =\\) iResolution.y for the width and height in pixels.\nStep 1: Normalization \\[T_1: [0, w] \\times [0, h] \\to [0,1]^2, \\quad T_1(x,y) = \\left(\\frac{x}{w}, \\frac{y}{h}\\right)\\]\nThis makes our coordinates resolution-independent—the same shader code works whether your screen is 1920×1080 or 800×600. A point that’s halfway across the screen is \\((0.5, v)\\) regardless of how many pixels wide the screen actually is.\nStep 2: Centering \\[T_2: [0,1]^2 \\to [-\\tfrac{1}{2}, \\tfrac{1}{2}]^2, \\quad T_2(u,v) = (u - \\tfrac{1}{2}, v - \\tfrac{1}{2})\\]\nNow the origin is at the center of the screen, which is much more natural for mathematical work. We can think about positive and negative coordinates, circles centered at the origin, and so on.\nStep 3: Aspect correction \\[T_3(u,v) = \\left(\\frac{w}{h} \\cdot u, v\\right)\\]\nThis is crucial! Without it, circles would appear as ellipses on non-square screens. The aspect ratio \\(w/h\\) stretches the \\(x\\)-coordinate so that one unit in \\(x\\) corresponds to the same screen distance as one unit in \\(y\\). On a typical 16:9 display (\\(w/h \\approx 1.78\\)), this means the \\(x\\)-axis spans a wider range than the \\(y\\)-axis—as it should to maintain equal scaling. A circle of radius \\(r\\) will actually appear circular on screen, not squashed.\nStep 4: Scaling to viewing window \\[T_4(u,v) = s \\cdot (u,v)\\]\nFinally, we scale by whatever factor gives us the mathematical viewing window we want. If we choose \\(s = 4\\), then on a 16:9 screen our coordinates range roughly from \\([-3.56, 3.56]\\) in \\(x\\) and \\([-2, 2]\\) in \\(y\\)—notice the \\(x\\)-range is wider to match the screen aspect ratio.\nThe composition \\(T_4 \\circ T_3 \\circ T_2 \\circ T_1\\) is our complete coordinate transformation, taking us from raw pixel coordinates to a centered, aspect-corrected mathematical coordinate system.\nFrom now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable p for “position.”\n\n\n\n\n\n\nTipThe coordinate transformation boilerplate\n\n\n\nYou’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit and you can modify it when needed.\n\n\n\n\n\nLet’s verify our coordinate system is working by coloring pixels according to their position:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\nYou should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup! This is a good debugging technique—whenever you’re unsure about your coordinates, visualize them directly as colors.\n\n\n\n\n\n\n\nGiven a linear function \\(L(x, y) = ax + by + c\\), we want to color pixels differently depending on whether \\(L(p) &lt; 0\\) or \\(L(p) \\geq 0\\). This divides the plane into two half-planes—the regions where the function is negative versus positive.\nThe line itself is the zero set: \\(\\{(x,y) : L(x,y) = 0\\}\\). This is the boundary between the two regions.\n\n\n\nGLSL provides a conditional operator (ternary operator) just like C:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\nLeft half-plane is red, right half-plane is blue. The syntax (condition) ? value_if_true : value_if_false should be familiar if you’ve programmed in C, Java, or JavaScript.\n\n\n\nGLSL also provides step(edge, x) which returns \\(0\\) if \\(x &lt; \\text{edge}\\) and \\(1\\) otherwise. The name comes from its graph—a step function in the calculus sense, jumping discontinuously from 0 to 1 at the edge value. This is useful for writing cleaner code without explicit conditionals:\nfloat s = step(0.0, p.x);  // 0 on left, 1 on right\nvec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\nHere mix(a, b, t) performs linear interpolation: \\((1-t)a + tb\\). So when s = 0 we get pure red, when s = 1 we get pure blue. The mix function is one of GLSL’s most useful tools—you’ll use it constantly for blending colors, smoothly transitioning between values, and implementing linear interpolation in all sorts of contexts.\n\n\n\n\n\n\nNoteWhy use step instead of the ternary operator?\n\n\n\nBoth work fine! The ternary operator ?: is more explicit and familiar if you know C-like languages. But step and mix are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation. For now, use whichever makes sense to you.\n\n\n\n\n\nFor a general line \\(ax + by + c = 0\\), we just evaluate the corresponding linear function:\nfloat a = 1.0, b = 1.0, c = 0.0;\nfloat L = a * p.x + b * p.y + c;\nvec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\nfragColor = vec4(color, 1.0);\nTry different values of \\(a\\), \\(b\\), and \\(c\\) to see different line orientations and positions. The line itself is where \\(L = 0\\), and we’re coloring the two sides differently. Notice that scaling \\((a,b,c)\\) by a positive constant doesn’t change the geometry—it’s the zero set that matters, not the specific values of the function away from zero.\n\n\n\n\n\n\n\nThe distance from a point \\(p = (x, y)\\) to the origin is just the usual Euclidean distance: \\[d = \\|p\\| = \\sqrt{x^2 + y^2}\\]\nIn GLSL this is built-in:\nfloat d = length(p);\nThe length() function computes the Euclidean norm of a vector. It works for vec2, vec3, vec4—whatever you need. Under the hood it’s computing the square root of the dot product of the vector with itself, but there’s no need to write that out explicitly.\n\n\n\nA circle of radius \\(r\\) centered at the origin is the set \\(\\{p : \\|p\\| &lt; r\\}\\)—just points whose distance from the origin is less than \\(r\\). So to color the inside versus outside of a circle, we just compare distances:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThat’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle. Simple, elegant, and fast—millions of distance calculations per frame, all happening in parallel.\n\n\n\nBut we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:\nfloat d = length(p);\nfloat intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\nintensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\nvec3 color = vec3(intensity);\nfragColor = vec4(color, 1.0);\nThis creates a radial gradient—bright at the center, dark at the edges. The clamp function ensures we stay within \\([0,1]\\) even if our formula would produce values outside that range. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!\nDistance fields will become increasingly important as the week progresses. On Day 4, we’ll use them as the foundation for raymarching—a technique for rendering 3D geometry without any triangles or polygons, purely by iteratively evaluating distance functions. The length(p) function we used for circles today generalizes to arbitrary implicit surfaces: $d(p) = $ “distance to the surface defined by \\(F(p) = 0\\).” It’s a beautiful connection between analysis and computer graphics.\n\n\n\nWhat if we want to draw just the boundary of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is approximately equal to the radius. Mathematically, we’re coloring the set \\(\\{p : |d(p) - r| &lt; \\epsilon\\}\\) where \\(\\epsilon\\) is a small thickness parameter:\nfloat d = length(p);\nfloat r = 1.0;\nfloat thickness = 0.05;\n\nfloat circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\nvec3 color = vec3(circle_mask);\nfragColor = vec4(color, 1.0);\nThis draws a thin white annulus around the circle. Play with the thickness parameter to see how it affects the line width!\nFor a smoother, anti-aliased edge, GLSL provides smoothstep:\nfloat circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\nThe smoothstep(a, b, x) function performs smooth Hermite interpolation. For \\(x \\in [a,b]\\), it returns \\[s(t) = 3t^2 - 2t^3 \\quad \\text{where } t = \\frac{x-a}{b-a}\\]\nThis is a cubic polynomial with \\(s(0) = 0\\), \\(s(1) = 1\\), and crucially \\(s'(0) = s'(1) = 0\\)—the zero derivatives at the endpoints mean it transitions smoothly without visible “kinks.” For \\(x &lt; a\\) it returns \\(0\\), for \\(x &gt; b\\) it returns \\(1\\).\nThe result is anti-aliasing: instead of a hard transition at a single pixel, the edge is blurred over the interval \\([a,b]\\). For circle outlines, using smoothstep(r - thickness, r + thickness, d) creates a smooth transition zone of width \\(2 \\cdot \\text{thickness}\\) around the target radius. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!\n\n\n\n\n\n\nTipAnti-aliasing in shaders\n\n\n\nThe harsh cutoffs from using &lt; or the ternary operator create jagged, pixelated edges—what computer graphics people call “aliasing” (the signal is being undersampled relative to its frequency content, creating artifacts). Functions like smoothstep give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with smoothstep for smoother results.\n\n\n\n\n\n\n\n\n\nThe modulo operation creates periodic repetition. For a period \\(T\\), the function \\(p \\mapsto (p \\bmod T) - T/2\\) maps \\(\\mathbb{R}\\) to \\([-T/2, T/2]\\) repeatedly—it “folds” the entire real line into a finite interval over and over again.\nMore precisely, recall that \\(x \\bmod T\\) is the unique value in \\([0, T)\\) satisfying \\(x \\equiv r \\pmod{T}\\)—that is, \\(x = nT + r\\) for some integer \\(n\\). Geometrically, this takes the real line and wraps it into the interval \\([0,T)\\). Subtracting \\(T/2\\) recenters this to \\([-T/2, T/2]\\).\nIn GLSL, mod(x, T) computes \\(x \\bmod T\\). This is one of the most powerful tools in shader programming!\n\n\n\nTo create a grid of repeated cells, we apply mod to our coordinates:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Now cell_p repeats every spacing units\n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis creates an infinite grid of yellow circles! The coordinate transformation cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0 ensures that cell_p is always in the range \\([-\\text{spacing}/2, \\text{spacing}/2]\\), and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.\nThink about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation.\nCompare this to how you might approach this in Python or MATLAB: you’d probably set up a nested loop over grid cells, compute the center of each cell, then draw a circle there. That’s \\(O(n^2)\\) work for an \\(n \\times n\\) grid. With shaders, it’s \\(O(1)\\) in the grid size—the cost is entirely in the number of pixels, not the number of circles. This is why shaders can render infinitely complex patterns at the same framerate as simple ones.\n\n\n\n\n\n\nNoteThe power of mod\n\n\n\nThis computational efficiency through coordinate transformations is a recurring theme in shader programming. You’ll see it again when we talk about domain repetition for fractals (Day 2), symmetry groups for hyperbolic tilings (Day 3), and space folding for raymarched scenes (Day 4). The key insight is always the same: instead of explicitly iterating over instances, transform the coordinate system so that all instances share the same local coordinates.\n\n\n\n\n\nWe can create checkerboard-like patterns by using the cell index to vary colors. To get the cell index, we divide by the spacing and floor:\nvec2 cell_id = floor(p / spacing);\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\n\nvec3 color_a = vec3(1.0, 0.0, 0.0);\nvec3 color_b = vec3(0.0, 0.0, 1.0);\nvec3 bg_color = mix(color_a, color_b, checker);\nHere floor(p / spacing) gives us integer grid indices \\((i, j)\\), and we alternate colors based on the parity of \\(i + j\\). When \\(i + j\\) is even, checker = 0 (giving us color_a), when odd, checker = 1 (giving us color_b).\nNotice the elegant separation: cell_id tells us which cell we’re in, while cell_p tells us where within that cell. This separation of global position and local coordinates is fundamental to working with repeating patterns.\n\n\n\nLet’s put it all together—a grid of circles on an alternating background:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}\nTry varying the spacing and r parameters. What happens if you make the circles larger than the cells? (They overlap across cell boundaries!) What if you use different spacing values for x and y? (You get a rectangular rather than square lattice.) This simple framework is incredibly flexible.\n\n\n\n\n\n\n\nAn implicit curve is defined by an equation \\(F(x, y) = 0\\). Points on the curve satisfy the equation exactly, while points off the curve have \\(F(x,y) \\neq 0\\). To render the curve, we compute \\(F(p)\\) for each pixel and color based on proximity to zero:\nfloat F = [some function of p.x and p.y];\nfloat thickness = 0.05;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nvec3 color = mix(background, curve_color, curve_mask);\nThis is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, transcendental curves, whatever you want. If you can write down a formula \\(F(x,y)\\), you can visualize its zero set.\n\n\n\nThe parabola \\(y = x^2\\) can be written implicitly as \\(F(x, y) = y - x^2 = 0\\):\nfloat F = p.y - p.x * p.x;\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n\nvec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\nfragColor = vec4(color, 1.0);\nYou should see a yellow parabola on a dark blue background. The curve appears wherever \\(|F(x,y)| &lt; 0.1\\)—a thin band around the zero set of \\(F\\).\nOne thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker, while in the steep regions it appears thinner. Why does this happen?\nWe’re thresholding on the value of \\(F\\), not the geometric distance to the curve. Near the vertex at \\((0,0)\\), the parabola is nearly horizontal—small changes in \\(y\\) correspond to small changes in \\(x\\), so the set \\(\\{p : |y - x^2| &lt; \\epsilon\\}\\) is a thick vertical band. But on the steep parts where \\(|x|\\) is large, the parabola is nearly vertical—now the same change in \\(y\\) corresponds to a large change in \\(x\\), so the band is thin.\nTo see this more precisely, consider the gradient: \\(\\nabla F = (-2x, 1)\\). Near the vertex this has magnitude close to \\(1\\), but for large \\(|x|\\) it has magnitude approximately \\(2|x|\\). The visual thickness is roughly inversely proportional to \\(|\\nabla F|\\)—where the gradient is small, the level sets are far apart, and where it’s large, they’re close together.\nTo get uniform thickness, we’d need the signed distance function to the curve: \\[d(p) = \\inf\\{\\|p - q\\| : F(q) = 0\\}\\]\nThen thresholding on \\(|d(p)| &lt; \\epsilon\\) gives exactly thickness \\(\\epsilon\\) everywhere. Computing exact signed distance functions is nontrivial (we’ll see techniques for this on Day 4 when we discuss raymarching), but for many applications the naive thresholding on \\(|F|\\) works fine—especially if you tune the thickness parameter appropriately or use different thickness values in different regions.\n\n\n\nWe’ve been using \\(\\|p\\| &lt; r\\) for filled circles, but we can also write the circle implicitly as \\(x^2 + y^2 - r^2 = 0\\):\nfloat r = 1.0;\nfloat F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nThis is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The dot(p, p) computes \\(x^2 + y^2\\) as a single GPU operation—more efficient than p.x * p.x + p.y * p.y and certainly cleaner than writing it out! For circles, the signed distance function and the implicit function are particularly closely related: \\(d(p) = |\\|p\\| - r|\\), so the naive implicit approach actually works quite well.\n\n\n\nLet’s look at a few more interesting curves:\nHyperbola: \\(xy = 1\\)\nfloat F = p.x * p.y - 1.0;\nEllipse: \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\)\nfloat a = 2.0, b = 1.0;\nfloat F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;\nLemniscate of Bernoulli: \\((x^2 + y^2)^2 = a^2(x^2 - y^2)\\)\nfloat a = 1.0;\nfloat r2 = dot(p, p);\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\nEach of these creates beautiful curves! Try implementing them and experimenting with different parameters.\n\n\n\n\n\n\nTipImplicit curves in your homework\n\n\n\nWhen you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation \\(F(x,y) = y - (ax^2 + bx + c)\\) and thresholding on \\(|F| &lt; \\epsilon\\). Make sure to test with various values of \\(a\\), \\(b\\), \\(c\\) to ensure your grapher is robust!\n\n\n\n\n\n\n\nToday we’ve learned the fundamental tools of shader programming:\n\nShaders as parallel functions: Every pixel evaluates \\(f(x, y, t, \\ldots) \\to \\text{color}\\) simultaneously—no loops required! The computational model is fundamentally different from sequential CPU programming.\nGLSL basics: Syntax rules (semicolons, .0 for floats), vector types (vec2, vec3, vec4), and essential built-in functions like length(), dot(), step(), and smoothstep()\nCoordinate systems: The four-step transformation (normalize, center, aspect-correct, scale) that takes us from pixel coordinates to a mathematical coordinate system suitable for visualization\nConditional coloring: Using boolean expressions, the ternary operator, and step() combined with mix() to create discrete color regions based on mathematical predicates\nDistance fields: Using length() to create circles and radial patterns—the foundation for much more complex techniques we’ll explore on Day 4 with raymarching\nModular arithmetic: Creating grids and repeating patterns with mod()—achieving infinite complexity with finite computation through coordinate transformations rather than explicit iteration\nImplicit curves: Rendering curves defined by \\(F(x, y) = 0\\) by thresholding on \\(|F|\\)—a general technique that works for any curve we can express as an equation, though we must be aware of the non-uniform thickness issue\n\nWith these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today.\n\n\n\n\n\n\nCreate a shader that draws a customizable parabola \\(y = ax^2 + bx + c\\) along with coordinate axes.\nRequirements:\n\nDefine variables a, b, c at the top of your shader (hardcoded values are fine—we’re not building a GUI yet)\nDraw the \\(x\\)-axis and \\(y\\)-axis as thin lines using the implicit line technique: \\(|y| &lt; \\epsilon\\) for the \\(x\\)-axis, \\(|x| &lt; \\epsilon\\) for the \\(y\\)-axis\nPlot the parabola \\(y = ax^2 + bx + c\\) as a thicker curve\nUse distinct colors for axes (suggest a neutral gray) and parabola (suggest something bright)\nThe visualization should work for any reasonable values of \\(a\\), \\(b\\), \\(c\\)—make sure to test edge cases!\n\nWhat it should look like: A coordinate plane with thin gray axes, and a colored curve tracing out your parabola. The entire parabola should be visible in your viewing window (you may need to adjust your scaling factor depending on your parameters).\nTest cases to verify: - \\(a=1, b=0, c=0\\) (standard parabola opening upward) - \\(a=-1, b=0, c=1\\) (downward-opening parabola shifted up) - \\(a=0.5, b=1, c=-0.5\\) (general case with all parameters nonzero) - \\(a=0, b=1, c=0\\) (degenerate case—just a line! Your code should handle this gracefully)\nSuggested approach:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Axes\n    float axis_thickness = 0.02;\n    float x_axis_mask = abs(p.y) &lt; axis_thickness ? 1.0 : 0.0;\n    float y_axis_mask = abs(p.x) &lt; axis_thickness ? 1.0 : 0.0;\n    vec3 axis_color = vec3(0.3, 0.3, 0.3);\n    \n    // Parabola: F(x,y) = y - (ax² + bx + c) = 0\n    float F = p.y - (a * p.x * p.x + b * p.x + c);\n    float curve_thickness = 0.08;\n    float parabola_mask = abs(F) &lt; curve_thickness ? 1.0 : 0.0;\n    vec3 parabola_color = vec3(1.0, 0.8, 0.0);\n    \n    // Combine (axes behind parabola)\n    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\n    color = mix(color, parabola_color, parabola_mask);\n    \n    fragColor = vec4(color, 1.0);\n}\nTry different values of \\(a\\), \\(b\\), \\(c\\) and verify your grapher works correctly! What happens with negative \\(a\\)? What about \\(b \\neq 0\\)? Make sure the axes and parabola remain visible for all parameter values you try. If the parabola goes off-screen, you may need to adjust your coordinate scaling in the setup.\n\n\n\nCreate a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build geometric intuition!\nEasier options:\n\nCircle family: Draw circles of varying radii: \\(x^2 + y^2 = r^2\\) where \\(r = 1 + 0.5\\sin(\\text{iTime})\\). Simple but mesmerizing!\nRotating ellipse: \\((x\\cos\\theta + y\\sin\\theta)^2/a^2 + (-x\\sin\\theta + y\\cos\\theta)^2/b^2 = 1\\) with \\(\\theta = \\text{iTime}\\). Watch an ellipse rotate continuously.\n\nMore challenging options:\n\nLissajous curves: Use parametric equations \\(x = A\\sin(at + \\delta)\\), \\(y = B\\sin(bt)\\) and animate \\(\\delta\\) with iTime. To render a parametric curve implicitly, you’ll need to be clever—one approach is to sample many points along the curve and draw circles at each point (we’ll learn better techniques for this later).\nCassini ovals: \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). Fix \\(c = 1\\) and vary \\(a\\) with iTime. Watch the curve transition from two separate loops to a single figure-eight-like shape as \\(a\\) passes through the critical value \\(a = c\\)!\nCubic curves: Take \\(y^2 = x^3 + ax + b\\) and vary one parameter with iTime. The topology of the curve changes dramatically as you pass through singular values—this is the beginning of the theory of elliptic curves!\n\nUse iTime creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes (these are the singularities of the family)!\n\n\n\nDesign an aesthetically pleasing tiling pattern using the mod() technique. This is your chance to be creative and make something visually striking!\nRequirements:\n\nCreate a non-trivial pattern within a fundamental domain (a single tile)\nUse mod() to repeat it across the plane\nThe pattern should tile seamlessly—edges must match up so there are no visible discontinuities at tile boundaries\n\nIdeas to get you started:\n\nGeometric patterns: Nested circles, polygons approximated by implicit curves, star shapes using angular coordinates\nColor gradients: Use cell_id to vary colors smoothly across tiles, creating large-scale gradient effects superimposed on the local pattern\nMultiple implicit curves: Combine several curves within each tile using boolean operations (intersection, union, etc.)\nSymmetry: Use abs() to create reflections within tiles—this is a simple way to get complex patterns with built-in symmetry\nDistance-based effects: Make features pulse or fade based on iTime and their position in the grid—create waves propagating across the tiling\n\nAdvanced challenge: Can you create a pattern that has different symmetries in different tiles? For example, alternate between rotational and reflectional symmetry using the checkerboard cell_id technique. Or create a pattern where the colors vary smoothly across the entire infinite tiling, creating a large-scale gradient effect that’s independent of the tile boundaries?\nThink about Islamic geometric patterns, Escher tilings, or quasiperiodic tilings (though true quasiperiodicity requires techniques beyond simple mod—we’ll see that on Day 3!). The goal is to create something mathematically interesting and visually beautiful.\n\n\n\n\n\nTomorrow we’ll use these techniques to explore complex dynamics and geometric transformations:\n\nMandelbrot and Julia sets: Using the implicit curve technique to visualize the boundary of escape sets for complex iteration\nCircle inversions: A geometric transformation that takes lines and circles to lines and circles, creating beautiful fractal-like patterns\nApollonian gasket: An infinite packing of circles constructed via repeated inversions—a stunning example of how simple geometric rules create intricate structures\n\nThe coordinate systems, distance fields, and implicit curve techniques you’ve learned today will be the foundation for everything to come. Make sure you’re comfortable with:\n\nSetting up coordinates (the standard four-step transformation from fragCoord to centered, aspect-corrected p)\nComputing distances with length() and dot products\nUsing mod() for repetition and understanding the separation of global cell_id and local cell_p\nConditionally coloring based on mathematical expressions, using both explicit conditionals and smooth interpolation with smoothstep\n\nIf any of these feel shaky, now is the time to practice! Work through the homework problems, experiment with variations, and make sure you understand not just how the code works but why the mathematics gives the visual results you see. Everything this week builds on this foundation."
  },
  {
    "objectID": "OLD/lectures/day1.html#overview",
    "href": "OLD/lectures/day1.html#overview",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Today we introduce the fundamental concept of shader programming: computing a function from pixel coordinates to colors, executed in parallel across the entire image. We’ll learn basic GLSL syntax, set up a coordinate system, and create simple geometric shapes.\nBy the end of today, you’ll be able to render implicit curves, distance-based coloring, and repeating patterns—all computed in real-time on the GPU.\n\n\n\n\n\n\nNoteRoadmap for Today\n\n\n\nWe’ll build up shader programming in layers:\n\nCore concept: Shaders as parallel functions (What is a Shader?)\nSetup: Coordinate systems and GLSL syntax (First Shader, Coordinate Systems)\nBasic techniques: Conditional coloring and distance fields (Half-Planes, Distance Fields)\n\nRepetition: Grids via modular arithmetic (Grids and Repetition)\nApplication: Implicit curves (Implicit Curves)\n\nEach section builds on the previous, so if something feels unclear, it’s worth revisiting earlier material before moving forward."
  },
  {
    "objectID": "OLD/lectures/day1.html#what-is-a-shader",
    "href": "OLD/lectures/day1.html#what-is-a-shader",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "A shader is fundamentally a function \\[f: \\mathbb{R}^2 \\times \\mathbb{R} \\times \\cdots \\to [0,1]^4\\] that maps pixel coordinates \\((x,y)\\), time \\(t\\), and potentially other parameters to RGBA color values. For today, we’ll focus on the spatial dependence—thinking of the shader as a function \\(f: \\mathbb{R}^2 \\to [0,1]^4\\) that assigns a color to each point in the plane. The domain \\([0,1]^4\\) represents the red, green, blue, and alpha (transparency) channels, each normalized to the unit interval.\nHere’s the magic: modern GPUs can evaluate this function for all pixels simultaneously. If your screen has 1920×1080 pixels, that’s over 2 million function evaluations happening in parallel, typically 60 times per second. We’re not looping over pixels one at a time—we’re computing them all at once!\nThis is completely different from how you might write mathematical visualization code in, say, Python or MATLAB. There you’d have nested loops:\nfor x in range(width):\n    for y in range(height):\n        color[x,y] = f(x, y)\nWith shaders, there are no loops. You write the function \\(f\\), and the GPU just does it everywhere at once. This parallelism is what makes shader-based visualization absurdly fast—fast enough to render complex mathematical objects in real-time, responding to your mouse, animating smoothly, all at 60fps.\nThe computational model is fundamentally different: in traditional CPU programming you have sequential control flow with explicit loops, while in shader programming you express computation as a pure mathematical function that gets evaluated independently at every pixel. The GPU architecture is specifically designed for this kind of massively parallel workload—it has thousands of small processors that can each evaluate your function simultaneously. This is why a relatively modest GPU can outperform even a powerful CPU on graphics tasks by orders of magnitude.\n\n\n\n\n\n\nNoteWhy is this called a “shader”?\n\n\n\nHistorically, these programs were used for shading 3D objects—computing how light interacts with surfaces to create realistic images. The name stuck even though nowadays we use them for all sorts of parallel computation, far beyond just lighting calculations. We’re going to use shaders to render implicit curves, fractals, hyperbolic tilings, and solve PDEs—none of which have anything to do with “shading” in the traditional sense!\n\n\n\n\n\nShadertoy is a web-based platform that handles all the annoying GPU setup for you. Normally, working with shaders requires writing a bunch of boilerplate code: setting up OpenGL contexts, compiling shader programs, managing buffers, handling the render loop—it’s a pain. Shadertoy abstracts all of that away. You write a single function, hit compile, and instantly see your results.\nShadertoy launched in 2013, created by Pol Jeremias-Vila and Íñigo Quílez (we’ll see more of Íñigo’s work throughout this week—he’s pioneered many shader techniques). Before platforms like Shadertoy, shader programming required managing the entire OpenGL or DirectX pipeline yourself—compiling shaders, linking programs, setting up vertex buffers, managing textures. It was the domain of graphics programmers, not mathematicians.\nThe genius of Shadertoy was recognizing that for many visualizations, you don’t need that complexity. Just give people a function to fill in, handle the boilerplate invisibly, and suddenly shaders become accessible to anyone. It’s democratized GPU programming in much the same way that Python notebooks democratized scientific computing—lower the barrier to entry, and a whole new community emerges.\nThe platform provides several built-in uniforms (read-only global variables that are the same for all pixels):\n\niResolution: screen resolution as a vec3 (width, height, pixel aspect ratio)\niTime: elapsed time in seconds since the shader started\niMouse: mouse position and click state as a vec4\n\nWe’ll use these throughout the week to create animated, interactive mathematical visualizations."
  },
  {
    "objectID": "OLD/lectures/day1.html#first-shader-solid-colors",
    "href": "OLD/lectures/day1.html#first-shader-solid-colors",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Every Shadertoy shader has the same entry point:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Your code here\n}\nParameters:\n\nfragCoord: the pixel coordinate we’re currently computing, as a vec2 giving the \\((x, y)\\) position\nfragColor: the output color we need to set, as a vec4 giving the \\((r, g, b, a)\\) color\n\nColors are represented in RGBA format with values in \\([0, 1]\\). So vec4(1.0, 0.0, 0.0, 1.0) represents opaque red, while vec4(0.5, 0.5, 0.5, 1.0) is middle gray.\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nThis sets every pixel to red. The function is evaluated once per pixel, but since the output doesn’t depend on fragCoord, every pixel gets the same value. Not very exciting—but it’s a start!\n\n\n\nBefore we go further, let’s talk about some essential GLSL conventions. If you’re coming from Python or MATLAB, a few things will feel different:\n\n\n\n\n\n\nImportantGLSL Syntax Rules\n\n\n\nSemicolons are required. Every statement must end with a semicolon. This is not Python! Forget one and your shader won’t compile.\nFloating point literals: Write 1.0 not 1 for floating point values. GLSL is very picky about types—if you write 1, it’s an integer, and mixing types causes errors. Get in the habit of always writing the .0.\nVector types: GLSL has built-in types vec2, vec3, vec4 for 2D, 3D, and 4D vectors. You can construct them with:\nvec2 v = vec2(1.0, 2.0);\nvec3 w = vec3(1.0, 2.0, 3.0);\nvec4 color = vec4(v, 0.0, 1.0);  // Can combine vectors and scalars\nSwizzling: You can access components by name: v.x, v.y or equivalently v.r, v.g (same thing, different naming convention—use whichever makes sense for your context). Even better, you can rearrange components: v.yx swaps the coordinates, v.xxx repeats the x-component three times. This is incredibly useful!\n\n\n\n\n\nLet’s make something that changes:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\nHere iTime grows continuously, sin(iTime) oscillates between \\(-1\\) and \\(1\\), and we remap this to \\([0, 1]\\) with the affine transformation \\(t \\mapsto \\frac{1}{2}(1 + t)\\). The screen now pulses between black and red!\nThis pattern—0.5 + 0.5 * sin(...)—comes up constantly when animating. It’s the standard way to turn a sinusoid into something that stays in the range \\([0,1]\\). You’ll use this so often it becomes second nature."
  },
  {
    "objectID": "OLD/lectures/day1.html#coordinate-systems",
    "href": "OLD/lectures/day1.html#coordinate-systems",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "By default, fragCoord gives pixel coordinates with:\n\nOrigin \\((0, 0)\\) at the bottom-left\n\\(x\\) increases rightward to iResolution.x\n\\(y\\) increases upward to iResolution.y\n\nThis is fine if you’re thinking about pixels, but for mathematical work we want something more natural: coordinates centered at the origin, normalized (not in pixels), and with aspect ratio handled correctly so that squares actually look square!\n\n\n\nHere’s the standard transformation we’ll use in every shader:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize to [0,1]\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Center at origin: [-0.5, 0.5]\n    uv = uv - 0.5;\n    \n    // Scale to account for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Now uv is centered and aspect-corrected\n    // Scale to desired viewing window (e.g., [-2, 2] on x-axis)\n    vec2 p = uv * 4.0;  \n    \n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\nLet’s understand this transformation rigorously. We’re composing four maps. Let’s write \\(w =\\) iResolution.x and \\(h =\\) iResolution.y for the width and height in pixels.\nStep 1: Normalization \\[T_1: [0, w] \\times [0, h] \\to [0,1]^2, \\quad T_1(x,y) = \\left(\\frac{x}{w}, \\frac{y}{h}\\right)\\]\nThis makes our coordinates resolution-independent—the same shader code works whether your screen is 1920×1080 or 800×600. A point that’s halfway across the screen is \\((0.5, v)\\) regardless of how many pixels wide the screen actually is.\nStep 2: Centering \\[T_2: [0,1]^2 \\to [-\\tfrac{1}{2}, \\tfrac{1}{2}]^2, \\quad T_2(u,v) = (u - \\tfrac{1}{2}, v - \\tfrac{1}{2})\\]\nNow the origin is at the center of the screen, which is much more natural for mathematical work. We can think about positive and negative coordinates, circles centered at the origin, and so on.\nStep 3: Aspect correction \\[T_3(u,v) = \\left(\\frac{w}{h} \\cdot u, v\\right)\\]\nThis is crucial! Without it, circles would appear as ellipses on non-square screens. The aspect ratio \\(w/h\\) stretches the \\(x\\)-coordinate so that one unit in \\(x\\) corresponds to the same screen distance as one unit in \\(y\\). On a typical 16:9 display (\\(w/h \\approx 1.78\\)), this means the \\(x\\)-axis spans a wider range than the \\(y\\)-axis—as it should to maintain equal scaling. A circle of radius \\(r\\) will actually appear circular on screen, not squashed.\nStep 4: Scaling to viewing window \\[T_4(u,v) = s \\cdot (u,v)\\]\nFinally, we scale by whatever factor gives us the mathematical viewing window we want. If we choose \\(s = 4\\), then on a 16:9 screen our coordinates range roughly from \\([-3.56, 3.56]\\) in \\(x\\) and \\([-2, 2]\\) in \\(y\\)—notice the \\(x\\)-range is wider to match the screen aspect ratio.\nThe composition \\(T_4 \\circ T_3 \\circ T_2 \\circ T_1\\) is our complete coordinate transformation, taking us from raw pixel coordinates to a centered, aspect-corrected mathematical coordinate system.\nFrom now on, we’ll assume this coordinate setup is done at the start of every shader, storing the result in a variable p for “position.”\n\n\n\n\n\n\nTipThe coordinate transformation boilerplate\n\n\n\nYou’ll do these first few lines in almost every shader you write. It becomes muscle memory quickly! Some people like to wrap it in a function, but for these lectures we’ll just write it out each time so the transformation is explicit and you can modify it when needed.\n\n\n\n\n\nLet’s verify our coordinate system is working by coloring pixels according to their position:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Map x coordinate to red, y to green\n    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]\n    fragColor = vec4(color_rg, 0.0, 1.0);\n}\nYou should see a smooth gradient: red increases rightward, green increases upward. If you don’t see this, something went wrong in your coordinate setup! This is a good debugging technique—whenever you’re unsure about your coordinates, visualize them directly as colors."
  },
  {
    "objectID": "OLD/lectures/day1.html#conditional-coloring-half-planes",
    "href": "OLD/lectures/day1.html#conditional-coloring-half-planes",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Given a linear function \\(L(x, y) = ax + by + c\\), we want to color pixels differently depending on whether \\(L(p) &lt; 0\\) or \\(L(p) \\geq 0\\). This divides the plane into two half-planes—the regions where the function is negative versus positive.\nThe line itself is the zero set: \\(\\{(x,y) : L(x,y) = 0\\}\\). This is the boundary between the two regions.\n\n\n\nGLSL provides a conditional operator (ternary operator) just like C:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // The function L(x,y) = x\n    \n    vec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    fragColor = vec4(color, 1.0);\n}\nLeft half-plane is red, right half-plane is blue. The syntax (condition) ? value_if_true : value_if_false should be familiar if you’ve programmed in C, Java, or JavaScript.\n\n\n\nGLSL also provides step(edge, x) which returns \\(0\\) if \\(x &lt; \\text{edge}\\) and \\(1\\) otherwise. The name comes from its graph—a step function in the calculus sense, jumping discontinuously from 0 to 1 at the edge value. This is useful for writing cleaner code without explicit conditionals:\nfloat s = step(0.0, p.x);  // 0 on left, 1 on right\nvec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);\nHere mix(a, b, t) performs linear interpolation: \\((1-t)a + tb\\). So when s = 0 we get pure red, when s = 1 we get pure blue. The mix function is one of GLSL’s most useful tools—you’ll use it constantly for blending colors, smoothly transitioning between values, and implementing linear interpolation in all sorts of contexts.\n\n\n\n\n\n\nNoteWhy use step instead of the ternary operator?\n\n\n\nBoth work fine! The ternary operator ?: is more explicit and familiar if you know C-like languages. But step and mix are more idiomatic in shader code, and they compose nicely with other functions. As you write more shaders, you’ll develop a feel for which style is clearer in each situation. For now, use whichever makes sense to you.\n\n\n\n\n\nFor a general line \\(ax + by + c = 0\\), we just evaluate the corresponding linear function:\nfloat a = 1.0, b = 1.0, c = 0.0;\nfloat L = a * p.x + b * p.y + c;\nvec3 color = (L &lt; 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\nfragColor = vec4(color, 1.0);\nTry different values of \\(a\\), \\(b\\), and \\(c\\) to see different line orientations and positions. The line itself is where \\(L = 0\\), and we’re coloring the two sides differently. Notice that scaling \\((a,b,c)\\) by a positive constant doesn’t change the geometry—it’s the zero set that matters, not the specific values of the function away from zero."
  },
  {
    "objectID": "OLD/lectures/day1.html#distance-fields-and-circles",
    "href": "OLD/lectures/day1.html#distance-fields-and-circles",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "The distance from a point \\(p = (x, y)\\) to the origin is just the usual Euclidean distance: \\[d = \\|p\\| = \\sqrt{x^2 + y^2}\\]\nIn GLSL this is built-in:\nfloat d = length(p);\nThe length() function computes the Euclidean norm of a vector. It works for vec2, vec3, vec4—whatever you need. Under the hood it’s computing the square root of the dot product of the vector with itself, but there’s no need to write that out explicitly.\n\n\n\nA circle of radius \\(r\\) centered at the origin is the set \\(\\{p : \\|p\\| &lt; r\\}\\)—just points whose distance from the origin is less than \\(r\\). So to color the inside versus outside of a circle, we just compare distances:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThat’s it! This renders a yellow disk on a dark blue background. Every pixel computes its distance to the origin and decides whether it’s inside or outside the circle. Simple, elegant, and fast—millions of distance calculations per frame, all happening in parallel.\n\n\n\nBut we don’t have to just make binary inside/outside decisions—we can use the distance value itself to create gradients and other effects. For example, we can make things fade out with distance:\nfloat d = length(p);\nfloat intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2\nintensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]\nvec3 color = vec3(intensity);\nfragColor = vec4(color, 1.0);\nThis creates a radial gradient—bright at the center, dark at the edges. The clamp function ensures we stay within \\([0,1]\\) even if our formula would produce values outside that range. Distance fields like this are incredibly versatile: you can use them for smooth transitions, glowing effects, or (as we’ll see on Day 4) as the foundation for 3D rendering!\nDistance fields will become increasingly important as the week progresses. On Day 4, we’ll use them as the foundation for raymarching—a technique for rendering 3D geometry without any triangles or polygons, purely by iteratively evaluating distance functions. The length(p) function we used for circles today generalizes to arbitrary implicit surfaces: $d(p) = $ “distance to the surface defined by \\(F(p) = 0\\).” It’s a beautiful connection between analysis and computer graphics.\n\n\n\nWhat if we want to draw just the boundary of a circle—not the filled disk, but the thin curve itself? We need to check if the distance is approximately equal to the radius. Mathematically, we’re coloring the set \\(\\{p : |d(p) - r| &lt; \\epsilon\\}\\) where \\(\\epsilon\\) is a small thickness parameter:\nfloat d = length(p);\nfloat r = 1.0;\nfloat thickness = 0.05;\n\nfloat circle_mask = abs(d - r) &lt; thickness ? 1.0 : 0.0;\nvec3 color = vec3(circle_mask);\nfragColor = vec4(color, 1.0);\nThis draws a thin white annulus around the circle. Play with the thickness parameter to see how it affects the line width!\nFor a smoother, anti-aliased edge, GLSL provides smoothstep:\nfloat circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);\nThe smoothstep(a, b, x) function performs smooth Hermite interpolation. For \\(x \\in [a,b]\\), it returns \\[s(t) = 3t^2 - 2t^3 \\quad \\text{where } t = \\frac{x-a}{b-a}\\]\nThis is a cubic polynomial with \\(s(0) = 0\\), \\(s(1) = 1\\), and crucially \\(s'(0) = s'(1) = 0\\)—the zero derivatives at the endpoints mean it transitions smoothly without visible “kinks.” For \\(x &lt; a\\) it returns \\(0\\), for \\(x &gt; b\\) it returns \\(1\\).\nThe result is anti-aliasing: instead of a hard transition at a single pixel, the edge is blurred over the interval \\([a,b]\\). For circle outlines, using smoothstep(r - thickness, r + thickness, d) creates a smooth transition zone of width \\(2 \\cdot \\text{thickness}\\) around the target radius. This eliminates jagged edges and makes the circle look much nicer—especially important when you’re creating publication-quality mathematical illustrations!\n\n\n\n\n\n\nTipAnti-aliasing in shaders\n\n\n\nThe harsh cutoffs from using &lt; or the ternary operator create jagged, pixelated edges—what computer graphics people call “aliasing” (the signal is being undersampled relative to its frequency content, creating artifacts). Functions like smoothstep give you smooth transitions over a few pixels, which is exactly what you want for anti-aliasing. We’ll use this technique constantly: anywhere you have a sharp boolean decision, consider replacing it with smoothstep for smoother results."
  },
  {
    "objectID": "OLD/lectures/day1.html#grids-and-repetition",
    "href": "OLD/lectures/day1.html#grids-and-repetition",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "The modulo operation creates periodic repetition. For a period \\(T\\), the function \\(p \\mapsto (p \\bmod T) - T/2\\) maps \\(\\mathbb{R}\\) to \\([-T/2, T/2]\\) repeatedly—it “folds” the entire real line into a finite interval over and over again.\nMore precisely, recall that \\(x \\bmod T\\) is the unique value in \\([0, T)\\) satisfying \\(x \\equiv r \\pmod{T}\\)—that is, \\(x = nT + r\\) for some integer \\(n\\). Geometrically, this takes the real line and wraps it into the interval \\([0,T)\\). Subtracting \\(T/2\\) recenters this to \\([-T/2, T/2]\\).\nIn GLSL, mod(x, T) computes \\(x \\bmod T\\). This is one of the most powerful tools in shader programming!\n\n\n\nTo create a grid of repeated cells, we apply mod to our coordinates:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Now cell_p repeats every spacing units\n    // Draw a circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    \n    vec3 color = (d &lt; r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);\n    fragColor = vec4(color, 1.0);\n}\nThis creates an infinite grid of yellow circles! The coordinate transformation cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0 ensures that cell_p is always in the range \\([-\\text{spacing}/2, \\text{spacing}/2]\\), and this range repeats forever. So every cell of the grid has identical coordinates, and therefore draws identical content.\nThink about what just happened: we created infinitely many circles with exactly the same amount of computation as drawing a single circle! There’s no loop over grid cells, no array of circle positions—the repetition comes purely from the coordinate transformation.\nCompare this to how you might approach this in Python or MATLAB: you’d probably set up a nested loop over grid cells, compute the center of each cell, then draw a circle there. That’s \\(O(n^2)\\) work for an \\(n \\times n\\) grid. With shaders, it’s \\(O(1)\\) in the grid size—the cost is entirely in the number of pixels, not the number of circles. This is why shaders can render infinitely complex patterns at the same framerate as simple ones.\n\n\n\n\n\n\nNoteThe power of mod\n\n\n\nThis computational efficiency through coordinate transformations is a recurring theme in shader programming. You’ll see it again when we talk about domain repetition for fractals (Day 2), symmetry groups for hyperbolic tilings (Day 3), and space folding for raymarched scenes (Day 4). The key insight is always the same: instead of explicitly iterating over instances, transform the coordinate system so that all instances share the same local coordinates.\n\n\n\n\n\nWe can create checkerboard-like patterns by using the cell index to vary colors. To get the cell index, we divide by the spacing and floor:\nvec2 cell_id = floor(p / spacing);\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\n\nvec3 color_a = vec3(1.0, 0.0, 0.0);\nvec3 color_b = vec3(0.0, 0.0, 1.0);\nvec3 bg_color = mix(color_a, color_b, checker);\nHere floor(p / spacing) gives us integer grid indices \\((i, j)\\), and we alternate colors based on the parity of \\(i + j\\). When \\(i + j\\) is even, checker = 0 (giving us color_a), when odd, checker = 1 (giving us color_b).\nNotice the elegant separation: cell_id tells us which cell we’re in, while cell_p tells us where within that cell. This separation of global position and local coordinates is fundamental to working with repeating patterns.\n\n\n\nLet’s put it all together—a grid of circles on an alternating background:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float spacing = 1.0;\n    vec2 cell_id = floor(p / spacing);\n    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = 0.3;\n    vec3 circle_color = vec3(1.0, 1.0, 0.0);\n    \n    vec3 color = (d &lt; r) ? circle_color : bg_color;\n    fragColor = vec4(color, 1.0);\n}\nTry varying the spacing and r parameters. What happens if you make the circles larger than the cells? (They overlap across cell boundaries!) What if you use different spacing values for x and y? (You get a rectangular rather than square lattice.) This simple framework is incredibly flexible."
  },
  {
    "objectID": "OLD/lectures/day1.html#implicit-curves",
    "href": "OLD/lectures/day1.html#implicit-curves",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "An implicit curve is defined by an equation \\(F(x, y) = 0\\). Points on the curve satisfy the equation exactly, while points off the curve have \\(F(x,y) \\neq 0\\). To render the curve, we compute \\(F(p)\\) for each pixel and color based on proximity to zero:\nfloat F = [some function of p.x and p.y];\nfloat thickness = 0.05;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nvec3 color = mix(background, curve_color, curve_mask);\nThis is a remarkably general technique! It works for any curve you can write as an implicit equation—circles, ellipses, hyperbolas, higher-degree algebraic curves, transcendental curves, whatever you want. If you can write down a formula \\(F(x,y)\\), you can visualize its zero set.\n\n\n\nThe parabola \\(y = x^2\\) can be written implicitly as \\(F(x, y) = y - x^2 = 0\\):\nfloat F = p.y - p.x * p.x;\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\n\nvec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);\nfragColor = vec4(color, 1.0);\nYou should see a yellow parabola on a dark blue background. The curve appears wherever \\(|F(x,y)| &lt; 0.1\\)—a thin band around the zero set of \\(F\\).\nOne thing to notice: the visual thickness of the curve varies! Near the vertex where the parabola is flat, the curve looks thicker, while in the steep regions it appears thinner. Why does this happen?\nWe’re thresholding on the value of \\(F\\), not the geometric distance to the curve. Near the vertex at \\((0,0)\\), the parabola is nearly horizontal—small changes in \\(y\\) correspond to small changes in \\(x\\), so the set \\(\\{p : |y - x^2| &lt; \\epsilon\\}\\) is a thick vertical band. But on the steep parts where \\(|x|\\) is large, the parabola is nearly vertical—now the same change in \\(y\\) corresponds to a large change in \\(x\\), so the band is thin.\nTo see this more precisely, consider the gradient: \\(\\nabla F = (-2x, 1)\\). Near the vertex this has magnitude close to \\(1\\), but for large \\(|x|\\) it has magnitude approximately \\(2|x|\\). The visual thickness is roughly inversely proportional to \\(|\\nabla F|\\)—where the gradient is small, the level sets are far apart, and where it’s large, they’re close together.\nTo get uniform thickness, we’d need the signed distance function to the curve: \\[d(p) = \\inf\\{\\|p - q\\| : F(q) = 0\\}\\]\nThen thresholding on \\(|d(p)| &lt; \\epsilon\\) gives exactly thickness \\(\\epsilon\\) everywhere. Computing exact signed distance functions is nontrivial (we’ll see techniques for this on Day 4 when we discuss raymarching), but for many applications the naive thresholding on \\(|F|\\) works fine—especially if you tune the thickness parameter appropriately or use different thickness values in different regions.\n\n\n\nWe’ve been using \\(\\|p\\| &lt; r\\) for filled circles, but we can also write the circle implicitly as \\(x^2 + y^2 - r^2 = 0\\):\nfloat r = 1.0;\nfloat F = dot(p, p) - r * r;  // dot(p,p) = x² + y²\nfloat thickness = 0.1;\nfloat curve_mask = abs(F) &lt; thickness ? 1.0 : 0.0;\nThis is mathematically equivalent to our earlier approach but demonstrates the general implicit curve technique. The dot(p, p) computes \\(x^2 + y^2\\) as a single GPU operation—more efficient than p.x * p.x + p.y * p.y and certainly cleaner than writing it out! For circles, the signed distance function and the implicit function are particularly closely related: \\(d(p) = |\\|p\\| - r|\\), so the naive implicit approach actually works quite well.\n\n\n\nLet’s look at a few more interesting curves:\nHyperbola: \\(xy = 1\\)\nfloat F = p.x * p.y - 1.0;\nEllipse: \\(\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1\\)\nfloat a = 2.0, b = 1.0;\nfloat F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;\nLemniscate of Bernoulli: \\((x^2 + y^2)^2 = a^2(x^2 - y^2)\\)\nfloat a = 1.0;\nfloat r2 = dot(p, p);\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\nEach of these creates beautiful curves! Try implementing them and experimenting with different parameters.\n\n\n\n\n\n\nTipImplicit curves in your homework\n\n\n\nWhen you’re implementing the parabola graphing calculator for homework, you’ll use this exact implicit curve technique. The key is setting up the equation \\(F(x,y) = y - (ax^2 + bx + c)\\) and thresholding on \\(|F| &lt; \\epsilon\\). Make sure to test with various values of \\(a\\), \\(b\\), \\(c\\) to ensure your grapher is robust!"
  },
  {
    "objectID": "OLD/lectures/day1.html#summary",
    "href": "OLD/lectures/day1.html#summary",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Today we’ve learned the fundamental tools of shader programming:\n\nShaders as parallel functions: Every pixel evaluates \\(f(x, y, t, \\ldots) \\to \\text{color}\\) simultaneously—no loops required! The computational model is fundamentally different from sequential CPU programming.\nGLSL basics: Syntax rules (semicolons, .0 for floats), vector types (vec2, vec3, vec4), and essential built-in functions like length(), dot(), step(), and smoothstep()\nCoordinate systems: The four-step transformation (normalize, center, aspect-correct, scale) that takes us from pixel coordinates to a mathematical coordinate system suitable for visualization\nConditional coloring: Using boolean expressions, the ternary operator, and step() combined with mix() to create discrete color regions based on mathematical predicates\nDistance fields: Using length() to create circles and radial patterns—the foundation for much more complex techniques we’ll explore on Day 4 with raymarching\nModular arithmetic: Creating grids and repeating patterns with mod()—achieving infinite complexity with finite computation through coordinate transformations rather than explicit iteration\nImplicit curves: Rendering curves defined by \\(F(x, y) = 0\\) by thresholding on \\(|F|\\)—a general technique that works for any curve we can express as an equation, though we must be aware of the non-uniform thickness issue\n\nWith these tools, you can already create a wide variety of mathematical visualizations! Tomorrow we’ll use these same techniques to explore complex dynamics (Mandelbrot and Julia sets) and geometric transformations (circle inversions and the Apollonian gasket). But everything builds on the foundation we’ve established today."
  },
  {
    "objectID": "OLD/lectures/day1.html#homework",
    "href": "OLD/lectures/day1.html#homework",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Create a shader that draws a customizable parabola \\(y = ax^2 + bx + c\\) along with coordinate axes.\nRequirements:\n\nDefine variables a, b, c at the top of your shader (hardcoded values are fine—we’re not building a GUI yet)\nDraw the \\(x\\)-axis and \\(y\\)-axis as thin lines using the implicit line technique: \\(|y| &lt; \\epsilon\\) for the \\(x\\)-axis, \\(|x| &lt; \\epsilon\\) for the \\(y\\)-axis\nPlot the parabola \\(y = ax^2 + bx + c\\) as a thicker curve\nUse distinct colors for axes (suggest a neutral gray) and parabola (suggest something bright)\nThe visualization should work for any reasonable values of \\(a\\), \\(b\\), \\(c\\)—make sure to test edge cases!\n\nWhat it should look like: A coordinate plane with thin gray axes, and a colored curve tracing out your parabola. The entire parabola should be visible in your viewing window (you may need to adjust your scaling factor depending on your parameters).\nTest cases to verify: - \\(a=1, b=0, c=0\\) (standard parabola opening upward) - \\(a=-1, b=0, c=1\\) (downward-opening parabola shifted up) - \\(a=0.5, b=1, c=-0.5\\) (general case with all parameters nonzero) - \\(a=0, b=1, c=0\\) (degenerate case—just a line! Your code should handle this gracefully)\nSuggested approach:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Define parameters\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Axes\n    float axis_thickness = 0.02;\n    float x_axis_mask = abs(p.y) &lt; axis_thickness ? 1.0 : 0.0;\n    float y_axis_mask = abs(p.x) &lt; axis_thickness ? 1.0 : 0.0;\n    vec3 axis_color = vec3(0.3, 0.3, 0.3);\n    \n    // Parabola: F(x,y) = y - (ax² + bx + c) = 0\n    float F = p.y - (a * p.x * p.x + b * p.x + c);\n    float curve_thickness = 0.08;\n    float parabola_mask = abs(F) &lt; curve_thickness ? 1.0 : 0.0;\n    vec3 parabola_color = vec3(1.0, 0.8, 0.0);\n    \n    // Combine (axes behind parabola)\n    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));\n    color = mix(color, parabola_color, parabola_mask);\n    \n    fragColor = vec4(color, 1.0);\n}\nTry different values of \\(a\\), \\(b\\), \\(c\\) and verify your grapher works correctly! What happens with negative \\(a\\)? What about \\(b \\neq 0\\)? Make sure the axes and parabola remain visible for all parameter values you try. If the parabola goes off-screen, you may need to adjust your coordinate scaling in the setup.\n\n\n\nCreate a shader that animates through a family of curves—watching how a curve morphs continuously as parameters change is a beautiful way to build geometric intuition!\nEasier options:\n\nCircle family: Draw circles of varying radii: \\(x^2 + y^2 = r^2\\) where \\(r = 1 + 0.5\\sin(\\text{iTime})\\). Simple but mesmerizing!\nRotating ellipse: \\((x\\cos\\theta + y\\sin\\theta)^2/a^2 + (-x\\sin\\theta + y\\cos\\theta)^2/b^2 = 1\\) with \\(\\theta = \\text{iTime}\\). Watch an ellipse rotate continuously.\n\nMore challenging options:\n\nLissajous curves: Use parametric equations \\(x = A\\sin(at + \\delta)\\), \\(y = B\\sin(bt)\\) and animate \\(\\delta\\) with iTime. To render a parametric curve implicitly, you’ll need to be clever—one approach is to sample many points along the curve and draw circles at each point (we’ll learn better techniques for this later).\nCassini ovals: \\((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\). Fix \\(c = 1\\) and vary \\(a\\) with iTime. Watch the curve transition from two separate loops to a single figure-eight-like shape as \\(a\\) passes through the critical value \\(a = c\\)!\nCubic curves: Take \\(y^2 = x^3 + ax + b\\) and vary one parameter with iTime. The topology of the curve changes dramatically as you pass through singular values—this is the beginning of the theory of elliptic curves!\n\nUse iTime creatively to create a compelling animation. The goal is to explore how continuous parameter variation produces interesting mathematical families. Bonus points if you can identify special parameter values where the curve topology changes (these are the singularities of the family)!\n\n\n\nDesign an aesthetically pleasing tiling pattern using the mod() technique. This is your chance to be creative and make something visually striking!\nRequirements:\n\nCreate a non-trivial pattern within a fundamental domain (a single tile)\nUse mod() to repeat it across the plane\nThe pattern should tile seamlessly—edges must match up so there are no visible discontinuities at tile boundaries\n\nIdeas to get you started:\n\nGeometric patterns: Nested circles, polygons approximated by implicit curves, star shapes using angular coordinates\nColor gradients: Use cell_id to vary colors smoothly across tiles, creating large-scale gradient effects superimposed on the local pattern\nMultiple implicit curves: Combine several curves within each tile using boolean operations (intersection, union, etc.)\nSymmetry: Use abs() to create reflections within tiles—this is a simple way to get complex patterns with built-in symmetry\nDistance-based effects: Make features pulse or fade based on iTime and their position in the grid—create waves propagating across the tiling\n\nAdvanced challenge: Can you create a pattern that has different symmetries in different tiles? For example, alternate between rotational and reflectional symmetry using the checkerboard cell_id technique. Or create a pattern where the colors vary smoothly across the entire infinite tiling, creating a large-scale gradient effect that’s independent of the tile boundaries?\nThink about Islamic geometric patterns, Escher tilings, or quasiperiodic tilings (though true quasiperiodicity requires techniques beyond simple mod—we’ll see that on Day 3!). The goal is to create something mathematically interesting and visually beautiful."
  },
  {
    "objectID": "OLD/lectures/day1.html#looking-ahead",
    "href": "OLD/lectures/day1.html#looking-ahead",
    "title": "1 Day 1: Introduction to Shader Programming",
    "section": "",
    "text": "Tomorrow we’ll use these techniques to explore complex dynamics and geometric transformations:\n\nMandelbrot and Julia sets: Using the implicit curve technique to visualize the boundary of escape sets for complex iteration\nCircle inversions: A geometric transformation that takes lines and circles to lines and circles, creating beautiful fractal-like patterns\nApollonian gasket: An infinite packing of circles constructed via repeated inversions—a stunning example of how simple geometric rules create intricate structures\n\nThe coordinate systems, distance fields, and implicit curve techniques you’ve learned today will be the foundation for everything to come. Make sure you’re comfortable with:\n\nSetting up coordinates (the standard four-step transformation from fragCoord to centered, aspect-corrected p)\nComputing distances with length() and dot products\nUsing mod() for repetition and understanding the separation of global cell_id and local cell_p\nConditionally coloring based on mathematical expressions, using both explicit conditionals and smooth interpolation with smoothstep\n\nIf any of these feel shaky, now is the time to practice! Work through the homework problems, experiment with variations, and make sure you understand not just how the code works but why the mathematics gives the visual results you see. Everything this week builds on this foundation."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "About\nThis mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We’ll learn to write code that “reads like mathematics” using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.\nWe’ll progress from 2D foundations (curves, tilings, fractals) to 3D rendering via raymarching. Along the way, we will implement classic examples like the Mandelbrot set, hyperbolic tessellations, and implicit surface renderers. The final day will explore either advanced geometric techniques (domain operations, 3D fractals) or temporal simulation methods (PDEs, buffer-based dynamics), depending on the group’s interests.\nNo prior experience with shaders or GLSL is required—only a strong foundation in undergraduate mathematics and willingness to work hard and experiment with code through daily homework exercises. Here are some examples of things we will make:",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "slides/day4-slides.html#how-to-render-a-scene",
    "href": "slides/day4-slides.html#how-to-render-a-scene",
    "title": "Day 4",
    "section": "How to render a scene",
    "text": "How to render a scene"
  },
  {
    "objectID": "slides/day2-slides.html#complex-numbers-in-glsl",
    "href": "slides/day2-slides.html#complex-numbers-in-glsl",
    "title": "Day 2",
    "section": "Complex Numbers in GLSL",
    "text": "Complex Numbers in GLSL\nGLSL doesn’t have native complex numbers, but vec2 works perfectly:\n// Complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(\n        a.x * b.x - a.y * b.y,\n        a.x * b.y + a.y * b.x\n    );\n}",
    "crumbs": [
      "Day 2: Dynamics",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day2-slides.html#the-mandelbrot-set",
    "href": "slides/day2-slides.html#the-mandelbrot-set",
    "title": "Day 2",
    "section": "The Mandelbrot Set",
    "text": "The Mandelbrot Set\nIterate \\(z_{n+1} = z_n^2 + c\\) and check for escape:\nint mandelbrot(vec2 c, int maxIter) {\n    vec2 z = vec2(0.0);\n    for (int i = 0; i &lt; maxIter; i++) {\n        z = cmul(z, z) + c;\n        if (dot(z, z) &gt; 4.0) return i;\n    }\n    return maxIter;\n}",
    "crumbs": [
      "Day 2: Dynamics",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day2-slides.html#mandelbrot-visualization",
    "href": "slides/day2-slides.html#mandelbrot-visualization",
    "title": "Day 2",
    "section": "Mandelbrot Visualization",
    "text": "Mandelbrot Visualization",
    "crumbs": [
      "Day 2: Dynamics",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day2-slides.html#julia-sets",
    "href": "slides/day2-slides.html#julia-sets",
    "title": "Day 2",
    "section": "Julia Sets",
    "text": "Julia Sets\nSame iteration, different perspective:\n\nMandelbrot: vary \\(c\\), start at \\(z_0 = 0\\)\nJulia: fix \\(c\\), vary starting \\(z_0\\)",
    "crumbs": [
      "Day 2: Dynamics",
      "Slides"
    ]
  },
  {
    "objectID": "slides/day2-slides.html#circle-inversion",
    "href": "slides/day2-slides.html#circle-inversion",
    "title": "Day 2",
    "section": "Circle Inversion",
    "text": "Circle Inversion\nInversion through a circle of radius \\(r\\):\n\\[z \\mapsto \\frac{r^2}{\\bar{z}}\\]",
    "crumbs": [
      "Day 2: Dynamics",
      "Slides"
    ]
  },
  {
    "objectID": "lectures/solutions/day1-solutions.html",
    "href": "lectures/solutions/day1-solutions.html",
    "title": "1 Appendix: Day 1 Homework Solutions",
    "section": "",
    "text": "(a) Green:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}\n(b) Cyan:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n}\n(c) Custom color (example: orange):\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.5, 0.2, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // changed from p.y\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // red on left\n    } else {\n        color = vec3(0.0, 0.0, 1.0);  // blue on right\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    vec2 center = vec2(1.0, 1.0);\n    float d = length(p - center);\n    float r = 0.5;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0 + 0.5 * sin(iTime);  // oscillates between 0.5 and 1.5\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float eps = 0.1;  // try 0.02, 0.05, 0.1, 0.2, 0.5\n    \n    vec3 color;\n    if (abs(d - r) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow ring\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: Students should observe that eps controls the visual thickness of the ring. Smaller values give thinner rings; larger values give thicker rings. The ring has total width \\(2\\varepsilon\\).\n\n\n\n\n\n\n\nStep 1: Draw a few rings manually\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float eps = 0.05;\n    \n    vec3 color = vec3(0.1, 0.1, 0.3);  // background\n    \n    // Draw rings at r = 0.5, 1.0, 1.5, 2.0\n    if (abs(d - 0.5) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    if (abs(d - 1.0) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    if (abs(d - 1.5) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    if (abs(d - 2.0) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nStep 2: Use a for loop\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float eps = 0.05;\n    \n    vec3 color = vec3(0.1, 0.1, 0.3);  // background\n    \n    // Draw rings at r = 0.5, 1.0, 1.5, 2.0\n    for (float r = 0.5; r &lt;= 2.0; r += 0.5) {\n        if (abs(d - r) &lt; eps) {\n            color = vec3(1.0, 1.0, 0.0);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nStep 3: Alternating colors with mod\nThe mod(x, y) function returns the remainder when x is divided by y. So mod(i, 2.0) alternates between 0 and 1 as i increases. We can use this to alternate colors:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float eps = 0.05;\n    \n    vec3 color = vec3(0.1, 0.1, 0.3);  // background\n    \n    float i = 0.0;\n    for (float r = 0.5; r &lt;= 2.0; r += 0.5) {\n        if (abs(d - r) &lt; eps) {\n            if (mod(i, 2.0) &lt; 1.0) {\n                color = vec3(1.0, 1.0, 0.0);  // yellow\n            } else {\n                color = vec3(0.0, 1.0, 1.0);  // cyan\n            }\n        }\n        i += 1.0;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 sun = normalize_coord(iMouse.zw);\n    \n    // Earth orbits the sun\n    float earth_orbit = 1.2;\n    float earth_speed = 1.0;\n    vec2 earth = sun + earth_orbit * vec2(cos(iTime * earth_speed), sin(iTime * earth_speed));\n    \n    // Moon orbits the earth (smaller orbit, faster speed)\n    float moon_orbit = 0.25;\n    float moon_speed = 3.0;\n    vec2 moon = earth + moon_orbit * vec2(cos(iTime * moon_speed), sin(iTime * moon_speed));\n    \n    // Distances\n    float d_sun = length(p - sun);\n    float d_earth = length(p - earth);\n    float d_moon = length(p - moon);\n    \n    // Draw (back to front: sun, earth, moon)\n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    if (d_sun &lt; 0.3) {\n        color = vec3(1.0, 0.9, 0.2);  // yellow sun\n    }\n    if (d_earth &lt; 0.15) {\n        color = vec3(0.2, 0.5, 1.0);  // blue earth\n    }\n    if (d_moon &lt; 0.08) {\n        color = vec3(0.8, 0.8, 0.8);  // gray moon\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nExtension: Solar system with more planets\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 sun = vec2(0.0, 0.0);  // sun at center\n    \n    // Planet parameters: orbit radius, speed, size, color\n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    // Sun\n    if (length(p - sun) &lt; 0.25) {\n        color = vec3(1.0, 0.9, 0.2);\n    }\n    \n    // Mercury\n    vec2 mercury = sun + 0.5 * vec2(cos(iTime * 4.0), sin(iTime * 4.0));\n    if (length(p - mercury) &lt; 0.05) {\n        color = vec3(0.7, 0.7, 0.7);\n    }\n    \n    // Venus\n    vec2 venus = sun + 0.8 * vec2(cos(iTime * 2.5), sin(iTime * 2.5));\n    if (length(p - venus) &lt; 0.08) {\n        color = vec3(0.9, 0.7, 0.4);\n    }\n    \n    // Earth with moon\n    vec2 earth = sun + 1.2 * vec2(cos(iTime * 1.5), sin(iTime * 1.5));\n    vec2 moon = earth + 0.15 * vec2(cos(iTime * 5.0), sin(iTime * 5.0));\n    if (length(p - earth) &lt; 0.1) {\n        color = vec3(0.2, 0.5, 1.0);\n    }\n    if (length(p - moon) &lt; 0.04) {\n        color = vec3(0.8, 0.8, 0.8);\n    }\n    \n    // Mars\n    vec2 mars = sun + 1.6 * vec2(cos(iTime * 1.0), sin(iTime * 1.0));\n    if (length(p - mars) &lt; 0.07) {\n        color = vec3(0.9, 0.4, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nExample: Cardioid \\((x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)\\)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.0;\n    float r2 = dot(p, p);\n    \n    // (x² + y² - ax)² = a²(x² + y²)\n    // F = (r² - ax)² - a²r²\n    float lhs = r2 - a * p.x;\n    float F = lhs * lhs - a * a * r2;\n    \n    // Gradient (computed analytically)\n    // dF/dx = 2(r² - ax)(2x - a) - 2a²x\n    // dF/dy = 2(r² - ax)(2y) - 2a²y\n    vec2 grad = vec2(\n        2.0 * lhs * (2.0 * p.x - a) - 2.0 * a * a * p.x,\n        2.0 * lhs * (2.0 * p.y) - 2.0 * a * a * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color;\n    if (dist &lt; 0.05) {\n        color = vec3(1.0, 0.5, 0.5);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nExample: Superellipse \\(|x/a|^n + |y/b|^n = 1\\), with exponent \\(n\\) controlled by mouse.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Map mouse x to exponent n in [0.5, 4.0]\n    // n &lt; 1: star shape, n = 1: diamond, n = 2: ellipse, n &gt; 2: rounded rectangle\n    float n = mix(0.5, 4.0, iMouse.x / iResolution.x);\n    \n    float a = 1.5;\n    float b = 1.0;\n    \n    // Superellipse: |x/a|^n + |y/b|^n = 1\n    // F = |x/a|^n + |y/b|^n - 1\n    float F = pow(abs(p.x / a), n) + pow(abs(p.y / b), n) - 1.0;\n    \n    // Numerical gradient (analytical is messy for arbitrary n)\n    float eps_grad = 0.01;\n    float Fx = pow(abs((p.x + eps_grad) / a), n) + pow(abs(p.y / b), n) - 1.0;\n    float Fy = pow(abs(p.x / a), n) + pow(abs((p.y + eps_grad) / b), n) - 1.0;\n    vec2 grad = vec2(Fx - F, Fy - F) / eps_grad;\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color;\n    if (dist &lt; 0.05) {\n        color = vec3(0.5, 1.0, 0.5);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: Dragging from left to right morphs the shape from a 4-pointed star (\\(n &lt; 1\\)) through a diamond (\\(n = 1\\)), circle (\\(n = 2\\)), to a rounded rectangle (\\(n &gt; 2\\)). This family is called the Lamé curves.\n\n\n\n\nVersion 1: One circle in front of the other\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Two circles\n    vec2 c1 = vec2(-0.6, 0.0);\n    vec2 c2 = vec2(0.6, 0.0);\n    float r = 1.0;\n    \n    float d1 = length(p - c1);\n    float d2 = length(p - c2);\n    \n    // Draw back to front: circle 1 first, then circle 2 on top\n    vec3 color = vec3(0.1, 0.1, 0.2);  // background\n    \n    if (d1 &lt; r) {\n        color = vec3(1.0, 0.3, 0.3);  // red circle 1\n    }\n    if (d2 &lt; r) {\n        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 (drawn on top)\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nVersion 2: Venn diagram with three colors\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Two circles\n    vec2 c1 = vec2(-0.6, 0.0);\n    vec2 c2 = vec2(0.6, 0.0);\n    float r = 1.0;\n    \n    float d1 = length(p - c1);\n    float d2 = length(p - c2);\n    \n    bool in1 = d1 &lt; r;\n    bool in2 = d2 &lt; r;\n    \n    vec3 color;\n    if (in1 && in2) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow intersection\n    } else if (in1) {\n        color = vec3(1.0, 0.3, 0.3);  // red circle 1 only\n    } else if (in2) {\n        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 only\n    } else {\n        color = vec3(0.1, 0.1, 0.2);  // background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Map mouse to coefficients\n    // a in [-2, 2], b in [-3, 3], c fixed at -1\n    float a = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n    float b = mix(-3.0, 3.0, iMouse.y / iResolution.y);\n    float c = -1.0;\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);  // background\n    \n    // Draw axes\n    float axis_thickness = 0.03;\n    if (abs(p.x) &lt; axis_thickness) {\n        color = vec3(0.3, 0.3, 0.3);  // y-axis\n    }\n    if (abs(p.y) &lt; axis_thickness) {\n        color = vec3(0.3, 0.3, 0.3);  // x-axis\n    }\n    \n    // Draw parabola: y = ax² + bx + c\n    // Implicit: F = y - ax² - bx - c\n    float F = p.y - a * p.x * p.x - b * p.x - c;\n    vec2 grad = vec2(-2.0 * a * p.x - b, 1.0);\n    float dist = abs(F) / length(grad);\n    \n    if (dist &lt; 0.05) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow parabola\n    }\n    \n    // Find and draw roots\n    // ax² + bx + c = 0\n    // x = (-b ± sqrt(b² - 4ac)) / 2a\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &gt;= 0.0 && abs(a) &gt; 0.01) {\n        float sqrt_disc = sqrt(discriminant);\n        float x1 = (-b + sqrt_disc) / (2.0 * a);\n        float x2 = (-b - sqrt_disc) / (2.0 * a);\n        \n        // Draw circles around roots\n        float root_radius = 0.15;\n        float root_thickness = 0.03;\n        \n        float d1 = abs(length(p - vec2(x1, 0.0)) - root_radius);\n        float d2 = abs(length(p - vec2(x2, 0.0)) - root_radius);\n        \n        if (d1 &lt; root_thickness) {\n            color = vec3(1.0, 0.3, 0.3);  // red circle at root 1\n        }\n        if (d2 &lt; root_thickness) {\n            color = vec3(0.3, 1.0, 0.3);  // green circle at root 2\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Map mouse to (a, b) parameter space\n    float a = mix(-3.0, 1.0, iMouse.x / iResolution.x);\n    float b = mix(-2.0, 2.0, iMouse.y / iResolution.y);\n    \n    // Discriminant\n    float disc = 4.0 * a * a * a + 27.0 * b * b;\n    \n    // Elliptic curve: y² = x³ + ax + b\n    float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n    vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color = vec3(0.1, 0.1, 0.2);\n    \n    if (dist &lt; 0.05) {\n        // Color based on discriminant: red for singular, yellow for smooth\n        if (abs(disc) &lt; 0.5) {\n            color = vec3(1.0, 0.2, 0.2);  // red for singular\n        } else {\n            color = vec3(1.0, 1.0, 0.0);  // yellow for smooth\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Signed distance to half-plane x &gt; 1\n    // SDF: distance is negative when inside (x &gt; 1), positive outside\n    float sdf_halfplane = 1.0 - p.x;  // negative when x &gt; 1\n    \n    // Signed distance to rectangle [-1, 1] x [-0.5, 0.5]\n    // SDF for axis-aligned box\n    vec2 box_size = vec2(1.0, 0.5);\n    vec2 d = abs(p) - box_size;\n    float sdf_rect = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    \n    // Choose which to display (toggle by uncommenting)\n    float sdf = sdf_rect;\n    // float sdf = sdf_halfplane;\n    \n    // Draw with uniform thickness boundary\n    float eps = 0.05;\n    \n    vec3 color;\n    if (sdf &lt; -eps) {\n        color = vec3(0.3, 0.3, 0.6);  // inside\n    } else if (sdf &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);  // boundary\n    } else {\n        color = vec3(0.1, 0.1, 0.2);  // outside\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: The key insight is that for the rectangle SDF: - max(d, 0.0) handles points outside the box - min(max(d.x, d.y), 0.0) handles points inside the box - No gradient correction needed because it’s a true distance function!\n\n\n\n\n// Smooth minimum function\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Two circles that orbit each other\n    float angle = iTime * 0.5;\n    vec2 c1 = 0.8 * vec2(cos(angle), sin(angle));\n    vec2 c2 = 0.8 * vec2(cos(angle + 3.14159), sin(angle + 3.14159));\n    float r = 0.8;\n    \n    float d1 = length(p - c1) - r;\n    float d2 = length(p - c2) - r;\n    \n    // Smooth blend parameter (try 0.1 to 1.0)\n    float k = 0.5;\n    float d = smin(d1, d2, k);\n    \n    vec3 color;\n    if (d &lt; 0.0) {\n        color = vec3(1.0, 0.8, 0.2);\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: The smin function smoothly blends two distance fields. The parameter k controls how “soft” the blend is—larger values create more melting together. Watch the two blobs merge and separate as they orbit.\n\n\n\n\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Mouse controls the line position\n    float line_x = mix(0.5, 2.0, iMouse.x / iResolution.x);\n    \n    // Apply circle inversion: p -&gt; p / |p|²\n    float r2 = dot(p, p);\n    vec2 p_inv = p / max(r2, 0.01);  // avoid division by zero\n    \n    vec3 color = vec3(0.1, 0.1, 0.2);\n    \n    // Draw unit circle (the circle of inversion)\n    if (abs(length(p) - 1.0) &lt; 0.02) {\n        color = vec3(0.3, 0.3, 0.4);\n    }\n    \n    // Draw the original line x = line_x (in cyan)\n    if (abs(p.x - line_x) &lt; 0.03) {\n        color = vec3(0.0, 0.8, 0.8);\n    }\n    \n    // Draw the inverted line (becomes a circle through origin!) in yellow\n    // The line x = a inverts to a circle with center (1/(2a), 0) and radius 1/(2a)\n    float inv_radius = 1.0 / (2.0 * line_x);\n    vec2 inv_center = vec2(inv_radius, 0.0);\n    if (abs(length(p - inv_center) - inv_radius) &lt; 0.03) {\n        color = vec3(1.0, 1.0, 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: Key observations: - Lines through origin map to themselves - Lines not through origin map to circles through origin (shown here) - Circles through origin map to lines - Circles not through origin map to circles - The unit circle (gray) is the “mirror” of the inversion\nDrag the mouse to move the original line (cyan) and watch its inverted image (yellow circle) change.\n\n\n\n\n\nExample solution: Truchet-style pattern\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float N = 8.0;\n    float L = (4.0 * aspect) / N;\n    \n    vec2 cell_id = floor(p / L);\n    vec2 cell_p = mod(p, L) - vec2(L/2.0, L/2.0);\n    \n    // Pseudo-random per cell (determines orientation)\n    float rand = fract(sin(dot(cell_id, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // Quarter circles in corners\n    float r = L / 2.0;\n    float thickness = 0.05;\n    \n    float d;\n    if (rand &gt; 0.5) {\n        // Arcs connecting top-left to bottom-right\n        float d1 = abs(length(cell_p - vec2(-L/2.0, L/2.0)) - r);\n        float d2 = abs(length(cell_p - vec2(L/2.0, -L/2.0)) - r);\n        d = min(d1, d2);\n    } else {\n        // Arcs connecting top-right to bottom-left\n        float d1 = abs(length(cell_p - vec2(L/2.0, L/2.0)) - r);\n        float d2 = abs(length(cell_p - vec2(-L/2.0, -L/2.0)) - r);\n        d = min(d1, d2);\n    }\n    \n    vec3 color;\n    if (d &lt; thickness) {\n        color = vec3(1.0, 0.9, 0.7);\n    } else {\n        // Subtle gradient background\n        float t = 0.5 + 0.5 * sin(length(cell_id) * 0.5 + iTime * 0.5);\n        color = mix(vec3(0.1, 0.15, 0.25), vec3(0.2, 0.1, 0.2), t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: This creates the classic Truchet tile pattern where quarter-circle arcs connect across cell boundaries to form continuous meandering paths. The pseudo-random function determines each cell’s orientation.\n\n\n\n\nFull solution with arms:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    float omega = 1.0;\n    int N = 7;\n    float scale = 1.2;\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    vec2 pos = vec2(0.0, 0.0);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (i &gt;= N) break;\n        \n        int n = 2 * i + 1;\n        float r = scale / float(n);\n        float freq = float(n) * omega;\n        float fade = 1.0 - float(i) / float(N);\n        \n        vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n        \n        // Circle\n        float d_circle = abs(length(p - pos) - r);\n        if (d_circle &lt; 0.02) {\n            color = mix(color, vec3(0.2, 0.2, 0.35), 0.5 * fade);\n        }\n        \n        // Arm\n        float d_arm = sd_segment(p, pos, next_pos);\n        if (d_arm &lt; 0.015) {\n            color = mix(color, vec3(0.3, 0.3, 0.4), 0.7 * fade);\n        }\n        \n        pos = next_pos;\n    }\n    \n    // Final point\n    float d_point = length(p - pos);\n    if (d_point &lt; 0.08) {\n        color = vec3(1.0, 1.0, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nVariation: Mouse-controlled number of terms:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    float omega = 1.0;\n    // Mouse x controls number of terms (1 to 15)\n    int N = int(mix(1.0, 15.0, iMouse.x / iResolution.x));\n    float scale = 1.2;\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    vec2 pos = vec2(0.0, 0.0);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (i &gt;= N) break;\n        \n        int n = 2 * i + 1;\n        float r = scale / float(n);\n        float freq = float(n) * omega;\n        float fade = 1.0 - float(i) / float(N);\n        \n        vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n        \n        // Circle\n        float d_circle = abs(length(p - pos) - r);\n        if (d_circle &lt; 0.02) {\n            color = mix(color, vec3(0.2, 0.2, 0.35), 0.5 * fade);\n        }\n        \n        // Arm\n        float d_arm = sd_segment(p, pos, next_pos);\n        if (d_arm &lt; 0.015) {\n            color = mix(color, vec3(0.3, 0.3, 0.4), 0.7 * fade);\n        }\n        \n        pos = next_pos;\n    }\n    \n    // Final point\n    float d_point = length(p - pos);\n    if (d_point &lt; 0.08) {\n        color = vec3(1.0, 1.0, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nVariation: Triangle wave (alternating signs, 1/n² coefficients):\n// In the loop, replace the square wave coefficients with:\nfloat sign = (i % 2 == 0) ? 1.0 : -1.0;\nfloat r = scale * sign / float(n * n);\nTeaching note: The triangle wave converges faster than the square wave because of the \\(1/n^2\\) coefficients. Students should observe smoother motion with fewer terms."
  },
  {
    "objectID": "lectures/solutions/day1-solutions.html#checkpoints",
    "href": "lectures/solutions/day1-solutions.html#checkpoints",
    "title": "1 Appendix: Day 1 Homework Solutions",
    "section": "",
    "text": "(a) Green:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}\n(b) Cyan:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n}\n(c) Custom color (example: orange):\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.5, 0.2, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.x;  // changed from p.y\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // red on left\n    } else {\n        color = vec3(0.0, 0.0, 1.0);  // blue on right\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    vec2 center = vec2(1.0, 1.0);\n    float d = length(p - center);\n    float r = 0.5;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0 + 0.5 * sin(iTime);  // oscillates between 0.5 and 1.5\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float eps = 0.1;  // try 0.02, 0.05, 0.1, 0.2, 0.5\n    \n    vec3 color;\n    if (abs(d - r) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow ring\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: Students should observe that eps controls the visual thickness of the ring. Smaller values give thinner rings; larger values give thicker rings. The ring has total width \\(2\\varepsilon\\)."
  },
  {
    "objectID": "lectures/solutions/day1-solutions.html#explorations",
    "href": "lectures/solutions/day1-solutions.html#explorations",
    "title": "1 Appendix: Day 1 Homework Solutions",
    "section": "",
    "text": "Step 1: Draw a few rings manually\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float eps = 0.05;\n    \n    vec3 color = vec3(0.1, 0.1, 0.3);  // background\n    \n    // Draw rings at r = 0.5, 1.0, 1.5, 2.0\n    if (abs(d - 0.5) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    if (abs(d - 1.0) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    if (abs(d - 1.5) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    if (abs(d - 2.0) &lt; eps) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\nStep 2: Use a for loop\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float eps = 0.05;\n    \n    vec3 color = vec3(0.1, 0.1, 0.3);  // background\n    \n    // Draw rings at r = 0.5, 1.0, 1.5, 2.0\n    for (float r = 0.5; r &lt;= 2.0; r += 0.5) {\n        if (abs(d - r) &lt; eps) {\n            color = vec3(1.0, 1.0, 0.0);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nStep 3: Alternating colors with mod\nThe mod(x, y) function returns the remainder when x is divided by y. So mod(i, 2.0) alternates between 0 and 1 as i increases. We can use this to alternate colors:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float eps = 0.05;\n    \n    vec3 color = vec3(0.1, 0.1, 0.3);  // background\n    \n    float i = 0.0;\n    for (float r = 0.5; r &lt;= 2.0; r += 0.5) {\n        if (abs(d - r) &lt; eps) {\n            if (mod(i, 2.0) &lt; 1.0) {\n                color = vec3(1.0, 1.0, 0.0);  // yellow\n            } else {\n                color = vec3(0.0, 1.0, 1.0);  // cyan\n            }\n        }\n        i += 1.0;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 sun = normalize_coord(iMouse.zw);\n    \n    // Earth orbits the sun\n    float earth_orbit = 1.2;\n    float earth_speed = 1.0;\n    vec2 earth = sun + earth_orbit * vec2(cos(iTime * earth_speed), sin(iTime * earth_speed));\n    \n    // Moon orbits the earth (smaller orbit, faster speed)\n    float moon_orbit = 0.25;\n    float moon_speed = 3.0;\n    vec2 moon = earth + moon_orbit * vec2(cos(iTime * moon_speed), sin(iTime * moon_speed));\n    \n    // Distances\n    float d_sun = length(p - sun);\n    float d_earth = length(p - earth);\n    float d_moon = length(p - moon);\n    \n    // Draw (back to front: sun, earth, moon)\n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    if (d_sun &lt; 0.3) {\n        color = vec3(1.0, 0.9, 0.2);  // yellow sun\n    }\n    if (d_earth &lt; 0.15) {\n        color = vec3(0.2, 0.5, 1.0);  // blue earth\n    }\n    if (d_moon &lt; 0.08) {\n        color = vec3(0.8, 0.8, 0.8);  // gray moon\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nExtension: Solar system with more planets\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 sun = vec2(0.0, 0.0);  // sun at center\n    \n    // Planet parameters: orbit radius, speed, size, color\n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    // Sun\n    if (length(p - sun) &lt; 0.25) {\n        color = vec3(1.0, 0.9, 0.2);\n    }\n    \n    // Mercury\n    vec2 mercury = sun + 0.5 * vec2(cos(iTime * 4.0), sin(iTime * 4.0));\n    if (length(p - mercury) &lt; 0.05) {\n        color = vec3(0.7, 0.7, 0.7);\n    }\n    \n    // Venus\n    vec2 venus = sun + 0.8 * vec2(cos(iTime * 2.5), sin(iTime * 2.5));\n    if (length(p - venus) &lt; 0.08) {\n        color = vec3(0.9, 0.7, 0.4);\n    }\n    \n    // Earth with moon\n    vec2 earth = sun + 1.2 * vec2(cos(iTime * 1.5), sin(iTime * 1.5));\n    vec2 moon = earth + 0.15 * vec2(cos(iTime * 5.0), sin(iTime * 5.0));\n    if (length(p - earth) &lt; 0.1) {\n        color = vec3(0.2, 0.5, 1.0);\n    }\n    if (length(p - moon) &lt; 0.04) {\n        color = vec3(0.8, 0.8, 0.8);\n    }\n    \n    // Mars\n    vec2 mars = sun + 1.6 * vec2(cos(iTime * 1.0), sin(iTime * 1.0));\n    if (length(p - mars) &lt; 0.07) {\n        color = vec3(0.9, 0.4, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nExample: Cardioid \\((x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)\\)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.0;\n    float r2 = dot(p, p);\n    \n    // (x² + y² - ax)² = a²(x² + y²)\n    // F = (r² - ax)² - a²r²\n    float lhs = r2 - a * p.x;\n    float F = lhs * lhs - a * a * r2;\n    \n    // Gradient (computed analytically)\n    // dF/dx = 2(r² - ax)(2x - a) - 2a²x\n    // dF/dy = 2(r² - ax)(2y) - 2a²y\n    vec2 grad = vec2(\n        2.0 * lhs * (2.0 * p.x - a) - 2.0 * a * a * p.x,\n        2.0 * lhs * (2.0 * p.y) - 2.0 * a * a * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color;\n    if (dist &lt; 0.05) {\n        color = vec3(1.0, 0.5, 0.5);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nExample: Superellipse \\(|x/a|^n + |y/b|^n = 1\\), with exponent \\(n\\) controlled by mouse.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Map mouse x to exponent n in [0.5, 4.0]\n    // n &lt; 1: star shape, n = 1: diamond, n = 2: ellipse, n &gt; 2: rounded rectangle\n    float n = mix(0.5, 4.0, iMouse.x / iResolution.x);\n    \n    float a = 1.5;\n    float b = 1.0;\n    \n    // Superellipse: |x/a|^n + |y/b|^n = 1\n    // F = |x/a|^n + |y/b|^n - 1\n    float F = pow(abs(p.x / a), n) + pow(abs(p.y / b), n) - 1.0;\n    \n    // Numerical gradient (analytical is messy for arbitrary n)\n    float eps_grad = 0.01;\n    float Fx = pow(abs((p.x + eps_grad) / a), n) + pow(abs(p.y / b), n) - 1.0;\n    float Fy = pow(abs(p.x / a), n) + pow(abs((p.y + eps_grad) / b), n) - 1.0;\n    vec2 grad = vec2(Fx - F, Fy - F) / eps_grad;\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color;\n    if (dist &lt; 0.05) {\n        color = vec3(0.5, 1.0, 0.5);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: Dragging from left to right morphs the shape from a 4-pointed star (\\(n &lt; 1\\)) through a diamond (\\(n = 1\\)), circle (\\(n = 2\\)), to a rounded rectangle (\\(n &gt; 2\\)). This family is called the Lamé curves.\n\n\n\n\nVersion 1: One circle in front of the other\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Two circles\n    vec2 c1 = vec2(-0.6, 0.0);\n    vec2 c2 = vec2(0.6, 0.0);\n    float r = 1.0;\n    \n    float d1 = length(p - c1);\n    float d2 = length(p - c2);\n    \n    // Draw back to front: circle 1 first, then circle 2 on top\n    vec3 color = vec3(0.1, 0.1, 0.2);  // background\n    \n    if (d1 &lt; r) {\n        color = vec3(1.0, 0.3, 0.3);  // red circle 1\n    }\n    if (d2 &lt; r) {\n        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 (drawn on top)\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nVersion 2: Venn diagram with three colors\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Two circles\n    vec2 c1 = vec2(-0.6, 0.0);\n    vec2 c2 = vec2(0.6, 0.0);\n    float r = 1.0;\n    \n    float d1 = length(p - c1);\n    float d2 = length(p - c2);\n    \n    bool in1 = d1 &lt; r;\n    bool in2 = d2 &lt; r;\n    \n    vec3 color;\n    if (in1 && in2) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow intersection\n    } else if (in1) {\n        color = vec3(1.0, 0.3, 0.3);  // red circle 1 only\n    } else if (in2) {\n        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 only\n    } else {\n        color = vec3(0.1, 0.1, 0.2);  // background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day1-solutions.html#challenges",
    "href": "lectures/solutions/day1-solutions.html#challenges",
    "title": "1 Appendix: Day 1 Homework Solutions",
    "section": "",
    "text": "vec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Map mouse to coefficients\n    // a in [-2, 2], b in [-3, 3], c fixed at -1\n    float a = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n    float b = mix(-3.0, 3.0, iMouse.y / iResolution.y);\n    float c = -1.0;\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);  // background\n    \n    // Draw axes\n    float axis_thickness = 0.03;\n    if (abs(p.x) &lt; axis_thickness) {\n        color = vec3(0.3, 0.3, 0.3);  // y-axis\n    }\n    if (abs(p.y) &lt; axis_thickness) {\n        color = vec3(0.3, 0.3, 0.3);  // x-axis\n    }\n    \n    // Draw parabola: y = ax² + bx + c\n    // Implicit: F = y - ax² - bx - c\n    float F = p.y - a * p.x * p.x - b * p.x - c;\n    vec2 grad = vec2(-2.0 * a * p.x - b, 1.0);\n    float dist = abs(F) / length(grad);\n    \n    if (dist &lt; 0.05) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow parabola\n    }\n    \n    // Find and draw roots\n    // ax² + bx + c = 0\n    // x = (-b ± sqrt(b² - 4ac)) / 2a\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant &gt;= 0.0 && abs(a) &gt; 0.01) {\n        float sqrt_disc = sqrt(discriminant);\n        float x1 = (-b + sqrt_disc) / (2.0 * a);\n        float x2 = (-b - sqrt_disc) / (2.0 * a);\n        \n        // Draw circles around roots\n        float root_radius = 0.15;\n        float root_thickness = 0.03;\n        \n        float d1 = abs(length(p - vec2(x1, 0.0)) - root_radius);\n        float d2 = abs(length(p - vec2(x2, 0.0)) - root_radius);\n        \n        if (d1 &lt; root_thickness) {\n            color = vec3(1.0, 0.3, 0.3);  // red circle at root 1\n        }\n        if (d2 &lt; root_thickness) {\n            color = vec3(0.3, 1.0, 0.3);  // green circle at root 2\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Map mouse to (a, b) parameter space\n    float a = mix(-3.0, 1.0, iMouse.x / iResolution.x);\n    float b = mix(-2.0, 2.0, iMouse.y / iResolution.y);\n    \n    // Discriminant\n    float disc = 4.0 * a * a * a + 27.0 * b * b;\n    \n    // Elliptic curve: y² = x³ + ax + b\n    float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n    vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color = vec3(0.1, 0.1, 0.2);\n    \n    if (dist &lt; 0.05) {\n        // Color based on discriminant: red for singular, yellow for smooth\n        if (abs(disc) &lt; 0.5) {\n            color = vec3(1.0, 0.2, 0.2);  // red for singular\n        } else {\n            color = vec3(1.0, 1.0, 0.0);  // yellow for smooth\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Signed distance to half-plane x &gt; 1\n    // SDF: distance is negative when inside (x &gt; 1), positive outside\n    float sdf_halfplane = 1.0 - p.x;  // negative when x &gt; 1\n    \n    // Signed distance to rectangle [-1, 1] x [-0.5, 0.5]\n    // SDF for axis-aligned box\n    vec2 box_size = vec2(1.0, 0.5);\n    vec2 d = abs(p) - box_size;\n    float sdf_rect = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    \n    // Choose which to display (toggle by uncommenting)\n    float sdf = sdf_rect;\n    // float sdf = sdf_halfplane;\n    \n    // Draw with uniform thickness boundary\n    float eps = 0.05;\n    \n    vec3 color;\n    if (sdf &lt; -eps) {\n        color = vec3(0.3, 0.3, 0.6);  // inside\n    } else if (sdf &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);  // boundary\n    } else {\n        color = vec3(0.1, 0.1, 0.2);  // outside\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: The key insight is that for the rectangle SDF: - max(d, 0.0) handles points outside the box - min(max(d.x, d.y), 0.0) handles points inside the box - No gradient correction needed because it’s a true distance function!\n\n\n\n\n// Smooth minimum function\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Two circles that orbit each other\n    float angle = iTime * 0.5;\n    vec2 c1 = 0.8 * vec2(cos(angle), sin(angle));\n    vec2 c2 = 0.8 * vec2(cos(angle + 3.14159), sin(angle + 3.14159));\n    float r = 0.8;\n    \n    float d1 = length(p - c1) - r;\n    float d2 = length(p - c2) - r;\n    \n    // Smooth blend parameter (try 0.1 to 1.0)\n    float k = 0.5;\n    float d = smin(d1, d2, k);\n    \n    vec3 color;\n    if (d &lt; 0.0) {\n        color = vec3(1.0, 0.8, 0.2);\n    } else {\n        color = vec3(0.1, 0.1, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: The smin function smoothly blends two distance fields. The parameter k controls how “soft” the blend is—larger values create more melting together. Watch the two blobs merge and separate as they orbit.\n\n\n\n\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Mouse controls the line position\n    float line_x = mix(0.5, 2.0, iMouse.x / iResolution.x);\n    \n    // Apply circle inversion: p -&gt; p / |p|²\n    float r2 = dot(p, p);\n    vec2 p_inv = p / max(r2, 0.01);  // avoid division by zero\n    \n    vec3 color = vec3(0.1, 0.1, 0.2);\n    \n    // Draw unit circle (the circle of inversion)\n    if (abs(length(p) - 1.0) &lt; 0.02) {\n        color = vec3(0.3, 0.3, 0.4);\n    }\n    \n    // Draw the original line x = line_x (in cyan)\n    if (abs(p.x - line_x) &lt; 0.03) {\n        color = vec3(0.0, 0.8, 0.8);\n    }\n    \n    // Draw the inverted line (becomes a circle through origin!) in yellow\n    // The line x = a inverts to a circle with center (1/(2a), 0) and radius 1/(2a)\n    float inv_radius = 1.0 / (2.0 * line_x);\n    vec2 inv_center = vec2(inv_radius, 0.0);\n    if (abs(length(p - inv_center) - inv_radius) &lt; 0.03) {\n        color = vec3(1.0, 1.0, 0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: Key observations: - Lines through origin map to themselves - Lines not through origin map to circles through origin (shown here) - Circles through origin map to lines - Circles not through origin map to circles - The unit circle (gray) is the “mirror” of the inversion\nDrag the mouse to move the original line (cyan) and watch its inverted image (yellow circle) change."
  },
  {
    "objectID": "lectures/solutions/day1-solutions.html#project-grid-patterns",
    "href": "lectures/solutions/day1-solutions.html#project-grid-patterns",
    "title": "1 Appendix: Day 1 Homework Solutions",
    "section": "",
    "text": "Example solution: Truchet-style pattern\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float N = 8.0;\n    float L = (4.0 * aspect) / N;\n    \n    vec2 cell_id = floor(p / L);\n    vec2 cell_p = mod(p, L) - vec2(L/2.0, L/2.0);\n    \n    // Pseudo-random per cell (determines orientation)\n    float rand = fract(sin(dot(cell_id, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // Quarter circles in corners\n    float r = L / 2.0;\n    float thickness = 0.05;\n    \n    float d;\n    if (rand &gt; 0.5) {\n        // Arcs connecting top-left to bottom-right\n        float d1 = abs(length(cell_p - vec2(-L/2.0, L/2.0)) - r);\n        float d2 = abs(length(cell_p - vec2(L/2.0, -L/2.0)) - r);\n        d = min(d1, d2);\n    } else {\n        // Arcs connecting top-right to bottom-left\n        float d1 = abs(length(cell_p - vec2(L/2.0, L/2.0)) - r);\n        float d2 = abs(length(cell_p - vec2(-L/2.0, -L/2.0)) - r);\n        d = min(d1, d2);\n    }\n    \n    vec3 color;\n    if (d &lt; thickness) {\n        color = vec3(1.0, 0.9, 0.7);\n    } else {\n        // Subtle gradient background\n        float t = 0.5 + 0.5 * sin(length(cell_id) * 0.5 + iTime * 0.5);\n        color = mix(vec3(0.1, 0.15, 0.25), vec3(0.2, 0.1, 0.2), t);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nTeaching note: This creates the classic Truchet tile pattern where quarter-circle arcs connect across cell boundaries to form continuous meandering paths. The pseudo-random function determines each cell’s orientation."
  },
  {
    "objectID": "lectures/solutions/day1-solutions.html#project-fourier-epicycles",
    "href": "lectures/solutions/day1-solutions.html#project-fourier-epicycles",
    "title": "1 Appendix: Day 1 Homework Solutions",
    "section": "",
    "text": "Full solution with arms:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    float omega = 1.0;\n    int N = 7;\n    float scale = 1.2;\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    vec2 pos = vec2(0.0, 0.0);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (i &gt;= N) break;\n        \n        int n = 2 * i + 1;\n        float r = scale / float(n);\n        float freq = float(n) * omega;\n        float fade = 1.0 - float(i) / float(N);\n        \n        vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n        \n        // Circle\n        float d_circle = abs(length(p - pos) - r);\n        if (d_circle &lt; 0.02) {\n            color = mix(color, vec3(0.2, 0.2, 0.35), 0.5 * fade);\n        }\n        \n        // Arm\n        float d_arm = sd_segment(p, pos, next_pos);\n        if (d_arm &lt; 0.015) {\n            color = mix(color, vec3(0.3, 0.3, 0.4), 0.7 * fade);\n        }\n        \n        pos = next_pos;\n    }\n    \n    // Final point\n    float d_point = length(p - pos);\n    if (d_point &lt; 0.08) {\n        color = vec3(1.0, 1.0, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nVariation: Mouse-controlled number of terms:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    float omega = 1.0;\n    // Mouse x controls number of terms (1 to 15)\n    int N = int(mix(1.0, 15.0, iMouse.x / iResolution.x));\n    float scale = 1.2;\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    vec2 pos = vec2(0.0, 0.0);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (i &gt;= N) break;\n        \n        int n = 2 * i + 1;\n        float r = scale / float(n);\n        float freq = float(n) * omega;\n        float fade = 1.0 - float(i) / float(N);\n        \n        vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n        \n        // Circle\n        float d_circle = abs(length(p - pos) - r);\n        if (d_circle &lt; 0.02) {\n            color = mix(color, vec3(0.2, 0.2, 0.35), 0.5 * fade);\n        }\n        \n        // Arm\n        float d_arm = sd_segment(p, pos, next_pos);\n        if (d_arm &lt; 0.015) {\n            color = mix(color, vec3(0.3, 0.3, 0.4), 0.7 * fade);\n        }\n        \n        pos = next_pos;\n    }\n    \n    // Final point\n    float d_point = length(p - pos);\n    if (d_point &lt; 0.08) {\n        color = vec3(1.0, 1.0, 0.2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\nVariation: Triangle wave (alternating signs, 1/n² coefficients):\n// In the loop, replace the square wave coefficients with:\nfloat sign = (i % 2 == 0) ? 1.0 : -1.0;\nfloat r = scale * sign / float(n * n);\nTeaching note: The triangle wave converges faster than the square wave because of the \\(1/n^2\\) coefficients. Students should observe smoother motion with fewer terms."
  },
  {
    "objectID": "lectures/solutions/day3-solutions.html",
    "href": "lectures/solutions/day3-solutions.html",
    "title": "1 Day 3: Exercise Solutions",
    "section": "",
    "text": "Complete shader solutions for the Day 3 exercises.\n\n\n\n\n\nDraw hyperbolic circles of radius 0.1 and 0.5 around the mouse position.\nfloat hypDist(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float num = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + num / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // acosh\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    // Get mouse position in same coordinates\n    vec2 center = normalize_coord(iMouse.xy);\n    \n    // Default center when not clicking\n    if (iMouse.z &lt; 0.5) {\n        center = vec2(2.0, 2.0);\n    }\n    \n    // Hyperbolic distance from center\n    float d = hypDist(z, center);\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw circle at radius 0.1\n    if (abs(d - 0.1) &lt; 0.02) {\n        color = vec3(0.3, 0.7, 0.9);\n    }\n    \n    // Draw circle at radius 0.5\n    if (abs(d - 0.5) &lt; 0.02) {\n        color = vec3(0.9, 0.5, 0.3);\n    }\n    \n    // Mark center\n    if (length(z - center) &lt; 0.03) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken below real axis\n    if (z.y &lt; 0.01) {\n        color = vec3(0.05);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nAdd edge drawing using hyperbolic distance to geodesics.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceVert h) {\n    z.x -= h.x;\n    return acosh(length(z) / z.y);\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    return acosh(length(w) / w.y);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0 - vec2(0.75, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    vec2 z_orig = z;\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Draw edges using hyperbolic distance\n    float edgeThickness = 0.03;\n    float d1 = distToGeodesic(z, left);\n    float d2 = distToGeodesic(z, right);\n    float d3 = distToGeodesic(z, bottom);\n    \n    if (d1 &lt; edgeThickness || d2 &lt; edgeThickness || d3 &lt; edgeThickness) {\n        color = vec3(1.0);\n    }\n    \n    if (z_orig.y &lt; 0.01) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nDrawing vertices and edges, in both UHP and Poincaré disk.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceVert h) {\n    z.x -= h.x;\n    return acosh(length(z) / z.y);\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    return acosh(length(w) / w.y);\n}\n\nfloat hypDist(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float num = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + num / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Draw edges\n    float edgeThickness = 0.02;\n    float d1 = distToGeodesic(z, left);\n    float d2 = distToGeodesic(z, right);\n    float d3 = distToGeodesic(z, bottom);\n    \n    if (d1 &lt; edgeThickness || d2 &lt; edgeThickness || d3 &lt; edgeThickness) {\n        color = vec3(0.2);\n    }\n    \n    // Draw vertices\n    vec2 v1 = vec2(0.0, 1.0);                    // i (angle pi/2)\n    vec2 v2 = vec2(0.5, 0.866);                  // 1/2 + sqrt(3)/2 * i (angle pi/3)\n    \n    float vertexRadius = 0.08;\n    if (hypDist(z, v1) &lt; vertexRadius) {\n        color = vec3(0.9, 0.3, 0.3);\n    }\n    if (hypDist(z, v2) &lt; vertexRadius) {\n        color = vec3(0.3, 0.9, 0.3);\n    }\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDisplay the tiling in the Klein disk where geodesics are straight lines.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\n// Klein disk to Poincaré disk\nvec2 kleinToPoincare(vec2 k) {\n    float k_mag2 = dot(k, k);\n    float denom = 1.0 + sqrt(1.0 - k_mag2);\n    return k / denom;\n}\n\n// Poincaré disk to upper half-plane\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 k = normalize_coord(fragCoord);  // Klein disk coordinates\n    \n    // Convert Klein -&gt; Poincaré -&gt; UHP\n    vec2 w = kleinToPoincare(k);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(k) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\nWarningSolution TODO\n\n\n\nThe band model solution needs to be written. The conversion uses ctanh to map from band to Poincaré disk, then the standard disk-to-UHP conversion.\n\n\n\n\n\n\nUse mouse to translate and scale the tiling.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\n// Apply Möbius transformation (a*z + b) / (c*z + d) with real coefficients\nvec2 mobius(vec2 z, float a, float b, float c, float d) {\n    vec2 num = vec2(a * z.x + b, a * z.y);\n    vec2 denom = vec2(c * z.x + d, c * z.y);\n    return cdiv(num, denom);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    // Get mouse position for transformation parameters\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (iMouse.z &lt; 0.5) {\n        mouse = vec2(0.5, 0.5);\n    }\n    \n    // Horizontal translation: z -&gt; z + t (positive t moves tiling left, so add t)\n    float t = (mouse.x - 0.5) * 4.0;\n    z.x += t;\n    \n    // Scaling: z -&gt; k*z (k &gt; 1 zooms in, so divide)\n    float k = exp((mouse.y - 0.5) * 2.0);\n    z /= k;\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nSmoothly morph between upper half-plane and Poincaré disk.\nThe key insight is to interpolate at the level of matrices. The Cayley transform \\(C(z) = \\frac{z-i}{z+i}\\) has matrix \\(M = \\begin{pmatrix} 1 & -i \\\\ 1 & i \\end{pmatrix}\\), and identity has matrix \\(I\\). The linear interpolation \\(M_t = (1-t)I + tM\\) has determinant \\(1 - t + it \\neq 0\\) for \\(t \\in [0,1]\\), so each \\(M_t\\) is invertible.\nThis gives us: \\(f_t(z) = \\frac{z - it}{tz + (1-t+it)}\\)\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\n// Interpolated Cayley transform: f_t(z) = (z - it) / (tz + (1-t+it))\nvec2 partialCayley(vec2 z, float t) {\n    vec2 num = z - vec2(0.0, t);                    // z - it\n    vec2 denom = t * z + vec2(1.0 - t, t);          // tz + (1-t+it)\n    return cdiv(num, denom);\n}\n\n// Inverse of partial Cayley: solve w = (z - it) / (tz + (1-t+it)) for z\n// w(tz + (1-t+it)) = z - it\n// wtz + w(1-t+it) = z - it\n// wtz - z = -it - w(1-t+it)\n// z(wt - 1) = -it - w(1-t+it)\n// z = (it + w(1-t+it)) / (1 - wt)\nvec2 invPartialCayley(vec2 w, float t) {\n    vec2 it = vec2(0.0, t);\n    vec2 coef = vec2(1.0 - t, t);                   // (1-t+it)\n    vec2 num = it + cmul(w, coef);                  // it + w(1-t+it)\n    vec2 denom = vec2(1.0, 0.0) - t * w;            // 1 - wt\n    return cdiv(num, denom);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = 0.5 + 0.5 * sin(iTime * 0.5);\n    \n    // Screen shows a disk-like region\n    vec2 w = normalize_coord(fragCoord);\n    \n    // Apply inverse partial Cayley to get UHP coordinates\n    vec2 z = invPartialCayley(w, t);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Always black in lower half-plane (z.y &lt; 0 in UHP)\n    if (z.y &lt; 0.0) {\n        color = vec3(0.05);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDraw geodesics connecting centers of adjacent triangles.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat hypDist(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float num = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + num / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Triangle incenter (approximate center of fundamental domain)\n    vec2 incenter = vec2(0.25, 1.1);\n    \n    // Draw dual edges: geodesic segments from incenter perpendicular to each edge\n    // These are the only three segments we draw; reflections tile the rest\n    \n    // Edge 1: perpendicular to left edge (x=0)\n    // The perpendicular geodesic from incenter to x=0 is a semicircle \n    // centered at origin passing through incenter\n    // It hits x=0 at y = |incenter| (the radius)\n    float r1 = length(incenter);\n    float d1 = abs(length(z) - r1);\n    // Only draw between incenter and the edge (y &lt;= incenter.y, x near 0 side)\n    bool onSeg1 = (z.y &lt;= r1) && (z.x &gt;= 0.0) && (z.x &lt;= incenter.x);\n    \n    // Edge 2: perpendicular to right edge (x=0.5)\n    // Semicircle centered at (0.5, 0) passing through incenter\n    vec2 c2 = vec2(0.5, 0.0);\n    float r2 = length(incenter - c2);\n    float d2 = abs(length(z - c2) - r2);\n    // Only draw between incenter and x=0.5\n    bool onSeg2 = (z.x &gt;= incenter.x) && (z.x &lt;= 0.5);\n    \n    // Edge 3: perpendicular to bottom (unit circle centered at origin)\n    // The perpendicular from incenter to unit circle is a vertical line x = incenter.x\n    // (since unit circle is centered at origin, radial lines are perpendicular)\n    float d3 = abs(z.x - incenter.x);\n    // Only draw from incenter down to unit circle (y between 1 and incenter.y)\n    float yOnCircle = sqrt(1.0 - incenter.x * incenter.x);\n    bool onSeg3 = (z.y &gt;= yOnCircle) && (z.y &lt;= incenter.y);\n    \n    // Draw dual edges with hyperbolic-ish thickness\n    float thickness = 0.02;\n    if ((d1 &lt; thickness && onSeg1) || \n        (d2 &lt; thickness && onSeg2) || \n        (d3 &lt; thickness && onSeg3)) {\n        color = vec3(0.8, 0.2, 0.2);\n    }\n    \n    // Draw dual vertex (incenter)\n    float dv = hypDist(z, incenter);\n    if (dv &lt; 0.05) {\n        color = vec3(0.2, 0.2, 0.8);\n    }\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDraw only the circular geodesic edge.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    return acosh(length(w) / w.y);\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Draw ONLY the circular edge\n    float d = distToGeodesic(z, bottom);\n    if (d &lt; 0.03) {\n        color = vec3(1.0);\n    }\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\nThis is a more substantial project. Here’s a starting point for the (2,3,7) tiling—a compact hyperbolic triangle with all finite vertices.\nThe key challenge is computing the geodesic positions from the angle constraints. For (2,3,7): - Angle at vertex A: π/2 - Angle at vertex B: π/3\n- Angle at vertex C: π/7\n// Note: This is a simplified solution showing the structure.\n// Computing exact vertex positions for arbitrary (p,q,r) requires\n// solving hyperbolic trigonometry equations.\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInCircle(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    // (2,3,7) triangle - precomputed geodesics\n    // These values are approximate - exact computation requires\n    // solving cosh(a) = cos(pi/p) + cos(pi/q)*cos(pi/r) / (sin(pi/q)*sin(pi/r))\n    // for the side lengths, then positioning the geodesics.\n    \n    HalfSpaceCirc edge1 = HalfSpaceCirc(-0.3, 1.1, 1.0);\n    HalfSpaceCirc edge2 = HalfSpaceCirc(0.5, 0.9, 1.0);\n    HalfSpaceCirc edge3 = HalfSpaceCirc(0.0, 0.7, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInCircle(z, edge1, foldCount);\n        z = reflectInCircle(z, edge2, foldCount);\n        z = reflectInCircle(z, edge3, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\nTo complete this project:\n\nImplement the hyperbolic law of cosines to compute side lengths from angles\nPosition three geodesics (semicircles) that meet at the correct angles\nAdd edge and vertex drawing\nMake p, q, r adjustable via uniforms\nAdd validation that 1/p + 1/q + 1/r &lt; 1 (hyperbolic condition)"
  },
  {
    "objectID": "lectures/solutions/day3-solutions.html#checkpoints",
    "href": "lectures/solutions/day3-solutions.html#checkpoints",
    "title": "1 Day 3: Exercise Solutions",
    "section": "",
    "text": "Draw hyperbolic circles of radius 0.1 and 0.5 around the mouse position.\nfloat hypDist(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float num = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + num / denom;\n    return log(arg + sqrt(arg * arg - 1.0));  // acosh\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    // Get mouse position in same coordinates\n    vec2 center = normalize_coord(iMouse.xy);\n    \n    // Default center when not clicking\n    if (iMouse.z &lt; 0.5) {\n        center = vec2(2.0, 2.0);\n    }\n    \n    // Hyperbolic distance from center\n    float d = hypDist(z, center);\n    \n    // Background\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw circle at radius 0.1\n    if (abs(d - 0.1) &lt; 0.02) {\n        color = vec3(0.3, 0.7, 0.9);\n    }\n    \n    // Draw circle at radius 0.5\n    if (abs(d - 0.5) &lt; 0.02) {\n        color = vec3(0.9, 0.5, 0.3);\n    }\n    \n    // Mark center\n    if (length(z - center) &lt; 0.03) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    \n    // Darken below real axis\n    if (z.y &lt; 0.01) {\n        color = vec3(0.05);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nAdd edge drawing using hyperbolic distance to geodesics.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceVert h) {\n    z.x -= h.x;\n    return acosh(length(z) / z.y);\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    return acosh(length(w) / w.y);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0 - vec2(0.75, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    vec2 z_orig = z;\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Draw edges using hyperbolic distance\n    float edgeThickness = 0.03;\n    float d1 = distToGeodesic(z, left);\n    float d2 = distToGeodesic(z, right);\n    float d3 = distToGeodesic(z, bottom);\n    \n    if (d1 &lt; edgeThickness || d2 &lt; edgeThickness || d3 &lt; edgeThickness) {\n        color = vec3(1.0);\n    }\n    \n    if (z_orig.y &lt; 0.01) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day3-solutions.html#explorations",
    "href": "lectures/solutions/day3-solutions.html#explorations",
    "title": "1 Day 3: Exercise Solutions",
    "section": "",
    "text": "Drawing vertices and edges, in both UHP and Poincaré disk.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceVert h) {\n    z.x -= h.x;\n    return acosh(length(z) / z.y);\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    return acosh(length(w) / w.y);\n}\n\nfloat hypDist(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float num = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + num / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Draw edges\n    float edgeThickness = 0.02;\n    float d1 = distToGeodesic(z, left);\n    float d2 = distToGeodesic(z, right);\n    float d3 = distToGeodesic(z, bottom);\n    \n    if (d1 &lt; edgeThickness || d2 &lt; edgeThickness || d3 &lt; edgeThickness) {\n        color = vec3(0.2);\n    }\n    \n    // Draw vertices\n    vec2 v1 = vec2(0.0, 1.0);                    // i (angle pi/2)\n    vec2 v2 = vec2(0.5, 0.866);                  // 1/2 + sqrt(3)/2 * i (angle pi/3)\n    \n    float vertexRadius = 0.08;\n    if (hypDist(z, v1) &lt; vertexRadius) {\n        color = vec3(0.9, 0.3, 0.3);\n    }\n    if (hypDist(z, v2) &lt; vertexRadius) {\n        color = vec3(0.3, 0.9, 0.3);\n    }\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDisplay the tiling in the Klein disk where geodesics are straight lines.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\n// Klein disk to Poincaré disk\nvec2 kleinToPoincare(vec2 k) {\n    float k_mag2 = dot(k, k);\n    float denom = 1.0 + sqrt(1.0 - k_mag2);\n    return k / denom;\n}\n\n// Poincaré disk to upper half-plane\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 k = normalize_coord(fragCoord);  // Klein disk coordinates\n    \n    // Convert Klein -&gt; Poincaré -&gt; UHP\n    vec2 w = kleinToPoincare(k);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(k) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\nWarningSolution TODO\n\n\n\nThe band model solution needs to be written. The conversion uses ctanh to map from band to Poincaré disk, then the standard disk-to-UHP conversion.\n\n\n\n\n\n\nUse mouse to translate and scale the tiling.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\n// Apply Möbius transformation (a*z + b) / (c*z + d) with real coefficients\nvec2 mobius(vec2 z, float a, float b, float c, float d) {\n    vec2 num = vec2(a * z.x + b, a * z.y);\n    vec2 denom = vec2(c * z.x + d, c * z.y);\n    return cdiv(num, denom);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    // Get mouse position for transformation parameters\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (iMouse.z &lt; 0.5) {\n        mouse = vec2(0.5, 0.5);\n    }\n    \n    // Horizontal translation: z -&gt; z + t (positive t moves tiling left, so add t)\n    float t = (mouse.x - 0.5) * 4.0;\n    z.x += t;\n    \n    // Scaling: z -&gt; k*z (k &gt; 1 zooms in, so divide)\n    float k = exp((mouse.y - 0.5) * 2.0);\n    z /= k;\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day3-solutions.html#challenges",
    "href": "lectures/solutions/day3-solutions.html#challenges",
    "title": "1 Day 3: Exercise Solutions",
    "section": "",
    "text": "Smoothly morph between upper half-plane and Poincaré disk.\nThe key insight is to interpolate at the level of matrices. The Cayley transform \\(C(z) = \\frac{z-i}{z+i}\\) has matrix \\(M = \\begin{pmatrix} 1 & -i \\\\ 1 & i \\end{pmatrix}\\), and identity has matrix \\(I\\). The linear interpolation \\(M_t = (1-t)I + tM\\) has determinant \\(1 - t + it \\neq 0\\) for \\(t \\in [0,1]\\), so each \\(M_t\\) is invertible.\nThis gives us: \\(f_t(z) = \\frac{z - it}{tz + (1-t+it)}\\)\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\n// Interpolated Cayley transform: f_t(z) = (z - it) / (tz + (1-t+it))\nvec2 partialCayley(vec2 z, float t) {\n    vec2 num = z - vec2(0.0, t);                    // z - it\n    vec2 denom = t * z + vec2(1.0 - t, t);          // tz + (1-t+it)\n    return cdiv(num, denom);\n}\n\n// Inverse of partial Cayley: solve w = (z - it) / (tz + (1-t+it)) for z\n// w(tz + (1-t+it)) = z - it\n// wtz + w(1-t+it) = z - it\n// wtz - z = -it - w(1-t+it)\n// z(wt - 1) = -it - w(1-t+it)\n// z = (it + w(1-t+it)) / (1 - wt)\nvec2 invPartialCayley(vec2 w, float t) {\n    vec2 it = vec2(0.0, t);\n    vec2 coef = vec2(1.0 - t, t);                   // (1-t+it)\n    vec2 num = it + cmul(w, coef);                  // it + w(1-t+it)\n    vec2 denom = vec2(1.0, 0.0) - t * w;            // 1 - wt\n    return cdiv(num, denom);\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = 0.5 + 0.5 * sin(iTime * 0.5);\n    \n    // Screen shows a disk-like region\n    vec2 w = normalize_coord(fragCoord);\n    \n    // Apply inverse partial Cayley to get UHP coordinates\n    vec2 z = invPartialCayley(w, t);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Always black in lower half-plane (z.y &lt; 0 in UHP)\n    if (z.y &lt; 0.0) {\n        color = vec3(0.05);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDraw geodesics connecting centers of adjacent triangles.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat hypDist(vec2 z1, vec2 z2) {\n    vec2 diff = z1 - z2;\n    float num = dot(diff, diff);\n    float denom = 2.0 * z1.y * z2.y;\n    float arg = 1.0 + num / denom;\n    return log(arg + sqrt(arg * arg - 1.0));\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Triangle incenter (approximate center of fundamental domain)\n    vec2 incenter = vec2(0.25, 1.1);\n    \n    // Draw dual edges: geodesic segments from incenter perpendicular to each edge\n    // These are the only three segments we draw; reflections tile the rest\n    \n    // Edge 1: perpendicular to left edge (x=0)\n    // The perpendicular geodesic from incenter to x=0 is a semicircle \n    // centered at origin passing through incenter\n    // It hits x=0 at y = |incenter| (the radius)\n    float r1 = length(incenter);\n    float d1 = abs(length(z) - r1);\n    // Only draw between incenter and the edge (y &lt;= incenter.y, x near 0 side)\n    bool onSeg1 = (z.y &lt;= r1) && (z.x &gt;= 0.0) && (z.x &lt;= incenter.x);\n    \n    // Edge 2: perpendicular to right edge (x=0.5)\n    // Semicircle centered at (0.5, 0) passing through incenter\n    vec2 c2 = vec2(0.5, 0.0);\n    float r2 = length(incenter - c2);\n    float d2 = abs(length(z - c2) - r2);\n    // Only draw between incenter and x=0.5\n    bool onSeg2 = (z.x &gt;= incenter.x) && (z.x &lt;= 0.5);\n    \n    // Edge 3: perpendicular to bottom (unit circle centered at origin)\n    // The perpendicular from incenter to unit circle is a vertical line x = incenter.x\n    // (since unit circle is centered at origin, radial lines are perpendicular)\n    float d3 = abs(z.x - incenter.x);\n    // Only draw from incenter down to unit circle (y between 1 and incenter.y)\n    float yOnCircle = sqrt(1.0 - incenter.x * incenter.x);\n    bool onSeg3 = (z.y &gt;= yOnCircle) && (z.y &lt;= incenter.y);\n    \n    // Draw dual edges with hyperbolic-ish thickness\n    float thickness = 0.02;\n    if ((d1 &lt; thickness && onSeg1) || \n        (d2 &lt; thickness && onSeg2) || \n        (d3 &lt; thickness && onSeg3)) {\n        color = vec3(0.8, 0.2, 0.2);\n    }\n    \n    // Draw dual vertex (incenter)\n    float dv = hypDist(z, incenter);\n    if (dv &lt; 0.05) {\n        color = vec3(0.2, 0.2, 0.8);\n    }\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nDraw only the circular geodesic edge.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nfloat distToGeodesic(vec2 z, HalfSpaceCirc h) {\n    vec2 num = z - vec2(h.center + h.radius, 0.0);\n    vec2 denom = z - vec2(h.center - h.radius, 0.0);\n    vec2 w = cdiv(num, denom);\n    return acosh(length(w) / w.y);\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    // Draw ONLY the circular edge\n    float d = distToGeodesic(z, bottom);\n    if (d &lt; 0.03) {\n        color = vec3(1.0);\n    }\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}"
  },
  {
    "objectID": "lectures/solutions/day3-solutions.html#projects",
    "href": "lectures/solutions/day3-solutions.html#projects",
    "title": "1 Day 3: Exercise Solutions",
    "section": "",
    "text": "This is a more substantial project. Here’s a starting point for the (2,3,7) tiling—a compact hyperbolic triangle with all finite vertices.\nThe key challenge is computing the geodesic positions from the angle constraints. For (2,3,7): - Angle at vertex A: π/2 - Angle at vertex B: π/3\n- Angle at vertex C: π/7\n// Note: This is a simplified solution showing the structure.\n// Computing exact vertex positions for arbitrary (p,q,r) requires\n// solving hyperbolic trigonometry equations.\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 reflectInCircle(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    // (2,3,7) triangle - precomputed geodesics\n    // These values are approximate - exact computation requires\n    // solving cosh(a) = cos(pi/p) + cos(pi/q)*cos(pi/r) / (sin(pi/q)*sin(pi/r))\n    // for the side lengths, then positioning the geodesics.\n    \n    HalfSpaceCirc edge1 = HalfSpaceCirc(-0.3, 1.1, 1.0);\n    HalfSpaceCirc edge2 = HalfSpaceCirc(0.5, 0.9, 1.0);\n    HalfSpaceCirc edge3 = HalfSpaceCirc(0.0, 0.7, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInCircle(z, edge1, foldCount);\n        z = reflectInCircle(z, edge2, foldCount);\n        z = reflectInCircle(z, edge3, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\nTo complete this project:\n\nImplement the hyperbolic law of cosines to compute side lengths from angles\nPosition three geodesics (semicircles) that meet at the correct angles\nAdd edge and vertex drawing\nMake p, q, r adjustable via uniforms\nAdd validation that 1/p + 1/q + 1/r &lt; 1 (hyperbolic condition)"
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html",
    "href": "lectures/shaders/day1-shaders.html",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "This appendix provides complete, standalone code for each shader referenced in Day 1. Each listing can be copied directly into Shadertoy and run immediately.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    vec2 sun = normalize_coord(iMouse.xy);\n    \n    // Earth orbits the sun\n    float orbit_radius = 0.8;\n    vec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n    \n    // Draw sun (larger, yellow)\n    float d_sun = length(p - sun);\n    // Draw earth (smaller, blue)\n    float d_earth = length(p - earth);\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);  // dark background\n    if (d_sun &lt; 0.3) {\n        color = vec3(1.0, 0.9, 0.2);  // yellow sun\n    }\n    if (d_earth &lt; 0.15) {\n        color = vec3(0.2, 0.5, 1.0);  // blue earth\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\nThe simplest shader: every pixel is red.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\n\n\n\nRed channel oscillates with time.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}\n\n\n\n\nVisualizing the coordinate system as color.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n\n\n\n\nDividing the plane into two regions based on y-coordinate.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.y;\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // red below\n    } else {\n        color = vec3(0.0, 0.0, 1.0);  // blue above\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nAnimated line dividing the plane, with rotating normal and shifting offset.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = cos(iTime);\n    float b = sin(iTime);\n    float c = 0.5 * sin(iTime * 0.7);\n    float L = a * p.x + b * p.y + c;\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nFilled circle centered at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float f = d - r;\n    \n    vec3 color;\n    if (f &lt; 0.0) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow inside\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nCircle outline (ring) centered at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float eps = 0.1;\n    float f = abs(d - r) - eps;\n    \n    vec3 color;\n    if (f &lt; 0.0) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow ring\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nThe parabola \\(y = x^2\\) rendered as an implicit curve.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.y - p.x * p.x;\n    float eps = 0.1;\n    \n    vec3 color;\n    if (abs(F) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow curve\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nLemniscate of Bernoulli with naive thresholding (non-uniform thickness).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.5;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n    \n    float eps = 0.15;\n    \n    vec3 color;\n    if (abs(F) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nLemniscate with gradient correction for uniform thickness.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.5;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n    \n    vec2 grad = vec2(\n        4.0 * p.x * r2 - 2.0 * a * a * p.x,\n        4.0 * p.y * r2 + 2.0 * a * a * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    float eps = 0.05;\n    \n    vec3 color;\n    if (dist &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nCassini ovals animated through the lemniscate transition.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Cassini oval parameters\n    float c = 1.0;  // half-distance between foci\n    float a = 0.8 + 0.4 * sin(iTime * 0.5);  // animate through transition\n    \n    // Implicit equation: (x² + y²)² - 2c²(x² - y²) = a⁴ - c⁴\n    float r2 = dot(p, p);\n    float c2 = c * c;\n    float a4 = a * a * a * a;\n    float c4 = c2 * c2;\n    float F = r2 * r2 - 2.0 * c2 * (p.x * p.x - p.y * p.y) - (a4 - c4);\n    \n    // Gradient\n    vec2 grad = vec2(\n        4.0 * p.x * r2 - 4.0 * c2 * p.x,\n        4.0 * p.y * r2 + 4.0 * c2 * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    float eps = 0.05;\n    \n    vec3 color;\n    if (dist &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nCircle that follows the mouse position.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize fragment coordinate\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Normalize mouse coordinate the same way\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse - vec2(0.5, 0.5);\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse = mouse * 4.0;\n    \n    // Circle centered at mouse\n    float d = length(p - mouse);\n    float r = 0.5;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 0.9, 0.2);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nSun at mouse click position with orbiting earth.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Use iMouse.zw (last click position) so sun stays put\n    vec2 sun = normalize_coord(iMouse.zw);\n    \n    // Earth orbits the sun\n    float orbit_radius = 0.8;\n    vec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n    \n    // Draw sun (larger, yellow)\n    float d_sun = length(p - sun);\n    // Draw earth (smaller, blue)\n    float d_earth = length(p - earth);\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);  // dark background\n    if (d_sun &lt; 0.3) {\n        color = vec3(1.0, 0.9, 0.2);  // yellow sun\n    }\n    if (d_earth &lt; 0.15) {\n        color = vec3(0.2, 0.5, 1.0);  // blue earth\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nFolium of Descartes with mouse-controlled level set.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fixed parameter a\n    float a = 1.5;\n    \n    // Map mouse x to level set value c in [-2, 2]\n    float c = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n    \n    // Folium of Descartes: x³ + y³ - 3axy = c\n    float F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;\n    \n    // Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)\n    vec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);\n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color;\n    if (dist &lt; 0.05) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nFamily of elliptic curves with mouse-controlled center parameters.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Mouse controls the central (a, b) of our family\n    float a_center = mix(-3.0, 1.0, iMouse.x / iResolution.x);\n    float b_center = mix(-2.0, 2.0, iMouse.y / iResolution.y);\n    \n    vec3 color = vec3(0.05, 0.05, 0.1);  // dark background\n    \n    // Draw curves for a range of a values around a_center\n    for (float i = -3.0; i &lt;= 3.0; i += 1.0) {\n        float a = a_center + i * 0.5;  // more spacing\n        float b = b_center;\n        \n        // Elliptic curve: y² = x³ + ax + b\n        float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n        \n        // Gradient\n        vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n        float dist = abs(F) / max(length(grad), 0.01);\n        \n        // Brightness fades quickly: central curve bright, outer curves fade to background\n        float t = abs(i) / 3.0;  // 0 at center, 1 at edges\n        float brightness = 1.0 - t * t;  // quadratic falloff\n        \n        if (dist &lt; 0.03 && brightness &gt; 0.05) {\n            // Check discriminant for this specific curve\n            float disc = 4.0 * a * a * a + 27.0 * b * b;\n            if (abs(disc) &lt; 0.3) {\n                color = mix(color, vec3(1.0, 0.3, 0.3), brightness);  // red for singular\n            } else {\n                color = mix(color, vec3(1.0, 1.0, 0.5), brightness);  // yellow for smooth\n            }\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nGrid of circles with square cells.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float N = 5.0;  // number of columns\n    float L = (4.0 * aspect) / N;  // cell size\n    \n    vec2 cell_id = floor(p / L);\n    vec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg = mix(vec3(0.15, 0.15, 0.25), vec3(0.25, 0.15, 0.15), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = L * 0.35;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = bg;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\nMost shaders use this standard coordinate setup:\nvec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]\nuv = uv - vec2(0.5, 0.5);               // center origin\nuv.x *= iResolution.x / iResolution.y;  // aspect correction\nvec2 p = uv * 4.0;                      // scale to [-2, 2] range\n\n\n\nFor shaders using mouse input, we define:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\n\n\nFor implicit curves \\(F(x,y) = 0\\) with uniform thickness:\nfloat dist = abs(F) / max(length(grad), 0.01);\nwhere grad is \\(\\nabla F\\) computed analytically.",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a1.-red",
    "href": "lectures/shaders/day1-shaders.html#a1.-red",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "The simplest shader: every pixel is red.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a2.-red-pulsing",
    "href": "lectures/shaders/day1-shaders.html#a2.-red-pulsing",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Red channel oscillates with time.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float red = 0.5 + 0.5 * sin(iTime);\n    fragColor = vec4(red, 0.0, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a3.-coordinates",
    "href": "lectures/shaders/day1-shaders.html#a3.-coordinates",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Visualizing the coordinate system as color.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a4.-half-plane",
    "href": "lectures/shaders/day1-shaders.html#a4.-half-plane",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Dividing the plane into two regions based on y-coordinate.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float L = p.y;\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);  // red below\n    } else {\n        color = vec3(0.0, 0.0, 1.0);  // blue above\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a5.-half-plane-animated",
    "href": "lectures/shaders/day1-shaders.html#a5.-half-plane-animated",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Animated line dividing the plane, with rotating normal and shifting offset.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = cos(iTime);\n    float b = sin(iTime);\n    float c = 0.5 * sin(iTime * 0.7);\n    float L = a * p.x + b * p.y + c;\n    \n    vec3 color;\n    if (L &lt; 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a6.-circle",
    "href": "lectures/shaders/day1-shaders.html#a6.-circle",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Filled circle centered at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float f = d - r;\n    \n    vec3 color;\n    if (f &lt; 0.0) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow inside\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a7.-circle-curve",
    "href": "lectures/shaders/day1-shaders.html#a7.-circle-curve",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Circle outline (ring) centered at the origin.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float d = length(p);\n    float r = 1.0;\n    float eps = 0.1;\n    float f = abs(d - r) - eps;\n    \n    vec3 color;\n    if (f &lt; 0.0) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow ring\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a8.-parabola",
    "href": "lectures/shaders/day1-shaders.html#a8.-parabola",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "The parabola \\(y = x^2\\) rendered as an implicit curve.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float F = p.y - p.x * p.x;\n    float eps = 0.1;\n    \n    vec3 color;\n    if (abs(F) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);  // yellow curve\n    } else {\n        color = vec3(0.1, 0.1, 0.3);  // dark background\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a9.-lemniscate-naive",
    "href": "lectures/shaders/day1-shaders.html#a9.-lemniscate-naive",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Lemniscate of Bernoulli with naive thresholding (non-uniform thickness).\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.5;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n    \n    float eps = 0.15;\n    \n    vec3 color;\n    if (abs(F) &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a10.-lemniscate-gradient",
    "href": "lectures/shaders/day1-shaders.html#a10.-lemniscate-gradient",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Lemniscate with gradient correction for uniform thickness.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float a = 1.5;\n    float r2 = dot(p, p);\n    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n    \n    vec2 grad = vec2(\n        4.0 * p.x * r2 - 2.0 * a * a * p.x,\n        4.0 * p.y * r2 + 2.0 * a * a * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    float eps = 0.05;\n    \n    vec3 color;\n    if (dist &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a11.-lemniscate-animated",
    "href": "lectures/shaders/day1-shaders.html#a11.-lemniscate-animated",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Cassini ovals animated through the lemniscate transition.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Cassini oval parameters\n    float c = 1.0;  // half-distance between foci\n    float a = 0.8 + 0.4 * sin(iTime * 0.5);  // animate through transition\n    \n    // Implicit equation: (x² + y²)² - 2c²(x² - y²) = a⁴ - c⁴\n    float r2 = dot(p, p);\n    float c2 = c * c;\n    float a4 = a * a * a * a;\n    float c4 = c2 * c2;\n    float F = r2 * r2 - 2.0 * c2 * (p.x * p.x - p.y * p.y) - (a4 - c4);\n    \n    // Gradient\n    vec2 grad = vec2(\n        4.0 * p.x * r2 - 4.0 * c2 * p.x,\n        4.0 * p.y * r2 + 4.0 * c2 * p.y\n    );\n    \n    float dist = abs(F) / max(length(grad), 0.01);\n    float eps = 0.05;\n    \n    vec3 color;\n    if (dist &lt; eps) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a12.-circle-mouse",
    "href": "lectures/shaders/day1-shaders.html#a12.-circle-mouse",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Circle that follows the mouse position.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize fragment coordinate\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Normalize mouse coordinate the same way\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse - vec2(0.5, 0.5);\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse = mouse * 4.0;\n    \n    // Circle centered at mouse\n    float d = length(p - mouse);\n    float r = 0.5;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 0.9, 0.2);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a13.-sun-earth",
    "href": "lectures/shaders/day1-shaders.html#a13.-sun-earth",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Sun at mouse click position with orbiting earth.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Use iMouse.zw (last click position) so sun stays put\n    vec2 sun = normalize_coord(iMouse.zw);\n    \n    // Earth orbits the sun\n    float orbit_radius = 0.8;\n    vec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n    \n    // Draw sun (larger, yellow)\n    float d_sun = length(p - sun);\n    // Draw earth (smaller, blue)\n    float d_earth = length(p - earth);\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);  // dark background\n    if (d_sun &lt; 0.3) {\n        color = vec3(1.0, 0.9, 0.2);  // yellow sun\n    }\n    if (d_earth &lt; 0.15) {\n        color = vec3(0.2, 0.5, 1.0);  // blue earth\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a14.-folium-mouse",
    "href": "lectures/shaders/day1-shaders.html#a14.-folium-mouse",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Folium of Descartes with mouse-controlled level set.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fixed parameter a\n    float a = 1.5;\n    \n    // Map mouse x to level set value c in [-2, 2]\n    float c = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n    \n    // Folium of Descartes: x³ + y³ - 3axy = c\n    float F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;\n    \n    // Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)\n    vec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);\n    float dist = abs(F) / max(length(grad), 0.01);\n    \n    vec3 color;\n    if (dist &lt; 0.05) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = vec3(0.1, 0.1, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a15.-elliptic-family",
    "href": "lectures/shaders/day1-shaders.html#a15.-elliptic-family",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Family of elliptic curves with mouse-controlled center parameters.\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Mouse controls the central (a, b) of our family\n    float a_center = mix(-3.0, 1.0, iMouse.x / iResolution.x);\n    float b_center = mix(-2.0, 2.0, iMouse.y / iResolution.y);\n    \n    vec3 color = vec3(0.05, 0.05, 0.1);  // dark background\n    \n    // Draw curves for a range of a values around a_center\n    for (float i = -3.0; i &lt;= 3.0; i += 1.0) {\n        float a = a_center + i * 0.5;  // more spacing\n        float b = b_center;\n        \n        // Elliptic curve: y² = x³ + ax + b\n        float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;\n        \n        // Gradient\n        vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);\n        float dist = abs(F) / max(length(grad), 0.01);\n        \n        // Brightness fades quickly: central curve bright, outer curves fade to background\n        float t = abs(i) / 3.0;  // 0 at center, 1 at edges\n        float brightness = 1.0 - t * t;  // quadratic falloff\n        \n        if (dist &lt; 0.03 && brightness &gt; 0.05) {\n            // Check discriminant for this specific curve\n            float disc = 4.0 * a * a * a + 27.0 * b * b;\n            if (abs(disc) &lt; 0.3) {\n                color = mix(color, vec3(1.0, 0.3, 0.3), brightness);  // red for singular\n            } else {\n                color = mix(color, vec3(1.0, 1.0, 0.5), brightness);  // yellow for smooth\n            }\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#a16.-grid-circles",
    "href": "lectures/shaders/day1-shaders.html#a16.-grid-circles",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Grid of circles with square cells.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    float N = 5.0;  // number of columns\n    float L = (4.0 * aspect) / N;  // cell size\n    \n    vec2 cell_id = floor(p / L);\n    vec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);\n    \n    // Checkerboard background\n    float checker = mod(cell_id.x + cell_id.y, 2.0);\n    vec3 bg = mix(vec3(0.15, 0.15, 0.25), vec3(0.25, 0.15, 0.15), checker);\n    \n    // Circle in each cell\n    float d = length(cell_p);\n    float r = L * 0.35;\n    \n    vec3 color;\n    if (d &lt; r) {\n        color = vec3(1.0, 1.0, 0.0);\n    } else {\n        color = bg;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day1-shaders.html#notes",
    "href": "lectures/shaders/day1-shaders.html#notes",
    "title": "1 Day 1 Code",
    "section": "",
    "text": "Most shaders use this standard coordinate setup:\nvec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]\nuv = uv - vec2(0.5, 0.5);               // center origin\nuv.x *= iResolution.x / iResolution.y;  // aspect correction\nvec2 p = uv * 4.0;                      // scale to [-2, 2] range\n\n\n\nFor shaders using mouse input, we define:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\n\n\nFor implicit curves \\(F(x,y) = 0\\) with uniform thickness:\nfloat dist = abs(F) / max(length(grad), 0.01);\nwhere grad is \\(\\nabla F\\) computed analytically.",
    "crumbs": [
      "Appendices",
      "Day 1 Code"
    ]
  },
  {
    "objectID": "lectures/shaders/day3-shaders.html",
    "href": "lectures/shaders/day3-shaders.html",
    "title": "1 Day 3 Code",
    "section": "",
    "text": "1 Day 3 Code\nThis document provides complete, standalone shader code for each demo in Day 3. Copy any of these directly into Shadertoy to run.\n\n\nstrip-circle\nBasic strip tiling with a circle in the fundamental domain.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    // Fold into the strip [0, 1]\n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    // Draw a circle in the fundamental domain\n    float d = length(p - vec2(0.5, 0.0));\n    vec3 color = vec3(0.1, 0.1, 0.15);\n    if (d &lt; 0.3) {\n        color = vec3(1.0, 0.8, 0.3);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nstrip-F\nStrip tiling with the letter F to show reflection behavior.\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n    }\n    \n    vec3 color = drawF(p - vec2(0.5, 0.0), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-F\nSquare tiling with the letter F.\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    for (int i = 0; i &lt; 20; i++) {\n        if (p.x &lt; 0.0) p.x = -p.x;\n        if (p.x &gt; 1.0) p.x = 2.0 - p.x;\n        if (p.y &lt; 0.0) p.y = -p.y;\n        if (p.y &gt; 1.0) p.y = 2.0 - p.y;\n    }\n    \n    vec3 color = drawF(p - vec2(0.5, 0.5), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-foldcount\nSquare tiling colored by number of reflections.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 20; i++) {\n        vec2 p0 = p;\n        if (p.x &lt; 0.0) { p.x = -p.x; foldCount++; }\n        if (p.x &gt; 1.0) { p.x = 2.0 - p.x; foldCount++; }\n        if (p.y &lt; 0.0) { p.y = -p.y; foldCount++; }\n        if (p.y &gt; 1.0) { p.y = 2.0 - p.y; foldCount++; }\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float t = float(foldCount) / 10.0;\n    vec3 color = 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-parity\nSquare tiling with checkerboard parity coloring.\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 20; i++) {\n        vec2 p0 = p;\n        if (p.x &lt; 0.0) { p.x = -p.x; foldCount++; }\n        if (p.x &gt; 1.0) { p.x = 2.0 - p.x; foldCount++; }\n        if (p.y &lt; 0.0) { p.y = -p.y; foldCount++; }\n        if (p.y &gt; 1.0) { p.y = 2.0 - p.y; foldCount++; }\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.9, 0.85, 0.8) : vec3(0.3, 0.35, 0.4);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhalfspace-single\nVisualization of a single half-space.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nbool inside(vec2 p, HalfSpace h) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    return val * h.side &lt; 0.0;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    HalfSpace h = HalfSpace(1.0, 0.0, 1.0, 1.0);\n    \n    vec3 color = inside(p, h) ? vec3(0.3, 0.5, 0.7) : vec3(0.1, 0.1, 0.15);\n    \n    float dist = abs(h.a * p.x + h.b * p.y - h.c) / length(vec2(h.a, h.b));\n    if (dist &lt; 0.03) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nsquare-halfspace\nSquare tiling using half-space abstraction with F and parity coloring.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    if (val * h.side &lt; 0.0) return p;\n    \n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);\n    float dist = val / length(vec2(h.a, h.b));\n    count++;\n    return p - 2.0 * dist * n;\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 8.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    HalfSpace left   = HalfSpace(1.0, 0.0, 0.0, -1.0);\n    HalfSpace right  = HalfSpace(1.0, 0.0, 1.0,  1.0);\n    HalfSpace bottom = HalfSpace(0.0, 1.0, 0.0, -1.0);\n    HalfSpace top    = HalfSpace(0.0, 1.0, 1.0,  1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 20; i++) {\n        vec2 p0 = p;\n        p = reflectInto(p, left, foldCount);\n        p = reflectInto(p, right, foldCount);\n        p = reflectInto(p, bottom, foldCount);\n        p = reflectInto(p, top, foldCount);\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 bg = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    vec3 fg = (parity &lt; 0.5) ? vec3(0.6, 0.2, 0.2) : vec3(0.2, 0.2, 0.6);\n    \n    vec3 color = drawF(p - vec2(0.5, 0.5), bg, fg);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\ntriangle-tiling\nEuclidean equilateral triangle tiling.\nstruct HalfSpace {\n    float a, b, c;\n    float side;\n};\n\nvec2 reflectInto(vec2 p, HalfSpace h, inout int count) {\n    float val = h.a * p.x + h.b * p.y - h.c;\n    if (val * h.side &lt; 0.0) return p;\n    \n    vec2 n = vec2(h.a, h.b);\n    n = n / length(n);\n    float dist = val / length(vec2(h.a, h.b));\n    count++;\n    return p - 2.0 * dist * n;\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.15 && p.x &lt; 0.0 && p.y &gt; -0.2 && p.y &lt; 0.2) color = fgColor;\n    if (p.x &gt; -0.15 && p.x &lt; 0.15 && p.y &gt; 0.1 && p.y &lt; 0.2) color = fgColor;\n    if (p.x &gt; -0.15 && p.x &lt; 0.08 && p.y &gt; -0.02 && p.y &lt; 0.08) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = normalize_coord(fragCoord);\n    \n    HalfSpace h1 = HalfSpace(0.0, 1.0, -0.5, -1.0);\n    HalfSpace h2 = HalfSpace(0.866, -0.5, -0.5, -1.0);\n    HalfSpace h3 = HalfSpace(-0.866, -0.5, -0.5, -1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 30; i++) {\n        vec2 p0 = p;\n        p = reflectInto(p, h1, foldCount);\n        p = reflectInto(p, h2, foldCount);\n        p = reflectInto(p, h3, foldCount);\n        if (length(p - p0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 bg = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    vec3 fg = (parity &lt; 0.5) ? vec3(0.6, 0.2, 0.2) : vec3(0.2, 0.2, 0.6);\n    \n    vec3 color = drawF(p, bg, fg);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-halfspaces\nHyperbolic half-spaces in the upper half-plane.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nbool inside(vec2 z, HalfSpaceVert h) {\n    return (z.x - h.x) * h.side &lt; 0.0;\n}\n\nbool inside(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    return (dist2 - h.radius * h.radius) * h.side &gt; 0.0;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 5.0 - vec2(1.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert hv = HalfSpaceVert(1.0, -1.0);\n    HalfSpaceCirc hc = HalfSpaceCirc(2.5, 1.0, 1.0);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    if (inside(z, hv)) color = vec3(0.3, 0.5, 0.7);\n    if (inside(z, hc)) color += vec3(0.4, 0.2, 0.1);\n    \n    if (abs(z.x - hv.x) &lt; 0.03) color = vec3(1.0);\n    if (abs(length(z - vec2(hc.center, 0.0)) - hc.radius) &lt; 0.03 && z.y &gt; 0.0) color = vec3(1.0);\n    \n    if (z.y &lt; 0.02) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-reflect-F\nHyperbolic reflections of F across vertical and circular geodesics.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h) {\n    if ((z.x - h.x) * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    return z;\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.2 && p.x &lt; -0.05 && p.y &gt; -0.3 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.2 && p.y &gt; 0.15 && p.y &lt; 0.3) color = fgColor;\n    if (p.x &gt; -0.2 && p.x &lt; 0.1 && p.y &gt; -0.05 && p.y &lt; 0.1) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.0);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 6.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert hv = HalfSpaceVert(-1.5, -1.0);\n    HalfSpaceCirc hc = HalfSpaceCirc(1.5, 2.5, 1.0);\n    \n    float t = mod(iTime, 4.0);\n    if (t &lt; 2.0) {\n        z = reflectInto(z, hv);\n    } else {\n        z = reflectInto(z, hc);\n    }\n    \n    vec3 color = drawF(z - vec2(0.5, 3.5), vec3(0.1, 0.1, 0.15), vec3(1.0, 0.8, 0.3));\n    \n    vec2 z_orig = normalize_coord(fragCoord);\n    \n    if (abs(z_orig.x - hv.x) &lt; 0.04) color = vec3(0.5);\n    if (abs(length(z_orig - vec2(hc.center, 0.0)) - hc.radius) &lt; 0.04 && z_orig.y &gt; 0.0) color = vec3(0.5);\n    if (z_orig.y &lt; 0.02) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-triangle-halfspaces\nThe three half-spaces defining the (2,3,∞) triangle.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nbool inside(vec2 z, HalfSpaceVert h) {\n    return (z.x - h.x) * h.side &lt; 0.0;\n}\n\nbool inside(vec2 z, HalfSpaceCirc h) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    return (dist2 - h.radius * h.radius) * h.side &gt; 0.0;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0 - vec2(0.75, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    if (inside(z, left) && inside(z, right) && inside(z, bottom)) {\n        color = vec3(0.3, 0.5, 0.7);\n    }\n    \n    if (abs(z.x - 0.0) &lt; 0.02 && z.y &gt; 0.0) color = vec3(1.0);\n    if (abs(z.x - 0.5) &lt; 0.02 && z.y &gt; 0.0) color = vec3(1.0);\n    if (abs(length(z) - 1.0) &lt; 0.02 && z.y &gt; 0.0) color = vec3(1.0);\n    \n    if (z.y &lt; 0.01) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\nhyp-tiling-23inf\nThe (2,3,∞) hyperbolic triangle tiling in the upper half-plane.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    return uv * 4.0 - vec2(0.75, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 z = normalize_coord(fragCoord);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    vec2 z_orig = normalize_coord(fragCoord);\n    if (z_orig.y &lt; 0.01) color = vec3(0.15);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\npoincare-disk\nThe (2,3,∞) tiling in the Poincaré disk model.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 color = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\npoincare-disk-F\nThe (2,3,∞) tiling in the Poincaré disk with F markers.\nstruct HalfSpaceVert {\n    float x;\n    float side;\n};\n\nstruct HalfSpaceCirc {\n    float center;\n    float radius;\n    float side;\n};\n\nvec2 reflectInto(vec2 z, HalfSpaceVert h, inout int count) {\n    float val = z.x - h.x;\n    if (val * h.side &lt; 0.0) return z;\n    z.x = 2.0 * h.x - z.x;\n    count++;\n    return z;\n}\n\nvec2 reflectInto(vec2 z, HalfSpaceCirc h, inout int count) {\n    vec2 rel = z - vec2(h.center, 0.0);\n    float dist2 = dot(rel, rel);\n    \n    if ((dist2 - h.radius * h.radius) * h.side &gt; 0.0) return z;\n    \n    z.x -= h.center;\n    z /= h.radius;\n    z /= dot(z, z);\n    z *= h.radius;\n    z.x += h.center;\n    \n    count++;\n    return z;\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / denom;\n}\n\nvec2 diskToUHP(vec2 w) {\n    vec2 i = vec2(0.0, 1.0);\n    vec2 one = vec2(1.0, 0.0);\n    return cmul(i, cdiv(one + w, one - w));\n}\n\nvec3 drawF(vec2 p, vec3 bgColor, vec3 fgColor) {\n    vec3 color = bgColor;\n    if (p.x &gt; -0.06 && p.x &lt; -0.02 && p.y &gt; -0.08 && p.y &lt; 0.08) color = fgColor;\n    if (p.x &gt; -0.06 && p.x &lt; 0.06 && p.y &gt; 0.04 && p.y &lt; 0.08) color = fgColor;\n    if (p.x &gt; -0.06 && p.x &lt; 0.03 && p.y &gt; -0.01 && p.y &lt; 0.03) color = fgColor;\n    return color;\n}\n\nvec2 normalize_coord(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.5;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 w = normalize_coord(fragCoord);\n    vec2 z = diskToUHP(w);\n    \n    HalfSpaceVert left = HalfSpaceVert(0.0, -1.0);\n    HalfSpaceVert right = HalfSpaceVert(0.5, 1.0);\n    HalfSpaceCirc bottom = HalfSpaceCirc(0.0, 1.0, 1.0);\n    \n    int foldCount = 0;\n    for (int i = 0; i &lt; 100; i++) {\n        vec2 z0 = z;\n        z = reflectInto(z, left, foldCount);\n        z = reflectInto(z, right, foldCount);\n        z = reflectInto(z, bottom, foldCount);\n        if (length(z - z0) &lt; 0.0001) break;\n    }\n    \n    float parity = mod(float(foldCount), 2.0);\n    vec3 bg = (parity &lt; 0.5) ? vec3(0.85, 0.8, 0.75) : vec3(0.35, 0.4, 0.45);\n    vec3 fg = (parity &lt; 0.5) ? vec3(0.6, 0.2, 0.2) : vec3(0.2, 0.2, 0.6);\n    \n    vec3 color = drawF(z - vec2(0.25, 1.2), bg, fg);\n    \n    if (length(w) &gt; 1.0) color = vec3(0.05);\n    \n    fragColor = vec4(color, 1.0);\n}",
    "crumbs": [
      "Appendices",
      "Day 3 Code"
    ]
  },
  {
    "objectID": "lectures/day2.html",
    "href": "lectures/day2.html",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "Today we’ll learn how to do per-pixel computation in shaders, to quickly produce images of compelx mathematical objects. In the homework today, you’ll create your own version of the classic mandelbrot fractal zoom:\n\n  \n  \n  \n\n\nToday we explore two kinds of iterative systems:\n\nComplex dynamics: Iterating holomorphic maps gives us the Mandelbrot set, Julia sets, and their cousins\nCircle inversion: Iterating geometric transformations gives us the Apollonian gasket\n\nBoth share the same GPU-friendly structure: each pixel asks “what happens when I iterate from here?” No pixel depends on any other—perfect for parallel computation.\nAlong the way, we’ll learn to implement complex arithmetic in GLSL and organize geometric data using structs.\n\n\n\nThe complex numbers \\(\\mathbb{C}\\) are the plane equipped with a multiplication operation. Today we implement that algebra in GLSL.\n\n\nA complex number \\(z = a + bi\\) is naturally represented as a 2D vector:\nvec2 z = vec2(a, b);  // represents a + bi\nWe’ll consistently use the convention that z.x is the real part and z.y is the imaginary part.\n\n\n\nAddition of complex numbers is componentwise—exactly what GLSL’s built-in + does for vectors. No helper function needed.\nMultiplication is more interesting. In GLSL, the * operator on vectors is componentwise: vec2(a,b) * vec2(c,d) gives vec2(a*c, b*d). This is not complex multiplication! We need to implement the correct formula ourselves.\nRecall \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\):\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\nThis is the FOIL pattern with \\(i^2 = -1\\) giving the minus sign in the real part.\n\n\n\nThe magnitude of \\(z = a + bi\\) is the distance from the origin: \\[|z| = \\sqrt{a^2 + b^2}\\]\nWe can implement this directly:\nfloat cabs(vec2 z) {\n    return sqrt(z.x * z.x + z.y * z.y);\n}\nBut consider: we’ll often have conditions like “is \\(|z|\\) bigger than 2?” rather than needing the actual magnitude. In these cases, we can check \\(|z|^2 &gt; 4\\) instead of \\(|z| &gt; 2\\)—same answer, but no square root. When you’re doing this check millions of times per frame (once per pixel, 60 frames per second), avoiding unnecessary square roots adds up.\nSo we define the squared magnitude:\nfloat cabs2(vec2 z) {\n    return z.x * z.x + z.y * z.y;\n}\nIf we want to be even more efficient, we can use GLSL’s built-in dot product, which computes exactly this sum of products:\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // a² + b²\n}\n\n\n\n\nThe Mandelbrot set is perhaps the most iconic fractal—its shape is instantly recognizable, and its discovery in 1980 helped launch the era of computer-generated mathematical visualization. The definition is remarkably simple.\n\n\nFix a complex number \\(c\\). Starting from \\(z_0 = 0\\), define a sequence by iterating: \\[z_{n+1} = z_n^2 + c\\]\nFor some values of \\(c\\), this sequence stays bounded forever. For others, it escapes to infinity. The Mandelbrot set \\(\\mathcal{M}\\) is the set of all \\(c\\) for which the sequence remains bounded.\nThat’s it! One quadratic formula, iterated. The intricate structure of the Mandelbrot set emerges entirely from this simple rule.\n\n\n\nTo draw the Mandelbrot set, we test each pixel: is this value of \\(c\\) in \\(\\mathcal{M}\\) or not?\nThis is exactly the kind of question shaders excel at. Each pixel performs its own independent calculation—no pixel needs information from any other pixel. The entire image can be computed in parallel, with thousands of GPU cores each testing their own value of \\(c\\) simultaneously.\nBut there’s a problem: the definition involves iterating “forever” and checking if the sequence “stays bounded.” We can’t iterate infinitely, and we can’t wait forever to decide. We need a practical criterion for when to stop.\n\n\n\nWe need two facts that make efficient rendering possible.\nFact 1. The Mandelbrot set is contained in the disk of radius 2. That is, if \\(|c| &gt; 2\\), then \\(c \\notin \\mathcal{M}\\).\nProof. [TODO] \\(\\square\\)\nFact 2. If \\(|c| \\leq 2\\) and \\(|z_n| &gt; 2\\) for some \\(n\\), then the orbit escapes to infinity (so \\(c \\notin \\mathcal{M}\\)).\nProof. [TODO] \\(\\square\\)\nThis gives us a stopping criterion: once \\(|z_n| &gt; 2\\), we know \\(c\\) is not in the Mandelbrot set. We don’t need to keep iterating.\nTogether, these facts justify the escape-time algorithm: iterate until either \\(|z_n| &gt; 2\\) (escaped, not in \\(\\mathcal{M}\\)) or we hit a maximum iteration count (probably in \\(\\mathcal{M}\\)).\n\n\n\nThese two facts give us our algorithm:\n\nFor each pixel, let \\(c\\) be the corresponding complex number\nStart with \\(z = 0\\)\nIterate \\(z \\mapsto z^2 + c\\)\nIf \\(|z| &gt; 2\\), stop—this point escapes (not in \\(\\mathcal{M}\\))\nIf we reach a maximum iteration count without escaping, assume bounded (in \\(\\mathcal{M}\\))\n\nThe core of this is a loop:\nvec2 z = vec2(0.0, 0.0);\nint max_iter = 100;\nint iter;\n\nfor (iter = 0; iter &lt; max_iter; iter++) {\n    if (cabs2(z) &gt; 4.0) break;  // |z|² &gt; 4 means |z| &gt; 2\n    z = cmul(z, z) + c;\n}\nAfter this loop, iter tells us what happened: if iter == max_iter, we never escaped (probably in \\(\\mathcal{M}\\)). Otherwise, we escaped on iteration iter.\n\n\n\nThe simplest approach: color points black if they’re in the set, white if they escaped.\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);  // In the set: black\n} else {\n    color = vec3(1.0);  // Escaped: white\n}\n\n\n\nPutting it together with our coordinate setup:\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale and center to show the Mandelbrot set\n    // By Fact 1, the set lies in |c| ≤ 2\n    vec2 c = uv * 4.0;\n    c.x -= 0.5;  // shift left to center the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Binary coloring\n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);  // In the set: black\n    } else {\n        color = vec3(1.0);  // Escaped: white\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThere it is—the Mandelbrot set in black and white!\n\n\n\nBlack and white shows the set, but we’re throwing away information. The number of iterations before escape tells us how “close” a point is to the boundary—points that escape after 5 iterations are different from points that escape after 50.\nLet’s use iter to create a gradient:\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);\n} else {\n    float t = float(iter) / float(max_iter);\n    color = vec3(t);\n}\n\n  \n  \n  \n\n\nNow we see structure! The boundary reveals intricate detail—tendrils, spirals, bulbs. Points near the boundary take many iterations to escape (bright), while points far away escape quickly (dark).\n\n\n\nGrayscale works, but we can do better. A common technique uses cosines to create smooth, cycling color palettes:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nThe parameters a, b, c, d control the palette’s character. The vector d shifts the phase of each color channel, creating different hues. Try d = vec3(0.00, 0.10, 0.20) for blues and purples, or d = vec3(0.30, 0.20, 0.20) for warmer tones.\n\n  \n  \n  \n\n\nThe color bands correspond to iteration counts—regions of the same color escaped after the same number of iterations. You’ll notice the bands have sharp edges. In the exercises, we’ll show you a technique called smooth coloring that interpolates between iteration counts, eliminating the banding for even smoother gradients.\n\n\n\n\nThe Mandelbrot set is one example of an escape-time fractal, but the same algorithm works for many other iterated systems. We just swap out the iteration formula (and sometimes the escape condition). Let’s explore a few.\n\n\nThe Mandelbrot set asks: for which values of \\(c\\) does the orbit of \\(0\\) stay bounded? We can ask a different question: for a fixed \\(c\\), which starting points \\(z_0\\) have bounded orbits?\nFix a complex number \\(c\\). The filled Julia set \\(K_c\\) is the set of all starting points \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded.\nSame iteration, different question. For the Mandelbrot set, we vary \\(c\\) and always start at \\(z_0 = 0\\). For a Julia set, we fix \\(c\\) and vary \\(z_0\\).\nThe code change is minimal:\n// Mandelbrot: c varies, z starts at 0\nvec2 c = p;\nvec2 z = vec2(0.0, 0.0);\n\n// Julia: c is fixed, z starts at pixel position\nvec2 c = vec2(-0.7, 0.27015);  // fixed parameter\nvec2 z = p;\n\n  \n  \n  \n\n\nDifferent values of \\(c\\) produce dramatically different Julia sets. In the exercises, you’ll build an interactive explorer that lets you click anywhere on the Mandelbrot set to see the corresponding Julia set:\n\n  \n  \n  \n\n\n\n\n\nThe Mandelbrot set uses \\(z^2 + c\\). What about \\(z^3 + c\\)? Or \\(z^4 + c\\)?\nFor \\(z^3\\), we can compose our existing cmul function:\nvec2 ccube(vec2 z) {\n    return cmul(cmul(z, z), z);  // z · z · z\n}\nHigher powers give higher-order rotational symmetry: \\(z^3 + c\\) has 3-fold symmetry, \\(z^4 + c\\) has 4-fold symmetry, and so on.\nFor some more variety, the Burning Ship fractal modifies the Mandelbrot iteration by taking the absolute value of the imaginary part after each squaring:\n\\[z_{n+1} = (\\text{Re}(z_n^2) + i|\\text{Im}(z_n^2)|) + c\\]\n\n\n\nAll these fractals share the same structure:\n\nIterate some function \\(f(z, c)\\)\nCheck escape: has \\(|z|\\) exceeded some threshold?\nColor based on iteration count\n\nChanging the iteration function changes the fractal. The exercises include more variations for you to try.\n\n\n\n\nWe shift gears from complex dynamics to geometric transformations. Circle inversion is a classical operation that turns circles into circles (or lines), preserves angles, and creates beautiful fractal patterns when iterated.\n\n\nInversion in the unit circle maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\frac{\\mathbf{p}}{|\\mathbf{p}|^2}\\]\nWhat does this do geometrically? The inverted point lies on the same ray from the origin as \\(\\mathbf{p}\\), but at distance \\(1/r\\) instead of \\(r\\).\n\nPoints inside the unit circle map to points outside\nPoints outside map to points inside\n\nPoints on the unit circle stay fixed\nThe origin maps to “infinity”\n\n\n\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\n\n\nTo see what inversion does, let’s draw some shapes and their images. We’ll draw the unit circle (gray), plus a vertical line and a circle (yellow). To make it clearer, we’ll toggle between showing the original shapes and their inversions:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Compute the inversion of p\n    vec2 p_inv = invert(p);\n    \n    // Toggle between original and inverted every second\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;      // original\n    } else {\n        q = p_inv;  // inverted\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle (the inversion circle)\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a vertical line at x = 2\n    if (abs(q.x - 2.0) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a horizontal line at y = 1.5\n    if (abs(q.y - 1.5) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a circle centered at (2, 0) with radius 0.5\n    float d_circle = abs(length(q - vec2(2.0, 0.0)) - 0.5);\n    if (d_circle &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nWatch the lines become circles! A line not passing through the origin inverts to a circle that does pass through the origin. The circle inverts to another circle (with a different center and radius).\n\n\n\n\n\n\nTipGLSL Shortcuts: mix and step\n\n\n\nThe toggle logic can be written more compactly using built-in functions:\n\nstep(edge, x) returns 0 if x &lt; edge, otherwise 1\nmix(a, b, t) linearly interpolates: returns a when t = 0, b when t = 1\n\nfloat t = step(0.5, fract(iTime * 0.5));\nvec2 q = mix(p, p_inv, t);\nThis is a common pattern for toggling or smoothly transitioning between states.\n\n\n\n\n\nCircle inversion maps circles to circles (or to lines, if the circle passes through the center). It’s conformal—it preserves angles between curves. And it’s involutive: applying inversion twice returns to the original point.\n\n\n\nFor a more dramatic visualization, let’s invert a whole grid of lines. The function mod(q, 0.5) gives the position of q within a repeating \\(0.5 \\times 0.5\\) cell—when either component is near zero, we’re on a grid line:\nvec2 grid = mod(q, 0.5);\nif (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n(If you did the grid project from Day 1, this is familiar!)\nUsing the same toggle shader structure as before, just replacing the individual shapes with this grid:\n\n  \n  \n  \n\n\n\n\n\n\nSo far our invert function only works for the unit circle at the origin. What if we want to invert through a different circle?\n\n\nFor a circle with center \\(\\mathbf{c}\\) and radius \\(R\\), inversion maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nThe idea is the same as before: the inverted point lies on the ray from \\(\\mathbf{c}\\) through \\(\\mathbf{p}\\), at distance \\(R^2/r\\) from the center (where \\(r = |\\mathbf{p} - \\mathbf{c}|\\)). When \\(\\mathbf{c} = \\mathbf{0}\\) and \\(R = 1\\), this reduces to our earlier formula \\(\\mathbf{p}/|\\mathbf{p}|^2\\).\nIn code:\nvec2 invertInCircle(vec2 p, vec2 center, float radius) {\n    vec2 d = p - center;\n    return center + radius * radius * d / dot(d, d);\n}\nThis works, but notice we need to pass two things (center and radius) to describe one object (a circle). If we’re working with multiple circles, every function call needs center1, radius1, center2, radius2, ...—it gets verbose and error-prone.\n\n\n\nGLSL lets us bundle related data into a struct:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nNow Circle is a type, just like vec2 or float. We can create circles and access their fields:\nCircle c;\nc.center = vec2(1.0, 0.5);\nc.radius = 0.7;\n\n// Or initialize directly:\nCircle c = Circle(vec2(1.0, 0.5), 0.7);\n\n\n\nNow our inversion function takes a Circle:\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\nMuch cleaner! And when we’re working with multiple circles, we can pass them around as single objects.\n\n\n\nLet’s animate a circle moving around and watch how the inversion changes. The key new elements are animating the circle’s center and radius:\n// Animate the inversion circle\nCircle inv_circle;\ninv_circle.center = vec2(sin(iTime) * 0.5, cos(iTime * 0.7) * 0.5);\ninv_circle.radius = 1.0 + 0.3 * sin(iTime * 1.3);\n\n// Compute inversion\nvec2 p_inv = invert(p, inv_circle);\n\n  \n  \n  \n\n\nAs the circle moves and breathes, the inverted grid warps and flows.\n\n\n\n\nThe Apollonian gasket is a classical fractal arising from circle packing. It’s named after Apollonius of Perga (~200 BCE), who studied the problem of finding circles tangent to three given circles.\n\n\nStart with four mutually tangent circles: three “inner” circles that touch each other pairwise, all enclosed by one “outer” circle that touches all three.\nLet’s define these circles using our Circle struct. We’ll place three circles of radius \\(r\\) with centers forming an equilateral triangle, all tangent to each other and to an outer circle:\n// Three inner circles, mutually tangent, plus outer circle\n// For circles of radius r to be mutually tangent, their centers\n// must be 2r apart. This forms an equilateral triangle with side 2r.\nfloat r = 1.0;\nfloat triSide = 2.0 * r;  // distance between inner circle centers\nfloat circumradius = triSide / sqrt(3.0);  // distance from origin to centers\n\nCircle c1 = Circle(vec2(0.0, circumradius), r);\nCircle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\nCircle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\nCircle outer = Circle(vec2(0.0, 0.0), circumradius + r);\nTo draw these circles, we need a distance function:\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\nThis returns the distance from p to the circle’s boundary—zero on the circle, positive elsewhere.\nLet’s draw our starting configuration:\nvec3 color = vec3(0.1, 0.1, 0.15);\n\n// Draw all four circles\nif (distToCircle(p, c1) &lt; 0.03) color = vec3(1.0, 0.3, 0.3);\nif (distToCircle(p, c2) &lt; 0.03) color = vec3(0.3, 1.0, 0.3);\nif (distToCircle(p, c3) &lt; 0.03) color = vec3(0.3, 0.3, 1.0);\nif (distToCircle(p, outer) &lt; 0.03) color = vec3(1.0, 1.0, 1.0);\n\n  \n  \n  \n\n\nThree colored circles inside a white outer circle, all mutually tangent.\n\n\n\nThe gaps between circles are curvilinear triangles. The Apollonian gasket fills each gap with a circle tangent to its three neighbors, then fills the new gaps, and so on forever.\nHere’s the key insight: we can generate this structure by iterating inversions. If a point is inside one of the inner circles, invert through that circle—this “pushes” it out. If a point is outside the outer circle, invert through the outer circle—this “pulls” it in.\nWe need to check: - Is \\(\\mathbf{p}\\) inside circle c1, c2, or c3? (distance from center &lt; radius) - Is \\(\\mathbf{p}\\) outside circle outer? (distance from center &gt; radius)\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nbool isOutside(vec2 p, Circle c) {\n    return length(p - c.center) &gt; c.radius;\n}\nThe iteration: keep inverting until the point lands in a “gap” (inside outer, outside all inner circles) or we hit a maximum iteration count.\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;  // In the gap—done!\n        }\n    }\n    \n    // Color by iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Draw circle boundaries\n    float dMin = min(min(distToCircle(p, c1), distToCircle(p, c2)), \n                     min(distToCircle(p, c3), distToCircle(p, outer)));\n    if (dMin &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\n\n\n\nThe limit set of the Apollonian gasket is the fractal boundary—the set of points that never escape to the fundamental domain, no matter how many iterations. Points near the limit set take many iterations before landing in a gap.\nWe can emphasize the limit set by adjusting our coloring. Instead of using a color palette, we use a nonlinear function that suppresses low iteration counts (the “background”) and brightens high iteration counts (near the fractal):\nfloat t = float(iter) / float(max_iter);\nvec3 color = 30.0 * vec3(pow(t, 2.0));\nThe squaring suppresses points that escape quickly, while the factor of 30 boosts the brightness of points near the limit set.\n\n  \n  \n  \n\n\n\n\n\n\n\n\nC1. Julia Set. Modify the Mandelbrot shader to render a Julia set. Fix c = vec2(-0.7, 0.27015) and initialize z from the pixel position instead of zero. Verify you get an intricate, connected fractal.\nC2. Cubic Mandelbrot. Change the iteration from \\(z^2 + c\\) to \\(z^3 + c\\). You’ll need to implement complex cubing:\nvec2 ccube(vec2 z) {\n    return cmul(cmul(z, z), z);\n}\nWhat symmetry do you observe?\nC3. Apollonian Animation. Animate the Apollonian gasket by letting the maximum iteration count grow with time. Use int max_iter = int(mod(iTime * 5.0, 50.0)) + 1; so the fractal “builds up” from the four starting circles to the full gasket, then resets. Watch how each iteration reveals a new layer of circles in the gaps.\nC4. Colorize a Fractal. Take any of the black-and-white fractals from today (Mandelbrot, Julia, Burning Ship, or Apollonian) and add color using the cosine palette:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nExperiment with different values of d to shift the hues.\nC5. Circle Art. Create an image with several circles of different sizes scattered across the screen. Color a pixel based on whether it’s inside zero, one, two, or more circles. (Hint: use isInside and count how many circles contain each point.)\n\n\n\nE1. Julia Explorer (Mouse). Make the Julia parameter c follow the mouse position. Map iMouse.xy to a reasonable region of the complex plane (say, \\([-2, 2] \\times [-2, 2]\\)). Drag around and watch the Julia set morph!\nE2. Julia Animation. Animate the parameter c along a path in the complex plane. Try a circle:\nfloat angle = iTime * 0.3;\nvec2 c = 0.7885 * vec2(cos(angle), sin(angle));\nOr trace the boundary of the main cardioid of the Mandelbrot set—every point on this curve gives a Julia set with a parabolic fixed point:\nvec2 cardioid(float t) {\n    vec2 eit = vec2(cos(t), sin(t));\n    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;\n    return cmul(eit, z);\n}\n\nvec2 c = cardioid(iTime * 0.5);\nWatch the Julia set continuously transform. What happens when c crosses from inside to outside the Mandelbrot set?\nE3. Other Escape-Time Fractals. Implement one or more of these variations on the Mandelbrot iteration:\n\nBurning Ship: \\(z \\leftarrow z^2\\), then \\(\\text{Im}(z) \\leftarrow |\\text{Im}(z)|\\), then \\(z \\leftarrow z + c\\)\nTricorn (Mandelbar): \\(z_{n+1} = \\bar{z}_n^2 + c\\) where \\(\\bar{z}\\) is the complex conjugate\nCeltic: \\(z_{n+1} = |\\text{Re}(z_n^2)| + i\\,\\text{Im}(z_n^2) + c\\)\n\nFor each, figure out how to translate the mathematical formula into GLSL. The escape condition (\\(|z| &gt; 2\\)) stays the same.\nE4. Smooth Coloring. The iteration count is an integer, so coloring by iteration gives discrete bands. But when a point escapes, it doesn’t land exactly on the escape radius—it overshoots. We can use how much it overshot to interpolate between iteration counts.\nThe idea: if \\(|z_n| &gt; 2\\), the “true” fractional iteration where \\(|z| = 2\\) is approximately: \\[n_{\\text{smooth}} = n - \\frac{\\log(\\log|z_n|/\\log 2)}{\\log 2}\\]\nThis comes from the fact that near escape, \\(|z_{n+1}| \\approx |z_n|^2\\), so \\(\\log|z|\\) roughly doubles each iteration.\nImplement this for the Mandelbrot set:\nif (iter &lt; max_iter) {\n    float log_zn = log(cabs2(z)) / 2.0;  // log|z|\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    t = smooth_iter / float(max_iter);\n}\nThe bands should disappear, replaced by smooth gradients.\nE5. Apollonian Coloring. Modify the Apollonian gasket to color by which circle was last inverted through, instead of iteration count. Use a different color for each of the four circles. What patterns emerge?\nE6. Apollonian Variations. The Apollonian gasket works with any four mutually tangent circles—the symmetric configuration we used is just one example. Descartes’ Circle Theorem tells us: if four circles are mutually tangent with curvatures \\(k_1, k_2, k_3, k_4\\) (where curvature = 1/radius, negative for the outer circle), then: \\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\\] Experiment with different configurations: - Change the radii of the three inner circles (they don’t have to be equal!) - Use Descartes’ theorem to find an outer circle tangent to three given inner circles - What happens if the circles overlap instead of being tangent?\n\n\n\nH1. Julia Explorer (Full). Build an interactive tool: display the Mandelbrot set, and wherever the user clicks, show the Julia set for that parameter overlaid or side-by-side. This requires: - Rendering Mandelbrot in one region - Reading click position from iMouse - Rendering Julia for that c in another region (or blended on top)\nH2. Newton Fractal. The Newton fractal comes from applying Newton’s method to find roots of a polynomial. For \\(f(z) = z^3 - 1\\), Newton’s iteration is: \\[z_{n+1} = z_n - \\frac{f(z_n)}{f'(z_n)} = z_n - \\frac{z_n^3 - 1}{3z_n^2} = \\frac{2z_n^3 + 1}{3z_n^2}\\] Iterate this and color based on which root the orbit converges to (the three cube roots of unity: \\(1\\), \\(e^{2\\pi i/3}\\), \\(e^{4\\pi i/3}\\)). Check convergence by testing if \\(|z^3 - 1| &lt; \\epsilon\\).\nH3. Higher-Power Mandelbrot. Implement \\(z^n + c\\) for general \\(n\\). Use the polar form: if \\(z = re^{i\\theta}\\), then \\(z^n = r^n e^{in\\theta}\\). In code:\nvec2 cpow(vec2 z, float n) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    float rn = pow(r, n);\n    return rn * vec2(cos(n * theta), sin(n * theta));\n}\nTry non-integer values of \\(n\\)! What happens at \\(n = 2.5\\)?\n\n\n\nProject 1: Grid of Julia Sets\nCreate a grid where each cell shows the Julia set for a different value of \\(c\\). The position in the grid determines \\(c\\)—effectively, each cell samples a point in the Mandelbrot parameter space.\nWhen you zoom out, the overall pattern should reveal the Mandelbrot set: cells with connected Julia sets (solid regions) correspond to \\(c \\in \\mathcal{M}\\), while cells with dust-like Julia sets correspond to \\(c \\notin \\mathcal{M}\\).\nUse the grid technique from Day 1:\nfloat grid_size = 8.0;\nvec2 cell_id = floor((p + 2.0) * grid_size / 4.0);\nvec2 cell_p = fract((p + 2.0) * grid_size / 4.0) * 4.0 - 2.0;\n\n// c comes from which cell we're in\nvec2 c = (cell_id / grid_size) * 4.0 - 2.0;\n\n// z starts from position within the cell\nvec2 z = cell_p;\nProject 2: Orbit Visualization\nInstead of just coloring by iteration count, visualize the actual orbit of a point. Make the starting point draggable with the mouse:\n\nLet \\(z_0\\) be the mouse position (normalized to the complex plane)\nFix a parameter \\(c\\) (or let it be controllable too)\nCompute the first \\(N\\) iterates: \\(z_0, z_1, z_2, \\ldots, z_N\\)\nDraw small circles at each iterate position\nConnect consecutive iterates with lines (use the segment SDF from Day 1!)\nColor by iteration index (early iterates one color, later iterates another)\n\nThis reveals the dynamics directly: bounded orbits stay in a region and may converge to a cycle, while escaping orbits spiral outward. Drag the starting point around and watch how the orbit changes—you’ll see the sensitive dependence on initial conditions that makes chaos!\nFor Julia sets, fix c and drag z_0. For the Mandelbrot perspective, fix z_0 = 0 and drag c.",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#overview",
    "href": "lectures/day2.html#overview",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "Today we’ll learn how to do per-pixel computation in shaders, to quickly produce images of compelx mathematical objects. In the homework today, you’ll create your own version of the classic mandelbrot fractal zoom:\n\n  \n  \n  \n\n\nToday we explore two kinds of iterative systems:\n\nComplex dynamics: Iterating holomorphic maps gives us the Mandelbrot set, Julia sets, and their cousins\nCircle inversion: Iterating geometric transformations gives us the Apollonian gasket\n\nBoth share the same GPU-friendly structure: each pixel asks “what happens when I iterate from here?” No pixel depends on any other—perfect for parallel computation.\nAlong the way, we’ll learn to implement complex arithmetic in GLSL and organize geometric data using structs.",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#complex-numbers-in-glsl",
    "href": "lectures/day2.html#complex-numbers-in-glsl",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "The complex numbers \\(\\mathbb{C}\\) are the plane equipped with a multiplication operation. Today we implement that algebra in GLSL.\n\n\nA complex number \\(z = a + bi\\) is naturally represented as a 2D vector:\nvec2 z = vec2(a, b);  // represents a + bi\nWe’ll consistently use the convention that z.x is the real part and z.y is the imaginary part.\n\n\n\nAddition of complex numbers is componentwise—exactly what GLSL’s built-in + does for vectors. No helper function needed.\nMultiplication is more interesting. In GLSL, the * operator on vectors is componentwise: vec2(a,b) * vec2(c,d) gives vec2(a*c, b*d). This is not complex multiplication! We need to implement the correct formula ourselves.\nRecall \\((a + bi)(c + di) = (ac - bd) + (ad + bc)i\\):\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\nThis is the FOIL pattern with \\(i^2 = -1\\) giving the minus sign in the real part.\n\n\n\nThe magnitude of \\(z = a + bi\\) is the distance from the origin: \\[|z| = \\sqrt{a^2 + b^2}\\]\nWe can implement this directly:\nfloat cabs(vec2 z) {\n    return sqrt(z.x * z.x + z.y * z.y);\n}\nBut consider: we’ll often have conditions like “is \\(|z|\\) bigger than 2?” rather than needing the actual magnitude. In these cases, we can check \\(|z|^2 &gt; 4\\) instead of \\(|z| &gt; 2\\)—same answer, but no square root. When you’re doing this check millions of times per frame (once per pixel, 60 frames per second), avoiding unnecessary square roots adds up.\nSo we define the squared magnitude:\nfloat cabs2(vec2 z) {\n    return z.x * z.x + z.y * z.y;\n}\nIf we want to be even more efficient, we can use GLSL’s built-in dot product, which computes exactly this sum of products:\nfloat cabs2(vec2 z) {\n    return dot(z, z);  // a² + b²\n}",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-mandelbrot-set",
    "href": "lectures/day2.html#the-mandelbrot-set",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "The Mandelbrot set is perhaps the most iconic fractal—its shape is instantly recognizable, and its discovery in 1980 helped launch the era of computer-generated mathematical visualization. The definition is remarkably simple.\n\n\nFix a complex number \\(c\\). Starting from \\(z_0 = 0\\), define a sequence by iterating: \\[z_{n+1} = z_n^2 + c\\]\nFor some values of \\(c\\), this sequence stays bounded forever. For others, it escapes to infinity. The Mandelbrot set \\(\\mathcal{M}\\) is the set of all \\(c\\) for which the sequence remains bounded.\nThat’s it! One quadratic formula, iterated. The intricate structure of the Mandelbrot set emerges entirely from this simple rule.\n\n\n\nTo draw the Mandelbrot set, we test each pixel: is this value of \\(c\\) in \\(\\mathcal{M}\\) or not?\nThis is exactly the kind of question shaders excel at. Each pixel performs its own independent calculation—no pixel needs information from any other pixel. The entire image can be computed in parallel, with thousands of GPU cores each testing their own value of \\(c\\) simultaneously.\nBut there’s a problem: the definition involves iterating “forever” and checking if the sequence “stays bounded.” We can’t iterate infinitely, and we can’t wait forever to decide. We need a practical criterion for when to stop.\n\n\n\nWe need two facts that make efficient rendering possible.\nFact 1. The Mandelbrot set is contained in the disk of radius 2. That is, if \\(|c| &gt; 2\\), then \\(c \\notin \\mathcal{M}\\).\nProof. [TODO] \\(\\square\\)\nFact 2. If \\(|c| \\leq 2\\) and \\(|z_n| &gt; 2\\) for some \\(n\\), then the orbit escapes to infinity (so \\(c \\notin \\mathcal{M}\\)).\nProof. [TODO] \\(\\square\\)\nThis gives us a stopping criterion: once \\(|z_n| &gt; 2\\), we know \\(c\\) is not in the Mandelbrot set. We don’t need to keep iterating.\nTogether, these facts justify the escape-time algorithm: iterate until either \\(|z_n| &gt; 2\\) (escaped, not in \\(\\mathcal{M}\\)) or we hit a maximum iteration count (probably in \\(\\mathcal{M}\\)).\n\n\n\nThese two facts give us our algorithm:\n\nFor each pixel, let \\(c\\) be the corresponding complex number\nStart with \\(z = 0\\)\nIterate \\(z \\mapsto z^2 + c\\)\nIf \\(|z| &gt; 2\\), stop—this point escapes (not in \\(\\mathcal{M}\\))\nIf we reach a maximum iteration count without escaping, assume bounded (in \\(\\mathcal{M}\\))\n\nThe core of this is a loop:\nvec2 z = vec2(0.0, 0.0);\nint max_iter = 100;\nint iter;\n\nfor (iter = 0; iter &lt; max_iter; iter++) {\n    if (cabs2(z) &gt; 4.0) break;  // |z|² &gt; 4 means |z| &gt; 2\n    z = cmul(z, z) + c;\n}\nAfter this loop, iter tells us what happened: if iter == max_iter, we never escaped (probably in \\(\\mathcal{M}\\)). Otherwise, we escaped on iteration iter.\n\n\n\nThe simplest approach: color points black if they’re in the set, white if they escaped.\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);  // In the set: black\n} else {\n    color = vec3(1.0);  // Escaped: white\n}\n\n\n\nPutting it together with our coordinate setup:\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat cabs2(vec2 z) {\n    return dot(z, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Coordinate setup\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Scale and center to show the Mandelbrot set\n    // By Fact 1, the set lies in |c| ≤ 2\n    vec2 c = uv * 4.0;\n    c.x -= 0.5;  // shift left to center the interesting part\n    \n    // Mandelbrot iteration\n    vec2 z = vec2(0.0, 0.0);\n    int max_iter = 100;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (cabs2(z) &gt; 4.0) break;\n        z = cmul(z, z) + c;\n    }\n    \n    // Binary coloring\n    vec3 color;\n    if (iter == max_iter) {\n        color = vec3(0.0);  // In the set: black\n    } else {\n        color = vec3(1.0);  // Escaped: white\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nThere it is—the Mandelbrot set in black and white!\n\n\n\nBlack and white shows the set, but we’re throwing away information. The number of iterations before escape tells us how “close” a point is to the boundary—points that escape after 5 iterations are different from points that escape after 50.\nLet’s use iter to create a gradient:\nvec3 color;\nif (iter == max_iter) {\n    color = vec3(0.0);\n} else {\n    float t = float(iter) / float(max_iter);\n    color = vec3(t);\n}\n\n  \n  \n  \n\n\nNow we see structure! The boundary reveals intricate detail—tendrils, spirals, bulbs. Points near the boundary take many iterations to escape (bright), while points far away escape quickly (dark).\n\n\n\nGrayscale works, but we can do better. A common technique uses cosines to create smooth, cycling color palettes:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nThe parameters a, b, c, d control the palette’s character. The vector d shifts the phase of each color channel, creating different hues. Try d = vec3(0.00, 0.10, 0.20) for blues and purples, or d = vec3(0.30, 0.20, 0.20) for warmer tones.\n\n  \n  \n  \n\n\nThe color bands correspond to iteration counts—regions of the same color escaped after the same number of iterations. You’ll notice the bands have sharp edges. In the exercises, we’ll show you a technique called smooth coloring that interpolates between iteration counts, eliminating the banding for even smoother gradients.",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#other-escape-time-fractals",
    "href": "lectures/day2.html#other-escape-time-fractals",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "The Mandelbrot set is one example of an escape-time fractal, but the same algorithm works for many other iterated systems. We just swap out the iteration formula (and sometimes the escape condition). Let’s explore a few.\n\n\nThe Mandelbrot set asks: for which values of \\(c\\) does the orbit of \\(0\\) stay bounded? We can ask a different question: for a fixed \\(c\\), which starting points \\(z_0\\) have bounded orbits?\nFix a complex number \\(c\\). The filled Julia set \\(K_c\\) is the set of all starting points \\(z_0\\) for which the iteration \\[z_{n+1} = z_n^2 + c\\] remains bounded.\nSame iteration, different question. For the Mandelbrot set, we vary \\(c\\) and always start at \\(z_0 = 0\\). For a Julia set, we fix \\(c\\) and vary \\(z_0\\).\nThe code change is minimal:\n// Mandelbrot: c varies, z starts at 0\nvec2 c = p;\nvec2 z = vec2(0.0, 0.0);\n\n// Julia: c is fixed, z starts at pixel position\nvec2 c = vec2(-0.7, 0.27015);  // fixed parameter\nvec2 z = p;\n\n  \n  \n  \n\n\nDifferent values of \\(c\\) produce dramatically different Julia sets. In the exercises, you’ll build an interactive explorer that lets you click anywhere on the Mandelbrot set to see the corresponding Julia set:\n\n  \n  \n  \n\n\n\n\n\nThe Mandelbrot set uses \\(z^2 + c\\). What about \\(z^3 + c\\)? Or \\(z^4 + c\\)?\nFor \\(z^3\\), we can compose our existing cmul function:\nvec2 ccube(vec2 z) {\n    return cmul(cmul(z, z), z);  // z · z · z\n}\nHigher powers give higher-order rotational symmetry: \\(z^3 + c\\) has 3-fold symmetry, \\(z^4 + c\\) has 4-fold symmetry, and so on.\nFor some more variety, the Burning Ship fractal modifies the Mandelbrot iteration by taking the absolute value of the imaginary part after each squaring:\n\\[z_{n+1} = (\\text{Re}(z_n^2) + i|\\text{Im}(z_n^2)|) + c\\]\n\n\n\nAll these fractals share the same structure:\n\nIterate some function \\(f(z, c)\\)\nCheck escape: has \\(|z|\\) exceeded some threshold?\nColor based on iteration count\n\nChanging the iteration function changes the fractal. The exercises include more variations for you to try.",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#circle-inversion",
    "href": "lectures/day2.html#circle-inversion",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "We shift gears from complex dynamics to geometric transformations. Circle inversion is a classical operation that turns circles into circles (or lines), preserves angles, and creates beautiful fractal patterns when iterated.\n\n\nInversion in the unit circle maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\frac{\\mathbf{p}}{|\\mathbf{p}|^2}\\]\nWhat does this do geometrically? The inverted point lies on the same ray from the origin as \\(\\mathbf{p}\\), but at distance \\(1/r\\) instead of \\(r\\).\n\nPoints inside the unit circle map to points outside\nPoints outside map to points inside\n\nPoints on the unit circle stay fixed\nThe origin maps to “infinity”\n\n\n\n\nvec2 invert(vec2 p) {\n    return p / dot(p, p);\n}\n\n\n\nTo see what inversion does, let’s draw some shapes and their images. We’ll draw the unit circle (gray), plus a vertical line and a circle (yellow). To make it clearer, we’ll toggle between showing the original shapes and their inversions:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 4.0;\n    \n    // Compute the inversion of p\n    vec2 p_inv = invert(p);\n    \n    // Toggle between original and inverted every second\n    float time = fract(iTime * 0.5);\n    vec2 q;\n    if (time &lt; 0.5) {\n        q = p;      // original\n    } else {\n        q = p_inv;  // inverted\n    }\n    \n    vec3 color = vec3(0.1, 0.1, 0.15);\n    \n    // Draw the unit circle (the inversion circle)\n    float d_unit = abs(length(p) - 1.0);\n    if (d_unit &lt; 0.02) color = vec3(0.5, 0.5, 0.5);\n    \n    // Draw a vertical line at x = 2\n    if (abs(q.x - 2.0) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a horizontal line at y = 1.5\n    if (abs(q.y - 1.5) &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    // Draw a circle centered at (2, 0) with radius 0.5\n    float d_circle = abs(length(q - vec2(2.0, 0.0)) - 0.5);\n    if (d_circle &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\nWatch the lines become circles! A line not passing through the origin inverts to a circle that does pass through the origin. The circle inverts to another circle (with a different center and radius).\n\n\n\n\n\n\nTipGLSL Shortcuts: mix and step\n\n\n\nThe toggle logic can be written more compactly using built-in functions:\n\nstep(edge, x) returns 0 if x &lt; edge, otherwise 1\nmix(a, b, t) linearly interpolates: returns a when t = 0, b when t = 1\n\nfloat t = step(0.5, fract(iTime * 0.5));\nvec2 q = mix(p, p_inv, t);\nThis is a common pattern for toggling or smoothly transitioning between states.\n\n\n\n\n\nCircle inversion maps circles to circles (or to lines, if the circle passes through the center). It’s conformal—it preserves angles between curves. And it’s involutive: applying inversion twice returns to the original point.\n\n\n\nFor a more dramatic visualization, let’s invert a whole grid of lines. The function mod(q, 0.5) gives the position of q within a repeating \\(0.5 \\times 0.5\\) cell—when either component is near zero, we’re on a grid line:\nvec2 grid = mod(q, 0.5);\nif (grid.x &lt; 0.02 || grid.y &lt; 0.02) color = vec3(1.0, 1.0, 0.0);\n(If you did the grid project from Day 1, this is familiar!)\nUsing the same toggle shader structure as before, just replacing the individual shapes with this grid:",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#structs",
    "href": "lectures/day2.html#structs",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "So far our invert function only works for the unit circle at the origin. What if we want to invert through a different circle?\n\n\nFor a circle with center \\(\\mathbf{c}\\) and radius \\(R\\), inversion maps a point \\(\\mathbf{p}\\) to:\n\\[\\text{inv}(\\mathbf{p}) = \\mathbf{c} + R^2 \\frac{\\mathbf{p} - \\mathbf{c}}{|\\mathbf{p} - \\mathbf{c}|^2}\\]\nThe idea is the same as before: the inverted point lies on the ray from \\(\\mathbf{c}\\) through \\(\\mathbf{p}\\), at distance \\(R^2/r\\) from the center (where \\(r = |\\mathbf{p} - \\mathbf{c}|\\)). When \\(\\mathbf{c} = \\mathbf{0}\\) and \\(R = 1\\), this reduces to our earlier formula \\(\\mathbf{p}/|\\mathbf{p}|^2\\).\nIn code:\nvec2 invertInCircle(vec2 p, vec2 center, float radius) {\n    vec2 d = p - center;\n    return center + radius * radius * d / dot(d, d);\n}\nThis works, but notice we need to pass two things (center and radius) to describe one object (a circle). If we’re working with multiple circles, every function call needs center1, radius1, center2, radius2, ...—it gets verbose and error-prone.\n\n\n\nGLSL lets us bundle related data into a struct:\nstruct Circle {\n    vec2 center;\n    float radius;\n};\nNow Circle is a type, just like vec2 or float. We can create circles and access their fields:\nCircle c;\nc.center = vec2(1.0, 0.5);\nc.radius = 0.7;\n\n// Or initialize directly:\nCircle c = Circle(vec2(1.0, 0.5), 0.7);\n\n\n\nNow our inversion function takes a Circle:\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\nMuch cleaner! And when we’re working with multiple circles, we can pass them around as single objects.\n\n\n\nLet’s animate a circle moving around and watch how the inversion changes. The key new elements are animating the circle’s center and radius:\n// Animate the inversion circle\nCircle inv_circle;\ninv_circle.center = vec2(sin(iTime) * 0.5, cos(iTime * 0.7) * 0.5);\ninv_circle.radius = 1.0 + 0.3 * sin(iTime * 1.3);\n\n// Compute inversion\nvec2 p_inv = invert(p, inv_circle);\n\n  \n  \n  \n\n\nAs the circle moves and breathes, the inverted grid warps and flows.",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#the-apollonian-gasket",
    "href": "lectures/day2.html#the-apollonian-gasket",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "The Apollonian gasket is a classical fractal arising from circle packing. It’s named after Apollonius of Perga (~200 BCE), who studied the problem of finding circles tangent to three given circles.\n\n\nStart with four mutually tangent circles: three “inner” circles that touch each other pairwise, all enclosed by one “outer” circle that touches all three.\nLet’s define these circles using our Circle struct. We’ll place three circles of radius \\(r\\) with centers forming an equilateral triangle, all tangent to each other and to an outer circle:\n// Three inner circles, mutually tangent, plus outer circle\n// For circles of radius r to be mutually tangent, their centers\n// must be 2r apart. This forms an equilateral triangle with side 2r.\nfloat r = 1.0;\nfloat triSide = 2.0 * r;  // distance between inner circle centers\nfloat circumradius = triSide / sqrt(3.0);  // distance from origin to centers\n\nCircle c1 = Circle(vec2(0.0, circumradius), r);\nCircle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\nCircle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\nCircle outer = Circle(vec2(0.0, 0.0), circumradius + r);\nTo draw these circles, we need a distance function:\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\nThis returns the distance from p to the circle’s boundary—zero on the circle, positive elsewhere.\nLet’s draw our starting configuration:\nvec3 color = vec3(0.1, 0.1, 0.15);\n\n// Draw all four circles\nif (distToCircle(p, c1) &lt; 0.03) color = vec3(1.0, 0.3, 0.3);\nif (distToCircle(p, c2) &lt; 0.03) color = vec3(0.3, 1.0, 0.3);\nif (distToCircle(p, c3) &lt; 0.03) color = vec3(0.3, 0.3, 1.0);\nif (distToCircle(p, outer) &lt; 0.03) color = vec3(1.0, 1.0, 1.0);\n\n  \n  \n  \n\n\nThree colored circles inside a white outer circle, all mutually tangent.\n\n\n\nThe gaps between circles are curvilinear triangles. The Apollonian gasket fills each gap with a circle tangent to its three neighbors, then fills the new gaps, and so on forever.\nHere’s the key insight: we can generate this structure by iterating inversions. If a point is inside one of the inner circles, invert through that circle—this “pushes” it out. If a point is outside the outer circle, invert through the outer circle—this “pulls” it in.\nWe need to check: - Is \\(\\mathbf{p}\\) inside circle c1, c2, or c3? (distance from center &lt; radius) - Is \\(\\mathbf{p}\\) outside circle outer? (distance from center &gt; radius)\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nbool isOutside(vec2 p, Circle c) {\n    return length(p - c.center) &gt; c.radius;\n}\nThe iteration: keep inverting until the point lands in a “gap” (inside outer, outside all inner circles) or we hit a maximum iteration count.\n\n\n\nstruct Circle {\n    vec2 center;\n    float radius;\n};\n\nvec2 invert(vec2 p, Circle c) {\n    vec2 d = p - c.center;\n    return c.center + c.radius * c.radius * d / dot(d, d);\n}\n\nfloat distToCircle(vec2 p, Circle c) {\n    return abs(length(p - c.center) - c.radius);\n}\n\nbool isInside(vec2 p, Circle c) {\n    return length(p - c.center) &lt; c.radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 p = uv * 6.0;\n    \n    // Setup circles with correct geometry\n    float r = 1.0;\n    float triSide = 2.0 * r;\n    float circumradius = triSide / sqrt(3.0);\n    \n    Circle c1 = Circle(vec2(0.0, circumradius), r);\n    Circle c2 = Circle(vec2(-circumradius * 0.866, -circumradius * 0.5), r);\n    Circle c3 = Circle(vec2(circumradius * 0.866, -circumradius * 0.5), r);\n    Circle outer = Circle(vec2(0.0, 0.0), circumradius + r);\n    \n    // Iterate inversions\n    int max_iter = 50;\n    int iter;\n    \n    for (iter = 0; iter &lt; max_iter; iter++) {\n        if (isInside(p, c1)) {\n            p = invert(p, c1);\n        } else if (isInside(p, c2)) {\n            p = invert(p, c2);\n        } else if (isInside(p, c3)) {\n            p = invert(p, c3);\n        } else if (!isInside(p, outer)) {\n            p = invert(p, outer);\n        } else {\n            break;  // In the gap—done!\n        }\n    }\n    \n    // Color by iteration count\n    float t = float(iter) / float(max_iter);\n    vec3 color = palette(t);\n    \n    // Draw circle boundaries\n    float dMin = min(min(distToCircle(p, c1), distToCircle(p, c2)), \n                     min(distToCircle(p, c3), distToCircle(p, outer)));\n    if (dMin &lt; 0.02) color = vec3(1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n  \n  \n  \n\n\n\n\n\nThe limit set of the Apollonian gasket is the fractal boundary—the set of points that never escape to the fundamental domain, no matter how many iterations. Points near the limit set take many iterations before landing in a gap.\nWe can emphasize the limit set by adjusting our coloring. Instead of using a color palette, we use a nonlinear function that suppresses low iteration counts (the “background”) and brightens high iteration counts (near the fractal):\nfloat t = float(iter) / float(max_iter);\nvec3 color = 30.0 * vec3(pow(t, 2.0));\nThe squaring suppresses points that escape quickly, while the factor of 30 boosts the brightness of points near the limit set.",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day2.html#exercises",
    "href": "lectures/day2.html#exercises",
    "title": "1 Day 2: Dynamics",
    "section": "",
    "text": "C1. Julia Set. Modify the Mandelbrot shader to render a Julia set. Fix c = vec2(-0.7, 0.27015) and initialize z from the pixel position instead of zero. Verify you get an intricate, connected fractal.\nC2. Cubic Mandelbrot. Change the iteration from \\(z^2 + c\\) to \\(z^3 + c\\). You’ll need to implement complex cubing:\nvec2 ccube(vec2 z) {\n    return cmul(cmul(z, z), z);\n}\nWhat symmetry do you observe?\nC3. Apollonian Animation. Animate the Apollonian gasket by letting the maximum iteration count grow with time. Use int max_iter = int(mod(iTime * 5.0, 50.0)) + 1; so the fractal “builds up” from the four starting circles to the full gasket, then resets. Watch how each iteration reveals a new layer of circles in the gaps.\nC4. Colorize a Fractal. Take any of the black-and-white fractals from today (Mandelbrot, Julia, Burning Ship, or Apollonian) and add color using the cosine palette:\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\nExperiment with different values of d to shift the hues.\nC5. Circle Art. Create an image with several circles of different sizes scattered across the screen. Color a pixel based on whether it’s inside zero, one, two, or more circles. (Hint: use isInside and count how many circles contain each point.)\n\n\n\nE1. Julia Explorer (Mouse). Make the Julia parameter c follow the mouse position. Map iMouse.xy to a reasonable region of the complex plane (say, \\([-2, 2] \\times [-2, 2]\\)). Drag around and watch the Julia set morph!\nE2. Julia Animation. Animate the parameter c along a path in the complex plane. Try a circle:\nfloat angle = iTime * 0.3;\nvec2 c = 0.7885 * vec2(cos(angle), sin(angle));\nOr trace the boundary of the main cardioid of the Mandelbrot set—every point on this curve gives a Julia set with a parabolic fixed point:\nvec2 cardioid(float t) {\n    vec2 eit = vec2(cos(t), sin(t));\n    vec2 z = (vec2(2.0, 0.0) - eit) / 4.0;\n    return cmul(eit, z);\n}\n\nvec2 c = cardioid(iTime * 0.5);\nWatch the Julia set continuously transform. What happens when c crosses from inside to outside the Mandelbrot set?\nE3. Other Escape-Time Fractals. Implement one or more of these variations on the Mandelbrot iteration:\n\nBurning Ship: \\(z \\leftarrow z^2\\), then \\(\\text{Im}(z) \\leftarrow |\\text{Im}(z)|\\), then \\(z \\leftarrow z + c\\)\nTricorn (Mandelbar): \\(z_{n+1} = \\bar{z}_n^2 + c\\) where \\(\\bar{z}\\) is the complex conjugate\nCeltic: \\(z_{n+1} = |\\text{Re}(z_n^2)| + i\\,\\text{Im}(z_n^2) + c\\)\n\nFor each, figure out how to translate the mathematical formula into GLSL. The escape condition (\\(|z| &gt; 2\\)) stays the same.\nE4. Smooth Coloring. The iteration count is an integer, so coloring by iteration gives discrete bands. But when a point escapes, it doesn’t land exactly on the escape radius—it overshoots. We can use how much it overshot to interpolate between iteration counts.\nThe idea: if \\(|z_n| &gt; 2\\), the “true” fractional iteration where \\(|z| = 2\\) is approximately: \\[n_{\\text{smooth}} = n - \\frac{\\log(\\log|z_n|/\\log 2)}{\\log 2}\\]\nThis comes from the fact that near escape, \\(|z_{n+1}| \\approx |z_n|^2\\), so \\(\\log|z|\\) roughly doubles each iteration.\nImplement this for the Mandelbrot set:\nif (iter &lt; max_iter) {\n    float log_zn = log(cabs2(z)) / 2.0;  // log|z|\n    float nu = log(log_zn / log(2.0)) / log(2.0);\n    float smooth_iter = float(iter) + 1.0 - nu;\n    t = smooth_iter / float(max_iter);\n}\nThe bands should disappear, replaced by smooth gradients.\nE5. Apollonian Coloring. Modify the Apollonian gasket to color by which circle was last inverted through, instead of iteration count. Use a different color for each of the four circles. What patterns emerge?\nE6. Apollonian Variations. The Apollonian gasket works with any four mutually tangent circles—the symmetric configuration we used is just one example. Descartes’ Circle Theorem tells us: if four circles are mutually tangent with curvatures \\(k_1, k_2, k_3, k_4\\) (where curvature = 1/radius, negative for the outer circle), then: \\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\\] Experiment with different configurations: - Change the radii of the three inner circles (they don’t have to be equal!) - Use Descartes’ theorem to find an outer circle tangent to three given inner circles - What happens if the circles overlap instead of being tangent?\n\n\n\nH1. Julia Explorer (Full). Build an interactive tool: display the Mandelbrot set, and wherever the user clicks, show the Julia set for that parameter overlaid or side-by-side. This requires: - Rendering Mandelbrot in one region - Reading click position from iMouse - Rendering Julia for that c in another region (or blended on top)\nH2. Newton Fractal. The Newton fractal comes from applying Newton’s method to find roots of a polynomial. For \\(f(z) = z^3 - 1\\), Newton’s iteration is: \\[z_{n+1} = z_n - \\frac{f(z_n)}{f'(z_n)} = z_n - \\frac{z_n^3 - 1}{3z_n^2} = \\frac{2z_n^3 + 1}{3z_n^2}\\] Iterate this and color based on which root the orbit converges to (the three cube roots of unity: \\(1\\), \\(e^{2\\pi i/3}\\), \\(e^{4\\pi i/3}\\)). Check convergence by testing if \\(|z^3 - 1| &lt; \\epsilon\\).\nH3. Higher-Power Mandelbrot. Implement \\(z^n + c\\) for general \\(n\\). Use the polar form: if \\(z = re^{i\\theta}\\), then \\(z^n = r^n e^{in\\theta}\\). In code:\nvec2 cpow(vec2 z, float n) {\n    float r = length(z);\n    float theta = atan(z.y, z.x);\n    float rn = pow(r, n);\n    return rn * vec2(cos(n * theta), sin(n * theta));\n}\nTry non-integer values of \\(n\\)! What happens at \\(n = 2.5\\)?\n\n\n\nProject 1: Grid of Julia Sets\nCreate a grid where each cell shows the Julia set for a different value of \\(c\\). The position in the grid determines \\(c\\)—effectively, each cell samples a point in the Mandelbrot parameter space.\nWhen you zoom out, the overall pattern should reveal the Mandelbrot set: cells with connected Julia sets (solid regions) correspond to \\(c \\in \\mathcal{M}\\), while cells with dust-like Julia sets correspond to \\(c \\notin \\mathcal{M}\\).\nUse the grid technique from Day 1:\nfloat grid_size = 8.0;\nvec2 cell_id = floor((p + 2.0) * grid_size / 4.0);\nvec2 cell_p = fract((p + 2.0) * grid_size / 4.0) * 4.0 - 2.0;\n\n// c comes from which cell we're in\nvec2 c = (cell_id / grid_size) * 4.0 - 2.0;\n\n// z starts from position within the cell\nvec2 z = cell_p;\nProject 2: Orbit Visualization\nInstead of just coloring by iteration count, visualize the actual orbit of a point. Make the starting point draggable with the mouse:\n\nLet \\(z_0\\) be the mouse position (normalized to the complex plane)\nFix a parameter \\(c\\) (or let it be controllable too)\nCompute the first \\(N\\) iterates: \\(z_0, z_1, z_2, \\ldots, z_N\\)\nDraw small circles at each iterate position\nConnect consecutive iterates with lines (use the segment SDF from Day 1!)\nColor by iteration index (early iterates one color, later iterates another)\n\nThis reveals the dynamics directly: bounded orbits stay in a region and may converge to a cycle, while escaping orbits spiral outward. Drag the starting point around and watch how the orbit changes—you’ll see the sensitive dependence on initial conditions that makes chaos!\nFor Julia sets, fix c and drag z_0. For the Mandelbrot perspective, fix z_0 = 0 and drag c.",
    "crumbs": [
      "Day 2: Dynamics",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html",
    "href": "lectures/day1.html",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "By the end of today, you’ll be able to create things like this:\n\n  \n  \n  \n\n\nA family of elliptic curves \\(y^2 = x^3 + ax + b\\), drawn for several values of \\(a\\) simultaneously, with \\(b\\) varying across the screen. The curves shift in brightness to show the family structure, and you can watch singularities appear and disappear along the discriminant locus.\nThis image is computed in real time, every pixel evaluated independently on the GPU. To get here, we’ll learn:\n\nWhat a shader is: a function from coordinates to colors, evaluated in parallel\nHow to set up a coordinate system for mathematical visualization\nHow to draw shapes using distance functions\nHow to render implicit curves \\(F(x,y) = 0\\) with uniform thickness\nHow to add interactivity with mouse input\n\nLet’s begin.\n\n\n\nWe want to draw images on a screen.\nMathematically, an image is a function from a region \\(S \\subset \\mathbb{R}^2\\) to the space of visible colors \\(\\mathcal{C}\\). This color space is three-dimensional, spanned by the responses of the three types of cone cells in our eyes. A convenient basis, roughly aligned with these responses, is red, green, and blue.\nTo realize this on a computer, we discretize. A screen is a grid of pixels: \\(X\\) pixels wide, \\(Y\\) pixels tall. Each pixel is a point in the integer lattice \\[\\{0, 1, \\ldots, X-1\\} \\times \\{0, 1, \\ldots, Y-1\\}.\\]\nColors are represented as RGB triples: red, green, and blue intensities, each in \\([0,1]\\). The constraint to \\([0,1]\\) reflects physical reality—a pixel has a maximum brightness it can display. (We can’t draw the sun.) So an image is a function \\[f\\colon \\{0,\\ldots,X-1\\} \\times \\{0,\\ldots,Y-1\\} \\to [0,1]^3\\] \\[(i,j) \\mapsto (r,g,b).\\]\nIn practice, we add a fourth component: alpha, representing transparency. This matters when compositing multiple layers (we won’t use it in this course, but the machinery expects it). So our shader computes \\[f\\colon (i,j) \\mapsto (r,g,b,1).\\]\nThis is what a shader is. You write a function that takes pixel coordinates and returns an RGBA color. The GPU evaluates your function at every pixel to produce the image.\n\n\nA 1920×1080 display has over two million pixels. How do we evaluate \\(f\\) at all of them fast enough to animate at 60 frames per second?\nThe answer is parallelism. A GPU contains thousands of cores, and it evaluates \\(f\\) at all pixels simultaneously. There’s no loop over pixels in your code—you write \\(f\\), and the hardware handles the rest.\nThe tradeoff: each pixel’s computation must be independent. Pixel \\((100, 200)\\) cannot ask what color pixel \\((100, 199)\\) received. Every pixel sees the same global inputs—coordinates, time, mouse position—and must determine its color from those alone. Learning to think within this constraint is what shader programming is about.\n\n\n\n\n\n\nNoteWhy “shader”?\n\n\n\nThe name comes from 3D graphics, where these programs computed shading—how light interacts with surfaces. It stuck even though we now use shaders for fractals, simulations, and mathematical visualization.\n\n\n\n\n\nShader programming normally requires substantial setup: OpenGL contexts, buffer management, compilation, render loops. Shadertoy abstracts all of this—you write one function, press play, and see results. We’ll use it throughout the course.\n\n\n\n\n\n\nIn Shadertoy, your shader is a function called mainImage:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // your code here\n}\nThis function is called once per pixel, every frame. The inputs and outputs:\n\nfragCoord — the pixel coordinates, passed in to your function\nfragColor — the RGBA color, which you write out\n\nThe in and out keywords are explicit about data flow: fragCoord is read-only input, fragColor is where you write your result. The function returns void because the output goes through fragColor, not a return value.\n\n\n\nThe simplest shader: make every pixel red.\n\n  \n  \n  \n\n\nThe vec4(1.0, 0.0, 0.0, 1.0) constructs a 4-component vector: red=1, green=0, blue=0, alpha=1. Every pixel receives the same color, so the screen fills with red.\n\n\n\nGLSL (OpenGL Shading Language) will feel familiar if you’ve seen C-like syntax, but a few things are worth noting upfront.\nSemicolons are required at the end of each statement.\nFloats must include a decimal point. Write 1.0, not 1. The integer 1 and the float 1.0 are different types, and GLSL is strict about this.\nVector types are built in: vec2, vec3, vec4 for 2, 3, and 4 component vectors. Construct them with:\nvec2 p = vec2(3.0, 4.0);\nvec3 color = vec3(1.0, 0.5, 0.0);\nvec4 rgba = vec4(1.0, 0.0, 0.0, 1.0);\nArithmetic is component-wise. Adding two vectors adds their components:\nvec2(1.0, 2.0) + vec2(3.0, 4.0)  // = vec2(4.0, 6.0)\nScalar-vector operations apply the scalar to each component:\n2.0 * vec2(1.0, 3.0)  // = vec2(2.0, 6.0)\nAccessing components uses .x, .y, .z, .w:\nvec2 p = vec2(3.0, 4.0);\nfloat a = p.x;  // 3.0\nfloat b = p.y;  // 4.0\nFor colors, .r, .g, .b, .a are synonyms—color.r is the same as color.x.\nCommon math functions work as expected: sin, cos, abs, min, max, sqrt, pow. These operate on floats, and apply component-wise to vectors:\nsin(vec2(0.0, 3.14159))  // = vec2(0.0, ~0.0)\nFor loops work as you’d expect:\nfor (int i = 0; i &lt; 5; i++) {\n    // body executes with i = 0, 1, 2, 3, 4\n}\nThe loop variable is an int. Note that some older GPUs require the loop bounds to be constants known at compile time—you can’t always loop up to a variable. We’ll use loops extensively starting tomorrow.\n\n\n\nShadertoy provides uniforms—global values that are constant across all pixels. Unlike fragCoord, which takes a different value at each pixel, a uniform has the same value everywhere. They’re how external information (time, screen size, mouse position) gets into your shader.\n\n\n\n\n\n\n\n\nUniform\nType\nDescription\n\n\n\n\niResolution\nvec3\nViewport size: (width, height, pixel_aspect_ratio)\n\n\niTime\nfloat\nSeconds since the shader started\n\n\niMouse\nvec4\nMouse position and click state\n\n\n\nWe’ll use iResolution constantly (for coordinate transforms) and iTime for animation.\n\n\n\nLet’s make the red channel pulse:\n\n  \n  \n  \n\n\nSince sin(iTime) oscillates between -1 and 1, the expression 0.5 + 0.5 * sin(iTime) oscillates between 0 and 1. The screen pulses from black to red.\nThis is our first animated shader—the output depends on time.\n\n\n\n\n\n\nThe input fragCoord gives the pixel coordinates of the current pixel. The coordinate system:\n\nOrigin at the bottom-left corner\nfragCoord.x increases to the right\nfragCoord.y increases upward\nRanges from \\((0, 0)\\) to \\((X, Y)\\) where \\(X \\times Y\\) is the screen resolution\n\nThis is workable, but inconvenient for mathematics. We’d prefer coordinates centered at the origin with a reasonable scale. Let’s build up a transformation step by step.\n\n\n\nDivide by the resolution to map pixel coordinates to the unit square:\nvec2 uv = fragCoord / iResolution.xy;\nNow uv ranges from \\((0,0)\\) at bottom-left to \\((1,1)\\) at top-right.\nSince both coordinates are in \\([0,1]\\), we can visualize them directly as color:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n\n  \n  \n  \n\n\nBlack at bottom-left (0,0), red at bottom-right (1,0), green at top-left (0,1), yellow at top-right (1,1).\n\n\n\nSubtract \\((0.5, 0.5)\\) to center the origin:\nuv = uv - vec2(0.5, 0.5);\nNow uv ranges from \\((-0.5, -0.5)\\) to \\((0.5, 0.5)\\), with \\((0,0)\\) at the screen center.\n\n\n\nWe’ve mapped a rectangle of pixels (\\(X \\times Y\\)) to the square \\([-0.5, 0.5]^2\\). This is an affine transformation, not a similarity—it distorts shapes. A circle in our coordinates would render as an ellipse on screen.\nTo fix this, we scale the \\(x\\)-coordinate by the aspect ratio:\nuv.x *= iResolution.x / iResolution.y;\nNow a circle in our coordinates appears as a circle on screen. (When we draw shapes later, try commenting out this line to see the distortion.)\n\n\n\nFinally, scale to a convenient window:\nvec2 p = uv * 4.0;\nWith a scale factor of 4, our coordinates range roughly from \\(-2\\) to \\(2\\)—a good default for visualizing mathematical objects.\n\n\n\nPutting it together, here’s the coordinate setup we’ll use throughout the course:\nvec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]\nuv = uv - vec2(0.5, 0.5);               // center origin\nuv.x *= iResolution.x / iResolution.y;  // aspect correction\nvec2 p = uv * 4.0;                      // scale\nFrom here on, p is our mathematical coordinate, centered at the origin, aspect-corrected, with a reasonable range.\n\n\n\n\nSo far we’ve colored every pixel the same, or colored based on position as a gradient. Now we want to draw: to render a shape on screen.\nWhat does it mean to draw a shape? For a simple filled region, we need a rule that tells us, for each pixel: are you inside the shape or not? When inside, we do one thing (say, color yellow). When outside, we do another (color blue). The boundary of the shape is where we switch.\n\n\nThe simplest shape is a half-plane. Consider the rule: is the \\(y\\)-coordinate greater than 0? This divides the plane into two regions—above and below the \\(x\\)-axis.\nfloat L = p.y;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red below\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue above\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nTo color left versus right instead, use p.x in place of p.y.\nMore generally, a line in the plane has the form \\(ax + by + c = 0\\). This divides the plane into two half-planes: where \\(ax + by + c &lt; 0\\) and where \\(ax + by + c &gt; 0\\).\nfloat a = 1.0, b = 1.0, c = 0.0;\nfloat L = a * p.x + b * p.y + c;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue\n}\n\nfragColor = vec4(color, 1.0);\nRecall that \\((a, b)\\) is the normal vector to the line, and \\(c\\) is an offset. Since these are just variables, we can animate them to move the line around:\nfloat a = cos(iTime);\nfloat b = sin(iTime);\nfloat c = 0.5 * sin(iTime * 0.7);\n\n  \n  \n  \n\n\n\n\n\nNow consider the function \\(d(p) = |p|\\), the distance from the origin. Geometrically, the graph of this function is a cone—zero at the origin, increasing linearly in all directions.\nTo draw a filled disk of radius \\(r\\), we could threshold on \\(d &lt; r\\) versus \\(d \\geq r\\). But it’s cleaner to define \\(f(p) = |p| - r\\). This function is negative inside the circle (where \\(d &lt; r\\)) and positive outside (where \\(d &gt; r\\)). The circle itself is the level set \\(f = 0\\).\nfloat d = length(p);\nfloat r = 1.0;\nfloat f = d - r;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow inside\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nTry commenting out the aspect ratio correction (uv.x *= ...) to see the distortion—the circle becomes an ellipse.\nTo center the circle at a point \\(c\\) instead of the origin, compute distance from \\(c\\):\nvec2 center = vec2(1.0, 0.5);\nfloat d = length(p - center);\nSince center and r are variables, you can animate them with iTime to create moving, pulsing circles.\n\n\n\nOur function \\(f = d - r\\) is negative inside the circle and positive outside. To draw a filled disk, we colored based on the sign of \\(f\\).\nBut what if we want just the boundary—a ring of some thickness? We want to color one way when \\(f\\) is small in absolute value (near the circle), and a different way when \\(|f|\\) is large (far from the circle).\nSo we look at \\(|f| = |d - r|\\) and ask: is this less than some threshold \\(\\varepsilon\\), or greater? Equivalently, is \\(|d - r| - \\varepsilon\\) negative or positive?\nfloat d = length(p);\nfloat r = 1.0;\nfloat eps = 0.1;\nfloat f = abs(d - r) - eps;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 1.0);  // white ring\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\n\n\n\n\nWe’ve drawn circles using the distance function \\(|p| - r\\). But circles are just one example of curves defined by an equation. Any equation \\(F(x,y) = 0\\) defines a curve—the set of points satisfying that equation. We can draw it the same way: threshold on \\(|F|\\).\n\n\nConsider \\(F(x,y) = y - x^2\\). The curve \\(F = 0\\) is the parabola \\(y = x^2\\). Points where \\(F &lt; 0\\) lie below the parabola; points where \\(F &gt; 0\\) lie above.\nTo draw the curve itself, we color pixels where \\(|F|\\) is small:\nfloat F = p.y - p.x * p.x;\nfloat eps = 0.1;\n\nvec3 color;\nif (abs(F) &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow curve\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\n\n\n\nAn ellipse: \\(F(x,y) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1\\)\nfloat a = 2.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) + (p.y*p.y)/(b*b) - 1.0;\nA hyperbola: \\(F(x,y) = \\frac{x^2}{a^2} - \\frac{y^2}{b^2} - 1\\)\nfloat a = 1.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) - (p.y*p.y)/(b*b) - 1.0;\nThe lemniscate of Bernoulli: \\((x^2 + y^2)^2 = a^2(x^2 - y^2)\\), or \\(F = (x^2+y^2)^2 - a^2(x^2 - y^2)\\)\nfloat a = 1.5;\nfloat r2 = dot(p, p);  // x² + y²\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n\n\nLook carefully at the parabola. The rendered thickness isn’t uniform—it’s thinner where the curve is steep, thicker where it’s flat. The problem gets worse with more complicated curves, especially those with singularities. Here’s the lemniscate:\n\n  \n  \n  \n\n\nNotice how the thickness blows up near the origin, where the curve crosses itself.\nWhy does this happen? The set \\(|F| &lt; \\varepsilon\\) contains all points within \\(\\varepsilon\\) of zero in the \\(F\\) direction. But \\(F\\) doesn’t measure distance to the curve—it’s just some function that happens to be zero on the curve. Where \\(|\\nabla F|\\) is large, \\(F\\) changes rapidly, so the band \\(|F| &lt; \\varepsilon\\) is narrow. Where \\(|\\nabla F|\\) is small, \\(F\\) changes slowly, so the band is wide. At the singular point, \\(\\nabla F = 0\\), and the band becomes infinitely wide.\n\n\n\nFor the circle, we used \\(f(p) = |p| - r\\). This is the signed distance function: it measures actual geometric distance to the curve. The gradient of a distance function has magnitude 1 everywhere (it points toward or away from the curve at unit rate). So \\(|f| &lt; \\varepsilon\\) really does capture points within distance \\(\\varepsilon\\), giving uniform thickness.\nThis is a fact from differential geometry: \\(|\\nabla d| = 1\\) for a distance function \\(d\\). When we use an arbitrary implicit equation \\(F = 0\\), we lose this property.\n\n\n\nWe can fix the non-uniform thickness by dividing by the gradient magnitude. Instead of thresholding \\(|F| &lt; \\varepsilon\\), we threshold \\[\\frac{|F|}{|\\nabla F|} &lt; \\varepsilon.\\]\nThis approximates the signed distance to the curve. The intuition: \\(|F|/|\\nabla F|\\) estimates how far you’d need to travel (in the direction \\(F\\) changes fastest) to reach the curve.\nFor the lemniscate, we compute the gradient analytically: \\[\\nabla F = \\bigl(4x(x^2+y^2) - 2a^2 x,\\; 4y(x^2+y^2) + 2a^2 y\\bigr)\\]\nfloat a = 1.5;\nfloat r2 = dot(p, p);\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\nvec2 grad = vec2(\n    4.0 * p.x * r2 - 2.0 * a * a * p.x,\n    4.0 * p.y * r2 + 2.0 * a * a * p.y\n);\n\nfloat dist = abs(F) / max(length(grad), 0.01);  // avoid division by zero\nfloat eps = 0.05;\n\nvec3 color;\nif (dist &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nCompare with the naive version above to see the difference in thickness uniformity.\n\n\n\nThe lemniscate is part of a one-parameter family called the Cassini ovals, defined by the product of distances from two foci being constant: \\[(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\]\nAs the parameter \\(a\\) varies relative to the fixed focal distance \\(c\\), the topology changes: two separate loops when \\(a &lt; c\\), a lemniscate when \\(a = c\\), a single oval when \\(a &gt; c\\).\n\n  \n  \n  \n\n\n\n\n\n\nSo far our shaders respond to time (iTime) but not to user input. Shadertoy provides iMouse for mouse interaction.\n\n\niMouse is a vec4:\n\niMouse.xy — current mouse position (in pixels)\niMouse.zw — position where the mouse was last clicked\n\nFor now we’ll focus on iMouse.xy.\n\n\n\nLet’s draw a circle centered at the mouse position. Since iMouse.xy is in pixel coordinates, we need to normalize it the same way we normalize fragCoord:\n// Normalize fragment coordinate\nvec2 uv = fragCoord / iResolution.xy;\nuv = uv - vec2(0.5, 0.5);\nuv.x *= iResolution.x / iResolution.y;\nvec2 p = uv * 4.0;\n\n// Normalize mouse coordinate the same way\nvec2 mouse = iMouse.xy / iResolution.xy;\nmouse = mouse - vec2(0.5, 0.5);\nmouse.x *= iResolution.x / iResolution.y;\nmouse = mouse * 4.0;\n\n// Circle centered at mouse\nfloat d = length(p - mouse);\nfloat r = 0.5;\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nClick and drag to move the circle.\n\n\n\nWe just wrote the same four lines of coordinate normalization twice. This is a sign we should write a function.\nA GLSL function declares its return type, then the function name, then its parameters with their types:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\nFunctions must be defined before they’re used, so they go above mainImage. Here’s the overall structure:\nvec2 normalize_coord(vec2 coord) {\n    // normalization logic here\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = normalize_coord(fragCoord);\n    vec2 mouse = normalize_coord(iMouse.xy);\n    \n    // code using p and mouse\n}\nNow our shader is cleaner, and we won’t make mistakes copying the normalization code.\n\n\n\nLet’s make a circle orbit around the mouse position:\nvec2 p = normalize_coord(fragCoord);\nvec2 sun = normalize_coord(iMouse.xy);\n\n// Earth orbits the sun\nfloat orbit_radius = 0.8;\nvec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n\n// Draw sun (larger, yellow)\nfloat d_sun = length(p - sun);\n// Draw earth (smaller, blue)\nfloat d_earth = length(p - earth);\n\nvec3 color = vec3(0.02, 0.02, 0.05);  // dark background\nif (d_sun &lt; 0.3) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow sun\n}\nif (d_earth &lt; 0.15) {\n    color = vec3(0.2, 0.5, 1.0);  // blue earth\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nDrag to move the sun; the earth follows in orbit. (Exercise: add a moon orbiting the earth!)\n\n\n\nThe mouse doesn’t have to control position—it can control any parameter. A useful pattern: map iMouse.x to a parameter range and drag across the screen to explore a family of curves.\nThe folium of Descartes is the curve \\(x^3 + y^3 = 3axy\\). We can explore its level sets by drawing \\(x^3 + y^3 - 3axy = c\\) for different values of \\(c\\):\nvec2 p = normalize_coord(fragCoord);\n\n// Fixed parameter a\nfloat a = 1.5;\n\n// Map mouse x to level set value c in [-2, 2]\nfloat c = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n\n// Folium of Descartes: x³ + y³ - 3axy = c\nfloat F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;\n\n// Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)\nvec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);\nfloat dist = abs(F) / max(length(grad), 0.01);\n\nvec3 color;\nif (dist &lt; 0.05) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nDrag left and right to sweep through the level sets and watch the curve topology change.\n\n\n\n\nHomework is organized into four types:\nCheckpoints — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.\nExplorations — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you’re right on track with the course.\nChallenges — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.\nProject — An extended project for someone familiar with shader basics, to make an artwork.\n\n\n\nC1. Solid Colors. Modify the red screen shader to display: (a) green, (b) cyan, (c) a color of your choice using all three RGB channels.\nC2. Vertical Split. Modify the half-plane shader to divide the screen into left (red) and right (blue) instead of top and bottom.\nC3. Off-Center Circle. Draw a filled circle of radius 0.5 centered at the point \\((1, 1)\\) instead of the origin.\nC4. Pulsing Circle. Make a circle whose radius oscillates between 0.5 and 1.5 over time using iTime.\nC5. Ring Thickness. Draw a ring (circle outline) centered at the origin. Experiment with different values of eps to understand how it controls thickness.\n\n\n\n\nE1. Concentric Rings. Draw several concentric rings (circles of different radii, all centered at the origin). Can you color alternate rings differently?\nE2. Moon Orbit. Extend the sun-earth shader to add a moon that orbits the earth. The moon should be smaller than the earth and orbit faster.\nE3. Your Favorite Curve. Pick an implicit curve from your mathematical experience (or find one online) and render it. Some suggestions: the cardioid \\((x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)\\), the astroid \\(x^{2/3} + y^{2/3} = a^{2/3}\\), or a rose curve in implicit form. Apply gradient correction for uniform thickness.\nE4. Curve Explorer. Take any one-parameter family of curves and build a mouse-controlled explorer (like the folium example). Map iMouse.x to the parameter and drag to explore the family.\nE5. Two Circles. Draw two filled circles at different positions. What happens when they overlap? Can you make one “in front of” the other? Can you make the intersection a different color, like a Venn diagram?\n\n\n\n\nH1. Parabola Graphing Calculator. Build an interactive graphing calculator for the parabola \\(y = ax^2 + bx + c\\). Requirements: - Draw coordinate axes (the lines \\(x = 0\\) and \\(y = 0\\)) - Draw the parabola using implicit curve techniques - Find the roots (where \\(y = 0\\)) and draw small circles around them - Use mouse position to control two of the coefficients (e.g., \\(a\\) and \\(b\\), with \\(c\\) fixed, or \\(b\\) and \\(c\\) with \\(a\\) fixed)\nAs you drag the mouse, the parabola should reshape and the root indicators should move (or appear/disappear as roots become real or complex).\nH2. Elliptic Curve Explorer. Elliptic curves in Weierstrass form are \\(y^2 = x^3 + ax + b\\). Build a shader where the mouse position controls \\((a, b)\\). Use gradient correction for uniform thickness. The discriminant \\(\\Delta = 4a^3 + 27b^2\\) determines whether the curve is smooth (\\(\\Delta \\neq 0\\)) or singular (\\(\\Delta = 0\\)). Can you display the current value of \\(\\Delta\\) somehow, or change the curve’s color when it becomes singular?\nH3. Signed Distance Functions. For a filled circle, \\(f(p) = |p| - r\\) is the signed distance function: negative inside, positive outside, with \\(|f|\\) giving the actual distance to the boundary. What is the signed distance function for a half-plane? For an axis-aligned rectangle? Implement both and draw them with uniform-thickness boundaries. Note: when you have the true signed distance function, you don’t need the gradient correction trick—that’s the payoff for computing the right thing from the start!\nH4. Smooth Blending. When two circles overlap, we currently just draw one on top of the other. Research smooth minimum functions (e.g., smin) that blend distance fields smoothly. Draw two circles that “melt together” where they meet.\nH5. Inversion. Circle inversion is the map \\(p \\mapsto p / |p|^2\\). Apply this transformation to your coordinate \\(p\\) before drawing a shape. What happens to a line? What happens to a circle not passing through the origin? Experiment with different shapes.\n\n\n\n\nThis extended project introduces a powerful technique—using modular arithmetic to repeat patterns across the plane. We’ll build up the machinery carefully, since we’ll use it again in Day 2 to create grids of Julia sets.\n\n\nWe want to tile the screen with square cells—say, 4 cells across. The challenge: the screen isn’t square, so we need to handle the aspect ratio.\nLet’s say we want N columns of cells. Each cell has width \\(L = \\text{screen\\_width} / N\\) in pixels, and since cells are square, height \\(L\\) as well. The number of rows depends on the screen’s aspect ratio.\nWorking in our normalized coordinates (after aspect correction), the screen spans roughly \\([-2 \\cdot \\text{aspect}, 2 \\cdot \\text{aspect}]\\) in \\(x\\) and \\([-2, 2]\\) in \\(y\\). If we want cells of side length \\(L\\) in these coordinates:\nfloat aspect = iResolution.x / iResolution.y;\nfloat N = 5.0;  // number of columns\nfloat L = (4.0 * aspect) / N;  // cell size in our coordinate system\nNow each cell is an \\(L \\times L\\) square.\n\n\n\nFor each pixel, we want two things:\n\nWhich cell are we in? Integer coordinates \\((i, j)\\) identifying the cell.\nWhere in the cell are we? Local coordinates ranging from \\(-L/2\\) to \\(L/2\\), with \\((0,0)\\) at the cell center.\n\nvec2 cell_id = floor(p / L);\nvec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);\nThe cell_id tells us which cell; the cell_p gives local coordinates within that cell.\nIf we want local coordinates normalized to \\([-1, 1]\\) (useful for drawing things at a standard scale), we can rescale:\nvec2 local = cell_p / (L / 2.0);  // now in [-1, 1] x [-1, 1]\nThis is exactly the setup we’ll need for Day 2, where each cell will contain a Julia set with its own coordinate system.\n\n\n\nNow draw something using the local coordinates. A filled circle at the center of each cell:\nfloat d = length(cell_p);\nfloat r = L * 0.4;  // radius relative to cell size\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nTry changing N to get more or fewer columns. The cells stay square regardless of screen shape.\n\n\n\nThe cell_id lets each cell behave differently. Some ideas:\nCheckerboard background:\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\nvec3 bg = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\nRadius varying by cell:\nfloat r = L * (0.2 + 0.15 * mod(cell_id.x + cell_id.y, 3.0));\nWave animation:\nfloat cell_dist = length(cell_id);\nfloat r = L * (0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5));\n\n\n\nDesign a grid-based pattern that you find visually interesting. Some directions:\nConnecting shapes: Draw shapes that connect across cell boundaries. Quarter-circles in each corner create a continuous network. What implicit curves tile seamlessly?\nAlternating motifs: Use cell_id to alternate between different shapes—circles in some cells, rings in others, or different orientations.\nColor fields: Map cell_id to colors using distance from origin, stripes, or a palette.\nPhase shifts: Animate cells with different phase offsets to create waves or ripples.\nUsing local coordinates: Draw something more complex in each cell using the \\([-1,1]\\) local coordinate system—perhaps a small implicit curve, or a pattern that changes based on cell_id.\nThe goal is to produce an image you’d be happy to hang on a wall.\n\n\n\n\nThis project builds a visualization of Fourier series using epicycles—circles whose centers sit on the circumferences of other circles. This is how Ptolemy modeled planetary motion, and it turns out to be exactly how Fourier series work geometrically.\n\n\nAny periodic function can be written as a sum of sines and cosines. Geometrically, \\(\\sin(n\\omega t)\\) and \\(\\cos(n\\omega t)\\) describe a point moving around a circle of frequency \\(n\\omega\\). Adding these components corresponds to stacking circles: each circle’s center rides on the previous circle’s edge.\nFor example, the square wave has Fourier series: \\[f(t) = \\sum_{n=1,3,5,...} \\frac{1}{n} \\sin(n\\omega t)\\]\nThis means circles with: - Radii: \\(1, \\frac{1}{3}, \\frac{1}{5}, \\frac{1}{7}, ...\\) - Frequencies: \\(\\omega, 3\\omega, 5\\omega, 7\\omega, ...\\)\nThe more terms we add, the closer the final point’s \\(y\\)-coordinate approximates a square wave.\n\n\n\nStart by drawing a chain of circles. Each circle is centered at the current position, and the next position is computed by moving along the circle:\nvec2 pos = vec2(0.0, 0.0);  // start at origin\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;  // 1, 3, 5, 7, ...\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    // Draw circle at current position\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // color the circle\n    }\n    \n    // Move to next position\n    pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n}\n\n// Draw final point\nfloat d_point = length(p - pos);\nif (d_point &lt; 0.08) {\n    // bright color\n}\nTry this with N = 1, then N = 3, then N = 7. Watch how more circles create more complex motion.\n\n\n\nTo draw the arms connecting circle centers, we need the signed distance function for a line segment. Given endpoints \\(a\\) and \\(b\\), the distance from point \\(p\\) to the segment is:\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\nThe math: we project \\(p - a\\) onto the line direction \\(b - a\\), clamp to \\([0, 1]\\) to stay within the segment, then measure the distance to that closest point.\n\n\n\nNow modify your loop to also draw line segments:\nvec2 pos = vec2(0.0, 0.0);\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n    \n    // Draw circle\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // faint circle color\n    }\n    \n    // Draw arm from pos to next_pos\n    float d_arm = sd_segment(p, pos, next_pos);\n    if (d_arm &lt; 0.015) {\n        // arm color\n    }\n    \n    pos = next_pos;\n}\n\n\n\nNow make it beautiful:\nFading circles: Later circles are smaller and less important. Fade their brightness:\nfloat fade = 1.0 - float(i) / float(N);\nColor variation: Color circles differently based on their index, or based on their frequency.\nDifferent waves: The square wave uses odd harmonics with \\(1/n\\) coefficients. Try: - Triangle wave: odd harmonics with \\(1/n^2\\) coefficients (alternating signs) - Sawtooth wave: all harmonics with \\(1/n\\) coefficients\nMouse control: Map iMouse.x to the number of terms, so dragging adds or removes circles.\nThe goal: create a mesmerizing animation that reveals the geometry hidden inside Fourier series.",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#overview",
    "href": "lectures/day1.html#overview",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "By the end of today, you’ll be able to create things like this:\n\n  \n  \n  \n\n\nA family of elliptic curves \\(y^2 = x^3 + ax + b\\), drawn for several values of \\(a\\) simultaneously, with \\(b\\) varying across the screen. The curves shift in brightness to show the family structure, and you can watch singularities appear and disappear along the discriminant locus.\nThis image is computed in real time, every pixel evaluated independently on the GPU. To get here, we’ll learn:\n\nWhat a shader is: a function from coordinates to colors, evaluated in parallel\nHow to set up a coordinate system for mathematical visualization\nHow to draw shapes using distance functions\nHow to render implicit curves \\(F(x,y) = 0\\) with uniform thickness\nHow to add interactivity with mouse input\n\nLet’s begin.",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#what-is-a-shader",
    "href": "lectures/day1.html#what-is-a-shader",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "We want to draw images on a screen.\nMathematically, an image is a function from a region \\(S \\subset \\mathbb{R}^2\\) to the space of visible colors \\(\\mathcal{C}\\). This color space is three-dimensional, spanned by the responses of the three types of cone cells in our eyes. A convenient basis, roughly aligned with these responses, is red, green, and blue.\nTo realize this on a computer, we discretize. A screen is a grid of pixels: \\(X\\) pixels wide, \\(Y\\) pixels tall. Each pixel is a point in the integer lattice \\[\\{0, 1, \\ldots, X-1\\} \\times \\{0, 1, \\ldots, Y-1\\}.\\]\nColors are represented as RGB triples: red, green, and blue intensities, each in \\([0,1]\\). The constraint to \\([0,1]\\) reflects physical reality—a pixel has a maximum brightness it can display. (We can’t draw the sun.) So an image is a function \\[f\\colon \\{0,\\ldots,X-1\\} \\times \\{0,\\ldots,Y-1\\} \\to [0,1]^3\\] \\[(i,j) \\mapsto (r,g,b).\\]\nIn practice, we add a fourth component: alpha, representing transparency. This matters when compositing multiple layers (we won’t use it in this course, but the machinery expects it). So our shader computes \\[f\\colon (i,j) \\mapsto (r,g,b,1).\\]\nThis is what a shader is. You write a function that takes pixel coordinates and returns an RGBA color. The GPU evaluates your function at every pixel to produce the image.\n\n\nA 1920×1080 display has over two million pixels. How do we evaluate \\(f\\) at all of them fast enough to animate at 60 frames per second?\nThe answer is parallelism. A GPU contains thousands of cores, and it evaluates \\(f\\) at all pixels simultaneously. There’s no loop over pixels in your code—you write \\(f\\), and the hardware handles the rest.\nThe tradeoff: each pixel’s computation must be independent. Pixel \\((100, 200)\\) cannot ask what color pixel \\((100, 199)\\) received. Every pixel sees the same global inputs—coordinates, time, mouse position—and must determine its color from those alone. Learning to think within this constraint is what shader programming is about.\n\n\n\n\n\n\nNoteWhy “shader”?\n\n\n\nThe name comes from 3D graphics, where these programs computed shading—how light interacts with surfaces. It stuck even though we now use shaders for fractals, simulations, and mathematical visualization.\n\n\n\n\n\nShader programming normally requires substantial setup: OpenGL contexts, buffer management, compilation, render loops. Shadertoy abstracts all of this—you write one function, press play, and see results. We’ll use it throughout the course.",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#first-shaders-colors-and-syntax",
    "href": "lectures/day1.html#first-shaders-colors-and-syntax",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "In Shadertoy, your shader is a function called mainImage:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // your code here\n}\nThis function is called once per pixel, every frame. The inputs and outputs:\n\nfragCoord — the pixel coordinates, passed in to your function\nfragColor — the RGBA color, which you write out\n\nThe in and out keywords are explicit about data flow: fragCoord is read-only input, fragColor is where you write your result. The function returns void because the output goes through fragColor, not a return value.\n\n\n\nThe simplest shader: make every pixel red.\n\n  \n  \n  \n\n\nThe vec4(1.0, 0.0, 0.0, 1.0) constructs a 4-component vector: red=1, green=0, blue=0, alpha=1. Every pixel receives the same color, so the screen fills with red.\n\n\n\nGLSL (OpenGL Shading Language) will feel familiar if you’ve seen C-like syntax, but a few things are worth noting upfront.\nSemicolons are required at the end of each statement.\nFloats must include a decimal point. Write 1.0, not 1. The integer 1 and the float 1.0 are different types, and GLSL is strict about this.\nVector types are built in: vec2, vec3, vec4 for 2, 3, and 4 component vectors. Construct them with:\nvec2 p = vec2(3.0, 4.0);\nvec3 color = vec3(1.0, 0.5, 0.0);\nvec4 rgba = vec4(1.0, 0.0, 0.0, 1.0);\nArithmetic is component-wise. Adding two vectors adds their components:\nvec2(1.0, 2.0) + vec2(3.0, 4.0)  // = vec2(4.0, 6.0)\nScalar-vector operations apply the scalar to each component:\n2.0 * vec2(1.0, 3.0)  // = vec2(2.0, 6.0)\nAccessing components uses .x, .y, .z, .w:\nvec2 p = vec2(3.0, 4.0);\nfloat a = p.x;  // 3.0\nfloat b = p.y;  // 4.0\nFor colors, .r, .g, .b, .a are synonyms—color.r is the same as color.x.\nCommon math functions work as expected: sin, cos, abs, min, max, sqrt, pow. These operate on floats, and apply component-wise to vectors:\nsin(vec2(0.0, 3.14159))  // = vec2(0.0, ~0.0)\nFor loops work as you’d expect:\nfor (int i = 0; i &lt; 5; i++) {\n    // body executes with i = 0, 1, 2, 3, 4\n}\nThe loop variable is an int. Note that some older GPUs require the loop bounds to be constants known at compile time—you can’t always loop up to a variable. We’ll use loops extensively starting tomorrow.\n\n\n\nShadertoy provides uniforms—global values that are constant across all pixels. Unlike fragCoord, which takes a different value at each pixel, a uniform has the same value everywhere. They’re how external information (time, screen size, mouse position) gets into your shader.\n\n\n\n\n\n\n\n\nUniform\nType\nDescription\n\n\n\n\niResolution\nvec3\nViewport size: (width, height, pixel_aspect_ratio)\n\n\niTime\nfloat\nSeconds since the shader started\n\n\niMouse\nvec4\nMouse position and click state\n\n\n\nWe’ll use iResolution constantly (for coordinate transforms) and iTime for animation.\n\n\n\nLet’s make the red channel pulse:\n\n  \n  \n  \n\n\nSince sin(iTime) oscillates between -1 and 1, the expression 0.5 + 0.5 * sin(iTime) oscillates between 0 and 1. The screen pulses from black to red.\nThis is our first animated shader—the output depends on time.",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#coordinate-systems",
    "href": "lectures/day1.html#coordinate-systems",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "The input fragCoord gives the pixel coordinates of the current pixel. The coordinate system:\n\nOrigin at the bottom-left corner\nfragCoord.x increases to the right\nfragCoord.y increases upward\nRanges from \\((0, 0)\\) to \\((X, Y)\\) where \\(X \\times Y\\) is the screen resolution\n\nThis is workable, but inconvenient for mathematics. We’d prefer coordinates centered at the origin with a reasonable scale. Let’s build up a transformation step by step.\n\n\n\nDivide by the resolution to map pixel coordinates to the unit square:\nvec2 uv = fragCoord / iResolution.xy;\nNow uv ranges from \\((0,0)\\) at bottom-left to \\((1,1)\\) at top-right.\nSince both coordinates are in \\([0,1]\\), we can visualize them directly as color:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);\n}\n\n  \n  \n  \n\n\nBlack at bottom-left (0,0), red at bottom-right (1,0), green at top-left (0,1), yellow at top-right (1,1).\n\n\n\nSubtract \\((0.5, 0.5)\\) to center the origin:\nuv = uv - vec2(0.5, 0.5);\nNow uv ranges from \\((-0.5, -0.5)\\) to \\((0.5, 0.5)\\), with \\((0,0)\\) at the screen center.\n\n\n\nWe’ve mapped a rectangle of pixels (\\(X \\times Y\\)) to the square \\([-0.5, 0.5]^2\\). This is an affine transformation, not a similarity—it distorts shapes. A circle in our coordinates would render as an ellipse on screen.\nTo fix this, we scale the \\(x\\)-coordinate by the aspect ratio:\nuv.x *= iResolution.x / iResolution.y;\nNow a circle in our coordinates appears as a circle on screen. (When we draw shapes later, try commenting out this line to see the distortion.)\n\n\n\nFinally, scale to a convenient window:\nvec2 p = uv * 4.0;\nWith a scale factor of 4, our coordinates range roughly from \\(-2\\) to \\(2\\)—a good default for visualizing mathematical objects.\n\n\n\nPutting it together, here’s the coordinate setup we’ll use throughout the course:\nvec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]\nuv = uv - vec2(0.5, 0.5);               // center origin\nuv.x *= iResolution.x / iResolution.y;  // aspect correction\nvec2 p = uv * 4.0;                      // scale\nFrom here on, p is our mathematical coordinate, centered at the origin, aspect-corrected, with a reasonable range.",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#drawing-with-distance",
    "href": "lectures/day1.html#drawing-with-distance",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "So far we’ve colored every pixel the same, or colored based on position as a gradient. Now we want to draw: to render a shape on screen.\nWhat does it mean to draw a shape? For a simple filled region, we need a rule that tells us, for each pixel: are you inside the shape or not? When inside, we do one thing (say, color yellow). When outside, we do another (color blue). The boundary of the shape is where we switch.\n\n\nThe simplest shape is a half-plane. Consider the rule: is the \\(y\\)-coordinate greater than 0? This divides the plane into two regions—above and below the \\(x\\)-axis.\nfloat L = p.y;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red below\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue above\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nTo color left versus right instead, use p.x in place of p.y.\nMore generally, a line in the plane has the form \\(ax + by + c = 0\\). This divides the plane into two half-planes: where \\(ax + by + c &lt; 0\\) and where \\(ax + by + c &gt; 0\\).\nfloat a = 1.0, b = 1.0, c = 0.0;\nfloat L = a * p.x + b * p.y + c;\n\nvec3 color;\nif (L &lt; 0.0) {\n    color = vec3(1.0, 0.0, 0.0);  // red\n} else {\n    color = vec3(0.0, 0.0, 1.0);  // blue\n}\n\nfragColor = vec4(color, 1.0);\nRecall that \\((a, b)\\) is the normal vector to the line, and \\(c\\) is an offset. Since these are just variables, we can animate them to move the line around:\nfloat a = cos(iTime);\nfloat b = sin(iTime);\nfloat c = 0.5 * sin(iTime * 0.7);\n\n  \n  \n  \n\n\n\n\n\nNow consider the function \\(d(p) = |p|\\), the distance from the origin. Geometrically, the graph of this function is a cone—zero at the origin, increasing linearly in all directions.\nTo draw a filled disk of radius \\(r\\), we could threshold on \\(d &lt; r\\) versus \\(d \\geq r\\). But it’s cleaner to define \\(f(p) = |p| - r\\). This function is negative inside the circle (where \\(d &lt; r\\)) and positive outside (where \\(d &gt; r\\)). The circle itself is the level set \\(f = 0\\).\nfloat d = length(p);\nfloat r = 1.0;\nfloat f = d - r;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow inside\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark blue outside\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nTry commenting out the aspect ratio correction (uv.x *= ...) to see the distortion—the circle becomes an ellipse.\nTo center the circle at a point \\(c\\) instead of the origin, compute distance from \\(c\\):\nvec2 center = vec2(1.0, 0.5);\nfloat d = length(p - center);\nSince center and r are variables, you can animate them with iTime to create moving, pulsing circles.\n\n\n\nOur function \\(f = d - r\\) is negative inside the circle and positive outside. To draw a filled disk, we colored based on the sign of \\(f\\).\nBut what if we want just the boundary—a ring of some thickness? We want to color one way when \\(f\\) is small in absolute value (near the circle), and a different way when \\(|f|\\) is large (far from the circle).\nSo we look at \\(|f| = |d - r|\\) and ask: is this less than some threshold \\(\\varepsilon\\), or greater? Equivalently, is \\(|d - r| - \\varepsilon\\) negative or positive?\nfloat d = length(p);\nfloat r = 1.0;\nfloat eps = 0.1;\nfloat f = abs(d - r) - eps;\n\nvec3 color;\nif (f &lt; 0.0) {\n    color = vec3(1.0, 1.0, 1.0);  // white ring\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#implicit-curves",
    "href": "lectures/day1.html#implicit-curves",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "We’ve drawn circles using the distance function \\(|p| - r\\). But circles are just one example of curves defined by an equation. Any equation \\(F(x,y) = 0\\) defines a curve—the set of points satisfying that equation. We can draw it the same way: threshold on \\(|F|\\).\n\n\nConsider \\(F(x,y) = y - x^2\\). The curve \\(F = 0\\) is the parabola \\(y = x^2\\). Points where \\(F &lt; 0\\) lie below the parabola; points where \\(F &gt; 0\\) lie above.\nTo draw the curve itself, we color pixels where \\(|F|\\) is small:\nfloat F = p.y - p.x * p.x;\nfloat eps = 0.1;\n\nvec3 color;\nif (abs(F) &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);  // yellow curve\n} else {\n    color = vec3(0.1, 0.1, 0.3);  // dark background\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\n\n\n\nAn ellipse: \\(F(x,y) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1\\)\nfloat a = 2.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) + (p.y*p.y)/(b*b) - 1.0;\nA hyperbola: \\(F(x,y) = \\frac{x^2}{a^2} - \\frac{y^2}{b^2} - 1\\)\nfloat a = 1.0, b = 1.0;\nfloat F = (p.x*p.x)/(a*a) - (p.y*p.y)/(b*b) - 1.0;\nThe lemniscate of Bernoulli: \\((x^2 + y^2)^2 = a^2(x^2 - y^2)\\), or \\(F = (x^2+y^2)^2 - a^2(x^2 - y^2)\\)\nfloat a = 1.5;\nfloat r2 = dot(p, p);  // x² + y²\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\n\n\nLook carefully at the parabola. The rendered thickness isn’t uniform—it’s thinner where the curve is steep, thicker where it’s flat. The problem gets worse with more complicated curves, especially those with singularities. Here’s the lemniscate:\n\n  \n  \n  \n\n\nNotice how the thickness blows up near the origin, where the curve crosses itself.\nWhy does this happen? The set \\(|F| &lt; \\varepsilon\\) contains all points within \\(\\varepsilon\\) of zero in the \\(F\\) direction. But \\(F\\) doesn’t measure distance to the curve—it’s just some function that happens to be zero on the curve. Where \\(|\\nabla F|\\) is large, \\(F\\) changes rapidly, so the band \\(|F| &lt; \\varepsilon\\) is narrow. Where \\(|\\nabla F|\\) is small, \\(F\\) changes slowly, so the band is wide. At the singular point, \\(\\nabla F = 0\\), and the band becomes infinitely wide.\n\n\n\nFor the circle, we used \\(f(p) = |p| - r\\). This is the signed distance function: it measures actual geometric distance to the curve. The gradient of a distance function has magnitude 1 everywhere (it points toward or away from the curve at unit rate). So \\(|f| &lt; \\varepsilon\\) really does capture points within distance \\(\\varepsilon\\), giving uniform thickness.\nThis is a fact from differential geometry: \\(|\\nabla d| = 1\\) for a distance function \\(d\\). When we use an arbitrary implicit equation \\(F = 0\\), we lose this property.\n\n\n\nWe can fix the non-uniform thickness by dividing by the gradient magnitude. Instead of thresholding \\(|F| &lt; \\varepsilon\\), we threshold \\[\\frac{|F|}{|\\nabla F|} &lt; \\varepsilon.\\]\nThis approximates the signed distance to the curve. The intuition: \\(|F|/|\\nabla F|\\) estimates how far you’d need to travel (in the direction \\(F\\) changes fastest) to reach the curve.\nFor the lemniscate, we compute the gradient analytically: \\[\\nabla F = \\bigl(4x(x^2+y^2) - 2a^2 x,\\; 4y(x^2+y^2) + 2a^2 y\\bigr)\\]\nfloat a = 1.5;\nfloat r2 = dot(p, p);\nfloat F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);\n\nvec2 grad = vec2(\n    4.0 * p.x * r2 - 2.0 * a * a * p.x,\n    4.0 * p.y * r2 + 2.0 * a * a * p.y\n);\n\nfloat dist = abs(F) / max(length(grad), 0.01);  // avoid division by zero\nfloat eps = 0.05;\n\nvec3 color;\nif (dist &lt; eps) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nCompare with the naive version above to see the difference in thickness uniformity.\n\n\n\nThe lemniscate is part of a one-parameter family called the Cassini ovals, defined by the product of distances from two foci being constant: \\[(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\\]\nAs the parameter \\(a\\) varies relative to the fixed focal distance \\(c\\), the topology changes: two separate loops when \\(a &lt; c\\), a lemniscate when \\(a = c\\), a single oval when \\(a &gt; c\\).",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#interactivity-and-abstraction",
    "href": "lectures/day1.html#interactivity-and-abstraction",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "So far our shaders respond to time (iTime) but not to user input. Shadertoy provides iMouse for mouse interaction.\n\n\niMouse is a vec4:\n\niMouse.xy — current mouse position (in pixels)\niMouse.zw — position where the mouse was last clicked\n\nFor now we’ll focus on iMouse.xy.\n\n\n\nLet’s draw a circle centered at the mouse position. Since iMouse.xy is in pixel coordinates, we need to normalize it the same way we normalize fragCoord:\n// Normalize fragment coordinate\nvec2 uv = fragCoord / iResolution.xy;\nuv = uv - vec2(0.5, 0.5);\nuv.x *= iResolution.x / iResolution.y;\nvec2 p = uv * 4.0;\n\n// Normalize mouse coordinate the same way\nvec2 mouse = iMouse.xy / iResolution.xy;\nmouse = mouse - vec2(0.5, 0.5);\nmouse.x *= iResolution.x / iResolution.y;\nmouse = mouse * 4.0;\n\n// Circle centered at mouse\nfloat d = length(p - mouse);\nfloat r = 0.5;\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nClick and drag to move the circle.\n\n\n\nWe just wrote the same four lines of coordinate normalization twice. This is a sign we should write a function.\nA GLSL function declares its return type, then the function name, then its parameters with their types:\nvec2 normalize_coord(vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv - vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv * 4.0;\n}\nFunctions must be defined before they’re used, so they go above mainImage. Here’s the overall structure:\nvec2 normalize_coord(vec2 coord) {\n    // normalization logic here\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = normalize_coord(fragCoord);\n    vec2 mouse = normalize_coord(iMouse.xy);\n    \n    // code using p and mouse\n}\nNow our shader is cleaner, and we won’t make mistakes copying the normalization code.\n\n\n\nLet’s make a circle orbit around the mouse position:\nvec2 p = normalize_coord(fragCoord);\nvec2 sun = normalize_coord(iMouse.xy);\n\n// Earth orbits the sun\nfloat orbit_radius = 0.8;\nvec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));\n\n// Draw sun (larger, yellow)\nfloat d_sun = length(p - sun);\n// Draw earth (smaller, blue)\nfloat d_earth = length(p - earth);\n\nvec3 color = vec3(0.02, 0.02, 0.05);  // dark background\nif (d_sun &lt; 0.3) {\n    color = vec3(1.0, 0.9, 0.2);  // yellow sun\n}\nif (d_earth &lt; 0.15) {\n    color = vec3(0.2, 0.5, 1.0);  // blue earth\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nDrag to move the sun; the earth follows in orbit. (Exercise: add a moon orbiting the earth!)\n\n\n\nThe mouse doesn’t have to control position—it can control any parameter. A useful pattern: map iMouse.x to a parameter range and drag across the screen to explore a family of curves.\nThe folium of Descartes is the curve \\(x^3 + y^3 = 3axy\\). We can explore its level sets by drawing \\(x^3 + y^3 - 3axy = c\\) for different values of \\(c\\):\nvec2 p = normalize_coord(fragCoord);\n\n// Fixed parameter a\nfloat a = 1.5;\n\n// Map mouse x to level set value c in [-2, 2]\nfloat c = mix(-2.0, 2.0, iMouse.x / iResolution.x);\n\n// Folium of Descartes: x³ + y³ - 3axy = c\nfloat F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;\n\n// Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)\nvec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);\nfloat dist = abs(F) / max(length(grad), 0.01);\n\nvec3 color;\nif (dist &lt; 0.05) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nfragColor = vec4(color, 1.0);\n\n  \n  \n  \n\n\nDrag left and right to sweep through the level sets and watch the curve topology change.",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  },
  {
    "objectID": "lectures/day1.html#exercises",
    "href": "lectures/day1.html#exercises",
    "title": "1 Day 1: Introduction",
    "section": "",
    "text": "Homework is organized into four types:\nCheckpoints — Short exercises to verify you understood the lecture material. Required for anyone new to shader programming.\nExplorations — Open-ended problems that extend the lecture topics. Pick the ones that interest you. If you can do several of these, you’re right on track with the course.\nChallenges — Problems that may require learning new concepts beyond what was covered in lecture. Attempt these if you skipped the checkpoints and found an exploration or two too easy.\nProject — An extended project for someone familiar with shader basics, to make an artwork.\n\n\n\nC1. Solid Colors. Modify the red screen shader to display: (a) green, (b) cyan, (c) a color of your choice using all three RGB channels.\nC2. Vertical Split. Modify the half-plane shader to divide the screen into left (red) and right (blue) instead of top and bottom.\nC3. Off-Center Circle. Draw a filled circle of radius 0.5 centered at the point \\((1, 1)\\) instead of the origin.\nC4. Pulsing Circle. Make a circle whose radius oscillates between 0.5 and 1.5 over time using iTime.\nC5. Ring Thickness. Draw a ring (circle outline) centered at the origin. Experiment with different values of eps to understand how it controls thickness.\n\n\n\n\nE1. Concentric Rings. Draw several concentric rings (circles of different radii, all centered at the origin). Can you color alternate rings differently?\nE2. Moon Orbit. Extend the sun-earth shader to add a moon that orbits the earth. The moon should be smaller than the earth and orbit faster.\nE3. Your Favorite Curve. Pick an implicit curve from your mathematical experience (or find one online) and render it. Some suggestions: the cardioid \\((x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)\\), the astroid \\(x^{2/3} + y^{2/3} = a^{2/3}\\), or a rose curve in implicit form. Apply gradient correction for uniform thickness.\nE4. Curve Explorer. Take any one-parameter family of curves and build a mouse-controlled explorer (like the folium example). Map iMouse.x to the parameter and drag to explore the family.\nE5. Two Circles. Draw two filled circles at different positions. What happens when they overlap? Can you make one “in front of” the other? Can you make the intersection a different color, like a Venn diagram?\n\n\n\n\nH1. Parabola Graphing Calculator. Build an interactive graphing calculator for the parabola \\(y = ax^2 + bx + c\\). Requirements: - Draw coordinate axes (the lines \\(x = 0\\) and \\(y = 0\\)) - Draw the parabola using implicit curve techniques - Find the roots (where \\(y = 0\\)) and draw small circles around them - Use mouse position to control two of the coefficients (e.g., \\(a\\) and \\(b\\), with \\(c\\) fixed, or \\(b\\) and \\(c\\) with \\(a\\) fixed)\nAs you drag the mouse, the parabola should reshape and the root indicators should move (or appear/disappear as roots become real or complex).\nH2. Elliptic Curve Explorer. Elliptic curves in Weierstrass form are \\(y^2 = x^3 + ax + b\\). Build a shader where the mouse position controls \\((a, b)\\). Use gradient correction for uniform thickness. The discriminant \\(\\Delta = 4a^3 + 27b^2\\) determines whether the curve is smooth (\\(\\Delta \\neq 0\\)) or singular (\\(\\Delta = 0\\)). Can you display the current value of \\(\\Delta\\) somehow, or change the curve’s color when it becomes singular?\nH3. Signed Distance Functions. For a filled circle, \\(f(p) = |p| - r\\) is the signed distance function: negative inside, positive outside, with \\(|f|\\) giving the actual distance to the boundary. What is the signed distance function for a half-plane? For an axis-aligned rectangle? Implement both and draw them with uniform-thickness boundaries. Note: when you have the true signed distance function, you don’t need the gradient correction trick—that’s the payoff for computing the right thing from the start!\nH4. Smooth Blending. When two circles overlap, we currently just draw one on top of the other. Research smooth minimum functions (e.g., smin) that blend distance fields smoothly. Draw two circles that “melt together” where they meet.\nH5. Inversion. Circle inversion is the map \\(p \\mapsto p / |p|^2\\). Apply this transformation to your coordinate \\(p\\) before drawing a shape. What happens to a line? What happens to a circle not passing through the origin? Experiment with different shapes.\n\n\n\n\nThis extended project introduces a powerful technique—using modular arithmetic to repeat patterns across the plane. We’ll build up the machinery carefully, since we’ll use it again in Day 2 to create grids of Julia sets.\n\n\nWe want to tile the screen with square cells—say, 4 cells across. The challenge: the screen isn’t square, so we need to handle the aspect ratio.\nLet’s say we want N columns of cells. Each cell has width \\(L = \\text{screen\\_width} / N\\) in pixels, and since cells are square, height \\(L\\) as well. The number of rows depends on the screen’s aspect ratio.\nWorking in our normalized coordinates (after aspect correction), the screen spans roughly \\([-2 \\cdot \\text{aspect}, 2 \\cdot \\text{aspect}]\\) in \\(x\\) and \\([-2, 2]\\) in \\(y\\). If we want cells of side length \\(L\\) in these coordinates:\nfloat aspect = iResolution.x / iResolution.y;\nfloat N = 5.0;  // number of columns\nfloat L = (4.0 * aspect) / N;  // cell size in our coordinate system\nNow each cell is an \\(L \\times L\\) square.\n\n\n\nFor each pixel, we want two things:\n\nWhich cell are we in? Integer coordinates \\((i, j)\\) identifying the cell.\nWhere in the cell are we? Local coordinates ranging from \\(-L/2\\) to \\(L/2\\), with \\((0,0)\\) at the cell center.\n\nvec2 cell_id = floor(p / L);\nvec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);\nThe cell_id tells us which cell; the cell_p gives local coordinates within that cell.\nIf we want local coordinates normalized to \\([-1, 1]\\) (useful for drawing things at a standard scale), we can rescale:\nvec2 local = cell_p / (L / 2.0);  // now in [-1, 1] x [-1, 1]\nThis is exactly the setup we’ll need for Day 2, where each cell will contain a Julia set with its own coordinate system.\n\n\n\nNow draw something using the local coordinates. A filled circle at the center of each cell:\nfloat d = length(cell_p);\nfloat r = L * 0.4;  // radius relative to cell size\n\nvec3 color;\nif (d &lt; r) {\n    color = vec3(1.0, 1.0, 0.0);\n} else {\n    color = vec3(0.1, 0.1, 0.3);\n}\n\nTry changing N to get more or fewer columns. The cells stay square regardless of screen shape.\n\n\n\nThe cell_id lets each cell behave differently. Some ideas:\nCheckerboard background:\nfloat checker = mod(cell_id.x + cell_id.y, 2.0);\nvec3 bg = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);\nRadius varying by cell:\nfloat r = L * (0.2 + 0.15 * mod(cell_id.x + cell_id.y, 3.0));\nWave animation:\nfloat cell_dist = length(cell_id);\nfloat r = L * (0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5));\n\n\n\nDesign a grid-based pattern that you find visually interesting. Some directions:\nConnecting shapes: Draw shapes that connect across cell boundaries. Quarter-circles in each corner create a continuous network. What implicit curves tile seamlessly?\nAlternating motifs: Use cell_id to alternate between different shapes—circles in some cells, rings in others, or different orientations.\nColor fields: Map cell_id to colors using distance from origin, stripes, or a palette.\nPhase shifts: Animate cells with different phase offsets to create waves or ripples.\nUsing local coordinates: Draw something more complex in each cell using the \\([-1,1]\\) local coordinate system—perhaps a small implicit curve, or a pattern that changes based on cell_id.\nThe goal is to produce an image you’d be happy to hang on a wall.\n\n\n\n\nThis project builds a visualization of Fourier series using epicycles—circles whose centers sit on the circumferences of other circles. This is how Ptolemy modeled planetary motion, and it turns out to be exactly how Fourier series work geometrically.\n\n\nAny periodic function can be written as a sum of sines and cosines. Geometrically, \\(\\sin(n\\omega t)\\) and \\(\\cos(n\\omega t)\\) describe a point moving around a circle of frequency \\(n\\omega\\). Adding these components corresponds to stacking circles: each circle’s center rides on the previous circle’s edge.\nFor example, the square wave has Fourier series: \\[f(t) = \\sum_{n=1,3,5,...} \\frac{1}{n} \\sin(n\\omega t)\\]\nThis means circles with: - Radii: \\(1, \\frac{1}{3}, \\frac{1}{5}, \\frac{1}{7}, ...\\) - Frequencies: \\(\\omega, 3\\omega, 5\\omega, 7\\omega, ...\\)\nThe more terms we add, the closer the final point’s \\(y\\)-coordinate approximates a square wave.\n\n\n\nStart by drawing a chain of circles. Each circle is centered at the current position, and the next position is computed by moving along the circle:\nvec2 pos = vec2(0.0, 0.0);  // start at origin\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;  // 1, 3, 5, 7, ...\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    // Draw circle at current position\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // color the circle\n    }\n    \n    // Move to next position\n    pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n}\n\n// Draw final point\nfloat d_point = length(p - pos);\nif (d_point &lt; 0.08) {\n    // bright color\n}\nTry this with N = 1, then N = 3, then N = 7. Watch how more circles create more complex motion.\n\n\n\nTo draw the arms connecting circle centers, we need the signed distance function for a line segment. Given endpoints \\(a\\) and \\(b\\), the distance from point \\(p\\) to the segment is:\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\nThe math: we project \\(p - a\\) onto the line direction \\(b - a\\), clamp to \\([0, 1]\\) to stay within the segment, then measure the distance to that closest point.\n\n\n\nNow modify your loop to also draw line segments:\nvec2 pos = vec2(0.0, 0.0);\n\nfor (int i = 0; i &lt; N; i++) {\n    int n = 2 * i + 1;\n    float r = scale / float(n);\n    float freq = float(n) * omega;\n    \n    vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));\n    \n    // Draw circle\n    float d_circle = abs(length(p - pos) - r);\n    if (d_circle &lt; 0.02) {\n        // faint circle color\n    }\n    \n    // Draw arm from pos to next_pos\n    float d_arm = sd_segment(p, pos, next_pos);\n    if (d_arm &lt; 0.015) {\n        // arm color\n    }\n    \n    pos = next_pos;\n}\n\n\n\nNow make it beautiful:\nFading circles: Later circles are smaller and less important. Fade their brightness:\nfloat fade = 1.0 - float(i) / float(N);\nColor variation: Color circles differently based on their index, or based on their frequency.\nDifferent waves: The square wave uses odd harmonics with \\(1/n\\) coefficients. Try: - Triangle wave: odd harmonics with \\(1/n^2\\) coefficients (alternating signs) - Sawtooth wave: all harmonics with \\(1/n\\) coefficients\nMouse control: Map iMouse.x to the number of terms, so dragging adds or removes circles.\nThe goal: create a mesmerizing animation that reveals the geometry hidden inside Fourier series.",
    "crumbs": [
      "Day 1: Introduction",
      "Lecture Notes"
    ]
  }
]