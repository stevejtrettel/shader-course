# Appendix: Complete Shader Code for Day 1

This appendix provides complete, standalone Shadertoy code for each shader program presented in Day 1. Each listing includes all necessary setup and can be copied directly into Shadertoy (https://www.shadertoy.com/new) and run immediately.

---

## A1. Basic Red Screen

The simplest possible shader - every pixel is red.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

---

## A2. Animated Color (Pulsing Red)

Using `iTime` to animate the red channel.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float red = 0.5 + 0.5 * sin(iTime);
    fragColor = vec4(red, 0.0, 0.0, 1.0);
}
```

---

## A3. Coordinate Visualization

Visualizing the coordinate system by mapping position to color.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Map x coordinate to red, y to green
    vec2 color_rg = p * 0.5 + 0.5;  // Remap to [0, 1]
    fragColor = vec4(color_rg, 0.0, 1.0);
}
```

---

## A4. Half-Plane Coloring (Ternary Operator)

Dividing the plane into two regions based on a linear function.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float L = p.x;  // The function L(x,y) = x
    
    vec3 color = (L < 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);
    fragColor = vec4(color, 1.0);
}
```

---

## A5. Half-Plane with Step Function

Same as above but using `step()` and `mix()`.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float s = step(0.0, p.x);  // 0 on left, 1 on right
    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), s);
    fragColor = vec4(color, 1.0);
}
```

---

## A6. Arbitrary Half-Plane

Dividing along an arbitrary line $ax + by + c = 0$.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float a = 1.0, b = 1.0, c = 0.0;
    float L = a * p.x + b * p.y + c;
    
    vec3 color = (L < 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);
    fragColor = vec4(color, 1.0);
}
```

---

## A7. Filled Circle

Using distance from origin to create a disk.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    
    vec3 color = (d < r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);
    fragColor = vec4(color, 1.0);
}
```

---

## A8. Distance-Based Coloring (Radial Gradient)

Using distance value itself to create a gradient.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float intensity = 1.0 - d / 2.0;  // Fades from 1 at center to 0 at distance 2
    intensity = clamp(intensity, 0.0, 1.0);  // Keep it in [0, 1]
    
    vec3 color = vec3(intensity);
    fragColor = vec4(color, 1.0);
}
```

---

## A9. Circle Outline (Hard Edge)

Drawing just the boundary of a circle with hard threshold.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float thickness = 0.05;
    
    float circle_mask = abs(d - r) < thickness ? 1.0 : 0.0;
    vec3 color = vec3(circle_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A10. Circle Outline (Smooth with Smoothstep)

Anti-aliased circle outline using `smoothstep()`.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float thickness = 0.05;
    
    float circle_mask = 1.0 - smoothstep(r - thickness, r + thickness, d);
    vec3 color = vec3(circle_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A11. Grid of Circles

Using `mod()` to create repeating circles.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float spacing = 1.0;
    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;
    
    // Draw a circle in each cell
    float d = length(cell_p);
    float r = 0.3;
    
    vec3 color = (d < r) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);
    fragColor = vec4(color, 1.0);
}
```

---

## A12. Grid with Alternating Background

Creating a checkerboard pattern behind the circles.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float spacing = 1.0;
    vec2 cell_id = floor(p / spacing);
    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;
    
    // Checkerboard background
    float checker = mod(cell_id.x + cell_id.y, 2.0);
    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);
    
    // Circle in each cell
    float d = length(cell_p);
    float r = 0.3;
    vec3 circle_color = vec3(1.0, 1.0, 0.0);
    
    vec3 color = (d < r) ? circle_color : bg_color;
    fragColor = vec4(color, 1.0);
}
```

---

## A13. Complete Grid Pattern

Full example combining grid cells, checkerboard, and circles.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float spacing = 1.0;
    vec2 cell_id = floor(p / spacing);
    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;
    
    // Checkerboard background
    float checker = mod(cell_id.x + cell_id.y, 2.0);
    vec3 bg_color = mix(vec3(0.2, 0.2, 0.3), vec3(0.3, 0.2, 0.2), checker);
    
    // Circle in each cell
    float d = length(cell_p);
    float r = 0.3;
    vec3 circle_color = vec3(1.0, 1.0, 0.0);
    
    vec3 color = (d < r) ? circle_color : bg_color;
    fragColor = vec4(color, 1.0);
}
```

---

## A14. Implicit Curve: Parabola

Drawing a parabola using the implicit equation $y = x^2$.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float F = p.y - p.x * p.x;
    float thickness = 0.1;
    float curve_mask = abs(F) < thickness ? 1.0 : 0.0;
    
    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A15. Implicit Curve: Circle

Drawing a circle using the implicit equation $x^2 + y^2 = r^2$.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float r = 1.0;
    float F = dot(p, p) - r * r;  // dot(p,p) = x² + y²
    float thickness = 0.1;
    float curve_mask = abs(F) < thickness ? 1.0 : 0.0;
    
    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A16. Implicit Curve: Hyperbola

Drawing a hyperbola $xy = 1$.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float F = p.x * p.y - 1.0;
    float thickness = 0.1;
    float curve_mask = abs(F) < thickness ? 1.0 : 0.0;
    
    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A17. Implicit Curve: Ellipse

Drawing an ellipse $\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1$.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float a = 2.0, b = 1.0;
    float F = (p.x * p.x) / (a * a) + (p.y * p.y) / (b * b) - 1.0;
    float thickness = 0.1;
    float curve_mask = abs(F) < thickness ? 1.0 : 0.0;
    
    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A18. Parabola Graphing Calculator (Homework Template)

Template for the required homework assignment.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Define parameters
    float a = 1.0;
    float b = 0.0;
    float c = 0.0;
    
    // Background
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    // TODO: Draw x-axis (|y| < thickness)
    // TODO: Draw y-axis (|x| < thickness)
    // TODO: Draw parabola (|y - (ax² + bx + c)| < thickness)
    
    fragColor = vec4(color, 1.0);
}
```

---

## A19. Parabola Graphing Calculator (Complete Solution)

Complete implementation of the required homework.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Define parameters
    float a = 1.0;
    float b = 0.0;
    float c = 0.0;
    
    // Background
    vec3 color = vec3(0.1, 0.1, 0.15);
    
    // Axes
    float axis_thickness = 0.02;
    float x_axis_mask = abs(p.y) < axis_thickness ? 1.0 : 0.0;
    float y_axis_mask = abs(p.x) < axis_thickness ? 1.0 : 0.0;
    vec3 axis_color = vec3(0.3, 0.3, 0.3);
    
    // Parabola: F(x,y) = y - (ax² + bx + c) = 0
    float F = p.y - (a * p.x * p.x + b * p.x + c);
    float curve_thickness = 0.08;
    float parabola_mask = abs(F) < curve_thickness ? 1.0 : 0.0;
    vec3 parabola_color = vec3(1.0, 0.8, 0.0);
    
    // Combine (axes behind parabola)
    color = mix(color, axis_color, max(x_axis_mask, y_axis_mask));
    color = mix(color, parabola_color, parabola_mask);
    
    fragColor = vec4(color, 1.0);
}
```

---

## A20. Animated Curve Family: Circle

Animating through different circle radii.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Animated radius
    float r = 1.0 + 0.5 * sin(iTime);
    
    float F = dot(p, p) - r * r;
    float thickness = 0.08;
    float curve_mask = abs(F) < thickness ? 1.0 : 0.0;
    
    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A21. Animated Curve Family: Rotating Ellipse

Ellipse that rotates over time.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Rotation angle from time
    float theta = iTime * 0.5;
    
    // Rotate coordinates
    vec2 p_rot = vec2(
        p.x * cos(theta) + p.y * sin(theta),
        -p.x * sin(theta) + p.y * cos(theta)
    );
    
    // Ellipse in rotated coordinates
    float a = 2.0, b = 1.0;
    float F = (p_rot.x * p_rot.x) / (a * a) + (p_rot.y * p_rot.y) / (b * b) - 1.0;
    float thickness = 0.08;
    float curve_mask = abs(F) < thickness ? 1.0 : 0.0;
    
    vec3 color = mix(vec3(0.1, 0.1, 0.3), vec3(1.0, 1.0, 0.0), curve_mask);
    fragColor = vec4(color, 1.0);
}
```

---

## A22. Beautiful Tiling: Geometric Pattern

Example of a custom tiling pattern using circles and symmetry.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float spacing = 1.0;
    vec2 cell_id = floor(p / spacing);
    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;
    
    // Use symmetry within each cell
    cell_p = abs(cell_p);  // 4-fold symmetry
    
    // Multiple circles at different positions
    float d1 = length(cell_p - vec2(0.2, 0.2));
    float d2 = length(cell_p - vec2(0.4, 0.0));
    float d3 = length(cell_p - vec2(0.0, 0.4));
    
    float r = 0.15;
    float mask = (d1 < r || d2 < r || d3 < r) ? 1.0 : 0.0;
    
    // Vary color by cell position
    float checker = mod(cell_id.x + cell_id.y, 2.0);
    vec3 color1 = vec3(0.2, 0.4, 0.6);
    vec3 color2 = vec3(0.6, 0.2, 0.4);
    vec3 bg = mix(color1, color2, checker);
    
    vec3 circle_color = vec3(1.0, 0.9, 0.7);
    vec3 color = mix(bg, circle_color, mask);
    
    fragColor = vec4(color, 1.0);
}
```

---

## A23. Beautiful Tiling: Distance-Based Animation

Pattern that pulses based on time and distance.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float spacing = 1.0;
    vec2 cell_id = floor(p / spacing);
    vec2 cell_p = mod(p + spacing/2.0, spacing) - spacing/2.0;
    
    // Distance from cell center
    float d = length(cell_p);
    
    // Distance from origin (in cell coordinates)
    float cell_dist = length(cell_id);
    
    // Animated radius that propagates outward
    float r = 0.3 + 0.1 * sin(iTime * 2.0 - cell_dist * 0.5);
    
    float mask = smoothstep(r + 0.05, r - 0.05, d);
    
    // Color based on cell distance
    vec3 color1 = vec3(0.2, 0.3, 0.5);
    vec3 color2 = vec3(0.8, 0.3, 0.4);
    float t = fract(cell_dist * 0.2);
    vec3 circle_color = mix(color1, color2, t);
    
    vec3 bg = vec3(0.1, 0.1, 0.15);
    vec3 color = mix(bg, circle_color, mask);
    
    fragColor = vec4(color, 1.0);
}
```

---

## A24. Lemniscate of Bernoulli (Naive Threshold)

Drawing a lemniscate using naive `|F| < thickness`. Notice the non-uniform visual thickness—especially near the origin where the curve self-intersects and the gradient approaches zero.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;

    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)
    float a = 1.0;
    float r2 = dot(p, p);
    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);

    // Naive threshold - thickness varies!
    float thickness = 0.15;
    vec3 color = (abs(F) < thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);

    fragColor = vec4(color, 1.0);
}
```

---

## A25. Lemniscate of Bernoulli (Gradient-Corrected)

Same curve, but now we divide by the gradient magnitude to approximate the signed distance function. This gives uniform visual thickness even near the singular point at the origin.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - 0.5;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;

    // Lemniscate of Bernoulli: (x² + y²)² = a²(x² - y²)
    float a = 1.0;
    float r2 = dot(p, p);
    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);

    // Compute gradient analytically:
    // ∂F/∂x = 4x(x² + y²) - 2a²x = 2x(2r² - a²)
    // ∂F/∂y = 4y(x² + y²) + 2a²y = 2y(2r² + a²)
    vec2 grad = vec2(
        2.0 * p.x * (2.0 * r2 - a * a),
        2.0 * p.y * (2.0 * r2 + a * a)
    );

    // Approximate signed distance: |F| / |∇F|
    float gradLen = length(grad);
    float dist = abs(F) / max(gradLen, 0.01);  // avoid division by zero

    // Uniform thickness
    float thickness = 0.05;
    vec3 color = (dist < thickness) ? vec3(1.0, 1.0, 0.0) : vec3(0.1, 0.1, 0.3);

    fragColor = vec4(color, 1.0);
}
```

---

## Notes on Using These Shaders

### Getting Started
1. Go to https://www.shadertoy.com/new
2. Delete the default code
3. Copy and paste any of the above listings
4. Click the play button (▶) or press Alt+Enter

### Coordinate System

All shaders (except A1 and A2) use the standard coordinate transformation:

```glsl
vec2 uv = fragCoord / iResolution.xy;  // Normalize to [0,1]
uv = uv - 0.5;                          // Center at origin
uv.x *= iResolution.x / iResolution.y; // Aspect ratio correction
vec2 p = uv * 4.0;                      // Scale viewing window
```

This gives you coordinates centered at the origin with equal scaling in x and y.

### Modifying Parameters

**Coordinate scaling:**
- Change `uv * 4.0` to zoom in/out (smaller number = zoom in)

**Colors:**
- Modify `vec3(r, g, b)` values (each in range [0, 1])
- Red: `vec3(1.0, 0.0, 0.0)`
- Green: `vec3(0.0, 1.0, 0.0)`
- Blue: `vec3(0.0, 0.0, 1.0)`
- Yellow: `vec3(1.0, 1.0, 0.0)`
- Cyan: `vec3(0.0, 1.0, 1.0)`
- Magenta: `vec3(1.0, 0.0, 1.0)`

**Distance and thickness:**
- `thickness` parameters control line width
- Larger thickness = thicker lines/curves

**Grid patterns:**
- `spacing` controls grid cell size
- Smaller spacing = more cells

**Animation:**
- Use `iTime` for time-based animation
- `sin(iTime)` oscillates between -1 and 1
- `0.5 + 0.5 * sin(iTime)` oscillates between 0 and 1

### Common Modifications to Try

**Make circles pulse:**
```glsl
float r = 0.3 + 0.1 * sin(iTime);
```

**Make grid spacing animate:**
```glsl
float spacing = 1.0 + 0.3 * sin(iTime * 0.5);
```

**Add mouse interaction:**
```glsl
vec2 mouse = iMouse.xy / iResolution.xy;
mouse = mouse - 0.5;
mouse.x *= iResolution.x / iResolution.y;
// Use mouse position to control parameters
```

**Combine techniques:**
- Put implicit curves on a grid using `mod()`
- Add animation to any parameter with `iTime`
- Use distance fields to create smooth transitions

### Troubleshooting

**Shader won't compile:**
- Check for missing semicolons
- Make sure all numbers are floats: `1.0` not `1`
- Verify parentheses and braces are balanced

**Nothing shows up:**
- Check your coordinate scaling - might be zoomed too far in/out
- Verify colors are in [0, 1] range
- Make sure alpha channel is 1.0: `vec4(color, 1.0)`

**Circles look like ellipses:**
- Make sure you include the aspect ratio correction:
  `uv.x *= iResolution.x / iResolution.y;`

### Next Steps

Once you're comfortable with these basics:
- Combine multiple techniques in one shader
- Create your own implicit curves
- Design custom tiling patterns
- Add animation and interactivity
- Experiment with color palettes and smooth transitions

The goal is to understand how coordinate transformations, distance functions, and conditionals work together to create mathematical visualizations on the GPU! 