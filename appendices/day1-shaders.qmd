# Appendix: Day 1 Shader Code

This appendix provides complete, standalone code for each shader referenced in Day 1. Each listing can be copied directly into [Shadertoy](https://www.shadertoy.com/new) and run immediately.

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    vec2 sun = normalize_coord(iMouse.xy);
    
    // Earth orbits the sun
    float orbit_radius = 0.8;
    vec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));
    
    // Draw sun (larger, yellow)
    float d_sun = length(p - sun);
    // Draw earth (smaller, blue)
    float d_earth = length(p - earth);
    
    vec3 color = vec3(0.02, 0.02, 0.05);  // dark background
    if (d_sun < 0.3) {
        color = vec3(1.0, 0.9, 0.2);  // yellow sun
    }
    if (d_earth < 0.15) {
        color = vec3(0.2, 0.5, 1.0);  // blue earth
    }
    
    fragColor = vec4(color, 1.0);
}
```

## A1. red

The simplest shader: every pixel is red.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
```

---

## A2. red-pulsing

Red channel oscillates with time.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float red = 0.5 + 0.5 * sin(iTime);
    fragColor = vec4(red, 0.0, 0.0, 1.0);
}
```

---

## A3. coordinates

Visualizing the coordinate system as color.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    fragColor = vec4(uv.x, uv.y, 0.0, 1.0);
}
```

---

## A4. half-plane

Dividing the plane into two regions based on y-coordinate.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float L = p.y;
    
    vec3 color;
    if (L < 0.0) {
        color = vec3(1.0, 0.0, 0.0);  // red below
    } else {
        color = vec3(0.0, 0.0, 1.0);  // blue above
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A5. half-plane-animated

Animated line dividing the plane, with rotating normal and shifting offset.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float a = cos(iTime);
    float b = sin(iTime);
    float c = 0.5 * sin(iTime * 0.7);
    float L = a * p.x + b * p.y + c;
    
    vec3 color;
    if (L < 0.0) {
        color = vec3(1.0, 0.0, 0.0);
    } else {
        color = vec3(0.0, 0.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A6. circle

Filled circle centered at the origin.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float f = d - r;
    
    vec3 color;
    if (f < 0.0) {
        color = vec3(1.0, 1.0, 0.0);  // yellow inside
    } else {
        color = vec3(0.1, 0.1, 0.3);  // dark blue outside
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A7. circle-curve

Circle outline (ring) centered at the origin.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float eps = 0.1;
    float f = abs(d - r) - eps;
    
    vec3 color;
    if (f < 0.0) {
        color = vec3(1.0, 1.0, 0.0);  // yellow ring
    } else {
        color = vec3(0.1, 0.1, 0.3);  // dark background
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A8. parabola

The parabola $y = x^2$ rendered as an implicit curve.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float F = p.y - p.x * p.x;
    float eps = 0.1;
    
    vec3 color;
    if (abs(F) < eps) {
        color = vec3(1.0, 1.0, 0.0);  // yellow curve
    } else {
        color = vec3(0.1, 0.1, 0.3);  // dark background
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A9. lemniscate-naive

Lemniscate of Bernoulli with naive thresholding (non-uniform thickness).

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float a = 1.5;
    float r2 = dot(p, p);
    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);
    
    float eps = 0.15;
    
    vec3 color;
    if (abs(F) < eps) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A10. lemniscate-gradient

Lemniscate with gradient correction for uniform thickness.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float a = 1.5;
    float r2 = dot(p, p);
    float F = r2 * r2 - a * a * (p.x * p.x - p.y * p.y);
    
    vec2 grad = vec2(
        4.0 * p.x * r2 - 2.0 * a * a * p.x,
        4.0 * p.y * r2 + 2.0 * a * a * p.y
    );
    
    float dist = abs(F) / max(length(grad), 0.01);
    float eps = 0.05;
    
    vec3 color;
    if (dist < eps) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A11. lemniscate-animated

Cassini ovals animated through the lemniscate transition.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Cassini oval parameters
    float c = 1.0;  // half-distance between foci
    float a = 0.8 + 0.4 * sin(iTime * 0.5);  // animate through transition
    
    // Implicit equation: (x² + y²)² - 2c²(x² - y²) = a⁴ - c⁴
    float r2 = dot(p, p);
    float c2 = c * c;
    float a4 = a * a * a * a;
    float c4 = c2 * c2;
    float F = r2 * r2 - 2.0 * c2 * (p.x * p.x - p.y * p.y) - (a4 - c4);
    
    // Gradient
    vec2 grad = vec2(
        4.0 * p.x * r2 - 4.0 * c2 * p.x,
        4.0 * p.y * r2 + 4.0 * c2 * p.y
    );
    
    float dist = abs(F) / max(length(grad), 0.01);
    float eps = 0.05;
    
    vec3 color;
    if (dist < eps) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A12. circle-mouse

Circle that follows the mouse position.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Normalize fragment coordinate
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Normalize mouse coordinate the same way
    vec2 mouse = iMouse.xy / iResolution.xy;
    mouse = mouse - vec2(0.5, 0.5);
    mouse.x *= iResolution.x / iResolution.y;
    mouse = mouse * 4.0;
    
    // Circle centered at mouse
    float d = length(p - mouse);
    float r = 0.5;
    
    vec3 color;
    if (d < r) {
        color = vec3(1.0, 0.9, 0.2);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A13. sun-earth

Sun at mouse click position with orbiting earth.

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Use iMouse.zw (last click position) so sun stays put
    vec2 sun = normalize_coord(iMouse.zw);
    
    // Earth orbits the sun
    float orbit_radius = 0.8;
    vec2 earth = sun + orbit_radius * vec2(cos(iTime), sin(iTime));
    
    // Draw sun (larger, yellow)
    float d_sun = length(p - sun);
    // Draw earth (smaller, blue)
    float d_earth = length(p - earth);
    
    vec3 color = vec3(0.02, 0.02, 0.05);  // dark background
    if (d_sun < 0.3) {
        color = vec3(1.0, 0.9, 0.2);  // yellow sun
    }
    if (d_earth < 0.15) {
        color = vec3(0.2, 0.5, 1.0);  // blue earth
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A14. folium-mouse

Folium of Descartes with mouse-controlled level set.

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Fixed parameter a
    float a = 1.5;
    
    // Map mouse x to level set value c in [-2, 2]
    float c = mix(-2.0, 2.0, iMouse.x / iResolution.x);
    
    // Folium of Descartes: x³ + y³ - 3axy = c
    float F = p.x*p.x*p.x + p.y*p.y*p.y - 3.0*a*p.x*p.y - c;
    
    // Gradient: ∇F = (3x² - 3ay, 3y² - 3ax)
    vec2 grad = vec2(3.0*p.x*p.x - 3.0*a*p.y, 3.0*p.y*p.y - 3.0*a*p.x);
    float dist = abs(F) / max(length(grad), 0.01);
    
    vec3 color;
    if (dist < 0.05) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A15. elliptic-family

Family of elliptic curves with mouse-controlled center parameters.

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Mouse controls the central (a, b) of our family
    float a_center = mix(-3.0, 1.0, iMouse.x / iResolution.x);
    float b_center = mix(-2.0, 2.0, iMouse.y / iResolution.y);
    
    vec3 color = vec3(0.05, 0.05, 0.1);  // dark background
    
    // Draw curves for a range of a values around a_center
    for (float i = -3.0; i <= 3.0; i += 1.0) {
        float a = a_center + i * 0.5;  // more spacing
        float b = b_center;
        
        // Elliptic curve: y² = x³ + ax + b
        float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;
        
        // Gradient
        vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);
        float dist = abs(F) / max(length(grad), 0.01);
        
        // Brightness fades quickly: central curve bright, outer curves fade to background
        float t = abs(i) / 3.0;  // 0 at center, 1 at edges
        float brightness = 1.0 - t * t;  // quadratic falloff
        
        if (dist < 0.03 && brightness > 0.05) {
            // Check discriminant for this specific curve
            float disc = 4.0 * a * a * a + 27.0 * b * b;
            if (abs(disc) < 0.3) {
                color = mix(color, vec3(1.0, 0.3, 0.3), brightness);  // red for singular
            } else {
                color = mix(color, vec3(1.0, 1.0, 0.5), brightness);  // yellow for smooth
            }
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## A16. grid-circles

Grid of circles with square cells.

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float aspect = iResolution.x / iResolution.y;
    float N = 5.0;  // number of columns
    float L = (4.0 * aspect) / N;  // cell size
    
    vec2 cell_id = floor(p / L);
    vec2 cell_p = mod(p + vec2(L/2.0, L/2.0), L) - vec2(L/2.0, L/2.0);
    
    // Checkerboard background
    float checker = mod(cell_id.x + cell_id.y, 2.0);
    vec3 bg = mix(vec3(0.15, 0.15, 0.25), vec3(0.25, 0.15, 0.15), checker);
    
    // Circle in each cell
    float d = length(cell_p);
    float r = L * 0.35;
    
    vec3 color;
    if (d < r) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = bg;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## Notes

### Coordinate Setup

Most shaders use this standard coordinate setup:

```glsl
vec2 uv = fragCoord / iResolution.xy;   // normalize to [0,1]
uv = uv - vec2(0.5, 0.5);               // center origin
uv.x *= iResolution.x / iResolution.y;  // aspect correction
vec2 p = uv * 4.0;                      // scale to [-2, 2] range
```

### Helper Function

For shaders using mouse input, we define:

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}
```

### Gradient Correction

For implicit curves $F(x,y) = 0$ with uniform thickness:

```glsl
float dist = abs(F) / max(length(grad), 0.01);
```

where `grad` is $\nabla F$ computed analytically.