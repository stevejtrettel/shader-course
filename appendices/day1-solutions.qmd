# Appendix: Day 1 Homework Solutions

---

## Checkpoints

### C1. Solid Colors

**(a) Green:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(0.0, 1.0, 0.0, 1.0);
}
```

**(b) Cyan:**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(0.0, 1.0, 1.0, 1.0);
}
```

**(c) Custom color (example: orange):**
```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    fragColor = vec4(1.0, 0.5, 0.2, 1.0);
}
```

---

### C2. Vertical Split

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float L = p.x;  // changed from p.y
    
    vec3 color;
    if (L < 0.0) {
        color = vec3(1.0, 0.0, 0.0);  // red on left
    } else {
        color = vec3(0.0, 0.0, 1.0);  // blue on right
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C3. Off-Center Circle

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    vec2 center = vec2(1.0, 1.0);
    float d = length(p - center);
    float r = 0.5;
    
    vec3 color;
    if (d < r) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C4. Pulsing Circle

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0 + 0.5 * sin(iTime);  // oscillates between 0.5 and 1.5
    
    vec3 color;
    if (d < r) {
        color = vec3(1.0, 1.0, 0.0);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### C5. Ring Thickness

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float r = 1.0;
    float eps = 0.1;  // try 0.02, 0.05, 0.1, 0.2, 0.5
    
    vec3 color;
    if (abs(d - r) < eps) {
        color = vec3(1.0, 1.0, 0.0);  // yellow ring
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** Students should observe that `eps` controls the visual thickness of the ring. Smaller values give thinner rings; larger values give thicker rings. The ring has total width $2\varepsilon$.

---

## Explorations

### E1. Concentric Rings

**Step 1: Draw a few rings manually**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float eps = 0.05;
    
    vec3 color = vec3(0.1, 0.1, 0.3);  // background
    
    // Draw rings at r = 0.5, 1.0, 1.5, 2.0
    if (abs(d - 0.5) < eps) color = vec3(1.0, 1.0, 0.0);
    if (abs(d - 1.0) < eps) color = vec3(1.0, 1.0, 0.0);
    if (abs(d - 1.5) < eps) color = vec3(1.0, 1.0, 0.0);
    if (abs(d - 2.0) < eps) color = vec3(1.0, 1.0, 0.0);
    
    fragColor = vec4(color, 1.0);
}
```

**Step 2: Use a for loop**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float eps = 0.05;
    
    vec3 color = vec3(0.1, 0.1, 0.3);  // background
    
    // Draw rings at r = 0.5, 1.0, 1.5, 2.0
    for (float r = 0.5; r <= 2.0; r += 0.5) {
        if (abs(d - r) < eps) {
            color = vec3(1.0, 1.0, 0.0);
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Step 3: Alternating colors with mod**

The `mod(x, y)` function returns the remainder when `x` is divided by `y`. So `mod(i, 2.0)` alternates between 0 and 1 as `i` increases. We can use this to alternate colors:

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float d = length(p);
    float eps = 0.05;
    
    vec3 color = vec3(0.1, 0.1, 0.3);  // background
    
    float i = 0.0;
    for (float r = 0.5; r <= 2.0; r += 0.5) {
        if (abs(d - r) < eps) {
            if (mod(i, 2.0) < 1.0) {
                color = vec3(1.0, 1.0, 0.0);  // yellow
            } else {
                color = vec3(0.0, 1.0, 1.0);  // cyan
            }
        }
        i += 1.0;
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E2. Moon Orbit

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    vec2 sun = normalize_coord(iMouse.zw);
    
    // Earth orbits the sun
    float earth_orbit = 1.2;
    float earth_speed = 1.0;
    vec2 earth = sun + earth_orbit * vec2(cos(iTime * earth_speed), sin(iTime * earth_speed));
    
    // Moon orbits the earth (smaller orbit, faster speed)
    float moon_orbit = 0.25;
    float moon_speed = 3.0;
    vec2 moon = earth + moon_orbit * vec2(cos(iTime * moon_speed), sin(iTime * moon_speed));
    
    // Distances
    float d_sun = length(p - sun);
    float d_earth = length(p - earth);
    float d_moon = length(p - moon);
    
    // Draw (back to front: sun, earth, moon)
    vec3 color = vec3(0.02, 0.02, 0.05);
    
    if (d_sun < 0.3) {
        color = vec3(1.0, 0.9, 0.2);  // yellow sun
    }
    if (d_earth < 0.15) {
        color = vec3(0.2, 0.5, 1.0);  // blue earth
    }
    if (d_moon < 0.08) {
        color = vec3(0.8, 0.8, 0.8);  // gray moon
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Extension: Solar system with more planets**

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    vec2 sun = vec2(0.0, 0.0);  // sun at center
    
    // Planet parameters: orbit radius, speed, size, color
    vec3 color = vec3(0.02, 0.02, 0.05);
    
    // Sun
    if (length(p - sun) < 0.25) {
        color = vec3(1.0, 0.9, 0.2);
    }
    
    // Mercury
    vec2 mercury = sun + 0.5 * vec2(cos(iTime * 4.0), sin(iTime * 4.0));
    if (length(p - mercury) < 0.05) {
        color = vec3(0.7, 0.7, 0.7);
    }
    
    // Venus
    vec2 venus = sun + 0.8 * vec2(cos(iTime * 2.5), sin(iTime * 2.5));
    if (length(p - venus) < 0.08) {
        color = vec3(0.9, 0.7, 0.4);
    }
    
    // Earth with moon
    vec2 earth = sun + 1.2 * vec2(cos(iTime * 1.5), sin(iTime * 1.5));
    vec2 moon = earth + 0.15 * vec2(cos(iTime * 5.0), sin(iTime * 5.0));
    if (length(p - earth) < 0.1) {
        color = vec3(0.2, 0.5, 1.0);
    }
    if (length(p - moon) < 0.04) {
        color = vec3(0.8, 0.8, 0.8);
    }
    
    // Mars
    vec2 mars = sun + 1.6 * vec2(cos(iTime * 1.0), sin(iTime * 1.0));
    if (length(p - mars) < 0.07) {
        color = vec3(0.9, 0.4, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E3. Your Favorite Curve

**Example: Cardioid** $(x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)$

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float a = 1.0;
    float r2 = dot(p, p);
    
    // (x² + y² - ax)² = a²(x² + y²)
    // F = (r² - ax)² - a²r²
    float lhs = r2 - a * p.x;
    float F = lhs * lhs - a * a * r2;
    
    // Gradient (computed analytically)
    // dF/dx = 2(r² - ax)(2x - a) - 2a²x
    // dF/dy = 2(r² - ax)(2y) - 2a²y
    vec2 grad = vec2(
        2.0 * lhs * (2.0 * p.x - a) - 2.0 * a * a * p.x,
        2.0 * lhs * (2.0 * p.y) - 2.0 * a * a * p.y
    );
    
    float dist = abs(F) / max(length(grad), 0.01);
    
    vec3 color;
    if (dist < 0.05) {
        color = vec3(1.0, 0.5, 0.5);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### E4. Curve Explorer

**Example: Superellipse** $|x/a|^n + |y/b|^n = 1$, with exponent $n$ controlled by mouse.

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Map mouse x to exponent n in [0.5, 4.0]
    // n < 1: star shape, n = 1: diamond, n = 2: ellipse, n > 2: rounded rectangle
    float n = mix(0.5, 4.0, iMouse.x / iResolution.x);
    
    float a = 1.5;
    float b = 1.0;
    
    // Superellipse: |x/a|^n + |y/b|^n = 1
    // F = |x/a|^n + |y/b|^n - 1
    float F = pow(abs(p.x / a), n) + pow(abs(p.y / b), n) - 1.0;
    
    // Numerical gradient (analytical is messy for arbitrary n)
    float eps_grad = 0.01;
    float Fx = pow(abs((p.x + eps_grad) / a), n) + pow(abs(p.y / b), n) - 1.0;
    float Fy = pow(abs(p.x / a), n) + pow(abs((p.y + eps_grad) / b), n) - 1.0;
    vec2 grad = vec2(Fx - F, Fy - F) / eps_grad;
    
    float dist = abs(F) / max(length(grad), 0.01);
    
    vec3 color;
    if (dist < 0.05) {
        color = vec3(0.5, 1.0, 0.5);
    } else {
        color = vec3(0.1, 0.1, 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** Dragging from left to right morphs the shape from a 4-pointed star ($n < 1$) through a diamond ($n = 1$), circle ($n = 2$), to a rounded rectangle ($n > 2$). This family is called the Lamé curves.

---

### E5. Two Circles (Venn Diagram)

**Version 1: One circle in front of the other**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Two circles
    vec2 c1 = vec2(-0.6, 0.0);
    vec2 c2 = vec2(0.6, 0.0);
    float r = 1.0;
    
    float d1 = length(p - c1);
    float d2 = length(p - c2);
    
    // Draw back to front: circle 1 first, then circle 2 on top
    vec3 color = vec3(0.1, 0.1, 0.2);  // background
    
    if (d1 < r) {
        color = vec3(1.0, 0.3, 0.3);  // red circle 1
    }
    if (d2 < r) {
        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 (drawn on top)
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Version 2: Venn diagram with three colors**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Two circles
    vec2 c1 = vec2(-0.6, 0.0);
    vec2 c2 = vec2(0.6, 0.0);
    float r = 1.0;
    
    float d1 = length(p - c1);
    float d2 = length(p - c2);
    
    bool in1 = d1 < r;
    bool in2 = d2 < r;
    
    vec3 color;
    if (in1 && in2) {
        color = vec3(1.0, 1.0, 0.0);  // yellow intersection
    } else if (in1) {
        color = vec3(1.0, 0.3, 0.3);  // red circle 1 only
    } else if (in2) {
        color = vec3(0.3, 0.3, 1.0);  // blue circle 2 only
    } else {
        color = vec3(0.1, 0.1, 0.2);  // background
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

## Challenges

### H1. Parabola Graphing Calculator

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Map mouse to coefficients
    // a in [-2, 2], b in [-3, 3], c fixed at -1
    float a = mix(-2.0, 2.0, iMouse.x / iResolution.x);
    float b = mix(-3.0, 3.0, iMouse.y / iResolution.y);
    float c = -1.0;
    
    vec3 color = vec3(0.1, 0.1, 0.15);  // background
    
    // Draw axes
    float axis_thickness = 0.03;
    if (abs(p.x) < axis_thickness) {
        color = vec3(0.3, 0.3, 0.3);  // y-axis
    }
    if (abs(p.y) < axis_thickness) {
        color = vec3(0.3, 0.3, 0.3);  // x-axis
    }
    
    // Draw parabola: y = ax² + bx + c
    // Implicit: F = y - ax² - bx - c
    float F = p.y - a * p.x * p.x - b * p.x - c;
    vec2 grad = vec2(-2.0 * a * p.x - b, 1.0);
    float dist = abs(F) / length(grad);
    
    if (dist < 0.05) {
        color = vec3(1.0, 1.0, 0.0);  // yellow parabola
    }
    
    // Find and draw roots
    // ax² + bx + c = 0
    // x = (-b ± sqrt(b² - 4ac)) / 2a
    float discriminant = b * b - 4.0 * a * c;
    
    if (discriminant >= 0.0 && abs(a) > 0.01) {
        float sqrt_disc = sqrt(discriminant);
        float x1 = (-b + sqrt_disc) / (2.0 * a);
        float x2 = (-b - sqrt_disc) / (2.0 * a);
        
        // Draw circles around roots
        float root_radius = 0.15;
        float root_thickness = 0.03;
        
        float d1 = abs(length(p - vec2(x1, 0.0)) - root_radius);
        float d2 = abs(length(p - vec2(x2, 0.0)) - root_radius);
        
        if (d1 < root_thickness) {
            color = vec3(1.0, 0.3, 0.3);  // red circle at root 1
        }
        if (d2 < root_thickness) {
            color = vec3(0.3, 1.0, 0.3);  // green circle at root 2
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### H2. Elliptic Curve Explorer

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Map mouse to (a, b) parameter space
    float a = mix(-3.0, 1.0, iMouse.x / iResolution.x);
    float b = mix(-2.0, 2.0, iMouse.y / iResolution.y);
    
    // Discriminant
    float disc = 4.0 * a * a * a + 27.0 * b * b;
    
    // Elliptic curve: y² = x³ + ax + b
    float F = p.y * p.y - p.x * p.x * p.x - a * p.x - b;
    vec2 grad = vec2(-3.0 * p.x * p.x - a, 2.0 * p.y);
    float dist = abs(F) / max(length(grad), 0.01);
    
    vec3 color = vec3(0.1, 0.1, 0.2);
    
    if (dist < 0.05) {
        // Color based on discriminant: red for singular, yellow for smooth
        if (abs(disc) < 0.5) {
            color = vec3(1.0, 0.2, 0.2);  // red for singular
        } else {
            color = vec3(1.0, 1.0, 0.0);  // yellow for smooth
        }
    }
    
    fragColor = vec4(color, 1.0);
}
```

---

### H3. Signed Distance Functions

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Signed distance to half-plane x > 1
    // SDF: distance is negative when inside (x > 1), positive outside
    float sdf_halfplane = 1.0 - p.x;  // negative when x > 1
    
    // Signed distance to rectangle [-1, 1] x [-0.5, 0.5]
    // SDF for axis-aligned box
    vec2 box_size = vec2(1.0, 0.5);
    vec2 d = abs(p) - box_size;
    float sdf_rect = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
    
    // Choose which to display (toggle by uncommenting)
    float sdf = sdf_rect;
    // float sdf = sdf_halfplane;
    
    // Draw with uniform thickness boundary
    float eps = 0.05;
    
    vec3 color;
    if (sdf < -eps) {
        color = vec3(0.3, 0.3, 0.6);  // inside
    } else if (sdf < eps) {
        color = vec3(1.0, 1.0, 0.0);  // boundary
    } else {
        color = vec3(0.1, 0.1, 0.2);  // outside
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** The key insight is that for the rectangle SDF:
- `max(d, 0.0)` handles points outside the box
- `min(max(d.x, d.y), 0.0)` handles points inside the box
- No gradient correction needed because it's a true distance function!

---

### H4. Smooth Blending

```glsl
// Smooth minimum function
float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * k * 0.25;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    // Two circles that orbit each other
    float angle = iTime * 0.5;
    vec2 c1 = 0.8 * vec2(cos(angle), sin(angle));
    vec2 c2 = 0.8 * vec2(cos(angle + 3.14159), sin(angle + 3.14159));
    float r = 0.8;
    
    float d1 = length(p - c1) - r;
    float d2 = length(p - c2) - r;
    
    // Smooth blend parameter (try 0.1 to 1.0)
    float k = 0.5;
    float d = smin(d1, d2, k);
    
    vec3 color;
    if (d < 0.0) {
        color = vec3(1.0, 0.8, 0.2);
    } else {
        color = vec3(0.1, 0.1, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** The `smin` function smoothly blends two distance fields. The parameter `k` controls how "soft" the blend is—larger values create more melting together. Watch the two blobs merge and separate as they orbit.

---

### H5. Inversion

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    // Mouse controls the line position
    float line_x = mix(0.5, 2.0, iMouse.x / iResolution.x);
    
    // Apply circle inversion: p -> p / |p|²
    float r2 = dot(p, p);
    vec2 p_inv = p / max(r2, 0.01);  // avoid division by zero
    
    vec3 color = vec3(0.1, 0.1, 0.2);
    
    // Draw unit circle (the circle of inversion)
    if (abs(length(p) - 1.0) < 0.02) {
        color = vec3(0.3, 0.3, 0.4);
    }
    
    // Draw the original line x = line_x (in cyan)
    if (abs(p.x - line_x) < 0.03) {
        color = vec3(0.0, 0.8, 0.8);
    }
    
    // Draw the inverted line (becomes a circle through origin!) in yellow
    // The line x = a inverts to a circle with center (1/(2a), 0) and radius 1/(2a)
    float inv_radius = 1.0 / (2.0 * line_x);
    vec2 inv_center = vec2(inv_radius, 0.0);
    if (abs(length(p - inv_center) - inv_radius) < 0.03) {
        color = vec3(1.0, 1.0, 0.0);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** Key observations:
- Lines through origin map to themselves
- Lines not through origin map to circles through origin (shown here)
- Circles through origin map to lines
- Circles not through origin map to circles
- The unit circle (gray) is the "mirror" of the inversion

Drag the mouse to move the original line (cyan) and watch its inverted image (yellow circle) change.

---

## Project: Grid Patterns

**Example solution: Truchet-style pattern**

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv * 4.0;
    
    float aspect = iResolution.x / iResolution.y;
    float N = 8.0;
    float L = (4.0 * aspect) / N;
    
    vec2 cell_id = floor(p / L);
    vec2 cell_p = mod(p, L) - vec2(L/2.0, L/2.0);
    
    // Pseudo-random per cell (determines orientation)
    float rand = fract(sin(dot(cell_id, vec2(12.9898, 78.233))) * 43758.5453);
    
    // Quarter circles in corners
    float r = L / 2.0;
    float thickness = 0.05;
    
    float d;
    if (rand > 0.5) {
        // Arcs connecting top-left to bottom-right
        float d1 = abs(length(cell_p - vec2(-L/2.0, L/2.0)) - r);
        float d2 = abs(length(cell_p - vec2(L/2.0, -L/2.0)) - r);
        d = min(d1, d2);
    } else {
        // Arcs connecting top-right to bottom-left
        float d1 = abs(length(cell_p - vec2(L/2.0, L/2.0)) - r);
        float d2 = abs(length(cell_p - vec2(-L/2.0, -L/2.0)) - r);
        d = min(d1, d2);
    }
    
    vec3 color;
    if (d < thickness) {
        color = vec3(1.0, 0.9, 0.7);
    } else {
        // Subtle gradient background
        float t = 0.5 + 0.5 * sin(length(cell_id) * 0.5 + iTime * 0.5);
        color = mix(vec3(0.1, 0.15, 0.25), vec3(0.2, 0.1, 0.2), t);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Teaching note:** This creates the classic Truchet tile pattern where quarter-circle arcs connect across cell boundaries to form continuous meandering paths. The pseudo-random function determines each cell's orientation.

---

## Project: Fourier Epicycles

**Full solution with arms:**

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

float sd_segment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * t);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    float omega = 1.0;
    int N = 7;
    float scale = 1.2;
    
    vec3 color = vec3(0.02, 0.02, 0.05);
    
    vec2 pos = vec2(0.0, 0.0);
    
    for (int i = 0; i < 20; i++) {
        if (i >= N) break;
        
        int n = 2 * i + 1;
        float r = scale / float(n);
        float freq = float(n) * omega;
        float fade = 1.0 - float(i) / float(N);
        
        vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));
        
        // Circle
        float d_circle = abs(length(p - pos) - r);
        if (d_circle < 0.02) {
            color = mix(color, vec3(0.2, 0.2, 0.35), 0.5 * fade);
        }
        
        // Arm
        float d_arm = sd_segment(p, pos, next_pos);
        if (d_arm < 0.015) {
            color = mix(color, vec3(0.3, 0.3, 0.4), 0.7 * fade);
        }
        
        pos = next_pos;
    }
    
    // Final point
    float d_point = length(p - pos);
    if (d_point < 0.08) {
        color = vec3(1.0, 1.0, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Variation: Mouse-controlled number of terms:**

```glsl
vec2 normalize_coord(vec2 coord) {
    vec2 uv = coord / iResolution.xy;
    uv = uv - vec2(0.5, 0.5);
    uv.x *= iResolution.x / iResolution.y;
    return uv * 4.0;
}

float sd_segment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * t);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 p = normalize_coord(fragCoord);
    
    float omega = 1.0;
    // Mouse x controls number of terms (1 to 15)
    int N = int(mix(1.0, 15.0, iMouse.x / iResolution.x));
    float scale = 1.2;
    
    vec3 color = vec3(0.02, 0.02, 0.05);
    
    vec2 pos = vec2(0.0, 0.0);
    
    for (int i = 0; i < 20; i++) {
        if (i >= N) break;
        
        int n = 2 * i + 1;
        float r = scale / float(n);
        float freq = float(n) * omega;
        float fade = 1.0 - float(i) / float(N);
        
        vec2 next_pos = pos + r * vec2(cos(freq * iTime), sin(freq * iTime));
        
        // Circle
        float d_circle = abs(length(p - pos) - r);
        if (d_circle < 0.02) {
            color = mix(color, vec3(0.2, 0.2, 0.35), 0.5 * fade);
        }
        
        // Arm
        float d_arm = sd_segment(p, pos, next_pos);
        if (d_arm < 0.015) {
            color = mix(color, vec3(0.3, 0.3, 0.4), 0.7 * fade);
        }
        
        pos = next_pos;
    }
    
    // Final point
    float d_point = length(p - pos);
    if (d_point < 0.08) {
        color = vec3(1.0, 1.0, 0.2);
    }
    
    fragColor = vec4(color, 1.0);
}
```

**Variation: Triangle wave (alternating signs, 1/n² coefficients):**

```glsl
// In the loop, replace the square wave coefficients with:
float sign = (i % 2 == 0) ? 1.0 : -1.0;
float r = scale * sign / float(n * n);
```

**Teaching note:** The triangle wave converges faster than the square wave because of the $1/n^2$ coefficients. Students should observe smoother motion with fewer terms.