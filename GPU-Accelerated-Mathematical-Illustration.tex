% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  10pt,
  letterpaper,
]{scrbook}
\usepackage{xcolor}
\usepackage[letterpaper,left=1.5in,right=1.5in,top=1.25in,bottom=1.25in]{geometry}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{5}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage[]{libertinus}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


% preamble.tex
% LaTeX preamble for GPU-Accelerated Mathematical Illustration

% Headers and footers
% \usepackage{fancyhdr}
% \pagestyle{fancy}



% Use JetBrains Mono for monospace/code instead of Libertinus Mono
\usepackage{fontspec}
\setmonofont{JetBrains Mono}[
  Scale=0.85,
  UprightFont = *-Regular,
  BoldFont = *-Bold,
  ItalicFont = *-Italic,
  BoldItalicFont = *-BoldItalic
]




% % Colored boxes for callouts
% % Note: 'most' loads all common libraries including skins, breakable, etc.
% \usepackage[most]{tcolorbox}

% % Define colors matching HTML callout styles
% \definecolor{noteblue}{HTML}{347dec}
% \definecolor{tipgreen}{HTML}{28a745}
% \definecolor{importantorange}{HTML}{fd7e14}
% \definecolor{warningyellow}{HTML}{ffc107}
% \definecolor{cautionred}{HTML}{dc3545}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={GPU-Accelerated Mathematical Illustration},
  pdfauthor={Steve Trettel},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{GPU-Accelerated Mathematical Illustration}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{An Introduction to Shader Programming}
\author{Steve Trettel}
\date{December 2025}
\begin{document}
\frontmatter
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{1}
\tableofcontents
}

\mainmatter
\bookmarksetup{startatroot}

\chapter*{About}\label{about}
\addcontentsline{toc}{chapter}{About}

\markboth{About}{About}

This mini-course introduces shader programming as a tool for
mathematical illustration and exploration. Shaders are programs that run
in parallel on the GPU, making them exceptionally fast for visualization
tasks. We'll learn to write code that ``reads like mathematics'' using
Shadertoy, a beginner-friendly web-based platform that handles all the
low-level programming complexities.

We'll progress from 2D foundations (curves, tilings, fractals) to 3D
rendering via raymarching. Along the way, we will implement classic
examples like the Mandelbrot set, hyperbolic tessellations, and implicit
surface renderers. The final day will explore either advanced geometric
techniques (domain operations, 3D fractals) or temporal simulation
methods (PDEs, buffer-based dynamics), depending on the group's
interests.

No prior experience with shaders or GLSL is required---only a strong
foundation in undergraduate mathematics and willingness to work hard and
experiment with code through daily homework exercises. Here are some
examples of things we will make:

The code

and the demo

and a still pic for testing

\pandocbounded{\includegraphics[keepaspectratio]{images/mandelbrot.png}}

\bookmarksetup{startatroot}

\chapter{Day 1: Introduction to Shader
Programming}\label{day-1-introduction-to-shader-programming}

\section{Overview}\label{overview}

By the end of today, you'll be able to create this:

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/elliptic-family/screenshot.png}

\end{center}

A family of elliptic curves \(y^2 = x^3 + ax + b\), drawn for several
values of \(a\) simultaneously, with \(b\) varying across the screen.
The curves shift in brightness to show the family structure, and you can
watch singularities appear and disappear along the discriminant locus.

This image is computed in real time, every pixel evaluated independently
on the GPU. To get here, we'll learn:

\begin{itemize}
\tightlist
\item
  What a shader is: a function from coordinates to colors, evaluated in
  parallel
\item
  How to set up a coordinate system for mathematical visualization
\item
  How to draw shapes using distance functions
\item
  How to render implicit curves \(F(x,y) = 0\) with uniform thickness
\item
  How to add interactivity with mouse input
\end{itemize}

Let's begin.

\section{What is a Shader?}\label{what-is-a-shader}

We want to draw images on a screen.

Mathematically, an image is a function from a region
\(S \subset \mathbb{R}^2\) to the space of visible colors
\(\mathcal{C}\). This color space is three-dimensional, spanned by the
responses of the three types of cone cells in our eyes. A convenient
basis, roughly aligned with these responses, is red, green, and blue.

To realize this on a computer, we discretize. A screen is a grid of
\emph{pixels}: \(X\) pixels wide, \(Y\) pixels tall. Each pixel is a
point in the integer lattice
\[\{0, 1, \ldots, X-1\} \times \{0, 1, \ldots, Y-1\}.\]

Colors are represented as RGB triples: red, green, and blue intensities,
each in \([0,1]\). The constraint to \([0,1]\) reflects physical
reality---a pixel has a maximum brightness it can display. (We can't
draw the sun.) So an image is a function
\[f\colon \{0,\ldots,X-1\} \times \{0,\ldots,Y-1\} \to [0,1]^3\]
\[(i,j) \mapsto (r,g,b).\]

In practice, we add a fourth component: \emph{alpha}, representing
transparency. This matters when compositing multiple layers (we won't
use it in this course, but the machinery expects it). So our shader
computes \[f\colon (i,j) \mapsto (r,g,b,1).\]

This is what a shader is. You write a function that takes pixel
coordinates and returns an RGBA color. The GPU evaluates your function
at every pixel to produce the image.

\subsection{Parallelism}\label{parallelism}

A 1920×1080 display has over two million pixels. How do we evaluate
\(f\) at all of them fast enough to animate at 60 frames per second?

The answer is parallelism. A GPU contains thousands of cores, and it
evaluates \(f\) at all pixels \emph{simultaneously}. There's no loop
over pixels in your code---you write \(f\), and the hardware handles the
rest.

The tradeoff: each pixel's computation must be \emph{independent}. Pixel
\((100, 200)\) cannot ask what color pixel \((100, 199)\) received.
Every pixel sees the same global inputs---coordinates, time, mouse
position---and must determine its color from those alone. Learning to
think within this constraint is what shader programming is about.

\begin{tcolorbox}[enhanced jigsaw, arc=.35mm, colback=white, breakable, toprule=.15mm, rightrule=.15mm, left=2mm, leftrule=.75mm, colframe=quarto-callout-note-color-frame, bottomrule=.15mm, opacityback=0]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-note-color}{\faInfo}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\vspace{-3mm}\textbf{Why ``shader''?}\vspace{3mm}

The name comes from 3D graphics, where these programs computed
\emph{shading}---how light interacts with surfaces. It stuck even though
we now use shaders for fractals, simulations, and mathematical
visualization.

\end{minipage}%
\end{tcolorbox}

\subsection{Why Shadertoy?}\label{why-shadertoy}

Shader programming normally requires substantial setup: OpenGL contexts,
buffer management, compilation, render loops.
\href{https://www.shadertoy.com}{Shadertoy} abstracts all of this---you
write one function, press play, and see results. We'll use it throughout
the course.

\section{First Shaders: Colors and
Syntax}\label{first-shaders-colors-and-syntax}

\subsection{The mainImage Function}\label{the-mainimage-function}

In Shadertoy, your shader is a function called \texttt{mainImage}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// your code here}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This function is called once per pixel, every frame. The inputs and
outputs:

\begin{itemize}
\tightlist
\item
  \texttt{fragCoord} --- the pixel coordinates, passed \emph{in} to your
  function
\item
  \texttt{fragColor} --- the RGBA color, which you write \emph{out}
\end{itemize}

The \texttt{in} and \texttt{out} keywords are explicit about data flow:
\texttt{fragCoord} is read-only input, \texttt{fragColor} is where you
write your result. The function returns \texttt{void} because the output
goes through \texttt{fragColor}, not a return value.

\subsection{Hello World: A Solid Color}\label{hello-world-a-solid-color}

The simplest shader: make every pixel red.

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/red/screenshot.png}

\end{center}

The \texttt{vec4(1.0,\ 0.0,\ 0.0,\ 1.0)} constructs a 4-component
vector: red=1, green=0, blue=0, alpha=1. Every pixel receives the same
color, so the screen fills with red.

\subsection{GLSL Syntax Essentials}\label{glsl-syntax-essentials}

GLSL (OpenGL Shading Language) will feel familiar if you've seen C-like
syntax, but a few things are worth noting upfront.

\textbf{Semicolons} are required at the end of each statement.

\textbf{Floats must include a decimal point.} Write \texttt{1.0}, not
\texttt{1}. The integer \texttt{1} and the float \texttt{1.0} are
different types, and GLSL is strict about this.

\textbf{Vector types} are built in: \texttt{vec2}, \texttt{vec3},
\texttt{vec4} for 2, 3, and 4 component vectors. Construct them with:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{,} \FloatTok{4.0}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\DataTypeTok{vec4}\NormalTok{ rgba }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Arithmetic is component-wise.} Adding two vectors adds their
components:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{)} \OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{,} \FloatTok{4.0}\OperatorTok{)}  \CommentTok{// = vec2(4.0, 6.0)}
\end{Highlighting}
\end{Shaded}

\textbf{Scalar-vector operations} apply the scalar to each component:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2.0} \OperatorTok{*} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{3.0}\OperatorTok{)}  \CommentTok{// = vec2(2.0, 6.0)}
\end{Highlighting}
\end{Shaded}

\textbf{Accessing components} uses \texttt{.x}, \texttt{.y},
\texttt{.z}, \texttt{.w}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{,} \FloatTok{4.0}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}  \CommentTok{// 3.0}
\DataTypeTok{float}\NormalTok{ b }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}  \CommentTok{// 4.0}
\end{Highlighting}
\end{Shaded}

For colors, \texttt{.r}, \texttt{.g}, \texttt{.b}, \texttt{.a} are
synonyms---\texttt{color.r} is the same as \texttt{color.x}.

\textbf{Common math functions} work as expected: \texttt{sin},
\texttt{cos}, \texttt{abs}, \texttt{min}, \texttt{max}, \texttt{sqrt},
\texttt{pow}. These operate on floats, and apply component-wise to
vectors:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{sin}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{3.14159}\OperatorTok{))}  \CommentTok{// = vec2(0.0, \textasciitilde{}0.0)}
\end{Highlighting}
\end{Shaded}

\textbf{For loops} work as you'd expect:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{5}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \CommentTok{// body executes with i = 0, 1, 2, 3, 4}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The loop variable is an \texttt{int}. Note that some older GPUs require
the loop bounds to be constants known at compile time---you can't always
loop up to a variable. We'll use loops extensively starting tomorrow.

\subsection{Uniforms: Global Inputs}\label{uniforms-global-inputs}

Shadertoy provides \emph{uniforms}---global values that are constant
across all pixels. Unlike \texttt{fragCoord}, which takes a different
value at each pixel, a uniform has the same value everywhere. They're
how external information (time, screen size, mouse position) gets into
your shader.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3214}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2143}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.4643}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Uniform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Description
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{iResolution} & \texttt{vec3} & Viewport size:
\texttt{(width,\ height,\ pixel\_aspect\_ratio)} \\
\texttt{iTime} & \texttt{float} & Seconds since the shader started \\
\texttt{iMouse} & \texttt{vec4} & Mouse position and click state \\
\end{longtable}

We'll use \texttt{iResolution} constantly (for coordinate transforms)
and \texttt{iTime} for animation.

\subsection{Animation: Using iTime}\label{animation-using-itime}

Let's make the red channel pulse:

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/red-pulsing/screenshot.png}

\end{center}

Since \texttt{sin(iTime)} oscillates between -1 and 1, the expression
\texttt{0.5\ +\ 0.5\ *\ sin(iTime)} oscillates between 0 and 1. The
screen pulses from black to red.

This is our first \emph{animated} shader---the output depends on time.

\section{Coordinate Systems}\label{coordinate-systems}

\subsection{Pixel Coordinates}\label{pixel-coordinates}

The input \texttt{fragCoord} gives the pixel coordinates of the current
pixel. The coordinate system:

\begin{itemize}
\tightlist
\item
  Origin at the \textbf{bottom-left} corner
\item
  \texttt{fragCoord.x} increases to the right
\item
  \texttt{fragCoord.y} increases upward
\item
  Ranges from \((0, 0)\) to \((X, Y)\) where \(X \times Y\) is the
  screen resolution
\end{itemize}

This is workable, but inconvenient for mathematics. We'd prefer
coordinates centered at the origin with a reasonable scale. Let's build
up a transformation step by step.

\subsection{\texorpdfstring{Step 1: Normalize to
\([0,1]^2\)}{Step 1: Normalize to {[}0,1{]}\^{}2}}\label{step-1-normalize-to-012}

Divide by the resolution to map pixel coordinates to the unit square:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now \texttt{uv} ranges from \((0,0)\) at bottom-left to \((1,1)\) at
top-right.

Since both coordinates are in \([0,1]\), we can visualize them directly
as color:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/coordinates/screenshot.png}

\end{center}

Black at bottom-left (0,0), red at bottom-right (1,0), green at top-left
(0,1), yellow at top-right (1,1).

\subsection{Step 2: Center the Origin}\label{step-2-center-the-origin}

Subtract \((0.5, 0.5)\) to center the origin:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now \texttt{uv} ranges from \((-0.5, -0.5)\) to \((0.5, 0.5)\), with
\((0,0)\) at the screen center.

\subsection{Step 3: Aspect Ratio
Correction}\label{step-3-aspect-ratio-correction}

We've mapped a rectangle of pixels (\(X \times Y\)) to the square
\([-0.5, 0.5]^2\). This is an affine transformation, not a
similarity---it distorts shapes. A circle in our coordinates would
render as an ellipse on screen.

To fix this, we scale the \(x\)-coordinate by the aspect ratio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Now a circle in our coordinates appears as a circle on screen. (When we
draw shapes later, try commenting out this line to see the distortion.)

\subsection{Step 4: Scale to a Useful
Range}\label{step-4-scale-to-a-useful-range}

Finally, scale to a convenient window:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

With a scale factor of 4, our coordinates range roughly from \(-2\) to
\(2\)---a good default for visualizing mathematical objects.

\subsection{The Standard Boilerplate}\label{the-standard-boilerplate}

Putting it together, here's the coordinate setup we'll use throughout
the course:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}   \CommentTok{// normalize to [0,1]}
\NormalTok{uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}               \CommentTok{// center origin}
\NormalTok{uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}  \CommentTok{// aspect correction}
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}                      \CommentTok{// scale}
\end{Highlighting}
\end{Shaded}

From here on, \texttt{p} is our mathematical coordinate, centered at the
origin, aspect-corrected, with a reasonable range.

\section{Drawing with Distance}\label{drawing-with-distance}

So far we've colored every pixel the same, or colored based on position
as a gradient. Now we want to \emph{draw}: to render a shape on screen.

What does it mean to draw a shape? For a simple filled region, we need a
rule that tells us, for each pixel: are you inside the shape or not?
When inside, we do one thing (say, color yellow). When outside, we do
another (color blue). The boundary of the shape is where we switch.

\subsection{Half-Planes}\label{half-planes}

The simplest shape is a half-plane. Consider the rule: is the
\(y\)-coordinate greater than 0? This divides the plane into two
regions---above and below the \(x\)-axis.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ L }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{L }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// red below}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// blue above}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/half-plane/screenshot.png}

\end{center}

To color left versus right instead, use \texttt{p.x} in place of
\texttt{p.y}.

More generally, a line in the plane has the form \(ax + by + c = 0\).
This divides the plane into two half-planes: where \(ax + by + c < 0\)
and where \(ax + by + c > 0\).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{,}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ L }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{L }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// red}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// blue}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Recall that \((a, b)\) is the normal vector to the line, and \(c\) is an
offset. Since these are just variables, we can animate them to move the
line around:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \BuiltInTok{cos}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ b }\OperatorTok{=} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{0.7}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/half-plane-animated/screenshot.png}

\end{center}

\subsection{Circles}\label{circles}

Now consider the function \(d(p) = |p|\), the distance from the origin.
Geometrically, the graph of this function is a cone---zero at the
origin, increasing linearly in all directions.

To draw a filled disk of radius \(r\), we could threshold on \(d < r\)
versus \(d \geq r\). But it's cleaner to define \(f(p) = |p| - r\). This
function is negative inside the circle (where \(d < r\)) and positive
outside (where \(d > r\)). The circle itself is the level set \(f = 0\).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ f }\OperatorTok{=}\NormalTok{ d }\OperatorTok{{-}}\NormalTok{ r}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// yellow inside}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// dark blue outside}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/circle/screenshot.png}

\end{center}

Try commenting out the aspect ratio correction (\texttt{uv.x\ *=\ ...})
to see the distortion---the circle becomes an ellipse.

To center the circle at a point \(c\) instead of the origin, compute
distance from \(c\):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ center }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Since \texttt{center} and \texttt{r} are variables, you can animate them
with \texttt{iTime} to create moving, pulsing circles.

\subsection{Drawing a Ring}\label{drawing-a-ring}

Our function \(f = d - r\) is negative inside the circle and positive
outside. To draw a filled disk, we colored based on the sign of \(f\).

But what if we want just the boundary---a ring of some thickness? We
want to color one way when \(f\) is small in absolute value (near the
circle), and a different way when \(|f|\) is large (far from the
circle).

So we look at \(|f| = |d - r|\) and ask: is this less than some
threshold \(\varepsilon\), or greater? Equivalently, is
\(|d - r| - \varepsilon\) negative or positive?

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ f }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{d }\OperatorTok{{-}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ eps}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{f }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// white ring}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// dark background}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/circle-ring/screenshot.png}

\end{center}

\section{Implicit Curves}\label{implicit-curves}

We've drawn circles using the distance function \(|p| - r\). But circles
are just one example of curves defined by an equation. Any equation
\(F(x,y) = 0\) defines a curve---the set of points satisfying that
equation. We can draw it the same way: threshold on \(|F|\).

\subsection{A First Example: The
Parabola}\label{a-first-example-the-parabola}

Consider \(F(x,y) = y - x^2\). The curve \(F = 0\) is the parabola
\(y = x^2\). Points where \(F < 0\) lie below the parabola; points where
\(F > 0\) lie above.

To draw the curve itself, we color pixels where \(|F|\) is small:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ eps}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// yellow curve}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// dark background}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/parabola/screenshot.png}

\end{center}

\subsection{More Examples}\label{more-examples}

An ellipse: \(F(x,y) = \frac{x^2}{a^2} + \frac{y^2}{b^2} - 1\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{)/(}\NormalTok{a}\OperatorTok{*}\NormalTok{a}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)/(}\NormalTok{b}\OperatorTok{*}\NormalTok{b}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

A hyperbola: \(F(x,y) = \frac{x^2}{a^2} - \frac{y^2}{b^2} - 1\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{)/(}\NormalTok{a}\OperatorTok{*}\NormalTok{a}\OperatorTok{)} \OperatorTok{{-}} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)/(}\NormalTok{b}\OperatorTok{*}\NormalTok{b}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The lemniscate of Bernoulli: \((x^2 + y^2)^2 = a^2(x^2 - y^2)\), or
\(F = (x^2+y^2)^2 - a^2(x^2 - y^2)\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.5}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}  \CommentTok{// x² + y²}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ r2 }\OperatorTok{*}\NormalTok{ r2 }\OperatorTok{{-}}\NormalTok{ a }\OperatorTok{*}\NormalTok{ a }\OperatorTok{*} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{The Thickness Problem}\label{the-thickness-problem}

Look carefully at the parabola. The rendered thickness isn't
uniform---it's thinner where the curve is steep, thicker where it's
flat. The problem gets worse with more complicated curves, especially
those with singularities. Here's the lemniscate:

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/lemniscate-naive/screenshot.png}

\end{center}

Notice how the thickness blows up near the origin, where the curve
crosses itself.

Why does this happen? The set \(|F| < \varepsilon\) contains all points
within \(\varepsilon\) of zero \emph{in the \(F\) direction}. But \(F\)
doesn't measure distance to the curve---it's just some function that
happens to be zero on the curve. Where \(|\nabla F|\) is large, \(F\)
changes rapidly, so the band \(|F| < \varepsilon\) is narrow. Where
\(|\nabla F|\) is small, \(F\) changes slowly, so the band is wide. At
the singular point, \(\nabla F = 0\), and the band becomes infinitely
wide.

\subsection{Why Circles Worked}\label{why-circles-worked}

For the circle, we used \(f(p) = |p| - r\). This is the \emph{signed
distance function}: it measures actual geometric distance to the curve.
The gradient of a distance function has magnitude 1 everywhere (it
points toward or away from the curve at unit rate). So
\(|f| < \varepsilon\) really does capture points within distance
\(\varepsilon\), giving uniform thickness.

This is a fact from differential geometry: \(|\nabla d| = 1\) for a
distance function \(d\). When we use an arbitrary implicit equation
\(F = 0\), we lose this property.

\subsection{Gradient Correction}\label{gradient-correction}

We can fix the non-uniform thickness by dividing by the gradient
magnitude. Instead of thresholding \(|F| < \varepsilon\), we threshold
\[\frac{|F|}{|\nabla F|} < \varepsilon.\]

This approximates the signed distance to the curve. The intuition:
\(|F|/|\nabla F|\) estimates how far you'd need to travel (in the
direction \(F\) changes fastest) to reach the curve.

For the lemniscate, we compute the gradient analytically:
\[\nabla F = \bigl(4x(x^2+y^2) - 2a^2 x,\; 4y(x^2+y^2) + 2a^2 y\bigr)\]

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.5}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ r2 }\OperatorTok{*}\NormalTok{ r2 }\OperatorTok{{-}}\NormalTok{ a }\OperatorTok{*}\NormalTok{ a }\OperatorTok{*} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}

\DataTypeTok{vec2}\NormalTok{ grad }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}
    \FloatTok{4.0} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ r2 }\OperatorTok{{-}} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}
    \FloatTok{4.0} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ r2 }\OperatorTok{+} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}
\OperatorTok{);}

\DataTypeTok{float}\NormalTok{ dist }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{max}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{grad}\OperatorTok{),} \FloatTok{0.01}\OperatorTok{);}  \CommentTok{// avoid division by zero}
\DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.05}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ eps}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/lemniscate-gradient/screenshot.png}

\end{center}

Compare with the naive version above to see the difference in thickness
uniformity.

\subsection{Animated Curve Families}\label{animated-curve-families}

The lemniscate is part of a one-parameter family called the Cassini
ovals, defined by the product of distances from two foci being constant:
\[(x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\]

As the parameter \(a\) varies relative to the fixed focal distance
\(c\), the topology changes: two separate loops when \(a < c\), a
lemniscate when \(a = c\), a single oval when \(a > c\).

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/lemniscate-animated/screenshot.png}

\end{center}

\section{Interactivity and
Abstraction}\label{interactivity-and-abstraction}

So far our shaders respond to time (\texttt{iTime}) but not to user
input. Shadertoy provides \texttt{iMouse} for mouse interaction.

\subsection{The iMouse Uniform}\label{the-imouse-uniform}

\texttt{iMouse} is a \texttt{vec4}:

\begin{itemize}
\tightlist
\item
  \texttt{iMouse.xy} --- current mouse position (in pixels)
\item
  \texttt{iMouse.zw} --- position where the mouse was last clicked
\end{itemize}

For now we'll focus on \texttt{iMouse.xy}.

\subsection{Dragging a Circle}\label{dragging-a-circle}

Let's draw a circle centered at the mouse position. Since
\texttt{iMouse.xy} is in pixel coordinates, we need to normalize it the
same way we normalize \texttt{fragCoord}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Normalize fragment coordinate}
\DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}

\CommentTok{// Normalize mouse coordinate the same way}
\DataTypeTok{vec2}\NormalTok{ mouse }\OperatorTok{=}\NormalTok{ iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{mouse }\OperatorTok{=}\NormalTok{ mouse }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{mouse}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
\NormalTok{mouse }\OperatorTok{=}\NormalTok{ mouse }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}

\CommentTok{// Circle centered at mouse}
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ mouse}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}  \CommentTok{// yellow}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/circle-mouse/screenshot.png}

\end{center}

Click and drag to move the circle.

\subsection{Writing a Helper Function}\label{writing-a-helper-function}

We just wrote the same four lines of coordinate normalization twice.
This is a sign we should write a function.

A GLSL function declares its return type, then the function name, then
its parameters with their types:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{normalize\_coord}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ coord}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ coord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Functions must be defined before they're used, so they go above
\texttt{mainImage}. Here's the overall structure:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{normalize\_coord}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ coord}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// normalization logic here}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=} \FunctionTok{normalize\_coord}\OperatorTok{(}\NormalTok{fragCoord}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ mouse }\OperatorTok{=} \FunctionTok{normalize\_coord}\OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{);}
    
    \CommentTok{// code using p and mouse}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now our shader is cleaner, and we won't make mistakes copying the
normalization code.

\subsection{Combining iMouse and iTime: Sun and
Earth}\label{combining-imouse-and-itime-sun-and-earth}

Let's make a circle orbit around the mouse position:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=} \FunctionTok{normalize\_coord}\OperatorTok{(}\NormalTok{fragCoord}\OperatorTok{);}
\DataTypeTok{vec2}\NormalTok{ sun }\OperatorTok{=} \FunctionTok{normalize\_coord}\OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{);}

\CommentTok{// Earth orbits the sun}
\DataTypeTok{float}\NormalTok{ orbit\_radius }\OperatorTok{=} \FloatTok{0.8}\OperatorTok{;}
\DataTypeTok{vec2}\NormalTok{ earth }\OperatorTok{=}\NormalTok{ sun }\OperatorTok{+}\NormalTok{ orbit\_radius }\OperatorTok{*} \DataTypeTok{vec2}\OperatorTok{(}\BuiltInTok{cos}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{),} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{));}

\CommentTok{// Draw sun (larger, yellow)}
\DataTypeTok{float}\NormalTok{ d\_sun }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ sun}\OperatorTok{);}
\CommentTok{// Draw earth (smaller, blue)}
\DataTypeTok{float}\NormalTok{ d\_earth }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ earth}\OperatorTok{);}

\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.02}\OperatorTok{,} \FloatTok{0.02}\OperatorTok{,} \FloatTok{0.05}\OperatorTok{);}  \CommentTok{// dark background}
\KeywordTok{if} \OperatorTok{(}\NormalTok{d\_sun }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}  \CommentTok{// yellow sun}
\OperatorTok{\}}
\KeywordTok{if} \OperatorTok{(}\NormalTok{d\_earth }\OperatorTok{\textless{}} \FloatTok{0.15}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// blue earth}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/sun-earth/screenshot.png}

\end{center}

Drag to move the sun; the earth follows in orbit. (Exercise: add a moon
orbiting the earth!)

\subsection{Mouse as Parameter}\label{mouse-as-parameter}

The mouse doesn't have to control position---it can control any
parameter. A useful pattern: map \texttt{iMouse.x} to a parameter range
and drag across the screen to explore a family of curves.

The folium of Descartes is the curve \(x^3 + y^3 = 3axy\). We can
explore its level sets by drawing \(x^3 + y^3 - 3axy = c\) for different
values of \(c\):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=} \FunctionTok{normalize\_coord}\OperatorTok{(}\NormalTok{fragCoord}\OperatorTok{);}

\CommentTok{// Fixed parameter a}
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.5}\OperatorTok{;}

\CommentTok{// Map mouse x to level set value c in [{-}2, 2]}
\DataTypeTok{float}\NormalTok{ c }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{({-}}\FloatTok{2.0}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{,}\NormalTok{ iMouse}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}

\CommentTok{// Folium of Descartes: x³ + y³ {-} 3axy = c}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ c}\OperatorTok{;}

\CommentTok{// Gradient: ∇F = (3x² {-} 3ay, 3y² {-} 3ax)}
\DataTypeTok{vec2}\NormalTok{ grad }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{3.0}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ dist }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{max}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{grad}\OperatorTok{),} \FloatTok{0.01}\OperatorTok{);}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}} \FloatTok{0.05}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\OperatorTok{\}}

\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{center}

\includegraphics[width=0.75\linewidth,height=\textheight,keepaspectratio]{./demos/day1/folium-mouse/screenshot.png}

\end{center}

Drag left and right to sweep through the level sets and watch the curve
topology change.

\section{Exercises}\label{exercises}

Homework is organized into four types:

\textbf{Checkpoints} --- Short exercises to verify you understood the
lecture material. Required for anyone new to shader programming.

\textbf{Explorations} --- Open-ended problems that extend the lecture
topics. Pick the ones that interest you. If you can do several of these,
you're right on track with the course.

\textbf{Challenges} --- Problems that may require learning new concepts
beyond what was covered in lecture. Attempt these if you skipped the
checkpoints and found an exploration or two too easy.

\textbf{Project} --- An extended project for someone familiar with
shader basics, to make an artwork.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Checkpoints}\label{checkpoints}

\textbf{C1. Solid Colors.} Modify the red screen shader to display: (a)
green, (b) cyan, (c) a color of your choice using all three RGB
channels.

\textbf{C2. Vertical Split.} Modify the half-plane shader to divide the
screen into left (red) and right (blue) instead of top and bottom.

\textbf{C3. Off-Center Circle.} Draw a filled circle of radius 0.5
centered at the point \((1, 1)\) instead of the origin.

\textbf{C4. Pulsing Circle.} Make a circle whose radius oscillates
between 0.5 and 1.5 over time using \texttt{iTime}.

\textbf{C5. Ring Thickness.} Draw a ring (circle outline) centered at
the origin. Experiment with different values of \texttt{eps} to
understand how it controls thickness.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Explorations}\label{explorations}

\textbf{E1. Concentric Rings.} Draw several concentric rings (circles of
different radii, all centered at the origin). Can you color alternate
rings differently?

\textbf{E2. Moon Orbit.} Extend the sun-earth shader to add a moon that
orbits the earth. The moon should be smaller than the earth and orbit
faster.

\textbf{E3. Your Favorite Curve.} Pick an implicit curve from your
mathematical experience (or find one online) and render it. Some
suggestions: the cardioid \((x^2 + y^2 - ax)^2 = a^2(x^2 + y^2)\), the
astroid \(x^{2/3} + y^{2/3} = a^{2/3}\), or a rose curve in implicit
form. Apply gradient correction for uniform thickness.

\textbf{E4. Curve Explorer.} Take any one-parameter family of curves and
build a mouse-controlled explorer (like the folium example). Map
\texttt{iMouse.x} to the parameter and drag to explore the family.

\textbf{E5. Two Circles.} Draw two filled circles at different
positions. What happens when they overlap? Can you make one ``in front
of'' the other? Can you make the intersection a different color, like a
Venn diagram?

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Challenges}\label{challenges}

\textbf{H1. Parabola Graphing Calculator.} Build an interactive graphing
calculator for the parabola \(y = ax^2 + bx + c\). Requirements: - Draw
coordinate axes (the lines \(x = 0\) and \(y = 0\)) - Draw the parabola
using implicit curve techniques - Find the roots (where \(y = 0\)) and
draw small circles around them - Use mouse position to control two of
the coefficients (e.g., \(a\) and \(b\), with \(c\) fixed, or \(b\) and
\(c\) with \(a\) fixed)

As you drag the mouse, the parabola should reshape and the root
indicators should move (or appear/disappear as roots become real or
complex).

\textbf{H2. Elliptic Curve Explorer.} Elliptic curves in Weierstrass
form are \(y^2 = x^3 + ax + b\). Build a shader where the mouse position
controls \((a, b)\). Use gradient correction for uniform thickness. The
\emph{discriminant} \(\Delta = 4a^3 + 27b^2\) determines whether the
curve is smooth (\(\Delta \neq 0\)) or singular (\(\Delta = 0\)). Can
you display the current value of \(\Delta\) somehow, or change the
curve's color when it becomes singular?

\textbf{H3. Signed Distance Functions.} For a filled circle,
\(f(p) = |p| - r\) is the \emph{signed} distance function: negative
inside, positive outside, with \(|f|\) giving the actual distance to the
boundary. What is the signed distance function for a half-plane? For an
axis-aligned rectangle? Implement both and draw them with
uniform-thickness boundaries. Note: when you have the true signed
distance function, you don't need the gradient correction trick---that's
the payoff for computing the right thing from the start!

\textbf{H4. Smooth Blending.} When two circles overlap, we currently
just draw one on top of the other. Research \emph{smooth minimum}
functions (e.g., \texttt{smin}) that blend distance fields smoothly.
Draw two circles that ``melt together'' where they meet.

\textbf{H5. Inversion.} Circle inversion is the map
\(p \mapsto p / |p|^2\). Apply this transformation to your coordinate
\(p\) before drawing a shape. What happens to a line? What happens to a
circle not passing through the origin? Experiment with different shapes.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Project: Grid Patterns}\label{project-grid-patterns}

This extended project introduces a powerful technique---using modular
arithmetic to repeat patterns across the plane. We'll build up the
machinery carefully, since we'll use it again in Day 2 to create grids
of Julia sets.

\subsubsection{Part 1: Setting Up a Grid of Square
Cells}\label{part-1-setting-up-a-grid-of-square-cells}

We want to tile the screen with square cells---say, 4 cells across. The
challenge: the screen isn't square, so we need to handle the aspect
ratio.

Let's say we want \texttt{N} columns of cells. Each cell has width
\(L = \text{screen\_width} / N\) in pixels, and since cells are square,
height \(L\) as well. The number of rows depends on the screen's aspect
ratio.

Working in our normalized coordinates (after aspect correction), the
screen spans roughly \([-2 \cdot \text{aspect}, 2 \cdot \text{aspect}]\)
in \(x\) and \([-2, 2]\) in \(y\). If we want cells of side length \(L\)
in these coordinates:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ aspect }\OperatorTok{=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ N }\OperatorTok{=} \FloatTok{5.0}\OperatorTok{;}  \CommentTok{// number of columns}
\DataTypeTok{float}\NormalTok{ L }\OperatorTok{=} \OperatorTok{(}\FloatTok{4.0} \OperatorTok{*}\NormalTok{ aspect}\OperatorTok{)} \OperatorTok{/}\NormalTok{ N}\OperatorTok{;}  \CommentTok{// cell size in our coordinate system}
\end{Highlighting}
\end{Shaded}

Now each cell is an \(L \times L\) square.

\subsubsection{Part 2: Cell Coordinates and
Identity}\label{part-2-cell-coordinates-and-identity}

For each pixel, we want two things:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Which cell are we in?} Integer coordinates \((i, j)\)
  identifying the cell.
\item
  \textbf{Where in the cell are we?} Local coordinates ranging from
  \(-L/2\) to \(L/2\), with \((0,0)\) at the cell center.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{/}\NormalTok{ L}\OperatorTok{);}
\DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{L}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ L}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{),}\NormalTok{ L}\OperatorTok{)} \OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{L}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ L}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The \texttt{cell\_id} tells us which cell; the \texttt{cell\_p} gives
local coordinates within that cell.

If we want local coordinates normalized to \([-1, 1]\) (useful for
drawing things at a standard scale), we can rescale:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ local }\OperatorTok{=}\NormalTok{ cell\_p }\OperatorTok{/} \OperatorTok{(}\NormalTok{L }\OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}  \CommentTok{// now in [{-}1, 1] x [{-}1, 1]}
\end{Highlighting}
\end{Shaded}

This is exactly the setup we'll need for Day 2, where each cell will
contain a Julia set with its own coordinate system.

\subsubsection{Part 3: Drawing in Each
Cell}\label{part-3-drawing-in-each-cell}

Now draw something using the local coordinates. A filled circle at the
center of each cell:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=}\NormalTok{ L }\OperatorTok{*} \FloatTok{0.4}\OperatorTok{;}  \CommentTok{// radius relative to cell size}

\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try changing \texttt{N} to get more or fewer columns. The cells stay
square regardless of screen shape.

\subsubsection{Part 4: Varying by Cell}\label{part-4-varying-by-cell}

The \texttt{cell\_id} lets each cell behave differently. Some ideas:

\textbf{Checkerboard background:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ checker }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ cell\_id}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ bg }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{),}\NormalTok{ checker}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Radius varying by cell:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=}\NormalTok{ L }\OperatorTok{*} \OperatorTok{(}\FloatTok{0.2} \OperatorTok{+} \FloatTok{0.15} \OperatorTok{*} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ cell\_id}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{3.0}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\textbf{Wave animation:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ cell\_dist }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=}\NormalTok{ L }\OperatorTok{*} \OperatorTok{(}\FloatTok{0.3} \OperatorTok{+} \FloatTok{0.1} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ cell\_dist }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\subsubsection{Part 5: Design Challenge}\label{part-5-design-challenge}

Design a grid-based pattern that you find visually interesting. Some
directions:

\textbf{Connecting shapes:} Draw shapes that connect across cell
boundaries. Quarter-circles in each corner create a continuous network.
What implicit curves tile seamlessly?

\textbf{Alternating motifs:} Use \texttt{cell\_id} to alternate between
different shapes---circles in some cells, rings in others, or different
orientations.

\textbf{Color fields:} Map \texttt{cell\_id} to colors using distance
from origin, stripes, or a palette.

\textbf{Phase shifts:} Animate cells with different phase offsets to
create waves or ripples.

\textbf{Using local coordinates:} Draw something more complex in each
cell using the \([-1,1]\) local coordinate system---perhaps a small
implicit curve, or a pattern that changes based on \texttt{cell\_id}.

The goal is to produce an image you'd be happy to hang on a wall.

\subsection{Project: Fourier Epicycles}\label{project-fourier-epicycles}

This project builds a visualization of Fourier series using
epicycles---circles whose centers sit on the circumferences of other
circles. This is how Ptolemy modeled planetary motion, and it turns out
to be exactly how Fourier series work geometrically.

\subsubsection{Part 1: The Idea}\label{part-1-the-idea}

Any periodic function can be written as a sum of sines and cosines.
Geometrically, \(\sin(n\omega t)\) and \(\cos(n\omega t)\) describe a
point moving around a circle of frequency \(n\omega\). Adding these
components corresponds to stacking circles: each circle's center rides
on the previous circle's edge.

For example, the square wave has Fourier series:
\[f(t) = \sum_{n=1,3,5,...} \frac{1}{n} \sin(n\omega t)\]

This means circles with: - Radii:
\(1, \frac{1}{3}, \frac{1}{5}, \frac{1}{7}, ...\) - Frequencies:
\(\omega, 3\omega, 5\omega, 7\omega, ...\)

The more terms we add, the closer the final point's \(y\)-coordinate
approximates a square wave.

\subsubsection{Part 2: Drawing Circles}\label{part-2-drawing-circles}

Start by drawing a chain of circles. Each circle is centered at the
current position, and the next position is computed by moving along the
circle:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ pos }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// start at origin}

\KeywordTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ N}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{2} \OperatorTok{*}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}  \CommentTok{// 1, 3, 5, 7, ...}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=}\NormalTok{ scale }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{n}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ freq }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{n}\OperatorTok{)} \OperatorTok{*}\NormalTok{ omega}\OperatorTok{;}
    
    \CommentTok{// Draw circle at current position}
    \DataTypeTok{float}\NormalTok{ d\_circle }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ pos}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ r}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{d\_circle }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// color the circle}
    \OperatorTok{\}}
    
    \CommentTok{// Move to next position}
\NormalTok{    pos }\OperatorTok{=}\NormalTok{ pos }\OperatorTok{+}\NormalTok{ r }\OperatorTok{*} \DataTypeTok{vec2}\OperatorTok{(}\BuiltInTok{cos}\OperatorTok{(}\NormalTok{freq }\OperatorTok{*}\NormalTok{ iTime}\OperatorTok{),} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{freq }\OperatorTok{*}\NormalTok{ iTime}\OperatorTok{));}
\OperatorTok{\}}

\CommentTok{// Draw final point}
\DataTypeTok{float}\NormalTok{ d\_point }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ pos}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{d\_point }\OperatorTok{\textless{}} \FloatTok{0.08}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// bright color}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try this with \texttt{N\ =\ 1}, then \texttt{N\ =\ 3}, then
\texttt{N\ =\ 7}. Watch how more circles create more complex motion.

\subsubsection{Part 3: The Line Segment
SDF}\label{part-3-the-line-segment-sdf}

To draw the arms connecting circle centers, we need the signed distance
function for a line segment. Given endpoints \(a\) and \(b\), the
distance from point \(p\) to the segment is:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{sd\_segment}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ pa }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ a}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ ba }\OperatorTok{=}\NormalTok{ b }\OperatorTok{{-}}\NormalTok{ a}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \BuiltInTok{clamp}\OperatorTok{(}\BuiltInTok{dot}\OperatorTok{(}\NormalTok{pa}\OperatorTok{,}\NormalTok{ ba}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{ba}\OperatorTok{,}\NormalTok{ ba}\OperatorTok{),} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{pa }\OperatorTok{{-}}\NormalTok{ ba }\OperatorTok{*}\NormalTok{ t}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The math: we project \(p - a\) onto the line direction \(b - a\), clamp
to \([0, 1]\) to stay within the segment, then measure the distance to
that closest point.

\subsubsection{Part 4: Connecting the
Arms}\label{part-4-connecting-the-arms}

Now modify your loop to also draw line segments:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ pos }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}

\KeywordTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ N}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
    \DataTypeTok{int}\NormalTok{ n }\OperatorTok{=} \DecValTok{2} \OperatorTok{*}\NormalTok{ i }\OperatorTok{+} \DecValTok{1}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=}\NormalTok{ scale }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{n}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ freq }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{n}\OperatorTok{)} \OperatorTok{*}\NormalTok{ omega}\OperatorTok{;}
    
    \DataTypeTok{vec2}\NormalTok{ next\_pos }\OperatorTok{=}\NormalTok{ pos }\OperatorTok{+}\NormalTok{ r }\OperatorTok{*} \DataTypeTok{vec2}\OperatorTok{(}\BuiltInTok{cos}\OperatorTok{(}\NormalTok{freq }\OperatorTok{*}\NormalTok{ iTime}\OperatorTok{),} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{freq }\OperatorTok{*}\NormalTok{ iTime}\OperatorTok{));}
    
    \CommentTok{// Draw circle}
    \DataTypeTok{float}\NormalTok{ d\_circle }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ pos}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ r}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{d\_circle }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// faint circle color}
    \OperatorTok{\}}
    
    \CommentTok{// Draw arm from pos to next\_pos}
    \DataTypeTok{float}\NormalTok{ d\_arm }\OperatorTok{=} \FunctionTok{sd\_segment}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ pos}\OperatorTok{,}\NormalTok{ next\_pos}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{d\_arm }\OperatorTok{\textless{}} \FloatTok{0.015}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// arm color}
    \OperatorTok{\}}
    
\NormalTok{    pos }\OperatorTok{=}\NormalTok{ next\_pos}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Part 5: Polish and
Explore}\label{part-5-polish-and-explore}

Now make it beautiful:

\textbf{Fading circles:} Later circles are smaller and less important.
Fade their brightness:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ fade }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{{-}} \DataTypeTok{float}\OperatorTok{(}\NormalTok{i}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{N}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Color variation:} Color circles differently based on their
index, or based on their frequency.

\textbf{Different waves:} The square wave uses odd harmonics with
\(1/n\) coefficients. Try: - Triangle wave: odd harmonics with \(1/n^2\)
coefficients (alternating signs) - Sawtooth wave: all harmonics with
\(1/n\) coefficients

\textbf{Mouse control:} Map \texttt{iMouse.x} to the number of terms, so
dragging adds or removes circles.

The goal: create a mesmerizing animation that reveals the geometry
hidden inside Fourier series.

\bookmarksetup{startatroot}

\chapter{Day 2: Complex Dynamics and Circle
Inversion}\label{day-2-complex-dynamics-and-circle-inversion}

\section{Overview}\label{overview-1}

By the end of today, you'll understand how simple iteration rules
generate infinite complexity---and have the tools to render it in real
time.

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/mandelbrot-zoom} not found.
\end{tcolorbox}

A zoom into the Mandelbrot set, colored by escape time. The entire
structure emerges from iterating one formula: \(z \mapsto z^2 + c\).

Today we explore two kinds of iterative systems:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Complex dynamics}: Iterating holomorphic maps gives us the
  Mandelbrot set, Julia sets, and their cousins
\item
  \textbf{Circle inversion}: Iterating geometric transformations gives
  us the Apollonian gasket
\end{enumerate}

Both share the same GPU-friendly structure: each pixel asks ``what
happens when I iterate from here?'' No pixel depends on any
other---perfect for parallel computation.

Along the way, we'll learn to implement complex arithmetic in GLSL and
organize geometric data using structs.

\section{Complex Numbers in GLSL}\label{complex-numbers-in-glsl}

The complex numbers \(\mathbb{C}\) are the plane equipped with a
multiplication operation. Today we implement that algebra in GLSL.

\subsection{Representation}\label{representation}

A complex number \(z = a + bi\) is naturally represented as a 2D vector:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{);}  \CommentTok{// represents a + bi}
\end{Highlighting}
\end{Shaded}

We'll consistently use the convention that \texttt{z.x} is the real part
and \texttt{z.y} is the imaginary part.

\subsection{Arithmetic}\label{arithmetic}

\textbf{Addition} of complex numbers is componentwise---exactly what
GLSL's built-in \texttt{+} does for vectors. No helper function needed.

\textbf{Multiplication} is more interesting. In GLSL, the \texttt{*}
operator on vectors is componentwise: \texttt{vec2(a,b)\ *\ vec2(c,d)}
gives \texttt{vec2(a*c,\ b*d)}. This is \emph{not} complex
multiplication! We need to implement the correct formula ourselves.

Recall \((a + bi)(c + di) = (ac - bd) + (ad + bc)i\):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This is the FOIL pattern with \(i^2 = -1\) giving the minus sign in the
real part.

\subsection{Magnitude}\label{magnitude}

The magnitude of \(z = a + bi\) is the distance from the origin:
\[|z| = \sqrt{a^2 + b^2}\]

We can implement this directly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{cabs}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

But consider: we'll often have conditions like ``is \(|z|\) bigger than
2?'' rather than needing the actual magnitude. In these cases, we can
check \(|z|^2 > 4\) instead of \(|z| > 2\)---same answer, but no square
root. When you're doing this check millions of times per frame (once per
pixel, 60 frames per second), avoiding unnecessary square roots adds up.

So we define the squared magnitude:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If we want to be even more efficient, we can use GLSL's built-in dot
product, which computes exactly this sum of products:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}  \CommentTok{// a² + b²}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\section{The Mandelbrot Set}\label{the-mandelbrot-set}

The Mandelbrot set is perhaps the most iconic fractal---its shape is
instantly recognizable, and its discovery in 1980 helped launch the era
of computer-generated mathematical visualization. The definition is
remarkably simple.

\subsection{Definition}\label{definition}

Fix a complex number \(c\). Starting from \(z_0 = 0\), define a sequence
by iterating: \[z_{n+1} = z_n^2 + c\]

For some values of \(c\), this sequence stays bounded forever. For
others, it escapes to infinity. The \textbf{Mandelbrot set}
\(\mathcal{M}\) is the set of all \(c\) for which the sequence remains
bounded.

That's it! One quadratic formula, iterated. The intricate structure of
the Mandelbrot set emerges entirely from this simple rule.

\subsection{Rendering Strategy}\label{rendering-strategy}

To draw the Mandelbrot set, we test each pixel: is this value of \(c\)
in \(\mathcal{M}\) or not?

This is exactly the kind of question shaders excel at. Each pixel
performs its own independent calculation---no pixel needs information
from any other pixel. The entire image can be computed in parallel, with
thousands of GPU cores each testing their own value of \(c\)
simultaneously.

But there's a problem: the definition involves iterating ``forever'' and
checking if the sequence ``stays bounded.'' We can't iterate infinitely,
and we can't wait forever to decide. We need a practical criterion for
when to stop.

\subsection{The Escape Radius}\label{the-escape-radius}

We need two facts that make efficient rendering possible.

\textbf{Fact 1.} The Mandelbrot set is contained in the disk of radius
2. That is, if \(|c| > 2\), then \(c \notin \mathcal{M}\).

\emph{Proof.} {[}TODO{]} \(\square\)

This tells us what region to display: we only need to look at
\(|c| \leq 2\).

\textbf{Fact 2.} If \(|c| \leq 2\) and \(|z_n| > 2\) for some \(n\),
then the orbit escapes to infinity (so \(c \notin \mathcal{M}\)).

\emph{Proof.} {[}TODO{]} \(\square\)

This gives us a stopping criterion: once \(|z_n| > 2\), we know \(c\) is
not in the Mandelbrot set. We don't need to keep iterating.

Together, these facts justify the \textbf{escape-time algorithm}:
iterate until either \(|z_n| > 2\) (escaped, not in \(\mathcal{M}\)) or
we hit a maximum iteration count (probably in \(\mathcal{M}\)).

\subsection{The Escape-Time Algorithm}\label{the-escape-time-algorithm}

These two facts give us our algorithm:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For each pixel, let \(c\) be the corresponding complex number
\item
  Start with \(z = 0\)
\item
  Iterate \(z \mapsto z^2 + c\)
\item
  If \(|z| > 2\), stop---this point escapes (not in \(\mathcal{M}\))
\item
  If we reach a maximum iteration count without escaping, assume bounded
  (in \(\mathcal{M}\))
\end{enumerate}

The core of this is a loop:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
\DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}

\KeywordTok{for} \OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}  \CommentTok{// |z|² \textgreater{} 4 means |z| \textgreater{} 2}
\NormalTok{    z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

After this loop, \texttt{iter} tells us what happened: if
\texttt{iter\ ==\ max\_iter}, we never escaped (probably in
\(\mathcal{M}\)). Otherwise, we escaped on iteration \texttt{iter}.

\subsection{Binary Coloring}\label{binary-coloring}

The simplest approach: color points black if they're in the set, white
if they escaped.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{iter }\OperatorTok{==}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}  \CommentTok{// In the set: black}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Escaped: white}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Full Implementation}\label{full-implementation}

Putting it together with our coordinate setup:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Scale and center to show the Mandelbrot set}
    \CommentTok{// By Fact 1, the set lies in |c| ≤ 2}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}=} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// shift left to center the interesting part}
    
    \CommentTok{// Mandelbrot iteration}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for} \OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Binary coloring}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{iter }\OperatorTok{==}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}  \CommentTok{// In the set: black}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Escaped: white}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/mandelbrot-bw} not found.
\end{tcolorbox}

There it is---the Mandelbrot set in black and white!

\subsection{Coloring by Iteration
Count}\label{coloring-by-iteration-count}

Black and white shows the set, but we're throwing away information. The
number of iterations before escape tells us how ``close'' a point is to
the boundary---points that escape after 5 iterations are different from
points that escape after 50.

Let's use \texttt{iter} to create a gradient:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{iter }\OperatorTok{==}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/mandelbrot-gray} not found.
\end{tcolorbox}

Now we see structure! The boundary reveals intricate detail---tendrils,
spirals, bulbs. Points near the boundary take many iterations to escape
(bright), while points far away escape quickly (dark).

\subsection{Color Palettes}\label{color-palettes}

Grayscale works, but we can do better. A common technique uses cosines
to create smooth, cycling color palettes:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.00}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The parameters \texttt{a}, \texttt{b}, \texttt{c}, \texttt{d} control
the palette's character. The vector \texttt{d} shifts the phase of each
color channel, creating different hues. Try
\texttt{d\ =\ vec3(0.00,\ 0.10,\ 0.20)} for blues and purples, or
\texttt{d\ =\ vec3(0.30,\ 0.20,\ 0.20)} for warmer tones.

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/mandelbrot-color} not found.
\end{tcolorbox}

The color bands correspond to iteration counts---regions of the same
color escaped after the same number of iterations. You'll notice the
bands have sharp edges. In the exercises, we'll show you a technique
called \emph{smooth coloring} that interpolates between iteration
counts, eliminating the banding for even smoother gradients.

\section{Other Escape-Time Fractals}\label{other-escape-time-fractals}

The Mandelbrot set is one example of an escape-time fractal, but the
same algorithm works for many other iterated systems. We just swap out
the iteration formula (and sometimes the escape condition). Let's
explore a few.

\subsection{Julia Sets}\label{julia-sets}

The Mandelbrot set asks: for which values of \(c\) does the orbit of
\(0\) stay bounded? We can ask a different question: for a \emph{fixed}
\(c\), which \emph{starting points} \(z_0\) have bounded orbits?

Fix a complex number \(c\). The \textbf{filled Julia set} \(K_c\) is the
set of all starting points \(z_0\) for which the iteration
\[z_{n+1} = z_n^2 + c\] remains bounded.

Same iteration, different question. For the Mandelbrot set, we vary
\(c\) and always start at \(z_0 = 0\). For a Julia set, we fix \(c\) and
vary \(z_0\).

The code change is minimal:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Mandelbrot: c varies, z starts at 0}
\DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
\DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}

\CommentTok{// Julia: c is fixed, z starts at pixel position}
\DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.27015}\OperatorTok{);}  \CommentTok{// fixed parameter}
\DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/julia-static} not found.
\end{tcolorbox}

Different values of \(c\) produce dramatically different Julia sets. In
the exercises, you'll build an interactive explorer that lets you click
anywhere on the Mandelbrot set to see the corresponding Julia set:

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/julia-explorer} not found.
\end{tcolorbox}

\subsection{The Burning Ship}\label{the-burning-ship}

The \textbf{Burning Ship fractal} modifies the Mandelbrot iteration by
taking the absolute value of the imaginary part after each squaring:

\[z_{n+1} = (\text{Re}(z_n^2) + i|\text{Im}(z_n^2)|) + c\]

In code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Inside the loop:}
\NormalTok{z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}  \CommentTok{// Take absolute value of imaginary part}
\NormalTok{z }\OperatorTok{=}\NormalTok{ z }\OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/burning-ship} not found.
\end{tcolorbox}

The absolute value breaks the symmetry, creating an asymmetric fractal
that (with some imagination) resembles a burning ship.

\subsection{Higher Powers}\label{higher-powers}

The Mandelbrot set uses \(z^2 + c\). What about \(z^3 + c\)? Or
\(z^4 + c\)?

For \(z^3\), we need to implement cubing:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{ccube}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// z³ = z · z · z}
    \KeywordTok{return} \FunctionTok{cmul}\OperatorTok{(}\FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{),}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Or we can derive it directly:
\((a + bi)^3 = a^3 + 3a^2(bi) + 3a(bi)^2 + (bi)^3 = (a^3 - 3ab^2) + (3a^2b - b^3)i\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{ccube}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        a}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{a }\OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{b}\OperatorTok{*}\NormalTok{b}\OperatorTok{,}
        \FloatTok{3.0}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{b }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{*}\NormalTok{b}\OperatorTok{*}\NormalTok{b}
    \OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then the iteration becomes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \FunctionTok{ccube}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/mandelbrot-cubic} not found.
\end{tcolorbox}

Higher powers give higher-order rotational symmetry: \(z^3 + c\) has
3-fold symmetry, \(z^4 + c\) has 4-fold symmetry, and so on.

\subsection{The Pattern}\label{the-pattern}

All these fractals share the same structure:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Iterate} some function \(f(z, c)\)
\item
  \textbf{Check escape}: has \(|z|\) exceeded some threshold?
\item
  \textbf{Color} based on iteration count
\end{enumerate}

Changing the iteration function changes the fractal. The exercises
include more variations for you to try.

\section{Circle Inversion}\label{circle-inversion}

We shift gears from complex dynamics to geometric transformations.
Circle inversion is a classical operation that turns circles into
circles (or lines), preserves angles, and creates beautiful fractal
patterns when iterated.

\subsection{Definition}\label{definition-1}

\textbf{Inversion in the unit circle} maps a point \(\mathbf{p}\) to:

\[\text{inv}(\mathbf{p}) = \frac{\mathbf{p}}{|\mathbf{p}|^2}\]

What does this do geometrically? The inverted point lies on the same ray
from the origin as \(\mathbf{p}\), but at distance \(1/r\) instead of
\(r\).

\begin{itemize}
\tightlist
\item
  Points inside the unit circle map to points outside
\item
  Points outside map to points inside\\
\item
  Points on the unit circle stay fixed
\item
  The origin maps to ``infinity''
\end{itemize}

\subsection{Implementation}\label{implementation}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{invert}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{/} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Visualizing Inversion}\label{visualizing-inversion}

To see what inversion does, let's draw some shapes and their images.
We'll draw the unit circle (gray), plus a vertical line and a circle
(yellow). To make it clearer, we'll toggle between showing the original
shapes and their inversions:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{invert}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{/} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Compute the inversion of p}
    \DataTypeTok{vec2}\NormalTok{ p\_inv }\OperatorTok{=} \FunctionTok{invert}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
    
    \CommentTok{// Toggle between original and inverted every second}
    \DataTypeTok{float}\NormalTok{ time }\OperatorTok{=} \BuiltInTok{fract}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ q}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{time }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        q }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}      \CommentTok{// original}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        q }\OperatorTok{=}\NormalTok{ p\_inv}\OperatorTok{;}  \CommentTok{// inverted}
    \OperatorTok{\}}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{);}
    
    \CommentTok{// Draw the unit circle (the inversion circle)}
    \DataTypeTok{float}\NormalTok{ d\_unit }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{d\_unit }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    
    \CommentTok{// Draw a vertical line at x = 2}
    \KeywordTok{if} \OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{q}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \FloatTok{2.0}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
    \CommentTok{// Draw a horizontal line at y = 1.5}
    \KeywordTok{if} \OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{q}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \FloatTok{1.5}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
    \CommentTok{// Draw a circle centered at (2, 0) with radius 0.5}
    \DataTypeTok{float}\NormalTok{ d\_circle }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{q }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{))} \OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{d\_circle }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/inversion-toggle} not found.
\end{tcolorbox}

Watch the lines become circles! A line not passing through the origin
inverts to a circle that \emph{does} pass through the origin. The circle
inverts to another circle (with a different center and radius).

\begin{tcolorbox}[enhanced jigsaw, arc=.35mm, colback=white, breakable, toprule=.15mm, rightrule=.15mm, left=2mm, leftrule=.75mm, colframe=quarto-callout-tip-color-frame, bottomrule=.15mm, opacityback=0]
\begin{minipage}[t]{5.5mm}
\textcolor{quarto-callout-tip-color}{\faLightbulb}
\end{minipage}%
\begin{minipage}[t]{\textwidth - 5.5mm}

\vspace{-3mm}\textbf{GLSL Shortcuts: mix and step}\vspace{3mm}

The toggle logic can be written more compactly using built-in functions:

\begin{itemize}
\tightlist
\item
  \texttt{step(edge,\ x)} returns 0 if \texttt{x\ \textless{}\ edge},
  otherwise 1
\item
  \texttt{mix(a,\ b,\ t)} linearly interpolates: returns \texttt{a} when
  \texttt{t\ =\ 0}, \texttt{b} when \texttt{t\ =\ 1}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \BuiltInTok{step}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \BuiltInTok{fract}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{));}
\DataTypeTok{vec2}\NormalTok{ q }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p\_inv}\OperatorTok{,}\NormalTok{ t}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This is a common pattern for toggling or smoothly transitioning between
states.

\end{minipage}%
\end{tcolorbox}

\subsection{Key Properties}\label{key-properties}

Circle inversion maps circles to circles (or to lines, if the circle
passes through the center). It's \emph{conformal}---it preserves angles
between curves. And it's \emph{involutive}: applying inversion twice
returns to the original point.

\subsection{Inverting a Grid}\label{inverting-a-grid}

For a more dramatic visualization, let's invert a whole grid of lines.
The function \texttt{mod(q,\ 0.5)} gives the position of \texttt{q}
within a repeating \(0.5 \times 0.5\) cell---when either component is
near zero, we're on a grid line:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ grid }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{q}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{grid}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.02} \OperatorTok{||}\NormalTok{ grid}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

(If you did the grid project from Day 1, this is familiar!)

We can run the same shader as before, just replacing the individual
shapes with this grid:

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/inversion-grid} not found.
\end{tcolorbox}

\section{Structs}\label{structs}

So far our \texttt{invert} function only works for the unit circle at
the origin. What if we want to invert through a different circle?

\subsection{General Circle Inversion}\label{general-circle-inversion}

For a circle with center \(\mathbf{c}\) and radius \(R\), inversion maps
a point \(\mathbf{p}\) to:

\[\text{inv}(\mathbf{p}) = \mathbf{c} + R^2 \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|^2}\]

The idea is the same as before: the inverted point lies on the ray from
\(\mathbf{c}\) through \(\mathbf{p}\), at distance \(R^2/r\) from the
center (where \(r = |\mathbf{p} - \mathbf{c}|\)). When
\(\mathbf{c} = \mathbf{0}\) and \(R = 1\), this reduces to our earlier
formula \(\mathbf{p}/|\mathbf{p}|^2\).

In code:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{invertInCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ d }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ center }\OperatorTok{+}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ d }\OperatorTok{/} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{d}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This works, but notice we need to pass \emph{two} things
(\texttt{center} and \texttt{radius}) to describe \emph{one} object (a
circle). If we're working with multiple circles, every function call
needs \texttt{center1,\ radius1,\ center2,\ radius2,\ ...}---it gets
verbose and error-prone.

\subsection{Defining a Struct}\label{defining-a-struct}

GLSL lets us bundle related data into a \textbf{struct}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Circle }\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Now \texttt{Circle} is a type, just like \texttt{vec2} or
\texttt{float}. We can create circles and access their fields:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Circle c}\OperatorTok{;}
\NormalTok{c}\OperatorTok{.}\FunctionTok{center} \OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{c}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{=} \FloatTok{0.7}\OperatorTok{;}

\CommentTok{// Or initialize directly:}
\NormalTok{Circle c }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{),} \FloatTok{0.7}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{Inversion with Structs}\label{inversion-with-structs}

Now our inversion function takes a \texttt{Circle}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{invert}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ d }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center} \OperatorTok{+}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{*}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{*}\NormalTok{ d }\OperatorTok{/} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{d}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Much cleaner! And when we're working with multiple circles, we can pass
them around as single objects.

\subsection{Demo: Moving Circle}\label{demo-moving-circle}

Let's animate a circle moving around and watch how the inversion
changes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Circle }\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{vec2} \FunctionTok{invert}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ d }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center} \OperatorTok{+}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{*}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{*}\NormalTok{ d }\OperatorTok{/} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{d}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Animate the inversion circle}
\NormalTok{    Circle inv\_circle}\OperatorTok{;}
\NormalTok{    inv\_circle}\OperatorTok{.}\FunctionTok{center} \OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{)} \OperatorTok{*} \FloatTok{0.5}\OperatorTok{,} \BuiltInTok{cos}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{0.7}\OperatorTok{)} \OperatorTok{*} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{    inv\_circle}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{=} \FloatTok{1.0} \OperatorTok{+} \FloatTok{0.3} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{1.3}\OperatorTok{);}
    
    \CommentTok{// Compute inversion}
    \DataTypeTok{vec2}\NormalTok{ p\_inv }\OperatorTok{=} \FunctionTok{invert}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ inv\_circle}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{);}
    
    \CommentTok{// Draw the inversion circle}
    \DataTypeTok{float}\NormalTok{ d\_inv }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ inv\_circle}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ inv\_circle}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{d\_inv }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    
    \CommentTok{// Draw a grid in the inverted space}
    \DataTypeTok{vec2}\NormalTok{ grid }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p\_inv}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{grid}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.02} \OperatorTok{||}\NormalTok{ grid}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/inversion-moving} not found.
\end{tcolorbox}

As the circle moves and breathes, the inverted grid warps and flows.

\section{The Apollonian Gasket}\label{the-apollonian-gasket}

The Apollonian gasket is a classical fractal arising from circle
packing. It's named after Apollonius of Perga (\textasciitilde200 BCE),
who studied the problem of finding circles tangent to three given
circles.

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/apollonian-final} not found.
\end{tcolorbox}

\subsection{The Setup}\label{the-setup}

Start with four mutually tangent circles: three ``inner'' circles that
touch each other pairwise, all enclosed by one ``outer'' circle that
touches all three.

Let's define these circles using our \texttt{Circle} struct. We'll place
three circles of radius \(r\) with centers forming an equilateral
triangle, all tangent to each other and to an outer circle:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Circle }\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\};}

\CommentTok{// Three inner circles, mutually tangent, plus outer circle}
\CommentTok{// For circles of radius r to be mutually tangent, their centers}
\CommentTok{// must be 2r apart. This forms an equilateral triangle with side 2r.}
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ triSide }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ r}\OperatorTok{;}  \CommentTok{// distance between inner circle centers}
\DataTypeTok{float}\NormalTok{ circumradius }\OperatorTok{=}\NormalTok{ triSide }\OperatorTok{/} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{);}  \CommentTok{// distance from origin to centers}

\NormalTok{Circle c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ circumradius}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{Circle c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{Circle c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{Circle outer }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ circumradius }\OperatorTok{+}\NormalTok{ r}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

To draw these circles, we need a distance function:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{distToCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This returns the distance from \texttt{p} to the circle's
boundary---zero on the circle, positive elsewhere.

Let's draw our starting configuration:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{6.0}\OperatorTok{;}
    
    \CommentTok{// Define circles}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ triSide }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ circumradius }\OperatorTok{=}\NormalTok{ triSide }\OperatorTok{/} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{);}
    
\NormalTok{    Circle c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ circumradius}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    Circle c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    Circle c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    Circle outer }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ circumradius }\OperatorTok{+}\NormalTok{ r}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{);}
    
    \CommentTok{// Draw all four circles}
    \KeywordTok{if} \OperatorTok{(}\FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.03}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.03}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.03}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.03}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/apollonian-setup} not found.
\end{tcolorbox}

Three colored circles inside a white outer circle, all mutually tangent.

\subsection{From Drawing to Iteration}\label{from-drawing-to-iteration}

The gaps between circles are curvilinear triangles. The Apollonian
gasket fills each gap with a circle tangent to its three neighbors, then
fills the new gaps, and so on forever.

Here's the key insight: we can generate this structure by
\emph{iterating inversions}. If a point is inside one of the inner
circles, invert through that circle---this ``pushes'' it out. If a point
is outside the outer circle, invert through the outer circle---this
``pulls'' it in.

We need to check: - Is \(\mathbf{p}\) inside circle \texttt{c1},
\texttt{c2}, or \texttt{c3}? (distance from center \textless{} radius) -
Is \(\mathbf{p}\) outside circle \texttt{outer}? (distance from center
\textgreater{} radius)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool} \FunctionTok{isInside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{bool} \FunctionTok{isOutside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textgreater{}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The iteration: keep inverting until the point lands in a ``gap'' (inside
outer, outside all inner circles) or we hit a maximum iteration count.

\subsection{Full Implementation}\label{full-implementation-1}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Circle }\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{vec2} \FunctionTok{invert}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ d }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center} \OperatorTok{+}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{*}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{*}\NormalTok{ d }\OperatorTok{/} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{d}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{distToCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{bool} \FunctionTok{isInside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{6.0}\OperatorTok{;}
    
    \CommentTok{// Define circles}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ triSide }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ circumradius }\OperatorTok{=}\NormalTok{ triSide }\OperatorTok{/} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{);}
    
\NormalTok{    Circle c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ circumradius}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    Circle c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    Circle c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{circumradius }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    Circle outer }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ circumradius }\OperatorTok{+}\NormalTok{ r}\OperatorTok{);}
    
    \CommentTok{// Iterate inversions}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{50}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for} \OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\FunctionTok{isInside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invert}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{);}
        \OperatorTok{\}} \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\FunctionTok{isInside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invert}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{);}
        \OperatorTok{\}} \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\FunctionTok{isInside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invert}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{);}
        \OperatorTok{\}} \KeywordTok{else} \KeywordTok{if} \OperatorTok{(!}\FunctionTok{isInside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{))} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invert}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{);}
        \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
            \KeywordTok{break}\OperatorTok{;}  \CommentTok{// In the gap—done!}
        \OperatorTok{\}}
    \OperatorTok{\}}
    
    \CommentTok{// Color by iteration count}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    
    \CommentTok{// Draw circle boundaries}
    \DataTypeTok{float}\NormalTok{ dMin }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{min}\OperatorTok{(}\FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{),} \FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{)),} 
                     \BuiltInTok{min}\OperatorTok{(}\FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{),} \FunctionTok{distToCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{)));}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{dMin }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/apollonian-iterated} not found.
\end{tcolorbox}

\subsection{Visualizing the Limit Set}\label{visualizing-the-limit-set}

The \textbf{limit set} of the Apollonian gasket is the fractal
boundary---the set of points that never escape to the fundamental
domain, no matter how many iterations. Points near the limit set take
many iterations before landing in a gap.

We can emphasize the limit set by adjusting our coloring. Instead of
using a color palette, we use a nonlinear function that suppresses low
iteration counts (the ``background'') and brightens high iteration
counts (near the fractal):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FloatTok{30.0} \OperatorTok{*} \DataTypeTok{vec3}\OperatorTok{(}\BuiltInTok{pow}\OperatorTok{(}\NormalTok{t}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

The squaring suppresses points that escape quickly, while the factor of
30 boosts the brightness of points near the limit set.

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/apollonian-final} not found.
\end{tcolorbox}

\section{Exercises}\label{exercises-1}

\subsection{Checkpoints}\label{checkpoints-1}

\textbf{C1. Julia Set.} Modify the Mandelbrot shader to render a Julia
set. Fix \texttt{c\ =\ vec2(-0.7,\ 0.27015)} and initialize \texttt{z}
from the pixel position instead of zero. Verify you get an intricate,
connected fractal.

\textbf{C2. Cubic Mandelbrot.} Change the iteration from \(z^2 + c\) to
\(z^3 + c\). You'll need to implement complex cubing:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{ccube}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{a}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{a }\OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{b}\OperatorTok{*}\NormalTok{b}\OperatorTok{,} \FloatTok{3.0}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{a}\OperatorTok{*}\NormalTok{b }\OperatorTok{{-}}\NormalTok{ b}\OperatorTok{*}\NormalTok{b}\OperatorTok{*}\NormalTok{b}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

What symmetry do you observe?

\textbf{C3. Apollonian Animation.} Animate the Apollonian gasket by
letting the maximum iteration count grow with time. Use
\texttt{int\ max\_iter\ =\ int(mod(iTime\ *\ 5.0,\ 50.0))\ +\ 1;} so the
fractal ``builds up'' from the four starting circles to the full gasket,
then resets. Watch how each iteration reveals a new layer of circles in
the gaps.

\textbf{C4. Colorize a Fractal.} Take any of the black-and-white
fractals from today (Mandelbrot, Julia, Burning Ship, or Apollonian) and
add color using the cosine palette:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.00}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Experiment with different values of \texttt{d} to shift the hues.

\textbf{C5. Circle Art.} Create an image with several circles of
different sizes scattered across the screen. Color a pixel based on
whether it's inside zero, one, two, or more circles. (Hint: use
\texttt{isInside} and count how many circles contain each point.)

\subsection{Explorations}\label{explorations-1}

\textbf{E1. Julia Explorer (Mouse).} Make the Julia parameter \texttt{c}
follow the mouse position. Map \texttt{iMouse.xy} to a reasonable region
of the complex plane (say, \([-2, 2] \times [-2, 2]\)). Drag around and
watch the Julia set morph!

\textbf{E2. Julia Animation.} Animate the parameter \texttt{c} along a
path in the complex plane. Try a circle:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ angle }\OperatorTok{=}\NormalTok{ iTime }\OperatorTok{*} \FloatTok{0.3}\OperatorTok{;}
\DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.7885} \OperatorTok{*} \DataTypeTok{vec2}\OperatorTok{(}\BuiltInTok{cos}\OperatorTok{(}\NormalTok{angle}\OperatorTok{),} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{angle}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Or trace the boundary of the main cardioid of the Mandelbrot set---every
point on this curve gives a Julia set with a parabolic fixed point:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cardioid}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ eit }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\BuiltInTok{cos}\OperatorTok{(}\NormalTok{t}\OperatorTok{),} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{t}\OperatorTok{));}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ eit}\OperatorTok{)} \OperatorTok{/} \FloatTok{4.0}\OperatorTok{;}
    \KeywordTok{return} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{eit}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \FunctionTok{cardioid}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Watch the Julia set continuously transform. What happens when \texttt{c}
crosses from inside to outside the Mandelbrot set?

\textbf{E3. Other Escape-Time Fractals.} Implement one or more of these
variations on the Mandelbrot iteration:

\begin{itemize}
\tightlist
\item
  \textbf{Burning Ship}: \(z \leftarrow z^2\), then
  \(\text{Im}(z) \leftarrow |\text{Im}(z)|\), then
  \(z \leftarrow z + c\)
\item
  \textbf{Tricorn} (Mandelbar): \(z_{n+1} = \bar{z}_n^2 + c\) where
  \(\bar{z}\) is the complex conjugate
\item
  \textbf{Celtic}:
  \(z_{n+1} = |\text{Re}(z_n^2)| + i\,\text{Im}(z_n^2) + c\)
\end{itemize}

For each, figure out how to translate the mathematical formula into
GLSL. The escape condition (\(|z| > 2\)) stays the same.

\textbf{E4. Smooth Coloring.} The iteration count is an integer, so
coloring by iteration gives discrete bands. But when a point escapes, it
doesn't land exactly on the escape radius---it overshoots. We can use
\emph{how much} it overshot to interpolate between iteration counts.

The idea: if \(|z_n| > 2\), the ``true'' fractional iteration where
\(|z| = 2\) is approximately:
\[n_{\text{smooth}} = n - \frac{\log(\log|z_n|/\log 2)}{\log 2}\]

This comes from the fact that near escape,
\(|z_{n+1}| \approx |z_n|^2\), so \(\log|z|\) roughly doubles each
iteration.

Implement this for the Mandelbrot set:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\NormalTok{iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ log\_zn }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{))} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}  \CommentTok{// log|z|}
    \DataTypeTok{float}\NormalTok{ nu }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\NormalTok{log\_zn }\OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{))} \OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ smooth\_iter }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{+} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ nu}\OperatorTok{;}
\NormalTok{    t }\OperatorTok{=}\NormalTok{ smooth\_iter }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The bands should disappear, replaced by smooth gradients.

\textbf{E5. Apollonian Coloring.} Modify the Apollonian gasket to color
by \emph{which circle} was last inverted through, instead of iteration
count. Use a different color for each of the four circles. What patterns
emerge?

\textbf{E6. Apollonian Variations.} The Apollonian gasket works with
\emph{any} four mutually tangent circles---the symmetric configuration
we used is just one example. Descartes' Circle Theorem tells us: if four
circles are mutually tangent with curvatures \(k_1, k_2, k_3, k_4\)
(where curvature = 1/radius, negative for the outer circle), then:
\[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\]
Experiment with different configurations: - Change the radii of the
three inner circles (they don't have to be equal!) - Use Descartes'
theorem to find an outer circle tangent to three given inner circles -
What happens if the circles overlap instead of being tangent?

\subsection{Challenges}\label{challenges-1}

\textbf{H1. Julia Explorer (Full).} Build an interactive tool: display
the Mandelbrot set, and wherever the user clicks, show the Julia set for
that parameter overlaid or side-by-side. This requires: - Rendering
Mandelbrot in one region - Reading click position from \texttt{iMouse} -
Rendering Julia for that \texttt{c} in another region (or blended on
top)

\begin{tcolorbox}[colback=yellow!10, colframe=yellow!50!black, title=Missing Demo]
Shader demo \texttt{day2/julia-explorer} not found.
\end{tcolorbox}

\textbf{H2. Newton Fractal.} The Newton fractal comes from applying
Newton's method to find roots of a polynomial. For \(f(z) = z^3 - 1\),
Newton's iteration is:
\[z_{n+1} = z_n - \frac{f(z_n)}{f'(z_n)} = z_n - \frac{z_n^3 - 1}{3z_n^2} = \frac{2z_n^3 + 1}{3z_n^2}\]
Iterate this and color based on \emph{which root} the orbit converges to
(the three cube roots of unity: \(1\), \(e^{2\pi i/3}\),
\(e^{4\pi i/3}\)). Check convergence by testing if
\(|z^3 - 1| < \epsilon\).

\textbf{H3. Higher-Power Mandelbrot.} Implement \(z^n + c\) for general
\(n\). Use the polar form: if \(z = re^{i\theta}\), then
\(z^n = r^n e^{in\theta}\). In code:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cpow}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ n}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{z}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ theta }\OperatorTok{=} \BuiltInTok{atan}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ rn }\OperatorTok{=} \BuiltInTok{pow}\OperatorTok{(}\NormalTok{r}\OperatorTok{,}\NormalTok{ n}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ rn }\OperatorTok{*} \DataTypeTok{vec2}\OperatorTok{(}\BuiltInTok{cos}\OperatorTok{(}\NormalTok{n }\OperatorTok{*}\NormalTok{ theta}\OperatorTok{),} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{n }\OperatorTok{*}\NormalTok{ theta}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try non-integer values of \(n\)! What happens at \(n = 2.5\)?

\subsection{Projects}\label{projects}

\textbf{Project 1: Grid of Julia Sets}

Create a grid where each cell shows the Julia set for a different value
of \(c\). The position in the grid determines \(c\)---effectively, each
cell samples a point in the Mandelbrot parameter space.

When you zoom out, the overall pattern should reveal the Mandelbrot set:
cells with connected Julia sets (solid regions) correspond to
\(c \in \mathcal{M}\), while cells with dust-like Julia sets correspond
to \(c \notin \mathcal{M}\).

Use the grid technique from Day 1:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ grid\_size }\OperatorTok{=} \FloatTok{8.0}\OperatorTok{;}
\DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{((}\NormalTok{p }\OperatorTok{+} \FloatTok{2.0}\OperatorTok{)} \OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{);}
\DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{fract}\OperatorTok{((}\NormalTok{p }\OperatorTok{+} \FloatTok{2.0}\OperatorTok{)} \OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0} \OperatorTok{{-}} \FloatTok{2.0}\OperatorTok{;}

\CommentTok{// c comes from which cell we\textquotesingle{}re in}
\DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \OperatorTok{(}\NormalTok{cell\_id }\OperatorTok{/}\NormalTok{ grid\_size}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0} \OperatorTok{{-}} \FloatTok{2.0}\OperatorTok{;}

\CommentTok{// z starts from position within the cell}
\DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ cell\_p}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Project 2: Orbit Visualization}

Instead of just coloring by iteration count, visualize the actual orbit
of a point. Make the starting point draggable with the mouse:

\begin{itemize}
\tightlist
\item
  Let \(z_0\) be the mouse position (normalized to the complex plane)
\item
  Fix a parameter \(c\) (or let it be controllable too)
\item
  Compute the first \(N\) iterates: \(z_0, z_1, z_2, \ldots, z_N\)
\item
  Draw small circles at each iterate position
\item
  Connect consecutive iterates with lines (use the segment SDF from Day
  1!)
\item
  Color by iteration index (early iterates one color, later iterates
  another)
\end{itemize}

This reveals the dynamics directly: bounded orbits stay in a region and
may converge to a cycle, while escaping orbits spiral outward. Drag the
starting point around and watch how the orbit changes---you'll see the
sensitive dependence on initial conditions that makes chaos!

For Julia sets, fix \texttt{c} and drag \texttt{z\_0}. For the
Mandelbrot perspective, fix \texttt{z\_0\ =\ 0} and drag \texttt{c}.


\backmatter


\end{document}
