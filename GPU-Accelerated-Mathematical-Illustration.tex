% Options for packages loaded elsewhere
% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  10pt,
  letterpaper,
]{scrbook}
\usepackage{xcolor}
\usepackage[letterpaper,left=1.5in,right=1.5in,top=1.25in,bottom=1.25in]{geometry}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{5}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage[]{libertinus}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother





\setlength{\emergencystretch}{3em} % prevent overfull lines

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}



 


\usepackage{fancyhdr}
\pagestyle{fancy}
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[skins,breakable]{tcolorbox}}
\@ifpackageloaded{fontawesome5}{}{\usepackage{fontawesome5}}
\definecolor{quarto-callout-color}{HTML}{909090}
\definecolor{quarto-callout-note-color}{HTML}{0758E5}
\definecolor{quarto-callout-important-color}{HTML}{CC1914}
\definecolor{quarto-callout-warning-color}{HTML}{EB9113}
\definecolor{quarto-callout-tip-color}{HTML}{00A047}
\definecolor{quarto-callout-caution-color}{HTML}{FC5300}
\definecolor{quarto-callout-color-frame}{HTML}{acacac}
\definecolor{quarto-callout-note-color-frame}{HTML}{4582ec}
\definecolor{quarto-callout-important-color-frame}{HTML}{d9534f}
\definecolor{quarto-callout-warning-color-frame}{HTML}{f0ad4e}
\definecolor{quarto-callout-tip-color-frame}{HTML}{02b875}
\definecolor{quarto-callout-caution-color-frame}{HTML}{fd7e14}
\makeatother
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  pdftitle={GPU-Accelerated Mathematical Illustration},
  pdfauthor={Steve Trettel},
  colorlinks=true,
  linkcolor={Maroon},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{GPU-Accelerated Mathematical Illustration}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{An Introduction to Shader Programming}
\author{Steve Trettel}
\date{December 2025}
\begin{document}
\frontmatter
\maketitle

\renewcommand*\contentsname{Table of contents}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{1}
\tableofcontents
}

\mainmatter
\bookmarksetup{startatroot}

\chapter*{About}\label{about}
\addcontentsline{toc}{chapter}{About}

\markboth{About}{About}

This mini-course introduces shader programming as a tool for
mathematical illustration and exploration. Shaders are programs that run
in parallel on the GPU, making them exceptionally fast for visualization
tasks. We'll learn to write code that ``reads like mathematics'' using
Shadertoy, a beginner-friendly web-based platform that handles all the
low-level programming complexities.

\pandocbounded{\includegraphics[keepaspectratio]{./demos/pt/screenshot.png}}

We'll progress from 2D foundations (curves, tilings, fractals) to 3D
rendering via raymarching. Along the way, we will implement classic
examples like the Mandelbrot set, hyperbolic tessellations, and implicit
surface renderers. The final day will explore either advanced geometric
techniques (domain operations, 3D fractals) or temporal simulation
methods (PDEs, buffer-based dynamics), depending on the group's
interests.

No prior experience with shaders or GLSL is required---only a strong
foundation in undergraduate mathematics and willingness to work hard and
experiment with code through daily homework exercises. Here are some
examples of things we will make:

\pandocbounded{\includegraphics[keepaspectratio]{images/mandelbrot.png}}

\pandocbounded{\includegraphics[keepaspectratio]{images/hyperbolic.png}}

\pandocbounded{\includegraphics[keepaspectratio]{images/cubic.png}}

\bookmarksetup{startatroot}

\chapter*{Outline}\label{outline}
\addcontentsline{toc}{chapter}{Outline}

\markboth{Outline}{Outline}

\section*{Course Overview}\label{course-overview}
\addcontentsline{toc}{section}{Course Overview}

\markright{Course Overview}

This mini-course introduces shader programming as a tool for
mathematical illustration and exploration. Shaders are programs that run
in parallel on the GPU, making them exceptionally fast for visualization
tasks. We'll learn to write code that ``reads like mathematics'' using
Shadertoy, a beginner-friendly web-based platform that handles all the
low-level programming complexities.

\textbf{Format:} Five days, each with one hour of lecture and
approximately 1.5 hours of homework

\textbf{Prerequisites:} Strong foundation in undergraduate mathematics;
no prior experience with shaders or GLSL required

\textbf{Audience:} Graduate students, postdocs, and faculty in
mathematics

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Day 1: Introduction to Shader
Programming}\label{day-1-introduction-to-shader-programming}
\addcontentsline{toc}{section}{Day 1: Introduction to Shader
Programming}

\markright{Day 1: Introduction to Shader Programming}

\subsection*{Learning Objectives}\label{learning-objectives}
\addcontentsline{toc}{subsection}{Learning Objectives}

\begin{itemize}
\tightlist
\item
  Understand the mathematical model of shader programming (function from
  pixels to colors)
\item
  Learn basic GLSL syntax and conventions
\item
  Master coordinate system setup and distance calculations
\item
  Create simple geometric shapes and implicit curves
\end{itemize}

\subsection*{In-Class Content}\label{in-class-content}
\addcontentsline{toc}{subsection}{In-Class Content}

\begin{itemize}
\tightlist
\item
  \textbf{Mathematical framing}: Shaders as parallel functions computing
  colors for all pixels simultaneously
\item
  \textbf{GLSL basics}: Syntax, vector types, built-in functions
\item
  \textbf{Coordinate systems}: Centering, normalizing, aspect ratio
  correction
\item
  \textbf{Conditional coloring}: Half-planes and regions defined by
  inequalities
\item
  \textbf{Distance fields}: Circles, filled and outlined
\item
  \textbf{Repetition}: Using \texttt{mod()} for grids and patterns
\item
  \textbf{Implicit curves}: Rendering curves defined by \(F(x,y) = 0\)
\end{itemize}

\subsection*{Homework}\label{homework}
\addcontentsline{toc}{subsection}{Homework}

\textbf{Required:} Parabola graphing calculator - Draw coordinate axes -
Plot \(y = ax^2 + bx + c\) with customizable coefficients - Make it
robust for various parameter values

\textbf{Optional \#1:} Animated curve family (vary parameters with time)

\textbf{Optional \#2:} Beautiful tiling pattern using \texttt{mod()}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Day 2: Complex Dynamics and Iterated
Inversions}\label{day-2-complex-dynamics-and-iterated-inversions}
\addcontentsline{toc}{section}{Day 2: Complex Dynamics and Iterated
Inversions}

\markright{Day 2: Complex Dynamics and Iterated Inversions}

\subsection*{Learning Objectives}\label{learning-objectives-1}
\addcontentsline{toc}{subsection}{Learning Objectives}

\begin{itemize}
\tightlist
\item
  Implement complex number arithmetic in GLSL
\item
  Render the Mandelbrot set through escape-time iteration
\item
  Master circle inversion as a conformal transformation
\item
  Use structs to organize geometric data
\item
  Generate the Apollonian gasket through iterated inversions
\end{itemize}

\subsection*{In-Class Content}\label{in-class-content-1}
\addcontentsline{toc}{subsection}{In-Class Content}

\begin{itemize}
\tightlist
\item
  \textbf{Complex arithmetic}: Addition, multiplication, division,
  conjugation
\item
  \textbf{Mandelbrot set}:

  \begin{itemize}
  \tightlist
  \item
    Iteration \(z_{n+1} = z_n^2 + c\) with \(z_0 = 0\)
  \item
    Escape-time algorithm
  \item
    Smooth coloring and palettes
  \end{itemize}
\item
  \textbf{Circle inversion}:

  \begin{itemize}
  \tightlist
  \item
    Mathematical definition and properties
  \item
    Conformal mapping (preserves angles, maps circles to circles/lines)
  \item
    Implementation and visualization
  \end{itemize}
\item
  \textbf{Structs in GLSL}: Organizing circle data (center, radius)
\item
  \textbf{Apollonian gasket}:

  \begin{itemize}
  \tightlist
  \item
    Three mutually tangent circles
  \item
    Iterated inversions generate fractal structure
  \item
    Coloring by escape time or basin of attraction
  \end{itemize}
\end{itemize}

\subsection*{Homework}\label{homework-1}
\addcontentsline{toc}{subsection}{Homework}

\textbf{Required:} Julia sets - Implement for fixed \(c\), varying
initial \(z_0\) - Explore parameter space (try different values of
\(c\)) - Optional: animate \(c\) to watch morphing

\textbf{Optional:} Schottky groups - Four or more disjoint circles -
Alternating inversion patterns - Create intricate nested structures

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Day 3: Geometric Tilings in Euclidean and Hyperbolic
Space}\label{day-3-geometric-tilings-in-euclidean-and-hyperbolic-space}
\addcontentsline{toc}{section}{Day 3: Geometric Tilings in Euclidean and
Hyperbolic Space}

\markright{Day 3: Geometric Tilings in Euclidean and Hyperbolic Space}

\subsection*{Learning Objectives}\label{learning-objectives-2}
\addcontentsline{toc}{subsection}{Learning Objectives}

\begin{itemize}
\tightlist
\item
  Create Euclidean triangle tilings through reflection
\item
  Understand hyperbolic geometry models (upper half-plane, Poincaré
  disk)
\item
  Implement hyperbolic triangle tilings using circle inversion
\item
  Convert between different hyperbolic models
\end{itemize}

\subsection*{In-Class Content}\label{in-class-content-2}
\addcontentsline{toc}{subsection}{In-Class Content}

\begin{itemize}
\tightlist
\item
  \textbf{Euclidean triangle tiling}:

  \begin{itemize}
  \tightlist
  \item
    Fundamental domain (equilateral triangle)
  \item
    Reflection across edges
  \item
    Iterative folding algorithm
  \item
    Coloring by reflection count
  \end{itemize}
\item
  \textbf{Hyperbolic geometry introduction}:

  \begin{itemize}
  \tightlist
  \item
    Upper half-plane model: \(\mathbb{H}^2 = \{z : \text{Im}(z) > 0\}\)
  \item
    Hyperbolic metric: \(ds^2 = \frac{dx^2 + dy^2}{y^2}\)
  \item
    Geodesics: vertical lines and semicircles
  \item
    Hyperbolic distance formula
  \end{itemize}
\item
  \textbf{Poincaré disk model}:

  \begin{itemize}
  \tightlist
  \item
    Unit disk representation
  \item
    Cayley transform between models
  \end{itemize}
\item
  \textbf{Hyperbolic triangle tiling}:

  \begin{itemize}
  \tightlist
  \item
    \((2,3,\infty)\) triangle with nice edges
  \item
    Reflection across vertical geodesics (simple)
  \item
    Reflection across circular geodesics (circle inversion!)
  \item
    Folding algorithm
  \item
    Visualization in both models
  \end{itemize}
\end{itemize}

\subsection*{Homework}\label{homework-2}
\addcontentsline{toc}{subsection}{Homework}

\textbf{Required \#1:} Draw geodesics and hyperbolic disks - Visualize
geodesics in upper half-plane - Draw hyperbolic disks (constant
hyperbolic distance) - Observe metric distortion

\textbf{Required \#2:} Draw triangle edges and vertices - Compute
distance to geodesics - Render triangle boundaries explicitly - Mark
vertices

\textbf{Required \#3:} Model conversion and Möbius transformations -
Convert tiling to Poincaré disk - Apply Möbius transformations
(isometries) - Observe how tiling transforms

\textbf{Optional:} - Different triangle groups (e.g., \((2,3,7)\) for
Escher-like tilings) - Klein model (geodesics become straight lines) -
Decorated tiles (Escher-style patterns)

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Day 4: Introduction to 3D
Rendering}\label{day-4-introduction-to-3d-rendering}
\addcontentsline{toc}{section}{Day 4: Introduction to 3D Rendering}

\markright{Day 4: Introduction to 3D Rendering}

\subsection*{Learning Objectives}\label{learning-objectives-3}
\addcontentsline{toc}{subsection}{Learning Objectives}

\begin{itemize}
\tightlist
\item
  Set up camera and generate rays from pixels
\item
  Implement analytical ray-object intersection
\item
  Learn the raymarching algorithm and signed distance functions
\item
  Apply basic lighting (diffuse shading)
\end{itemize}

\subsection*{In-Class Content}\label{in-class-content-3}
\addcontentsline{toc}{subsection}{In-Class Content}

\begin{itemize}
\tightlist
\item
  \textbf{Camera and ray setup}:

  \begin{itemize}
  \tightlist
  \item
    Pinhole camera model
  \item
    Ray generation from pixel coordinates
  \item
    Field of view control
  \end{itemize}
\item
  \textbf{Analytical intersections}:

  \begin{itemize}
  \tightlist
  \item
    Ray-sphere: solve quadratic equation
  \item
    Compute surface normals analytically
  \item
    Ray-torus: implicit equation and gradient
  \item
    Bisection method for root-finding
  \end{itemize}
\item
  \textbf{Lighting introduction}:

  \begin{itemize}
  \tightlist
  \item
    Surface normals
  \item
    Diffuse lighting: dot product with light direction
  \item
    Seeing 3D structure through shading
  \end{itemize}
\item
  \textbf{Motivation for raymarching}:

  \begin{itemize}
  \tightlist
  \item
    Analytical methods don't scale
  \item
    Complex surfaces need flexible approach
  \end{itemize}
\item
  \textbf{Signed Distance Functions (SDFs)}:

  \begin{itemize}
  \tightlist
  \item
    Definition and properties
  \item
    SDFs for primitives: sphere, box, plane, torus
  \item
    Distance as bound for safe marching
  \end{itemize}
\item
  \textbf{Raymarching algorithm}:

  \begin{itemize}
  \tightlist
  \item
    Sphere tracing: march by SDF value
  \item
    Stopping conditions
  \item
    Scene composition (minimum distance)
  \end{itemize}
\item
  \textbf{Normal estimation}:

  \begin{itemize}
  \tightlist
  \item
    Gradient via finite differences
  \item
    Estimating partial derivatives
  \item
    Same lighting applied to raymarched objects
  \end{itemize}
\item
  \textbf{Scene progression}:

  \begin{itemize}
  \tightlist
  \item
    Single sphere
  \item
    Two spheres
  \item
    Sphere and torus
  \end{itemize}
\end{itemize}

\subsection*{Homework}\label{homework-3}
\addcontentsline{toc}{subsection}{Homework}

\textbf{Required:} Algebraic variety rendering - Choose polynomial
implicit surface (degree 3 or 4) - Implement root-finding (bisection or
Newton's method) - Compute gradient for normals - Optional: bounding
sphere optimization

\textbf{Optional:} - Specular lighting (Phong model) - Rotation matrices
for object transformation - Complex multi-object scenes

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Day 5: Choose Your
Adventure}\label{day-5-choose-your-adventure}
\addcontentsline{toc}{section}{Day 5: Choose Your Adventure}

\markright{Day 5: Choose Your Adventure}

The final day will be determined based on pacing, student interest, and
energy levels. Two complete lectures are prepared:

\subsection*{Option A: Advanced Raymarching
Techniques}\label{option-a-advanced-raymarching-techniques}
\addcontentsline{toc}{subsection}{Option A: Advanced Raymarching
Techniques}

\subsubsection*{Learning Objectives}\label{learning-objectives-4}
\addcontentsline{toc}{subsubsection}{Learning Objectives}

\begin{itemize}
\tightlist
\item
  Master domain operations for efficient complex scenes
\item
  Understand and apply boolean operations on SDFs
\item
  Create 3D fractals via iterated folding (Menger sponge)
\item
  Build sophisticated scenes from simple primitives
\end{itemize}

\subsubsection*{In-Class Content}\label{in-class-content-4}
\addcontentsline{toc}{subsubsection}{In-Class Content}

\begin{itemize}
\tightlist
\item
  \textbf{Domain operations}:

  \begin{itemize}
  \tightlist
  \item
    Repetition: \texttt{mod()} for infinite object grids
  \item
    Symmetry: \texttt{abs()} for mirror planes
  \item
    Polar repetition for radial patterns
  \item
    Zero computational cost for infinite complexity
  \end{itemize}
\item
  \textbf{Boolean operations on SDFs}:

  \begin{itemize}
  \tightlist
  \item
    Union: \texttt{min(d1,\ d2)}
  \item
    Intersection: \texttt{max(d1,\ d2)}
  \item
    Subtraction: \texttt{max(d1,\ -d2)}
  \item
    Smooth minimum: \texttt{smin()} for organic blending
  \end{itemize}
\item
  \textbf{Menger sponge}:

  \begin{itemize}
  \tightlist
  \item
    Box folding in 3D
  \item
    Axis-aligned operations
  \item
    Iterated subdivision
  \item
    Connection to 2D fractals
  \end{itemize}
\item
  \textbf{Scene building}:

  \begin{itemize}
  \tightlist
  \item
    Combining techniques
  \item
    Architectural structures
  \item
    Infinite repeated patterns
  \end{itemize}
\end{itemize}

\subsubsection*{Homework}\label{homework-4}
\addcontentsline{toc}{subsubsection}{Homework}

\textbf{Required:} Creative scene building - Build complex scene using
domain ops and booleans - Experiment with combinations - Focus on
mathematical or aesthetic interest

\textbf{Optional:} Sierpinski tetrahedron - Implement via 3D folding
(non-axis-aligned) - Connection to Day 2's triangle folding in higher
dimension

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection*{Option B: Buffers and Temporal
Dynamics}\label{option-b-buffers-and-temporal-dynamics}
\addcontentsline{toc}{subsection}{Option B: Buffers and Temporal
Dynamics}

\subsubsection*{Learning Objectives}\label{learning-objectives-5}
\addcontentsline{toc}{subsubsection}{Learning Objectives}

\begin{itemize}
\tightlist
\item
  Understand buffer-based computation in Shadertoy
\item
  Implement differential operators (Laplacian)
\item
  Solve partial differential equations on the GPU
\item
  Create dynamic, evolving mathematical systems
\end{itemize}

\subsubsection*{In-Class Content}\label{in-class-content-5}
\addcontentsline{toc}{subsubsection}{In-Class Content}

\begin{itemize}
\tightlist
\item
  \textbf{Introduction to buffers}:

  \begin{itemize}
  \tightlist
  \item
    Reading from previous frame
  \item
    Multi-pass rendering
  \item
    Simple example: conditional coloring based on buffer
  \end{itemize}
\item
  \textbf{Edge detection and the Laplacian}:

  \begin{itemize}
  \tightlist
  \item
    Discrete Laplacian stencil (5-point or 9-point)
  \item
    Sampling neighboring pixels
  \item
    Spatial derivatives on grids
  \end{itemize}
\item
  \textbf{The heat equation}:

  \begin{itemize}
  \tightlist
  \item
    Mathematical formulation: \(u_t = \alpha\nabla^2 u\)
  \item
    Applying Laplacian for diffusion
  \item
    Time-stepping:
    \texttt{u\_new\ =\ u\_old\ +\ dt\ *\ α\ *\ laplacian(u\_old)}
  \item
    Initial conditions (e.g., heat in a fractal region)
  \item
    Watching patterns blur and diffuse
  \end{itemize}
\item
  \textbf{Boundary conditions}:

  \begin{itemize}
  \tightlist
  \item
    Zero boundaries (edges set to 0)
  \item
    Avoiding wrap-around
  \end{itemize}
\item
  \textbf{Timestep stability}:

  \begin{itemize}
  \tightlist
  \item
    CFL condition (briefly mentioned)
  \item
    Providing stable \texttt{dt} value
  \end{itemize}
\end{itemize}

\subsubsection*{Homework}\label{homework-5}
\addcontentsline{toc}{subsubsection}{Homework}

\textbf{Required:} Interactive heat equation or reaction-diffusion -
Option 1: Heat source at mouse position, watch it diffuse - Option 2:
Gray-Scott reaction-diffusion (pattern formation)

\textbf{Optional:} Wave equation - Requires two buffers (current and
previous state) - Implement \(u_{tt} = c^2\nabla^2 u\) - Watch waves
propagate and reflect

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Resources and Further
Exploration}\label{resources-and-further-exploration}
\addcontentsline{toc}{section}{Resources and Further Exploration}

\markright{Resources and Further Exploration}

\subsection*{Shadertoy}\label{shadertoy}
\addcontentsline{toc}{subsection}{Shadertoy}

\begin{itemize}
\tightlist
\item
  Main site: https://www.shadertoy.com
\item
  Community examples and tutorials
\item
  GLSL documentation
\end{itemize}

\subsection*{References}\label{references}
\addcontentsline{toc}{subsection}{References}

\begin{itemize}
\tightlist
\item
  Complex dynamics and fractals
\item
  Hyperbolic geometry and tilings
\item
  Signed distance functions (Inigo Quilez:
  https://iquilezles.org/articles/distfunctions/)
\item
  GPU computing for scientific visualization
\end{itemize}

\subsection*{Advanced Topics}\label{advanced-topics}
\addcontentsline{toc}{subsection}{Advanced Topics}

\begin{itemize}
\tightlist
\item
  Path tracing and global illumination
\item
  Non-Euclidean ray tracing
\item
  Real-time denoising
\item
  More complex PDEs and simulations
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Assessment Philosophy}\label{assessment-philosophy}
\addcontentsline{toc}{section}{Assessment Philosophy}

\markright{Assessment Philosophy}

This is a workshop-style course focused on skill development. Success
means: - Completing required homework to keep pace - Experimenting with
optional problems based on interest - Developing intuition for when
shader programming is appropriate - Leaving with working code templates
for future projects

\textbf{Philosophy:} Getting something working and understanding it is
more valuable than perfect, polished results. The goal is to build
practical skills and mathematical intuition, not to create
production-quality graphics.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section*{Schedule Summary}\label{schedule-summary}
\addcontentsline{toc}{section}{Schedule Summary}

\markright{Schedule Summary}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.2800}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.5200}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Day
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Topic
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key Concepts
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
1 & Shader Basics & Coordinates, distance fields, implicit curves \\
2 & Complex Dynamics & Mandelbrot, circle inversion, Apollonian
gasket \\
3 & Geometric Tilings & Euclidean and hyperbolic tilings, models \\
4 & 3D Rendering & Raymarching, SDFs, lighting \\
5 & Advanced (flexible) & Domain ops + fractals OR buffers + PDEs \\
\end{longtable}

Each day: 1 hour lecture + \textasciitilde1.5 hours homework Total: 5
lectures, 10-12 programming assignments (5 required, 5-7 optional)

\bookmarksetup{startatroot}

\chapter{Day 1: Introduction to Shader
Programming}\label{day-1-introduction-to-shader-programming-1}

\section{Overview}\label{overview}

Today we introduce the fundamental concept of shader programming:
computing a function from pixel coordinates to colors, executed in
parallel across the entire image. We'll learn basic GLSL syntax, set up
a coordinate system, and create simple geometric shapes.

By the end of today, you'll be able to render implicit curves,
distance-based coloring, and repeating patterns---all computed in
real-time on the GPU.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Roadmap for Today}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

We'll build up shader programming in layers:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Core concept}: Shaders as parallel functions (What is a
  Shader?)
\item
  \textbf{Setup}: Coordinate systems and GLSL syntax (First Shader,
  Coordinate Systems)
\item
  \textbf{Basic techniques}: Conditional coloring and distance fields
  (Half-Planes, Distance Fields)\\
\item
  \textbf{Repetition}: Grids via modular arithmetic (Grids and
  Repetition)
\item
  \textbf{Application}: Implicit curves (Implicit Curves)
\end{enumerate}

Each section builds on the previous, so if something feels unclear, it's
worth revisiting earlier material before moving forward.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{What is a Shader?}\label{what-is-a-shader}

\subsection{Mathematical Perspective}\label{mathematical-perspective}

A shader is fundamentally a function
\[f: \mathbb{R}^2 \times \mathbb{R} \times \cdots \to [0,1]^4\] that
maps pixel coordinates \((x,y)\), time \(t\), and potentially other
parameters to RGBA color values. For today, we'll focus on the spatial
dependence---thinking of the shader as a function
\(f: \mathbb{R}^2 \to [0,1]^4\) that assigns a color to each point in
the plane. The domain \([0,1]^4\) represents the red, green, blue, and
alpha (transparency) channels, each normalized to the unit interval.

Here's the magic: modern GPUs can evaluate this function for \textbf{all
pixels simultaneously}. If your screen has 1920×1080 pixels, that's over
2 million function evaluations happening in parallel, typically 60 times
per second. We're not looping over pixels one at a time---we're
computing them all at once!

This is completely different from how you might write mathematical
visualization code in, say, Python or MATLAB. There you'd have nested
loops:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(width):}
    \ControlFlowTok{for}\NormalTok{ y }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(height):}
\NormalTok{        color[x,y] }\OperatorTok{=}\NormalTok{ f(x, y)}
\end{Highlighting}
\end{Shaded}

With shaders, there are no loops. You write the function \(f\), and the
GPU just \emph{does it} everywhere at once. This parallelism is what
makes shader-based visualization absurdly fast---fast enough to render
complex mathematical objects in real-time, responding to your mouse,
animating smoothly, all at 60fps.

The computational model is fundamentally different: in traditional CPU
programming you have sequential control flow with explicit loops, while
in shader programming you express computation as a pure mathematical
function that gets evaluated independently at every pixel. The GPU
architecture is specifically designed for this kind of massively
parallel workload---it has thousands of small processors that can each
evaluate your function simultaneously. This is why a relatively modest
GPU can outperform even a powerful CPU on graphics tasks by orders of
magnitude.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Why is this called a ``shader''?}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

Historically, these programs were used for \emph{shading} 3D
objects---computing how light interacts with surfaces to create
realistic images. The name stuck even though nowadays we use them for
all sorts of parallel computation, far beyond just lighting
calculations. We're going to use shaders to render implicit curves,
fractals, hyperbolic tilings, and solve PDEs---none of which have
anything to do with ``shading'' in the traditional sense!

\end{tcolorbox}

\subsection{Why Shadertoy?}\label{why-shadertoy}

Shadertoy is a web-based platform that handles all the annoying GPU
setup for you. Normally, working with shaders requires writing a bunch
of boilerplate code: setting up OpenGL contexts, compiling shader
programs, managing buffers, handling the render loop---it's a pain.
Shadertoy abstracts all of that away. You write a single function, hit
compile, and instantly see your results.

Shadertoy launched in 2013, created by Pol Jeremias-Vila and Íñigo
Quílez (we'll see more of Íñigo's work throughout this week---he's
pioneered many shader techniques). Before platforms like Shadertoy,
shader programming required managing the entire OpenGL or DirectX
pipeline yourself---compiling shaders, linking programs, setting up
vertex buffers, managing textures. It was the domain of graphics
programmers, not mathematicians.

The genius of Shadertoy was recognizing that for many visualizations,
you don't need that complexity. Just give people a function to fill in,
handle the boilerplate invisibly, and suddenly shaders become accessible
to anyone. It's democratized GPU programming in much the same way that
Python notebooks democratized scientific computing---lower the barrier
to entry, and a whole new community emerges.

The platform provides several built-in \textbf{uniforms} (read-only
global variables that are the same for all pixels):

\begin{itemize}
\tightlist
\item
  \texttt{iResolution}: screen resolution as a \texttt{vec3} (width,
  height, pixel aspect ratio)
\item
  \texttt{iTime}: elapsed time in seconds since the shader started
\item
  \texttt{iMouse}: mouse position and click state as a \texttt{vec4}
\end{itemize}

We'll use these throughout the week to create animated, interactive
mathematical visualizations.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{First Shader: Solid Colors}\label{first-shader-solid-colors}

\subsection{Basic Structure}\label{basic-structure}

Every Shadertoy shader has the same entry point:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Your code here}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Parameters:}

\begin{itemize}
\tightlist
\item
  \texttt{fragCoord}: the pixel coordinate we're currently computing, as
  a \texttt{vec2} giving the \((x, y)\) position
\item
  \texttt{fragColor}: the output color we need to set, as a
  \texttt{vec4} giving the \((r, g, b, a)\) color
\end{itemize}

Colors are represented in RGBA format with values in \([0, 1]\). So
\texttt{vec4(1.0,\ 0.0,\ 0.0,\ 1.0)} represents opaque red, while
\texttt{vec4(0.5,\ 0.5,\ 0.5,\ 1.0)} is middle gray.

\subsection{Example: Red Screen}\label{example-red-screen}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This sets every pixel to red. The function is evaluated once per pixel,
but since the output doesn't depend on \texttt{fragCoord}, every pixel
gets the same value. Not very exciting---but it's a start!

\subsection{GLSL Syntax Basics}\label{glsl-syntax-basics}

Before we go further, let's talk about some essential GLSL conventions.
If you're coming from Python or MATLAB, a few things will feel
different:

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{GLSL Syntax Rules}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-important-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-important-color!10!white, bottomrule=.15mm]

\textbf{Semicolons are required.} Every statement must end with a
semicolon. This is not Python! Forget one and your shader won't compile.

\textbf{Floating point literals:} Write \texttt{1.0} not \texttt{1} for
floating point values. GLSL is very picky about types---if you write
\texttt{1}, it's an integer, and mixing types causes errors. Get in the
habit of always writing the \texttt{.0}.

\textbf{Vector types:} GLSL has built-in types \texttt{vec2},
\texttt{vec3}, \texttt{vec4} for 2D, 3D, and 4D vectors. You can
construct them with:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ v }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ w }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{,} \FloatTok{3.0}\OperatorTok{);}
\DataTypeTok{vec4}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{v}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Can combine vectors and scalars}
\end{Highlighting}
\end{Shaded}

\textbf{Swizzling:} You can access components by name: \texttt{v.x},
\texttt{v.y} or equivalently \texttt{v.r}, \texttt{v.g} (same thing,
different naming convention---use whichever makes sense for your
context). Even better, you can rearrange components: \texttt{v.yx} swaps
the coordinates, \texttt{v.xxx} repeats the x-component three times.
This is incredibly useful!

\end{tcolorbox}

\subsection{Animating with Time}\label{animating-with-time}

Let's make something that changes:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ red }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{red}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Here \texttt{iTime} grows continuously, \texttt{sin(iTime)} oscillates
between \(-1\) and \(1\), and we remap this to \([0, 1]\) with the
affine transformation \(t \mapsto \frac{1}{2}(1 + t)\). The screen now
pulses between black and red!

This pattern---\texttt{0.5\ +\ 0.5\ *\ sin(...)}---comes up constantly
when animating. It's the standard way to turn a sinusoid into something
that stays in the range \([0,1]\). You'll use this so often it becomes
second nature.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Coordinate Systems}\label{coordinate-systems}

\subsection{Raw Coordinates}\label{raw-coordinates}

By default, \texttt{fragCoord} gives pixel coordinates with:

\begin{itemize}
\tightlist
\item
  Origin \((0, 0)\) at the bottom-left
\item
  \(x\) increases rightward to \texttt{iResolution.x}
\item
  \(y\) increases upward to \texttt{iResolution.y}
\end{itemize}

This is fine if you're thinking about pixels, but for mathematical work
we want something more natural: coordinates centered at the origin,
normalized (not in pixels), and with aspect ratio handled correctly so
that squares actually look square!

\subsection{Centered, Normalized
Coordinates}\label{centered-normalized-coordinates}

Here's the standard transformation we'll use in every shader:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Normalize to [0,1]}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
    
    \CommentTok{// Center at origin: [{-}0.5, 0.5]}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
    
    \CommentTok{// Scale to account for aspect ratio}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Now uv is centered and aspect{-}corrected}
    \CommentTok{// Scale to desired viewing window (e.g., [{-}2, 2] on x{-}axis)}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}  
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Let's understand this transformation rigorously. We're composing four
maps. Let's write \(w =\) \texttt{iResolution.x} and \(h =\)
\texttt{iResolution.y} for the width and height in pixels.

\textbf{Step 1: Normalization}
\[T_1: [0, w] \times [0, h] \to [0,1]^2, \quad T_1(x,y) = \left(\frac{x}{w}, \frac{y}{h}\right)\]

This makes our coordinates resolution-independent---the same shader code
works whether your screen is 1920×1080 or 800×600. A point that's
halfway across the screen is \((0.5, v)\) regardless of how many pixels
wide the screen actually is.

\textbf{Step 2: Centering}
\[T_2: [0,1]^2 \to [-\tfrac{1}{2}, \tfrac{1}{2}]^2, \quad T_2(u,v) = (u - \tfrac{1}{2}, v - \tfrac{1}{2})\]

Now the origin is at the center of the screen, which is much more
natural for mathematical work. We can think about positive and negative
coordinates, circles centered at the origin, and so on.

\textbf{Step 3: Aspect correction}
\[T_3(u,v) = \left(\frac{w}{h} \cdot u, v\right)\]

This is crucial! Without it, circles would appear as ellipses on
non-square screens. The aspect ratio \(w/h\) stretches the
\(x\)-coordinate so that one unit in \(x\) corresponds to the same
screen distance as one unit in \(y\). On a typical 16:9 display
(\(w/h \approx 1.78\)), this means the \(x\)-axis spans a wider range
than the \(y\)-axis---as it should to maintain equal scaling. A circle
of radius \(r\) will actually appear circular on screen, not squashed.

\textbf{Step 4: Scaling to viewing window} \[T_4(u,v) = s \cdot (u,v)\]

Finally, we scale by whatever factor gives us the mathematical viewing
window we want. If we choose \(s = 4\), then on a 16:9 screen our
coordinates range roughly from \([-3.56, 3.56]\) in \(x\) and
\([-2, 2]\) in \(y\)---notice the \(x\)-range is wider to match the
screen aspect ratio.

The composition \(T_4 \circ T_3 \circ T_2 \circ T_1\) is our complete
coordinate transformation, taking us from raw pixel coordinates to a
centered, aspect-corrected mathematical coordinate system.

From now on, we'll assume this coordinate setup is done at the start of
every shader, storing the result in a variable \texttt{p} for
``position.''

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{The coordinate transformation boilerplate}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

You'll do these first few lines in almost every shader you write. It
becomes muscle memory quickly! Some people like to wrap it in a
function, but for these lectures we'll just write it out each time so
the transformation is explicit and you can modify it when needed.

\end{tcolorbox}

\subsection{Visualizing Coordinates}\label{visualizing-coordinates}

Let's verify our coordinate system is working by coloring pixels
according to their position:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Map x coordinate to red, y to green}
    \DataTypeTok{vec2}\NormalTok{ color\_rg }\OperatorTok{=}\NormalTok{ p }\OperatorTok{*} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Remap to [0, 1]}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color\_rg}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see a smooth gradient: red increases rightward, green
increases upward. If you don't see this, something went wrong in your
coordinate setup! This is a good debugging technique---whenever you're
unsure about your coordinates, visualize them directly as colors.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Conditional Coloring:
Half-Planes}\label{conditional-coloring-half-planes}

\subsection{The Concept}\label{the-concept}

Given a linear function \(L(x, y) = ax + by + c\), we want to color
pixels differently depending on whether \(L(p) < 0\) or \(L(p) \geq 0\).
This divides the plane into two half-planes---the regions where the
function is negative versus positive.

The line itself is the zero set: \(\{(x,y) : L(x,y) = 0\}\). This is the
boundary between the two regions.

\subsection{Implementation}\label{implementation}

GLSL provides a conditional operator (ternary operator) just like C:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ L }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}  \CommentTok{// The function L(x,y) = x}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{L }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Left half-plane is red, right half-plane is blue. The syntax
\texttt{(condition)\ ?\ value\_if\_true\ :\ value\_if\_false} should be
familiar if you've programmed in C, Java, or JavaScript.

\subsection{The Step Function}\label{the-step-function}

GLSL also provides \texttt{step(edge,\ x)} which returns \(0\) if
\(x < \text{edge}\) and \(1\) otherwise. The name comes from its
graph---a step function in the calculus sense, jumping discontinuously
from 0 to 1 at the edge value. This is useful for writing cleaner code
without explicit conditionals:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ s }\OperatorTok{=} \BuiltInTok{step}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}  \CommentTok{// 0 on left, 1 on right}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{),}\NormalTok{ s}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Here \texttt{mix(a,\ b,\ t)} performs linear interpolation:
\((1-t)a + tb\). So when \texttt{s\ =\ 0} we get pure red, when
\texttt{s\ =\ 1} we get pure blue. The \texttt{mix} function is one of
GLSL's most useful tools---you'll use it constantly for blending colors,
smoothly transitioning between values, and implementing linear
interpolation in all sorts of contexts.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Why use \texttt{step} instead of the ternary operator?}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

Both work fine! The ternary operator \texttt{?:} is more explicit and
familiar if you know C-like languages. But \texttt{step} and
\texttt{mix} are more idiomatic in shader code, and they compose nicely
with other functions. As you write more shaders, you'll develop a feel
for which style is clearer in each situation. For now, use whichever
makes sense to you.

\end{tcolorbox}

\subsection{Arbitrary Half-Planes}\label{arbitrary-half-planes}

For a general line \(ax + by + c = 0\), we just evaluate the
corresponding linear function:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{,}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ L }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{L }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Try different values of \(a\), \(b\), and \(c\) to see different line
orientations and positions. The line itself is where \(L = 0\), and
we're coloring the two sides differently. Notice that scaling
\((a,b,c)\) by a positive constant doesn't change the geometry---it's
the zero set that matters, not the specific values of the function away
from zero.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Distance Fields and Circles}\label{distance-fields-and-circles}

\subsection{Distance to Center}\label{distance-to-center}

The distance from a point \(p = (x, y)\) to the origin is just the usual
Euclidean distance: \[d = \|p\| = \sqrt{x^2 + y^2}\]

In GLSL this is built-in:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The \texttt{length()} function computes the Euclidean norm of a vector.
It works for \texttt{vec2}, \texttt{vec3}, \texttt{vec4}---whatever you
need. Under the hood it's computing the square root of the dot product
of the vector with itself, but there's no need to write that out
explicitly.

\subsection{Filled Circle}\label{filled-circle}

A circle of radius \(r\) centered at the origin is the set
\(\{p : \|p\| < r\}\)---just points whose distance from the origin is
less than \(r\). So to color the inside versus outside of a circle, we
just compare distances:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

That's it! This renders a yellow disk on a dark blue background. Every
pixel computes its distance to the origin and decides whether it's
inside or outside the circle. Simple, elegant, and fast---millions of
distance calculations per frame, all happening in parallel.

\subsection{Distance-Based Coloring}\label{distance-based-coloring}

But we don't have to just make binary inside/outside decisions---we can
use the distance value itself to create gradients and other effects. For
example, we can make things fade out with distance:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ intensity }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ d }\OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}  \CommentTok{// Fades from 1 at center to 0 at distance 2}
\NormalTok{intensity }\OperatorTok{=} \BuiltInTok{clamp}\OperatorTok{(}\NormalTok{intensity}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Keep it in [0, 1]}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{intensity}\OperatorTok{);}
\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This creates a radial gradient---bright at the center, dark at the
edges. The \texttt{clamp} function ensures we stay within \([0,1]\) even
if our formula would produce values outside that range. Distance fields
like this are incredibly versatile: you can use them for smooth
transitions, glowing effects, or (as we'll see on Day 4) as the
foundation for 3D rendering!

Distance fields will become increasingly important as the week
progresses. On Day 4, we'll use them as the foundation for
\textbf{raymarching}---a technique for rendering 3D geometry without any
triangles or polygons, purely by iteratively evaluating distance
functions. The \texttt{length(p)} function we used for circles today
generalizes to arbitrary implicit surfaces: \$d(p) = \$ ``distance to
the surface defined by \(F(p) = 0\).'' It's a beautiful connection
between analysis and computer graphics.

\subsection{Circle Outline}\label{circle-outline}

What if we want to draw just the \emph{boundary} of a circle---not the
filled disk, but the thin curve itself? We need to check if the distance
is \emph{approximately equal} to the radius. Mathematically, we're
coloring the set \(\{p : |d(p) - r| < \epsilon\}\) where \(\epsilon\) is
a small thickness parameter:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.05}\OperatorTok{;}

\DataTypeTok{float}\NormalTok{ circle\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{d }\OperatorTok{{-}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{circle\_mask}\OperatorTok{);}
\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This draws a thin white annulus around the circle. Play with the
\texttt{thickness} parameter to see how it affects the line width!

For a smoother, anti-aliased edge, GLSL provides \texttt{smoothstep}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ circle\_mask }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{{-}} \BuiltInTok{smoothstep}\OperatorTok{(}\NormalTok{r }\OperatorTok{{-}}\NormalTok{ thickness}\OperatorTok{,}\NormalTok{ r }\OperatorTok{+}\NormalTok{ thickness}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The \texttt{smoothstep(a,\ b,\ x)} function performs smooth Hermite
interpolation. For \(x \in [a,b]\), it returns
\[s(t) = 3t^2 - 2t^3 \quad \text{where } t = \frac{x-a}{b-a}\]

This is a cubic polynomial with \(s(0) = 0\), \(s(1) = 1\), and
crucially \(s'(0) = s'(1) = 0\)---the zero derivatives at the endpoints
mean it transitions smoothly without visible ``kinks.'' For \(x < a\) it
returns \(0\), for \(x > b\) it returns \(1\).

The result is anti-aliasing: instead of a hard transition at a single
pixel, the edge is blurred over the interval \([a,b]\). For circle
outlines, using
\texttt{smoothstep(r\ -\ thickness,\ r\ +\ thickness,\ d)} creates a
smooth transition zone of width \(2 \cdot \text{thickness}\) around the
target radius. This eliminates jagged edges and makes the circle look
much nicer---especially important when you're creating
publication-quality mathematical illustrations!

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Anti-aliasing in shaders}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

The harsh cutoffs from using \texttt{\textless{}} or the ternary
operator create jagged, pixelated edges---what computer graphics people
call ``aliasing'' (the signal is being undersampled relative to its
frequency content, creating artifacts). Functions like
\texttt{smoothstep} give you smooth transitions over a few pixels, which
is exactly what you want for anti-aliasing. We'll use this technique
constantly: anywhere you have a sharp boolean decision, consider
replacing it with \texttt{smoothstep} for smoother results.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Grids and Repetition}\label{grids-and-repetition}

\subsection{Modular Arithmetic}\label{modular-arithmetic}

The modulo operation creates periodic repetition. For a period \(T\),
the function \(p \mapsto (p \bmod T) - T/2\) maps \(\mathbb{R}\) to
\([-T/2, T/2]\) repeatedly---it ``folds'' the entire real line into a
finite interval over and over again.

More precisely, recall that \(x \bmod T\) is the unique value in
\([0, T)\) satisfying \(x \equiv r \pmod{T}\)---that is, \(x = nT + r\)
for some integer \(n\). Geometrically, this takes the real line and
wraps it into the interval \([0,T)\). Subtracting \(T/2\) recenters this
to \([-T/2, T/2]\).

In GLSL, \texttt{mod(x,\ T)} computes \(x \bmod T\). This is one of the
most powerful tools in shader programming!

\subsection{Creating a Grid}\label{creating-a-grid}

To create a grid of repeated cells, we apply \texttt{mod} to our
coordinates:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ spacing}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Now cell\_p repeats every spacing units}
    \CommentTok{// Draw a circle in each cell}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.3}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This creates an infinite grid of yellow circles! The coordinate
transformation
\texttt{cell\_p\ =\ mod(p\ +\ spacing/2.0,\ spacing)\ -\ spacing/2.0}
ensures that \texttt{cell\_p} is always in the range
\([-\text{spacing}/2, \text{spacing}/2]\), and this range repeats
forever. So every cell of the grid has identical coordinates, and
therefore draws identical content.

Think about what just happened: we created infinitely many circles with
exactly the same amount of computation as drawing a single circle!
There's no loop over grid cells, no array of circle positions---the
repetition comes purely from the coordinate transformation.

Compare this to how you might approach this in Python or MATLAB: you'd
probably set up a nested loop over grid cells, compute the center of
each cell, then draw a circle there. That's \(O(n^2)\) work for an
\(n \times n\) grid. With shaders, it's \(O(1)\) in the grid size---the
cost is entirely in the number of \emph{pixels}, not the number of
\emph{circles}. This is why shaders can render infinitely complex
patterns at the same framerate as simple ones.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{The power of \texttt{mod}}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

This computational efficiency through coordinate transformations is a
recurring theme in shader programming. You'll see it again when we talk
about domain repetition for fractals (Day 2), symmetry groups for
hyperbolic tilings (Day 3), and space folding for raymarched scenes (Day
4). The key insight is always the same: instead of explicitly iterating
over instances, transform the coordinate system so that all instances
share the same local coordinates.

\end{tcolorbox}

\subsection{Alternating Pattern}\label{alternating-pattern}

We can create checkerboard-like patterns by using the \emph{cell index}
to vary colors. To get the cell index, we divide by the spacing and
floor:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{/}\NormalTok{ spacing}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ checker }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ cell\_id}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}

\DataTypeTok{vec3}\NormalTok{ color\_a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ color\_b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ bg\_color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color\_a}\OperatorTok{,}\NormalTok{ color\_b}\OperatorTok{,}\NormalTok{ checker}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Here \texttt{floor(p\ /\ spacing)} gives us integer grid indices
\((i, j)\), and we alternate colors based on the parity of \(i + j\).
When \(i + j\) is even, \texttt{checker\ =\ 0} (giving us
\texttt{color\_a}), when odd, \texttt{checker\ =\ 1} (giving us
\texttt{color\_b}).

Notice the elegant separation: \texttt{cell\_id} tells us \emph{which}
cell we're in, while \texttt{cell\_p} tells us \emph{where within} that
cell. This separation of global position and local coordinates is
fundamental to working with repeating patterns.

\subsection{Combining with Circles}\label{combining-with-circles}

Let's put it all together---a grid of circles on an alternating
background:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{/}\NormalTok{ spacing}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ spacing}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Checkerboard background}
    \DataTypeTok{float}\NormalTok{ checker }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ cell\_id}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ bg\_color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{),}\NormalTok{ checker}\OperatorTok{);}
    
    \CommentTok{// Circle in each cell}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.3}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ circle\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?}\NormalTok{ circle\_color }\OperatorTok{:}\NormalTok{ bg\_color}\OperatorTok{;}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try varying the \texttt{spacing} and \texttt{r} parameters. What happens
if you make the circles larger than the cells? (They overlap across cell
boundaries!) What if you use different spacing values for \texttt{x} and
\texttt{y}? (You get a rectangular rather than square lattice.) This
simple framework is incredibly flexible.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Implicit Curves}\label{implicit-curves}

\subsection{General Principle}\label{general-principle}

An implicit curve is defined by an equation \(F(x, y) = 0\). Points on
the curve satisfy the equation exactly, while points off the curve have
\(F(x,y) \neq 0\). To render the curve, we compute \(F(p)\) for each
pixel and color based on proximity to zero:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \OperatorTok{[}\NormalTok{some function of p}\OperatorTok{.}\FunctionTok{x}\NormalTok{ and p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{];}
\DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.05}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{background}\OperatorTok{,}\NormalTok{ curve\_color}\OperatorTok{,}\NormalTok{ curve\_mask}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This is a remarkably general technique! It works for any curve you can
write as an implicit equation---circles, ellipses, hyperbolas,
higher-degree algebraic curves, transcendental curves, whatever you
want. If you can write down a formula \(F(x,y)\), you can visualize its
zero set.

\subsection{Example: Parabola}\label{example-parabola}

The parabola \(y = x^2\) can be written implicitly as
\(F(x, y) = y - x^2 = 0\):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}

\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ curve\_mask}\OperatorTok{);}
\NormalTok{fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

You should see a yellow parabola on a dark blue background. The curve
appears wherever \(|F(x,y)| < 0.1\)---a thin band around the zero set of
\(F\).

One thing to notice: the visual thickness of the curve varies! Near the
vertex where the parabola is flat, the curve looks thicker, while in the
steep regions it appears thinner. Why does this happen?

We're thresholding on the \emph{value} of \(F\), not the \emph{geometric
distance} to the curve. Near the vertex at \((0,0)\), the parabola is
nearly horizontal---small changes in \(y\) correspond to small changes
in \(x\), so the set \(\{p : |y - x^2| < \epsilon\}\) is a thick
vertical band. But on the steep parts where \(|x|\) is large, the
parabola is nearly vertical---now the same change in \(y\) corresponds
to a large change in \(x\), so the band is thin.

To see this more precisely, consider the gradient:
\(\nabla F = (-2x, 1)\). Near the vertex this has magnitude close to
\(1\), but for large \(|x|\) it has magnitude approximately \(2|x|\).
The visual thickness is roughly inversely proportional to
\(|\nabla F|\)---where the gradient is small, the level sets are far
apart, and where it's large, they're close together.

To get uniform thickness, we'd need the \emph{signed distance function}
to the curve: \[d(p) = \inf\{\|p - q\| : F(q) = 0\}\]

Then thresholding on \(|d(p)| < \epsilon\) gives exactly thickness
\(\epsilon\) everywhere. Computing exact signed distance functions is
nontrivial (we'll see techniques for this on Day 4 when we discuss
raymarching), but for many applications the naive thresholding on
\(|F|\) works fine---especially if you tune the thickness parameter
appropriately or use different thickness values in different regions.

\subsection{Example: Circle (Implicit
Form)}\label{example-circle-implicit-form}

We've been using \(\|p\| < r\) for filled circles, but we can also write
the circle implicitly as \(x^2 + y^2 - r^2 = 0\):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}  \CommentTok{// dot(p,p) = x² + y²}
\DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

This is mathematically equivalent to our earlier approach but
demonstrates the general implicit curve technique. The
\texttt{dot(p,\ p)} computes \(x^2 + y^2\) as a single GPU
operation---more efficient than \texttt{p.x\ *\ p.x\ +\ p.y\ *\ p.y} and
certainly cleaner than writing it out! For circles, the signed distance
function and the implicit function are particularly closely related:
\(d(p) = |\|p\| - r|\), so the naive implicit approach actually works
quite well.

\subsection{More Examples}\label{more-examples}

Let's look at a few more interesting curves:

\textbf{Hyperbola}: \(xy = 1\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Ellipse}: \(\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{)} \OperatorTok{/} \OperatorTok{(}\NormalTok{a }\OperatorTok{*}\NormalTok{ a}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/} \OperatorTok{(}\NormalTok{b }\OperatorTok{*}\NormalTok{ b}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\textbf{Lemniscate of Bernoulli}: \((x^2 + y^2)^2 = a^2(x^2 - y^2)\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ r2 }\OperatorTok{*}\NormalTok{ r2 }\OperatorTok{{-}}\NormalTok{ a }\OperatorTok{*}\NormalTok{ a }\OperatorTok{*} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Each of these creates beautiful curves! Try implementing them and
experimenting with different parameters.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Implicit curves in your homework}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

When you're implementing the parabola graphing calculator for homework,
you'll use this exact implicit curve technique. The key is setting up
the equation \(F(x,y) = y - (ax^2 + bx + c)\) and thresholding on
\(|F| < \epsilon\). Make sure to test with various values of \(a\),
\(b\), \(c\) to ensure your grapher is robust!

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Summary}\label{summary}

Today we've learned the fundamental tools of shader programming:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Shaders as parallel functions}: Every pixel evaluates
  \(f(x, y, t, \ldots) \to \text{color}\) simultaneously---no loops
  required! The computational model is fundamentally different from
  sequential CPU programming.
\item
  \textbf{GLSL basics}: Syntax rules (semicolons, \texttt{.0} for
  floats), vector types (\texttt{vec2}, \texttt{vec3}, \texttt{vec4}),
  and essential built-in functions like \texttt{length()},
  \texttt{dot()}, \texttt{step()}, and \texttt{smoothstep()}
\item
  \textbf{Coordinate systems}: The four-step transformation (normalize,
  center, aspect-correct, scale) that takes us from pixel coordinates to
  a mathematical coordinate system suitable for visualization
\item
  \textbf{Conditional coloring}: Using boolean expressions, the ternary
  operator, and \texttt{step()} combined with \texttt{mix()} to create
  discrete color regions based on mathematical predicates
\item
  \textbf{Distance fields}: Using \texttt{length()} to create circles
  and radial patterns---the foundation for much more complex techniques
  we'll explore on Day 4 with raymarching
\item
  \textbf{Modular arithmetic}: Creating grids and repeating patterns
  with \texttt{mod()}---achieving infinite complexity with finite
  computation through coordinate transformations rather than explicit
  iteration
\item
  \textbf{Implicit curves}: Rendering curves defined by \(F(x, y) = 0\)
  by thresholding on \(|F|\)---a general technique that works for any
  curve we can express as an equation, though we must be aware of the
  non-uniform thickness issue
\end{enumerate}

With these tools, you can already create a wide variety of mathematical
visualizations! Tomorrow we'll use these same techniques to explore
complex dynamics (Mandelbrot and Julia sets) and geometric
transformations (circle inversions and the Apollonian gasket). But
everything builds on the foundation we've established today.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Homework}\label{homework-6}

\subsection{Required: Parabola Graphing
Calculator}\label{required-parabola-graphing-calculator}

Create a shader that draws a customizable parabola \(y = ax^2 + bx + c\)
along with coordinate axes.

\textbf{Requirements:}

\begin{itemize}
\tightlist
\item
  Define variables \texttt{a}, \texttt{b}, \texttt{c} at the top of your
  shader (hardcoded values are fine---we're not building a GUI yet)
\item
  Draw the \(x\)-axis and \(y\)-axis as thin lines using the implicit
  line technique: \(|y| < \epsilon\) for the \(x\)-axis,
  \(|x| < \epsilon\) for the \(y\)-axis
\item
  Plot the parabola \(y = ax^2 + bx + c\) as a thicker curve
\item
  Use distinct colors for axes (suggest a neutral gray) and parabola
  (suggest something bright)
\item
  The visualization should work for any reasonable values of \(a\),
  \(b\), \(c\)---make sure to test edge cases!
\end{itemize}

\textbf{What it should look like:} A coordinate plane with thin gray
axes, and a colored curve tracing out your parabola. The entire parabola
should be visible in your viewing window (you may need to adjust your
scaling factor depending on your parameters).

\textbf{Test cases to verify:} - \(a=1, b=0, c=0\) (standard parabola
opening upward) - \(a=-1, b=0, c=1\) (downward-opening parabola shifted
up) - \(a=0.5, b=1, c=-0.5\) (general case with all parameters nonzero)
- \(a=0, b=1, c=0\) (degenerate case---just a line! Your code should
handle this gracefully)

\textbf{Suggested approach:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Define parameters}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ b }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \CommentTok{// Background}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{);}
    
    \CommentTok{// Axes}
    \DataTypeTok{float}\NormalTok{ axis\_thickness }\OperatorTok{=} \FloatTok{0.02}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ x\_axis\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ axis\_thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ y\_axis\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ axis\_thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ axis\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    
    \CommentTok{// Parabola: F(x,y) = y {-} (ax² + bx + c) = 0}
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \OperatorTok{(}\NormalTok{a }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ c}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ curve\_thickness }\OperatorTok{=} \FloatTok{0.08}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ parabola\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ curve\_thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ parabola\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
    \CommentTok{// Combine (axes behind parabola)}
\NormalTok{    color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color}\OperatorTok{,}\NormalTok{ axis\_color}\OperatorTok{,} \BuiltInTok{max}\OperatorTok{(}\NormalTok{x\_axis\_mask}\OperatorTok{,}\NormalTok{ y\_axis\_mask}\OperatorTok{));}
\NormalTok{    color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color}\OperatorTok{,}\NormalTok{ parabola\_color}\OperatorTok{,}\NormalTok{ parabola\_mask}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Try different values of \(a\), \(b\), \(c\) and verify your grapher
works correctly! What happens with negative \(a\)? What about
\(b \neq 0\)? Make sure the axes and parabola remain visible for all
parameter values you try. If the parabola goes off-screen, you may need
to adjust your coordinate scaling in the setup.

\subsection{Optional \#1: Animated Curve
Family}\label{optional-1-animated-curve-family}

Create a shader that animates through a family of curves---watching how
a curve morphs continuously as parameters change is a beautiful way to
build geometric intuition!

\textbf{Easier options:}

\begin{itemize}
\item
  \textbf{Circle family}: Draw circles of varying radii:
  \(x^2 + y^2 = r^2\) where \(r = 1 + 0.5\sin(\text{iTime})\). Simple
  but mesmerizing!
\item
  \textbf{Rotating ellipse}:
  \((x\cos\theta + y\sin\theta)^2/a^2 + (-x\sin\theta + y\cos\theta)^2/b^2 = 1\)
  with \(\theta = \text{iTime}\). Watch an ellipse rotate continuously.
\end{itemize}

\textbf{More challenging options:}

\begin{itemize}
\item
  \textbf{Lissajous curves}: Use parametric equations
  \(x = A\sin(at + \delta)\), \(y = B\sin(bt)\) and animate \(\delta\)
  with \texttt{iTime}. To render a parametric curve implicitly, you'll
  need to be clever---one approach is to sample many points along the
  curve and draw circles at each point (we'll learn better techniques
  for this later).
\item
  \textbf{Cassini ovals}:
  \((x^2 + y^2)^2 - 2c^2(x^2 - y^2) = a^4 - c^4\). Fix \(c = 1\) and
  vary \(a\) with \texttt{iTime}. Watch the curve transition from two
  separate loops to a single figure-eight-like shape as \(a\) passes
  through the critical value \(a = c\)!
\item
  \textbf{Cubic curves}: Take \(y^2 = x^3 + ax + b\) and vary one
  parameter with \texttt{iTime}. The topology of the curve changes
  dramatically as you pass through singular values---this is the
  beginning of the theory of elliptic curves!
\end{itemize}

Use \texttt{iTime} creatively to create a compelling animation. The goal
is to explore how continuous parameter variation produces interesting
mathematical families. Bonus points if you can identify special
parameter values where the curve topology changes (these are the
singularities of the family)!

\subsection{Optional \#2: Beautiful Tiling
Pattern}\label{optional-2-beautiful-tiling-pattern}

Design an aesthetically pleasing tiling pattern using the \texttt{mod()}
technique. This is your chance to be creative and make something
visually striking!

\textbf{Requirements:}

\begin{itemize}
\tightlist
\item
  Create a non-trivial pattern within a fundamental domain (a single
  tile)
\item
  Use \texttt{mod()} to repeat it across the plane
\item
  The pattern should tile seamlessly---edges must match up so there are
  no visible discontinuities at tile boundaries
\end{itemize}

\textbf{Ideas to get you started:}

\begin{itemize}
\tightlist
\item
  \textbf{Geometric patterns}: Nested circles, polygons approximated by
  implicit curves, star shapes using angular coordinates
\item
  \textbf{Color gradients}: Use \texttt{cell\_id} to vary colors
  smoothly across tiles, creating large-scale gradient effects
  superimposed on the local pattern
\item
  \textbf{Multiple implicit curves}: Combine several curves within each
  tile using boolean operations (intersection, union, etc.)
\item
  \textbf{Symmetry}: Use \texttt{abs()} to create reflections within
  tiles---this is a simple way to get complex patterns with built-in
  symmetry
\item
  \textbf{Distance-based effects}: Make features pulse or fade based on
  \texttt{iTime} and their position in the grid---create waves
  propagating across the tiling
\end{itemize}

\textbf{Advanced challenge}: Can you create a pattern that has different
symmetries in different tiles? For example, alternate between rotational
and reflectional symmetry using the checkerboard \texttt{cell\_id}
technique. Or create a pattern where the colors vary smoothly across the
entire infinite tiling, creating a large-scale gradient effect that's
independent of the tile boundaries?

Think about Islamic geometric patterns, Escher tilings, or quasiperiodic
tilings (though true quasiperiodicity requires techniques beyond simple
\texttt{mod}---we'll see that on Day 3!). The goal is to create
something mathematically interesting and visually beautiful.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Looking Ahead}\label{looking-ahead}

Tomorrow we'll use these techniques to explore \textbf{complex dynamics}
and \textbf{geometric transformations}:

\begin{itemize}
\tightlist
\item
  \textbf{Mandelbrot and Julia sets}: Using the implicit curve technique
  to visualize the boundary of escape sets for complex iteration
\item
  \textbf{Circle inversions}: A geometric transformation that takes
  lines and circles to lines and circles, creating beautiful
  fractal-like patterns
\item
  \textbf{Apollonian gasket}: An infinite packing of circles constructed
  via repeated inversions---a stunning example of how simple geometric
  rules create intricate structures
\end{itemize}

The coordinate systems, distance fields, and implicit curve techniques
you've learned today will be the foundation for everything to come. Make
sure you're comfortable with:

\begin{itemize}
\tightlist
\item
  Setting up coordinates (the standard four-step transformation from
  \texttt{fragCoord} to centered, aspect-corrected \texttt{p})
\item
  Computing distances with \texttt{length()} and dot products
\item
  Using \texttt{mod()} for repetition and understanding the separation
  of global \texttt{cell\_id} and local \texttt{cell\_p}
\item
  Conditionally coloring based on mathematical expressions, using both
  explicit conditionals and smooth interpolation with
  \texttt{smoothstep}
\end{itemize}

If any of these feel shaky, now is the time to practice! Work through
the homework problems, experiment with variations, and make sure you
understand not just \emph{how} the code works but \emph{why} the
mathematics gives the visual results you see. Everything this week
builds on this foundation.

\bookmarksetup{startatroot}

\chapter{Day 2: Complex Dynamics and Iterated
Inversions}\label{day-2-complex-dynamics-and-iterated-inversions-1}

\section{Overview}\label{overview-1}

Today we explore the power of iteration to generate fractals. We'll
implement complex arithmetic in GLSL and use it to render the iconic
Mandelbrot set, then understand its companion, the Julia set. After
that, we shift gears to geometric iteration: circle inversion, a
beautiful conformal transformation that creates intricate nested
patterns when applied repeatedly. We'll see how the Apollonian gasket
emerges from iterated inversions of three mutually tangent circles.

By the end of today, you'll understand how simple iterative
processes---whether in the complex plane or through geometric
transformations---can generate infinitely detailed fractal structures
from just a few lines of code.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Roadmap for Today}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

We'll explore iteration in two different mathematical settings:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Complex dynamics}: Iterating holomorphic maps (Mandelbrot and
  Julia sets)
\item
  \textbf{Geometric dynamics}: Iterating circle inversions (Apollonian
  gasket)
\end{enumerate}

Both produce fractals through the same fundamental mechanism: simple
rules applied repeatedly reveal infinite complexity. The common thread
is \textbf{conformality}---both complex multiplication and circle
inversion preserve angles, and this angle preservation is key to the
beautiful structures we'll see.

Along the way, we'll learn shader programming techniques for organizing
data (structs), implementing mathematical operations efficiently, and
creating sophisticated coloring schemes.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Complex Numbers in GLSL}\label{complex-numbers-in-glsl}

\subsection{Representation}\label{representation}

A complex number \(z = a + bi\) can be represented as a 2D vector with
real part \(a\) and imaginary part \(b\). This is the natural
representation---complex numbers are the 2D plane with a particular
multiplication structure! In GLSL:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{);}  \CommentTok{// Represents a + bi}
\end{Highlighting}
\end{Shaded}

We'll consistently use the convention: \texttt{z.x} is the real part,
\texttt{z.y} is the imaginary part. You already know complex numbers
geometrically as rotations and scalings in the plane---here we're just
implementing that algebra in shader code.

\subsection{Complex Arithmetic}\label{complex-arithmetic}

Let \(z = a + bi\) and \(w = c + di\). We need to implement the basic
operations. Some of these are trivial, others require a bit more work:

\textbf{Addition:} \((a + bi) + (c + di) = (a + c) + (b + d)i\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cadd}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return}\NormalTok{ z }\OperatorTok{+}\NormalTok{ w}\OperatorTok{;}  \CommentTok{// Vector addition is sufficient!}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Addition of complex numbers is just vector addition---componentwise! You
might not even need this function since you can just write
\texttt{z\ +\ w} directly, but it's here for completeness.

\textbf{Multiplication:} \((a + bi)(c + di) = (ac - bd) + (ad + bc)i\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}  \CommentTok{// Real part: ac {-} bd}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}   \CommentTok{// Imaginary part: ad + bc}
    \OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This implements the familiar FOIL pattern with \(i^2 = -1\), giving us
that minus sign in the real part.

\textbf{Magnitude squared:} \(|z|^2 = a^2 + b^2\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}  \CommentTok{// z.x * z.x + z.y * z.y}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The squared magnitude is just the dot product with itself. This is
computationally cheaper than taking the square root, so when we just
need to check if \(|z| > 2\), we'll check if \(|z|^2 > 4\)
instead---millions of avoided square roots per frame!

\textbf{Magnitude:} \(|z| = \sqrt{a^2 + b^2}\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{cabs}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{z}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The magnitude is the Euclidean distance from the origin---exactly what
\texttt{length()} computes!

\textbf{Conjugate:} \(\overline{z} = a - bi\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cconj}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{z}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The conjugate flips the sign of the imaginary part---reflection across
the real axis.

\textbf{Division:}
\(\frac{a + bi}{c + di} = \frac{(a + bi)(c - di)}{c^2 + d^2}\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cdiv}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{w}\OperatorTok{,}\NormalTok{ w}\OperatorTok{);}  \CommentTok{// c² + d²}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
        \OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom}\OperatorTok{,}  \CommentTok{// Real part}
        \OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom   }\CommentTok{// Imaginary part}
    \OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Division multiplies numerator and denominator by the conjugate of \(w\)
to rationalize. The denominator becomes real (\(c^2 + d^2\)), and the
numerator becomes a new complex number we can compute directly.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Computational Efficiency in Complex Arithmetic}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

Notice we use \texttt{dot(z,\ z)} for magnitude squared---this is a
single GPU operation rather than component-wise multiplication and
addition. Similarly, \texttt{dot(w,\ w)} in the division routine. For
operations you'll compute millions of times per frame, these
micro-optimizations add up!

We're also using helper functions rather than inlining the formulas
everywhere. This makes the code much more readable (\texttt{cmul(z,\ z)}
vs \texttt{vec2(z.x*z.x\ -\ z.y*z.y,\ 2.0*z.x*z.y)}) and easier to
debug. If you make a sign error once in \texttt{cmul}, you fix it once.
If you inline the formula fifty times, you'll hunt for bugs forever!

\end{tcolorbox}

These are the building blocks we need for complex dynamics. Let's put
them to work!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{The Mandelbrot Set}\label{the-mandelbrot-set}

\subsection{Definition}\label{definition}

The Mandelbrot set \(\mathcal{M}\) is one of the most famous objects in
mathematics---and for good reason! It's defined as the set of complex
numbers \(c\) for which the iteration
\[z_{n+1} = z_n^2 + c, \quad z_0 = 0\] remains bounded as
\(n \to \infty\).

That's it! Just iterate this simple quadratic map starting from
\(z_0 = 0\), and see if the orbit escapes to infinity or stays bounded.
Points that stay bounded are in the set (traditionally colored black),
while points that escape are colored based on how quickly they escape.

\subsection{The Escape Radius Theorem}\label{the-escape-radius-theorem}

In practice, we can't iterate to infinity, so we need a criterion to
detect escape. Fortunately, there's a beautiful theorem that tells us
exactly when to stop:

\textbf{Theorem (Escape Radius).} If \(|z_n| > 2\) for any \(n\), then
\(|z_n| \to \infty\) as \(n \to \infty\).

This means: once the orbit leaves the disk of radius 2, it's definitely
escaping to infinity. Points that escape are not in the Mandelbrot set,
while points that remain bounded after many iterations are (likely) in
the set or very close to its boundary.

\textbf{Proof.} Suppose \(|z_n| > 2\) and write \(|z_n| = 2 + \epsilon\)
for some \(\epsilon > 0\). Then \begin{align*}
|z_{n+1}| &= |z_n^2 + c|\\
&\geq |z_n^2| - |c|\\
&= |z_n|^2 - |c|\\
&> |z_n|^2 - 2 \quad \text{(since $c$ is in or near $\mathcal{M}$, which fits in $|z| \leq 2$)}\\
&= (2 + \epsilon)^2 - 2\\
&= 4 + 4\epsilon + \epsilon^2 - 2\\
&= 2 + 4\epsilon + \epsilon^2\\
&> 2 + 2\epsilon = |z_n| + \epsilon
\end{align*}

So once \(|z_n| > 2\), we have \(|z_{n+1}| > |z_n| + \epsilon\), meaning
the magnitude grows by at least \(\epsilon\) each iteration. This linear
growth accelerates: if \(|z_{n+1}| > 2 + \epsilon\), then
\(|z_{n+2}| > |z_{n+1}| + \epsilon' > 2 + 2\epsilon\), and so on. More
carefully, the orbit actually grows exponentially (roughly like
\(|z_n| \sim 2^{2^n}\) for large \(n\)), but the key point is: it
definitely escapes to infinity.

\textbf{Computational Implication:} We only need to check if
\(|z_n| > 2\). The moment this happens, we can stop iterating---this
point will never be in the Mandelbrot set. This single theorem makes
efficient rendering possible!

\subsection{Historical Context}\label{historical-context}

The Mandelbrot set was discovered remarkably recently---1980! Benoit
Mandelbrot, working at IBM, was among the first to have access to
computers powerful enough to visualize iterative processes in the
complex plane. Before computers, studying these sets was nearly
impossible---you'd need to manually iterate complex arithmetic hundreds
of times for millions of points.

Interestingly, the mathematical theory predates visualization by over 60
years. Gaston Julia and Pierre Fatou studied iterative complex dynamics
extensively in 1918, but without computers, they could only reason about
these sets abstractly. They knew Julia sets existed and had deep
properties, but had never seen one! When Mandelbrot generated the first
images in 1980, it revolutionized the field---suddenly the intricate
structure of these sets was visible, creating an explosion of interest
in fractal geometry and complex dynamics.

The Mandelbrot set became iconic partly because it's so accessible:
anyone can understand the definition (iterate \(z \mapsto z^2 + c\)),
yet it produces infinitely intricate beauty. It also sparked broader
interest in fractals, chaos theory, and the idea that simple rules can
generate complex behavior---themes that would influence everything from
physics to economics to art.

\subsection{Basic Implementation}\label{basic-implementation}

Let's code it up:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup: center at origin, scale to show interesting region}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Scale to view the Mandelbrot set (roughly [{-}2.5, 1] × [{-}1.25, 1.25])}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.5}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}=} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Center on the interesting part}
    
    \CommentTok{// Mandelbrot iteration}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// z\_0 = 0}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \CommentTok{// Check if escaped}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}  \CommentTok{// |z| \textgreater{} 2, so |z|² \textgreater{} 4}
        
        \CommentTok{// z\_\{n+1\} = z\_n² + c}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Color based on iteration count}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}  \CommentTok{// Grayscale for now}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

That's the entire Mandelbrot set renderer! The coordinate scaling is
tuned to show the ``interesting part''---the main cardioid body and its
surrounding bulbs. The set extends roughly from \(-2.5\) to \(0.5\) on
the real axis, so we shift our coordinate system accordingly.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Why This Is Perfect for GPUs}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

Notice what's happening computationally: every pixel performs its own
independent calculation. There's no communication between pixels, no
shared data structures, no synchronization needed. Each pixel just
iterates its own complex number and decides when to stop.

This is \textbf{embarrassingly parallel}---the ideal workload for GPU
architecture. A modern GPU has thousands of small processors, and they
can all work on different pixels simultaneously. No pixel needs to wait
for another pixel's result. The entire screen (potentially millions of
pixels) is computed in parallel, which is why we can render the
Mandelbrot set at 60fps even with 100+ iterations per pixel.

Memory-wise, this is also very efficient: each pixel only needs to store
its current \(z\) value (two floats) and an iteration counter (one
integer). No arrays, no history, no complex data structures. The
computation is stateless---we only care about the current iterate, not
the full orbit.

This contrasts sharply with sequential CPU code, where you'd iterate
over pixels one at a time. Even with clever optimizations and SIMD
vectorization, you'd be orders of magnitude slower than a GPU shader
doing the same work.

\end{tcolorbox}

\subsection{Smooth Coloring}\label{smooth-coloring}

The grayscale rendering shows the structure of the set, but it has harsh
banding---sudden transitions between integer iteration counts create
visible stripes. We can do much better by interpolating between
iteration steps!

The key insight is that near escape, the orbit grows exponentially.
Specifically, once \(|z_n|\) is large, we have approximately
\(|z_{n+1}| \approx |z_n|^2\), which means
\(\log |z_{n+1}| \approx 2\log|z_n|\). Taking logs repeatedly, we get
\[\log\log|z_{n+1}| \approx \log(2\log|z_n|) = \log 2 + \log\log|z_n|\]

This suggests that \(\log\log|z_n|\) grows approximately linearly near
escape, increasing by \(\log 2\) per iteration. We can use this to
compute a fractional iteration count!

Here's the formula:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if}\OperatorTok{(}\NormalTok{iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Smooth iteration count (accounts for continuous escape)}
    \DataTypeTok{float}\NormalTok{ log\_zn }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{))} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}  \CommentTok{// = log|z\_n|}
    \DataTypeTok{float}\NormalTok{ nu }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\NormalTok{log\_zn }\OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{))} \OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ smooth\_iter }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{+} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ nu}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=}\NormalTok{ smooth\_iter }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
    \CommentTok{// Inside the set: black}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The variable \texttt{nu} represents how far we've progressed toward the
next integer iteration. When \(|z_n| = 2\) exactly (just hitting the
escape threshold), \(nu = 0\) and we get the integer iteration count.
When \(|z_n|\) is large (deep into escape), \(nu\) approaches 1.
Subtracting \texttt{nu} from \texttt{iter\ +\ 1} gives us a continuous,
smooth value that transitions gradually between iteration levels.

This eliminates banding entirely! The result is smooth, continuous color
gradients that look much more professional and reveal the fractal
structure more clearly.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Smooth Coloring as Anti-Aliasing}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

Smooth coloring is fundamentally an anti-aliasing technique. Without it,
nearby pixels with iteration counts of, say, 45 and 46 get completely
different colors---creating harsh edges. With smooth coloring, these
pixels get nearly identical colors (say, iteration 45.3 and 45.8),
producing a smooth gradient.

This is especially important at high zoom levels, where tiny changes in
position lead to different integer iteration counts. The smooth
interpolation ensures that small changes in \(c\) produce small changes
in color, which is exactly what we want for a continuous mathematical
function.

\end{tcolorbox}

\subsection{Color Palettes}\label{color-palettes}

Now we need a good color mapping function. A classic approach uses
cosines to create smooth, cyclic color palettes:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Create a cyclic color palette using cosines}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This uses a cosine-based palette function that creates smooth, cyclic
colors---perfect for the Mandelbrot set where we want colors to repeat
as we zoom in to the fractal boundary. The parameters control different
aspects:

\begin{itemize}
\tightlist
\item
  \texttt{a} and \texttt{b} control the range and center of the colors
  (here, mapping to \([0,1]\))
\item
  \texttt{c} controls the frequency of color cycling
\item
  \texttt{d} controls the phase offset, shifting the entire palette
\end{itemize}

Play with these parameters to get different color schemes! Try
\texttt{d\ =\ vec3(0.0,\ 0.1,\ 0.2)} for a blue-purple palette, or
\texttt{d\ =\ vec3(0.3,\ 0.2,\ 0.2)} for warmer tones. You can also
adjust \texttt{c} to make the colors cycle faster or slower through the
iteration range.

The beauty of this cosine approach is that it's smooth (continuous
derivatives), cyclic (no seams), and efficient (just a few trig
operations). Other approaches exist---hand-picked color stops with
interpolation, HSV color spaces, perceptually uniform LAB spaces---but
cosine palettes are a great default for fractal visualization.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Julia Sets}\label{julia-sets}

The Julia set is the natural companion to the Mandelbrot set, and
understanding their relationship is key to understanding complex
dynamics. Where the Mandelbrot set varies \(c\) and fixes \(z_0 = 0\),
the Julia set does the opposite: it fixes \(c\) and varies \(z_0\).

\subsection{Definition}\label{definition-1}

For a fixed complex number \(c\), the \textbf{filled Julia set} \(K_c\)
is the set of initial conditions \(z_0\) for which the iteration
\[z_{n+1} = z_n^2 + c\] remains bounded. The \textbf{Julia set} \(J_c\)
is the boundary of \(K_c\)---the set where the dynamics are chaotic,
neither definitely bounded nor definitely escaping.

Think about what this means: every point \(c\) in the complex plane has
an associated Julia set \(J_c\). The Mandelbrot set is telling us about
the topology of these Julia sets! Specifically:

\begin{itemize}
\tightlist
\item
  If \(c \in \mathcal{M}\) (inside the Mandelbrot set), then \(J_c\) is
  \textbf{connected}---a single, intricate curve
\item
  If \(c \notin \mathcal{M}\) (outside the Mandelbrot set), then \(J_c\)
  is \textbf{totally disconnected}---a Cantor-like dust of points
\end{itemize}

This is one of the most beautiful connections in mathematics: the
Mandelbrot set is a map of parameter space, showing which values of
\(c\) produce connected Julia sets. Julia and Fatou proved this in 1918
without ever seeing a picture---they understood these sets purely
abstractly!

\subsection{Implementation as
Homework}\label{implementation-as-homework}

You'll implement Julia set rendering in the homework. The algorithm is
nearly identical to the Mandelbrot set---just swap what's fixed and what
varies! Instead of setting \texttt{z\ =\ vec2(0.0)} and varying
\texttt{c} across pixels, you'll set \texttt{c} to a fixed value and let
\texttt{z} be the pixel coordinate.

The key changes: 1. Fix \texttt{c} to an interesting value (we'll give
suggestions) 2. Initialize \texttt{z} from the pixel position (that's
your \(z_0\)) 3. Iterate \(z \mapsto z^2 + c\) exactly as before 4. Use
the same escape criterion and coloring

This will give you a Julia set! Try different values of \(c\) to see how
the topology changes. You can make \texttt{c} depend on time
(\texttt{iTime}) for animation, or on mouse position (\texttt{iMouse})
for interactive exploration.

\textbf{Some interesting values to try:} - \(c = -0.7 + 0.27015i\) ---
classic Julia set, intricate tendrils - \(c = -0.4 + 0.6i\) ---
dendrite-like fractal trees - \(c = 0.285 + 0.01i\) --- beautiful spiral
patterns - \(c = -0.8 + 0.156i\) --- highly filamentary -
\(c = -0.70176 - 0.3842i\) --- ``San Marco dragon''

Values inside the Mandelbrot set give connected Julia sets (single
curves), while values outside give disconnected Julia sets (dust). The
most interesting Julia sets often come from values right near the
boundary of \(\mathcal{M}\)---this is where the transition between
connected and disconnected happens!

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Exploring Parameter Space}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

When you implement Julia sets, try this: tie \(c\) to your mouse
position. Move the mouse around and watch the Julia set morph in real
time! This is an incredibly powerful way to build intuition for how the
parameter \(c\) affects the dynamics.

You'll notice that small changes in \(c\) can produce dramatic changes
in the Julia set topology---this is the sensitive dependence on
parameters that makes complex dynamics so rich. Near the boundary of the
Mandelbrot set, tiny movements create entirely different structures.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Interlude: From Complex to Geometric
Dynamics}\label{interlude-from-complex-to-geometric-dynamics}

We've been iterating algebraic functions in the complex plane:
\(z \mapsto z^2 + c\). Now we shift to iterating geometric
transformations of the plane itself: circle inversion. The mathematical
frameworks are different---holomorphic dynamics versus conformal
geometry---but they share fundamental similarities.

Both complex multiplication and circle inversion are \textbf{conformal
maps}: they preserve angles between curves. In complex dynamics, this
comes from the Cauchy-Riemann equations and the geometric interpretation
of multiplication as rotation and scaling. In circle inversion, it's a
theorem we'll state shortly. This angle preservation is crucial---it's
what makes the fractal structures we generate geometrically coherent and
visually beautiful.

There's also a deep connection we'll explore tomorrow: circle inversion
is actually an isometry of hyperbolic space! The inversions we're about
to do are the same transformations that generate Kleinian groups and
tessellate the hyperbolic plane. So in some sense, we're already working
in non-Euclidean geometry without realizing it. Tomorrow we'll make this
explicit when we explore hyperbolic tilings.

For now, let's learn circle inversion and use it to build the Apollonian
gasket---a fractal structure every bit as intricate as the Mandelbrot
set, but generated through pure Euclidean geometry.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Circle Inversion}\label{circle-inversion}

Circle inversion is a beautiful geometric operation that will be the
foundation for everything we do with geometric dynamics. It's a
transformation of the plane that turns inside into outside, maps circles
to circles (or lines), and preserves angles---making it a powerful tool
for creating fractal patterns.

\subsection{Mathematical Definition}\label{mathematical-definition}

Circle inversion is a transformation with respect to a circle. For a
circle of radius \(R\) centered at a point \(\mathbf{c}\), inversion
maps a point \(\mathbf{p} \neq \mathbf{c}\) to:
\[\text{inv}(\mathbf{p}) = \mathbf{c} + R^2 \frac{\mathbf{p} - \mathbf{c}}{|\mathbf{p} - \mathbf{c}|^2}\]

The vector \(\mathbf{p} - \mathbf{c}\) points from the center to
\(\mathbf{p}\). We normalize this direction by dividing by its squared
length, then scale by \(R^2\), and finally translate back by the center.
Geometrically:

\begin{itemize}
\tightlist
\item
  Points inside the circle map to points outside (and vice versa)
\item
  Points on the circle are fixed (they map to themselves)
\item
  The closer you are to the center, the farther away you go
\item
  The center itself maps to infinity, and infinity maps to the center
\end{itemize}

Here's another way to think about it: draw a ray from the center through
\(\mathbf{p}\). The inversion of \(\mathbf{p}\) is the unique point on
this ray such that the product of distances from the center is \(R^2\).
If \(\mathbf{p}\) is at distance \(r\) from the center, its image is at
distance \(R^2/r\).

\subsection{Key Properties}\label{key-properties}

Circle inversion has remarkable geometric properties. These aren't
obvious from the formula, but they're all classical theorems:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Lines through the center} remain lines through the center
  (they're ``flipped inside out'' along the ray)
\item
  \textbf{Lines not through the center} become circles through the
  center
\item
  \textbf{Circles through the center} become lines (not through the
  center)
\item
  \textbf{Circles not through the center} generally remain circles, but
  with different center and radius
\item
  \textbf{Angles are preserved} (conformal property)
\end{enumerate}

The angle preservation is the deepest property. It's not at all obvious
from the formula, but it can be proved using the chain rule and careful
calculation. The key insight is that inversion is locally similar to a
complex conjugation-like operation, which preserves angles.

\textbf{Why These Properties Matter for Iteration:} When we iterate
inversions through multiple circles, these properties ensure that the
geometry remains coherent. Circles stay circles (or become lines), and
the angles between curves are preserved. This means repeated inversion
creates intricate but geometrically regular patterns---the hallmark of
fractals generated by conformal maps.

Another key fact: inversion is \textbf{involutive}---applying it twice
returns to the original point (assuming the point isn't the center).
Mathematically, \(\text{inv}(\text{inv}(\mathbf{p})) = \mathbf{p}\).
This makes inversion a geometric reflection of sorts, which will be
important when we think about symmetry groups tomorrow.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Historical Context: Circle Inversion}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

Circle inversion has ancient roots---Apollonius of Perga studied related
problems involving tangent circles around 200 BCE. But the modern theory
of inversion as a geometric transformation developed in the 19th century
as part of projective and non-Euclidean geometry.

A key insight was recognizing that circle inversion is related to
stereographic projection: if you place a sphere on the plane, inversion
in a circle corresponds to reflection through the sphere! This
connection links circle inversion to spherical geometry and ultimately
to hyperbolic geometry.

In the late 19th and early 20th centuries, mathematicians realized that
groups of circle inversions (Kleinian groups) could tessellate
hyperbolic space and create fractal limit sets. This anticipates the
fractal geometry revolution of the 1970s-80s, though the connection
wasn't fully appreciated until computers made visualization possible.

\end{tcolorbox}

\subsection{Implementation}\label{implementation-1}

The formula translates directly to GLSL:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{invertCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}  \CommentTok{// squared distance from center}
    
    \CommentTok{// Handle center (would be division by zero)}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{r2 }\OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1000.0}\OperatorTok{);}  \CommentTok{// Map to "infinity"}
    
    \KeywordTok{return}\NormalTok{ center }\OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ diff }\OperatorTok{/}\NormalTok{ r2}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The only tricky part is handling the center point, which mathematically
maps to infinity. We approximate this by mapping to a very large
value---far enough away that it's effectively off-screen. The threshold
\texttt{0.0001} is small enough to catch points numerically close to the
center but large enough to avoid precision issues.

Computationally, circle inversion is very cheap: just one dot product, a
division, a multiplication, and some vector operations. This efficiency
is important because we'll be doing many inversions per pixel when
generating fractals!

\subsection{Visualizing Circle
Inversion}\label{visualizing-circle-inversion}

Let's see what happens when we apply inversion to a grid. This is one of
the best ways to understand the transformation visually:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Standard coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Inversion circle}
    \DataTypeTok{vec2}\NormalTok{ circleCenter }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ circleRadius }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    
    \CommentTok{// Apply inversion}
    \DataTypeTok{vec2}\NormalTok{ p\_inverted }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ circleCenter}\OperatorTok{,}\NormalTok{ circleRadius}\OperatorTok{);}
    
    \CommentTok{// Draw a grid in the inverted space}
    \DataTypeTok{vec2}\NormalTok{ grid }\OperatorTok{=} \BuiltInTok{fract}\OperatorTok{(}\NormalTok{p\_inverted }\OperatorTok{*} \FloatTok{2.0}\OperatorTok{);}  \CommentTok{// Create repeating cells}
    \DataTypeTok{float}\NormalTok{ gridLine }\OperatorTok{=} \BuiltInTok{step}\OperatorTok{(}\FloatTok{0.95}\OperatorTok{,} \BuiltInTok{max}\OperatorTok{(}\NormalTok{grid}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ grid}\OperatorTok{.}\FunctionTok{y}\OperatorTok{));}  \CommentTok{// Draw grid lines}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{gridLine}\OperatorTok{);}
    
    \CommentTok{// Draw the inversion circle itself (for reference)}
    \DataTypeTok{float}\NormalTok{ circDist }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ circleRadius}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{circDist }\OperatorTok{\textless{}} \FloatTok{0.05}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You'll see straight grid lines transform into beautiful circular arcs!
Lines farther from the inversion circle get bent more dramatically,
while lines near the circle stay relatively straight. Horizontal and
vertical lines through the center remain horizontal and vertical (but
swap inside/outside), while other lines become circles.

This visualization really helps build intuition. You can see: - The
circle itself (in red) is unchanged---points on it are fixed - The grid
inside the circle maps to a grid outside (and vice versa) - Lines become
curves, but the angles where they intersect are preserved - The pattern
has a pole singularity at the center (infinite distortion)

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Exploring Circle Inversion}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

Here are some experiments to try:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Multiple circles}: Create a grid of circles using
  \texttt{mod()} (like we did on Day 1) and invert through each cell's
  circle independently. You'll see beautiful overlapping patterns!
\item
  \textbf{Animated radius}: Make
  \texttt{circleRadius\ =\ 1.0\ +\ 0.5\ *\ sin(iTime)} to watch the grid
  breathe in and out. This helps you see how the inversion depends on
  the circle's size.
\item
  \textbf{Different patterns}: Instead of a grid, try drawing circles or
  other shapes in the inverted space. Circles become circles (or lines),
  creating intricate nested patterns.
\item
  \textbf{Off-center inversion}: Move the inversion circle away from the
  origin. Watch how the asymmetry creates even more complex distortions.
\end{enumerate}

Each of these will give you geometric intuition for how inversion
behaves, which will be crucial when we iterate multiple inversions!

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Structs in GLSL}\label{structs-in-glsl}

Before we build the Apollonian gasket, we need to talk about organizing
our data. We're about to deal with multiple circles, and passing around
\texttt{center1}, \texttt{radius1}, \texttt{center2}, \texttt{radius2},
etc. gets unwieldy fast. GLSL provides \textbf{structs} (just like in C)
for grouping related data together.

\subsection{Defining and Using
Structs}\label{defining-and-using-structs}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Circle }\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Now \texttt{Circle} is a type we can use just like \texttt{vec2} or
\texttt{float}. Creating and using structs is straightforward:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Declare and initialize}
\NormalTok{Circle c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),} \FloatTok{1.0}\OperatorTok{);}

\CommentTok{// Or declare first, set later}
\NormalTok{Circle c2}\OperatorTok{;}
\NormalTok{c2}\OperatorTok{.}\FunctionTok{center} \OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
\NormalTok{c2}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{=} \FloatTok{0.75}\OperatorTok{;}

\CommentTok{// Pass to functions}
\DataTypeTok{vec2} \FunctionTok{invertThroughCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle circ}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ circ}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ circ}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This makes the code dramatically more readable. Compare:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Without structs {-} messy!}
\DataTypeTok{vec2} \FunctionTok{iterate}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ c1\_cen}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ c1\_rad}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ c2\_cen}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ c2\_rad}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ c3\_cen}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ c3\_rad}\OperatorTok{);}

\CommentTok{// With structs {-} clean!}
\DataTypeTok{vec2} \FunctionTok{iterate}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c1}\OperatorTok{,}\NormalTok{ Circle c2}\OperatorTok{,}\NormalTok{ Circle c3}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

For the Apollonian gasket, we'll have three circles we need to track and
pass around. Structs make this much more manageable and semantically
clear---we're working with circles as geometric objects, not just pairs
of vectors and floats.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{The Apollonian Gasket}\label{the-apollonian-gasket}

Now for the main event! The Apollonian gasket is a fractal generated by
iterating circle inversions through three mutually tangent circles. It's
named after Apollonius of Perga, who studied the problem of finding
circles tangent to three given circles around 200 BCE, though the
fractal interpretation is much more modern.

\subsection{Descartes Circle Theorem}\label{descartes-circle-theorem}

To understand the Apollonian gasket, we need to know about a beautiful
theorem: \textbf{Descartes Circle Theorem} (1643).

Given four mutually tangent circles (each tangent to the other three),
let their curvatures be \(k_1, k_2, k_3, k_4\) where curvature
\(k = 1/r\) (positive for external tangency, negative for internal).
Then: \[(k_1 + k_2 + k_3 + k_4)^2 = 2(k_1^2 + k_2^2 + k_3^2 + k_4^2)\]

This can be rearranged to solve for the fourth curvature given three:
\[k_4 = k_1 + k_2 + k_3 \pm 2\sqrt{k_1 k_2 + k_2 k_3 + k_3 k_1}\]

The \(\pm\) gives two solutions---the two circles tangent to the
original three (one inside the curvilinear triangle they form, one
outside).

What makes this magical for fractals: if you start with three mutually
tangent circles with integer curvatures, then \textbf{all} circles in
the Apollonian gasket have integer curvatures! This is the Apollonian
gasket's connection to number theory---it's a fractal made entirely of
circles with rational radii.

We won't use this formula directly in our shader (we'll set up circles
geometrically), but it explains why certain configurations are special
and why the patterns are so regular despite infinite nesting.

\subsection{Setup: Three Mutually Tangent
Circles}\label{setup-three-mutually-tangent-circles}

We start with three circles that are all tangent to each other---meaning
each pair touches at exactly one point. For this to work, the distance
between any two circle centers must be exactly twice the radius (so they
touch edge-to-edge). The three centers form an equilateral triangle, and
we'll position this triangle symmetrically at the origin:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{setupApollonianCircles}\OperatorTok{(}\DataTypeTok{out}\NormalTok{ Circle c1}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c2}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c3}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle outer}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Radius of each inner circle}
    \CommentTok{// For three circles to be mutually tangent: distance between centers = 2r}
    \CommentTok{// Centers form equilateral triangle with circumradius = 2r/sqrt(3)}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ r }\OperatorTok{/} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{);}  \CommentTok{// ≈ 0.577 for r = 0.5}
    
    \CommentTok{// Three inner circles}
\NormalTok{    c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ d}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}  \CommentTok{// 0.866 ≈ sqrt(3)/2}
\NormalTok{    c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{d }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
    
    \CommentTok{// Outer circle tangent to all three, centered at origin}
    \DataTypeTok{float}\NormalTok{ R }\OperatorTok{=}\NormalTok{ d }\OperatorTok{+}\NormalTok{ r}\OperatorTok{;}  \CommentTok{// ≈ 1.077 for r = 0.5}
\NormalTok{    outer }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ R}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

With \(r = 0.5\), the circumradius \(d \approx 0.577\), and the outer
circle has radius \(R = d + r \approx 1.077\). All four circles are
mutually tangent---each inner circle touches the other two inner circles
and the outer circle.

This is just one possible configuration! You could use different radii
(related by Descartes' theorem), different arrangements, or even
animated circles. The key is that they start mutually tangent---this
ensures the iteration creates a proper Apollonian packing.

\subsection{The Iteration Algorithm}\label{the-iteration-algorithm}

The algorithm is beautifully simple:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Start with a point \(p\)
\item
  Check which circles contain \(p\)
\item
  If \(p\) is inside a circle, invert through that circle
\item
  Repeat until \(p\) is outside all circles or we hit max iterations
\item
  Color based on iteration behavior
\end{enumerate}

Here's the implementation:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{iterateApollonian}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c1}\OperatorTok{,}\NormalTok{ Circle c2}\OperatorTok{,}\NormalTok{ Circle c3}\OperatorTok{,}\NormalTok{ Circle outer}\OperatorTok{,}
                       \DataTypeTok{int}\NormalTok{ maxIter}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{int}\NormalTok{ finalIter}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{int}\NormalTok{ lastCircle}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ maxIter}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{bool}\NormalTok{ moved }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
        
        \CommentTok{// Check the three inner circles}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}} 
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        \CommentTok{// Check if outside the outer circle}
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textgreater{}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        
        \CommentTok{// If we didn\textquotesingle{}t move, we\textquotesingle{}re in the gaps {-} done!}
        \KeywordTok{if}\OperatorTok{(!}\NormalTok{moved}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            finalIter }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
            \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
    
\NormalTok{    finalIter }\OperatorTok{=}\NormalTok{ maxIter}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

We also track which circle we last inverted through
(\texttt{lastCircle}) and how many iterations we performed
(\texttt{finalIter}). These will be useful for coloring!

\textbf{Why This Creates a Fractal:} Each time we invert through a
circle, we ``push'' the point away from that circle's center. But
because the four circles are mutually tangent, pushing away from one
circle might push us into another circle, triggering another inversion.
The interplay between these four inversions (three inner circles plus
the outer circle) creates a complex orbit.

Points in the ``gaps'' between the inner circles (the curvilinear
triangles) escape quickly---they're inside the outer circle but not
inside any inner circle, so no inversion happens. But points near the
tangency points get bounced back and forth between circles many times
before escaping. And at the actual tangency points (where circles
touch), the orbit never escapes---these are fixed points or periodic
orbits of the iterated inversions.

The fractal structure emerges because these dynamics are self-similar:
zooming in near any tangency point reveals the same pattern of nested
circles and gaps. This self-similarity is a direct consequence of the
conformal nature of circle inversion---the transformation preserves
angles, so local geometry looks the same at all scales.

\subsection{Coloring Strategies}\label{coloring-strategies}

There are several interesting ways to color the Apollonian gasket:

\textbf{By iteration count} (like the Mandelbrot set):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{finalIter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{maxIter}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This shows the ``depth'' of the orbit---points that escape quickly are
colored differently from points that bounce around many times.

\textbf{By last circle hit}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3}\NormalTok{ colors}\OperatorTok{[}\DecValTok{4}\OperatorTok{]} \OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{[}\DecValTok{4}\OperatorTok{](}
    \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}  \CommentTok{// Circle 1: red}
    \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}  \CommentTok{// Circle 2: green}
    \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{),}  \CommentTok{// Circle 3: blue}
    \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)}   \CommentTok{// Outer circle: yellow}
\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=}\NormalTok{ colors}\OperatorTok{[}\NormalTok{lastCircle}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

This shows the basin of attraction---which circle's ``influence'' each
point ultimately fell into. Yellow regions show points that escaped
through the outer circle.

\textbf{By final distance from circles}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d1}\OperatorTok{,} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d2}\OperatorTok{,}\NormalTok{ d3}\OperatorTok{));}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\BuiltInTok{smoothstep}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.05}\OperatorTok{,}\NormalTok{ d}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

This highlights the circle boundaries themselves, making the geometric
structure more apparent.

Each coloring reveals different aspects of the fractal. Try combining
them---for example, color by iteration count but modulate brightness by
distance to circles.

\subsection{Putting It All Together}\label{putting-it-all-together}

Here's a complete Apollonian gasket renderer:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Setup the four circles}
\NormalTok{    Circle c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{;}
    \FunctionTok{setupApollonianCircles}\OperatorTok{(}\NormalTok{c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{);}
    
    \CommentTok{// Iterate}
    \DataTypeTok{int}\NormalTok{ maxIter }\OperatorTok{=} \DecValTok{50}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ finalIter}\OperatorTok{,}\NormalTok{ lastCircle}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ final\_p }\OperatorTok{=} \FunctionTok{iterateApollonian}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{,}\NormalTok{ maxIter}\OperatorTok{,}\NormalTok{ finalIter}\OperatorTok{,}\NormalTok{ lastCircle}\OperatorTok{);}
    
    \CommentTok{// Color by iteration count with palette}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{finalIter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{maxIter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    
    \CommentTok{// Draw all four circles for reference}
    \DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d\_outer }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{min}\OperatorTok{(}\NormalTok{d1}\OperatorTok{,} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d2}\OperatorTok{,}\NormalTok{ d3}\OperatorTok{)),}\NormalTok{ d\_outer}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// White circle outlines}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see a beautiful nested pattern of circles! The fractal
structure is immediately apparent---circles within circles within
circles, filling every gap with smaller circles.

Zoom in (by scaling \texttt{p} differently in the coordinate setup) to
see the self-similarity. No matter how far you zoom, you'll keep finding
the same pattern repeated at smaller scales. This is true
fractality---infinite detail that never runs out.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Computational Efficiency}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

Despite the complexity of the output, this algorithm is remarkably
efficient. Each iteration just checks three distances (cheap) and
potentially does one inversion (also cheap---just a few arithmetic
operations). With 50 iterations, we're doing maybe 150 distance checks
and 50 inversions per pixel.

Compare this to raymarching (Day 4), where we might do hundreds of
distance evaluations per pixel! The Apollonian gasket is very
GPU-friendly.

The key is that we terminate early---most pixels escape in just a few
iterations. Only points near the fractal boundary require many
iterations. This is similar to the Mandelbrot set: most of the
computational work focuses on the interesting regions (the boundary),
while simple regions (deep inside or far outside) are handled quickly.

\end{tcolorbox}

\subsection{Historical Context and
Connections}\label{historical-context-and-connections}

The Apollonian gasket connects several mathematical threads across
millennia:

\textbf{Ancient roots:} Apollonius of Perga (\textasciitilde200 BCE)
studied the problem of constructing circles tangent to three given
circles (the ``Problem of Apollonius''). He found geometric
constructions but couldn't have imagined the infinite fractal structure
we're visualizing.

\textbf{Renaissance mathematics:} René Descartes (1643) discovered the
circle theorem bearing his name, giving an algebraic formula for tangent
circles. This turned Apollonius's geometric problem into arithmetic.

\textbf{19th century:} The connection to projective geometry and circle
inversions was developed. Mathematicians realized that packing problems
could be studied through group theory---the inversions form a discrete
subgroup of the group of Möbius transformations.

\textbf{20th century:} With computers, the fractal nature became
visible. The Apollonian gasket was recognized as a limit set of a
Kleinian group---a group of isometries of hyperbolic space. This
connects to tomorrow's material: the inversions we're doing are actually
hyperbolic isometries! In the Poincaré disk model (which we'll see
tomorrow), these inversions are reflections through hyperbolic
geodesics.

The gasket also has connections to number theory: if the initial circles
have integer curvatures, all circles in the packing do too (by
Descartes' theorem). This has led to deep questions about the
distribution of integers in these packings, which remain active research
areas today.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Summary}\label{summary-1}

Today we've explored two powerful iterative processes that generate
fractals:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Complex dynamics}: The Mandelbrot and Julia sets emerge from
  iterating \(z \mapsto z^2 + c\)

  \begin{itemize}
  \tightlist
  \item
    Implemented complex arithmetic in GLSL efficiently
  \item
    Learned escape-time algorithms and the crucial escape radius theorem
  \item
    Developed smooth coloring techniques for anti-aliased rendering
  \item
    Understood the parameter space (Mandelbrot) vs dynamical space
    (Julia) distinction
  \item
    Saw how 1980s computational power revolutionized a 1918 theory
  \end{itemize}
\item
  \textbf{Geometric dynamics}: The Apollonian gasket emerges from
  iterating circle inversions

  \begin{itemize}
  \tightlist
  \item
    Circle inversion as a conformal transformation preserving angles
  \item
    Used structs to organize geometric data cleanly
  \item
    Applied Descartes Circle Theorem to understand tangent circle
    configurations
  \item
    Iterated inversions through three circles to create fractal patterns
  \item
    Connected ancient Greek geometry to modern fractal theory
  \end{itemize}
\end{enumerate}

Both processes show how incredibly simple rules---a quadratic map, a
geometric transformation---generate infinite complexity through
iteration. The key in both cases is \textbf{conformality}:
angle-preserving maps create geometrically coherent fractals. This is
one of the core insights of fractal geometry and dynamical systems.

The computational perspective is also crucial: both algorithms are
embarrassingly parallel, making them perfect for GPU rendering. Each
pixel's calculation is independent, and we can terminate early when
orbits escape. The result is real-time rendering of infinitely detailed
mathematical objects.

Tomorrow we'll push geometric iteration further, moving from Euclidean
to hyperbolic geometry. The circle inversions we've learned today are
actually hyperbolic isometries---transformations that preserve distances
in hyperbolic space. We'll explore the upper half-plane and Poincaré
disk models, create \((2,3,7)\) and \((2,3,\infty)\) triangle tilings,
and see how the same algorithmic ideas (iterated geometric
transformations) work in non-Euclidean geometry. The results will be
even more intricate because hyperbolic space has ``more room'' than
Euclidean space---triangles can have angle sums less than \(\pi\),
allowing denser tilings and more complex fractal structures.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Homework}\label{homework-7}

\subsection{Required: Julia Set
Explorer}\label{required-julia-set-explorer}

Implement a Julia set renderer starting from the Mandelbrot code. The
algorithm is nearly identical---you just need to swap what's fixed and
what varies!

\textbf{Requirements:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Start from the Mandelbrot implementation
\item
  Fix \texttt{c} to a constant value (see suggestions below)
\item
  Initialize \texttt{z} from the pixel position instead of zero
\item
  Iterate \(z_{n+1} = z_n^2 + c\) exactly as before
\item
  Use the same escape criterion and coloring
\end{enumerate}

\textbf{Suggested structure:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.0}\OperatorTok{;}  \CommentTok{// Scale for Julia set viewing}
    
    \CommentTok{// Fix c to an interesting value}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.27015}\OperatorTok{);}  \CommentTok{// Classic Julia set}
    
    \CommentTok{// Initialize z from pixel position (this is the key change!)}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}  \CommentTok{// z\_0 = pixel position}
    
    \CommentTok{// [Rest of iteration exactly like Mandelbrot]}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Interesting parameters to try:} - \texttt{vec2(-0.7,\ 0.27015)}
--- classic Julia set, intricate tendrils - \texttt{vec2(-0.4,\ 0.6)}
--- dendrite-like fractal trees\\
- \texttt{vec2(0.285,\ 0.01)} --- beautiful spiral patterns -
\texttt{vec2(-0.8,\ 0.156)} --- highly filamentary structure -
\texttt{vec2(-0.70176,\ -0.3842)} --- ``San Marco dragon'' -
\texttt{vec2(-0.835,\ -0.2321)} --- another classic -
\texttt{vec2(-0.7269,\ 0.1889)} --- ``Douady's rabbit'' (famous example)

\textbf{Extension Options (pick one or both):}

\textbf{Option A: Animated Parameter Space}

Make \(c\) depend on time to watch the Julia set morph:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ angle }\OperatorTok{=}\NormalTok{ iTime }\OperatorTok{*} \FloatTok{0.3}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \FloatTok{0.7885}\OperatorTok{;}  \CommentTok{// Distance from origin in parameter space}
\DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{radius }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\NormalTok{angle}\OperatorTok{),}\NormalTok{ radius }\OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{angle}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Watch how the Julia set changes topology as you trace a circle in the
complex plane! You'll see it transition from connected to disconnected,
develop tendrils, and create organic shapes.

\textbf{Option B: Mouse-Controlled Exploration}

Tie \(c\) to mouse position for interactive exploration:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ mouse\_uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{mouse\_uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
\DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=}\NormalTok{ mouse\_uv }\OperatorTok{*} \FloatTok{3.0}\OperatorTok{;}  \CommentTok{// Scale to cover interesting parameter range}
\end{Highlighting}
\end{Shaded}

Now you can explore parameter space by moving the mouse! This really
helps build intuition for how \(c\) affects the Julia set. Try finding
the boundary of the Mandelbrot set---parameters right at the edge
produce the most intricate Julia sets.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Understanding Connected vs Disconnected}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

As you explore parameter space, pay attention to whether the Julia set
appears as a single connected structure or as disconnected dust. Values
of \(c\) inside the Mandelbrot set give connected Julia sets, while
values outside give disconnected ones. The most beautiful Julia sets
often come from values right near the boundary of \(\mathcal{M}\)!

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Optional \#1: Grid of Julia
Sets}\label{optional-1-grid-of-julia-sets}

Create a grid where each cell shows the Julia set for that value of
\(c\), revealing the Mandelbrot set as an emergent pattern!

\textbf{The idea:} The Mandelbrot set is a map of Julia set topology. If
we draw a grid of Julia sets for different values of \(c\), we should
see the Mandelbrot set emerge in the overall pattern---cells with
connected Julia sets (solid regions) correspond to points in
\(\mathcal{M}\), while cells with disconnected Julia sets (dust) are
outside.

\textbf{Implementation strategy:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Divide screen into grid cells}
    \DataTypeTok{float}\NormalTok{ grid\_size }\OperatorTok{=} \FloatTok{8.0}\OperatorTok{;}  \CommentTok{// 8×8 grid of Julia sets}
    \DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{fract}\OperatorTok{(}\NormalTok{p }\OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    cell\_p }\OperatorTok{*=} \FloatTok{4.0}\OperatorTok{;}  \CommentTok{// Local coordinates within cell}
    
    \CommentTok{// Map cell\_id to parameter c}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \OperatorTok{(}\NormalTok{cell\_id }\OperatorTok{/}\NormalTok{ grid\_size}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0} \OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{2.5}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}
\NormalTok{    c}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}=} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Center on interesting region of Mandelbrot set}
    
    \CommentTok{// Run Julia set iteration with z = cell\_p, fixed c}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ cell\_p}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{50}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Color}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    
    \CommentTok{// Optional: draw grid lines to separate cells}
    \DataTypeTok{vec2}\NormalTok{ grid\_edge }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{fract}\OperatorTok{(}\NormalTok{p }\OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{max}\OperatorTok{(}\NormalTok{grid\_edge}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ grid\_edge}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{0.48}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see a grid of tiny Julia sets! If you look carefully at the
overall pattern, you'll notice it resembles the Mandelbrot set---cells
with connected Julia sets (solid colored regions) correspond to points
inside \(\mathcal{M}\), while cells with disconnected Julia sets (fine
dust patterns) are outside.

This is one of the most beautiful visualizations in complex
dynamics---the Mandelbrot set literally encodes the topology of all
Julia sets!

\textbf{Variations to try:} - Adjust \texttt{grid\_size} (larger for
more detail, smaller for clearer overview) - Change the parameter space
region being sampled - Color cells based on whether the Julia set
appears connected (black) or disconnected (white)---you'll get a
pixelated approximation of the Mandelbrot set!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Optional \#2: Other Iterated
Inversions}\label{optional-2-other-iterated-inversions}

Explore variations on the Apollonian gasket theme! The key is setting up
circles in interesting configurations and iterating inversions.

\textbf{Different circle arrangements:}

\textbf{Four circles in a square:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{setupSquareCircles}\OperatorTok{(}\DataTypeTok{out}\NormalTok{ Circle c1}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c2}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c3}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c4}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FloatTok{1.5}\OperatorTok{;}  \CommentTok{// Distance from center}
\NormalTok{    c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{d}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ d}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{d}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    c4 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{d}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Modify the iteration loop to check four circles instead of three!

\textbf{Nested circles:}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// One large circle containing several smaller ones}
\NormalTok{c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}  \CommentTok{// Large outer circle}
\NormalTok{c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),} \FloatTok{0.4}\OperatorTok{);}  \CommentTok{// Small inner circles}
\NormalTok{c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),} \FloatTok{0.4}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Animated radii:}

Make the circles pulse:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c1}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.2} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{);}
\NormalTok{c2}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.2} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{+} \FloatTok{2.0} \OperatorTok{*} \FloatTok{3.14159} \OperatorTok{/} \FloatTok{3.0}\OperatorTok{);}
\NormalTok{c3}\OperatorTok{.}\FunctionTok{radius} \OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.2} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{+} \FloatTok{4.0} \OperatorTok{*} \FloatTok{3.14159} \OperatorTok{/} \FloatTok{3.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Watch the fractal breathe!

\textbf{Alternating inversion patterns:}

Instead of inverting through whichever circle contains the point, try a
fixed cycling pattern:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Cycle through circles in order}
\DataTypeTok{int}\NormalTok{ circle\_index }\OperatorTok{=}\NormalTok{ i }\OperatorTok{\%} \DecValTok{3}\OperatorTok{;}
\KeywordTok{if}\OperatorTok{(}\NormalTok{circle\_index }\OperatorTok{==} \DecValTok{0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\OperatorTok{\}} \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\NormalTok{circle\_index }\OperatorTok{==} \DecValTok{1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{    p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This creates very different patterns---more regular and less
space-filling than the gasket, but with interesting self-similarity.

\textbf{Challenge problems:} - Can you create a configuration that tiles
the plane with circular patterns? - What about spiraling structures? -
Can you make a fractal that's asymmetric (not rotationally symmetric)? -
Try combining inversion with other transformations (rotation, scaling)

The key is experimentation---try different setups and see what emerges!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Looking Ahead}\label{looking-ahead-1}

Tomorrow we continue with geometric transformations, but move from
Euclidean to \textbf{hyperbolic geometry}. The circle inversions you've
learned today are actually hyperbolic isometries---transformations that
preserve distances in hyperbolic space!

We'll explore: - \textbf{Multiple models} of the hyperbolic plane (upper
half-plane, Poincaré disk) - \textbf{Geodesics} (straight lines in
hyperbolic geometry---they look like circles in our Euclidean view!) -
\textbf{Triangle tilings} with \((2,3,7)\) and \((2,3,\infty)\) symmetry
groups - \textbf{Why hyperbolic space is different}: triangles with
angle sum less than \(\pi\), exponential growth of area

The same algorithmic ideas we've used today (iterated geometric
transformations, escape-time coloring, distance-based rendering) will
work in hyperbolic space. But the results will be even more intricate
because hyperbolic space has ``more room'' than Euclidean
space---allowing denser tilings and more complex fractal structures.

Make sure you're comfortable with: - \textbf{Iteration and escape-time
algorithms} (we'll use similar ideas for tiling) - \textbf{Circle
inversion} (this becomes reflection through hyperbolic geodesics!) -
\textbf{Structs} for organizing geometric data - \textbf{Coloring
strategies} based on orbit behavior

See you tomorrow!

\bookmarksetup{startatroot}

\chapter{Day 3: Geometric Tilings in Euclidean and Hyperbolic
Space}\label{day-3-geometric-tilings-in-euclidean-and-hyperbolic-space-1}

\section{Overview}\label{overview-2}

Today we explore geometric tilings through reflection operations. We'll
start by building a general framework for reflections in Euclidean
space, then venture into hyperbolic geometry where the same algorithmic
approach produces dramatically different patterns.

The key insight: \textbf{the algorithm stays the same across
geometries---only the reflection operations change.} This mirrors what
we saw on Day 2 with the Apollonian gasket: iteratively apply a
geometric transformation until we reach a desired region. But today
we'll understand \emph{why} this works through the lens of group theory.

By the end of today, you'll understand: - How to construct reflections
using linear algebra - \textbf{Why the folding algorithm works}
(reflection groups and fundamental domains) - The structure of
hyperbolic geometry in the upper half-plane model - How to implement
hyperbolic triangle tilings using the same algorithmic pattern - How to
convert between different models of hyperbolic space - The connection
between circle inversion (Day 2) and hyperbolic isometries

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Roadmap for Today}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

\textbf{Part 1: Euclidean Geometry} - Simple tilings (strip, square) -
Half-space abstraction - Triangle tilings - \textbf{Why this works}:
Reflection groups

\textbf{Part 2: Hyperbolic Geometry} - The upper half-plane model and
metric - Geodesics and reflections (connection to Day 2!) - Triangle
tilings in \(\mathbb{H}^2\) - Multiple models (Poincaré disk, Klein) -
Historical context and applications

The unifying theme is \textbf{geometric transformations and their
groups}---the same mathematical structure underlies fractals, tilings,
and symmetry across all geometries.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Part 1: Reflection and Tilings in Euclidean
Geometry}\label{part-1-reflection-and-tilings-in-euclidean-geometry}

\subsection{Starting Simple: The Folding
Algorithm}\label{starting-simple-the-folding-algorithm}

Before we dive into general theory, let's build intuition with the
simplest possible example: creating a repeating strip pattern.

\subsubsection{Tiling a Strip}\label{tiling-a-strip}

Imagine we want to tile the plane horizontally. We'll define a
fundamental domain---the strip \(0 < x < 1\)---and reflect any point
outside this strip back inside.

The algorithm is remarkably simple: - If \(x < 0\), reflect across
\(x = 0\) - If \(x > 1\), reflect across \(x = 1\)\\
- Repeat until the point stops moving

For a vertical line at \(x = c\), reflection just flips the
\(x\)-coordinate: \((x, y) \mapsto (2c - x, y)\).

Here's a complete shader:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Standard coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Fold into the strip [0, 1]}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Draw something in the fundamental domain}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Dark background}
    
    \CommentTok{// A circle in the strip}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Yellow circle}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see the yellow circle repeat infinitely across the screen! We
only drew it once, but the folding algorithm tiles it everywhere.

\textbf{What's happening geometrically?} Every point on the screen gets
mapped back to the fundamental domain \([0,1]\). Points that were in
reflected copies of the domain get folded back through a sequence of
reflections. Since we draw the same pattern in the fundamental domain,
all the reflected copies show the same pattern.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Square Tiling}\label{square-tiling}

Let's extend to two dimensions. Now we have four boundaries: \(x = 0\),
\(x = 1\), \(y = 0\), and \(y = 1\). Same algorithm, just more
boundaries to check:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Fold into the square [0,1] × [0,1]}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Draw something in the fundamental domain}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    
    \CommentTok{// Circle at center}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Perfect! A full 2D tiling.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Square Tiling with Fold
Count}\label{square-tiling-with-fold-count}

Let's track how many reflections were needed. This helps us understand
the geometry and creates beautiful visualizations:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Fold into the square [0,1] × [0,1]}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ p\_old }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
        
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
        
        \CommentTok{// If point didn\textquotesingle{}t move, we\textquotesingle{}re done}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ p\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color based on fold count}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{)} \OperatorTok{/} \FloatTok{8.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{)} \OperatorTok{*}\NormalTok{ t }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{)));}
    
    \CommentTok{// Draw something in the fundamental domain}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \BuiltInTok{smoothstep}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{,}\NormalTok{ d}\OperatorTok{));}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Beautiful! The color gradient shows how many reflections were
needed---points near the fundamental domain require few iterations,
while points far away need many.

Notice the convergence check: we save the old position and check if the
point stopped moving. When no boundary causes a reflection, the point
has reached the fundamental domain and we can stop.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Computational Efficiency: Iteration Count}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

Why does this converge so quickly? Each reflection moves the point
strictly closer to the fundamental domain (in the sense of reducing the
number of boundary crossings). For a viewport of size \(4 \times 4\) and
fundamental domain of size \(1 \times 1\), we need at most
\(\lceil \log_2(4) \rceil = 2\) reflections per axis, so 4 reflections
total in the worst case.

The 20-iteration limit is very conservative---most pixels converge in
under 5 iterations. We could dynamically adjust this based on the
coordinate scale, but for real-time rendering, a fixed conservative
bound works well.

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Abstracting: Half-Spaces}\label{abstracting-half-spaces}

Looking at our square tiling code, we see repetition: check a boundary,
reflect if outside, repeat. Let's abstract this pattern so we can handle
arbitrary shapes.

\subsubsection{What is a Half-Space?}\label{what-is-a-half-space}

A \textbf{half-space} is one side of a line. Any line \(ax + by = c\)
divides the plane into two regions: - Points where \(ax + by < c\) -
Points where \(ax + by > c\)

We'll encode a half-space by storing the line parameters and which side
we want:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}  \CommentTok{// Line parameters: ax + by = c}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}     \CommentTok{// +1 or {-}1 for which side}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

The \texttt{side} parameter determines which inequality we want: -
\texttt{side\ =\ -1.0} means we want \(ax + by > c\) (equivalently,
\((ax + by - c) \cdot (-1) < 0\)) - \texttt{side\ =\ 1.0} means we want
\(ax + by < c\) (equivalently, \((ax + by - c) \cdot (1) < 0\))

This might seem redundant---we could always use \(ax + by < c\) and just
flip the signs of \(a, b, c\) to get the other side. But having an
explicit \texttt{side} parameter makes the code clearer and will be
essential in hyperbolic geometry where sign-flipping doesn't work as
cleanly.

\subsubsection{Visualizing Half-Spaces}\label{visualizing-half-spaces}

Before we implement reflections, let's visualize what a half-space is.
Here's a shader that colors one side of a line:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define a half{-}space: x \textless{} 1 (left side of vertical line at x=1)}
\NormalTok{    HalfSpace hs }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Color based on whether we\textquotesingle{}re inside}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see the left side of the line colored blue, the right side
dark. Try changing the half-space parameters to see how it affects the
coloring!

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Exercise: Drawing the Boundary Line}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

Want to see where the line is? Add this distance function:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{distToHalfSpace}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Then draw the line:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{);}
\KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// White boundary}
\end{Highlighting}
\end{Shaded}

This computes the perpendicular distance from the point to the line,
then colors points near the line white. See Appendix E4b for the
complete implementation!

\end{tcolorbox}

\subsubsection{Intersecting Half-Spaces: Making a
Square}\label{intersecting-half-spaces-making-a-square}

Now let's intersect four half-spaces to create a square region. We'll
use \textbf{additive coloring}---each half-space we're inside adds to
the color, so the interior (inside all four) will be brightest:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define the four half{-}spaces for [0,1] × [0,1]}
\NormalTok{    HalfSpace left   }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// x \textgreater{} 0}
\NormalTok{    HalfSpace right  }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// x \textless{} 1}
\NormalTok{    HalfSpace bottom }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// y \textgreater{} 0}
\NormalTok{    HalfSpace top    }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// y \textless{} 1}
    
    \CommentTok{// Additive coloring {-} each half{-}space adds brightness}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ left}\OperatorTok{))}\NormalTok{   color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ right}\OperatorTok{))}\NormalTok{  color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ bottom}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ top}\OperatorTok{))}\NormalTok{    color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see the square region brightest (inside all four
half-spaces), with regions inside fewer half-spaces progressively
darker. This additive approach makes it easy to see how the regions
overlap!

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Exercise: Improved Visualization}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

For a cleaner look, you might want to:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Binary coloring} (inside domain or not):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool}\NormalTok{ in\_square }\OperatorTok{=} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ left}\OperatorTok{)} \OperatorTok{\&\&} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ right}\OperatorTok{)} \OperatorTok{\&\&} 
                 \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ bottom}\OperatorTok{)} \OperatorTok{\&\&} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ top}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=}\NormalTok{ in\_square }\OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.4}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\item
  \textbf{Draw boundaries} using the distance function from earlier
\item
  \textbf{Create an \texttt{insideDomain()} function}:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool} \FunctionTok{insideDomain}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs1}\OperatorTok{,}\NormalTok{ HalfSpace hs2}\OperatorTok{,} 
\NormalTok{                  HalfSpace hs3}\OperatorTok{,}\NormalTok{ HalfSpace hs4}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{)} \OperatorTok{\&\&} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{)} \OperatorTok{\&\&} 
           \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{)} \OperatorTok{\&\&} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs4}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

See Appendix E5b for complete enhanced versions!

\end{tcolorbox}

\subsubsection{Three Half-Spaces Make a
Triangle}\label{three-half-spaces-make-a-triangle}

Let's visualize three half-spaces defining a triangle:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define three half{-}spaces for equilateral triangle}
\NormalTok{    HalfSpace hs1 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs2 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.732}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs3 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{({-}}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Additive coloring}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see a triangle region where all three half-spaces overlap!
The additive coloring helps visualize the structure.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{The Reflection Formula}\label{the-reflection-formula}

Now we're ready to implement reflection. To reflect a point
\(\mathbf{p} = (x, y)\) across the line \(ax + by = c\), we use linear
algebra. The normal vector to the line is \(\mathbf{n} = (a, b)\). After
normalizing to \(\hat{\mathbf{n}} = \mathbf{n}/|\mathbf{n}|\), the
reflection formula is:

\[\mathbf{p}' = \mathbf{p} - 2d\hat{\mathbf{n}}\]

where \(d\) is the signed distance from \(\mathbf{p}\) to the line:

\[d = \frac{ax + by - c}{\sqrt{a^2 + b^2}}\]

This is a standard result from linear algebra! The signed distance tells
us how far we are from the line (positive on one side, negative on the
other), and we move twice that distance in the normal direction to get
the reflection.

Our \texttt{reflectInto} function checks if we're on the correct side
and only reflects if necessary---it \textbf{extends} our
\texttt{inside()} test by conditionally reflecting:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectInto}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Compute which side of the line we\textquotesingle{}re on}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Check if we\textquotesingle{}re already on the correct side (this is our inside() test!)}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}  \CommentTok{// Already inside, nothing to do}
    \OperatorTok{\}}
    
    \CommentTok{// We\textquotesingle{}re on the wrong side {-} reflect across the boundary line}
    \DataTypeTok{vec2}\NormalTok{ normal }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ norm }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{normal}\OperatorTok{);}
\NormalTok{    normal }\OperatorTok{=}\NormalTok{ normal }\OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ signedDist }\OperatorTok{=} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{{-}} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ signedDist }\OperatorTok{*}\NormalTok{ normal}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This function encapsulates the entire pattern: check if we're on the
correct side (the \texttt{inside()} test), and only reflect if we're
not. So \texttt{reflectInto()} extends and renames our visualization
function to also perform the reflection!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Square Tiling with
Half-Spaces}\label{square-tiling-with-half-spaces}

Let's rewrite our square tiling using this abstraction. For the square
\([0, 1] \times [0, 1]\), we need four half-spaces:

\begin{itemize}
\tightlist
\item
  \textbf{Left edge} (\(x = 0\)): We want \(x > 0\) →
  \texttt{HalfSpace(1.0,\ 0.0,\ 0.0,\ -1.0)}
\item
  \textbf{Right edge} (\(x = 1\)): We want \(x < 1\) →
  \texttt{HalfSpace(1.0,\ 0.0,\ 1.0,\ 1.0)}
\item
  \textbf{Bottom and top}: Similarly for \(y\)
\end{itemize}

Complete shader:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{vec2} \FunctionTok{reflectInto}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \KeywordTok{if}\OperatorTok{((}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
    \OperatorTok{\}}
    
    \DataTypeTok{vec2}\NormalTok{ normal }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ norm }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{normal}\OperatorTok{);}
\NormalTok{    normal }\OperatorTok{=}\NormalTok{ normal }\OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ signedDist }\OperatorTok{=} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{{-}} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ signedDist }\OperatorTok{*}\NormalTok{ normal}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define the four half{-}spaces for [0,1]×[0,1]}
\NormalTok{    HalfSpace left   }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace right  }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace bottom }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace top    }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Fold into the square}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ p\_old }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
        
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ left}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ right}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ bottom}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ top}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ p\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color based on fold count}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{)} \OperatorTok{/} \FloatTok{8.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{)} \OperatorTok{*}\NormalTok{ t }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{)));}
    
    \CommentTok{// Draw something in fundamental domain}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \BuiltInTok{smoothstep}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{,}\NormalTok{ d}\OperatorTok{));}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This looks identical to our earlier version, but now our code is
flexible. The beauty: \textbf{changing from a square to a triangle only
requires changing the half-space definitions!}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Triangle Tiling}\label{triangle-tiling}

Now we're ready for triangles. We'll use an equilateral triangle with
vertices at:

\[v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)\]

This triangle is centered at the origin with one vertex pointing up.

\subsubsection{Computing Half-Spaces from
Edges}\label{computing-half-spaces-from-edges}

For each edge, we need to compute the line parameters \((a, b, c)\) and
determine the correct side. The process:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Take two vertices defining an edge: \(\mathbf{v}_i\) and
  \(\mathbf{v}_j\)
\item
  Compute edge direction: \(\mathbf{d} = \mathbf{v}_j - \mathbf{v}_i\)
\item
  Compute perpendicular (rotate 90° counterclockwise):
  \(\mathbf{n} = (-d_y, d_x)\)
\item
  Line equation: \(n_x \cdot x + n_y \cdot y = c\) where
  \(c = \mathbf{n} \cdot \mathbf{v}_i\)
\item
  Test origin: if \((n_x \cdot 0 + n_y \cdot 0 - c) < 0\), then
  \texttt{side\ =\ -1.0}, else \texttt{side\ =\ 1.0}
\end{enumerate}

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Derivation of Triangle Half-Space Parameters}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

\textbf{Edge from \(v_0 = (0, 1)\) to \(v_1 = (-\sqrt{3}/2, -1/2)\):}

\begin{itemize}
\tightlist
\item
  Edge direction: \(\mathbf{d} = v_1 - v_0 = (-0.866, -1.5)\)
\item
  Perpendicular (90° CCW): \(\mathbf{n} = (1.5, -0.866)\)
\item
  Line: \(1.5x - 0.866y = c\) where
  \(c = \mathbf{n} \cdot v_0 = (1.5)(0) + (-0.866)(1) = -0.866\)
\item
  For origin (inside): \(1.5(0) - 0.866(0) - (-0.866) = 0.866 > 0\)
\item
  We want inside when \((ax + by - c) < 0\), so we need
  \texttt{side\ =\ -1.0}
\end{itemize}

\textbf{Result:} \texttt{HalfSpace(1.5,\ -0.866,\ -0.866,\ -1.0)}

Similar calculations give: - \textbf{Edge \(v_1\) to \(v_2\):}
\texttt{HalfSpace(0.0,\ 1.732,\ -0.866,\ -1.0)} - \textbf{Edge \(v_2\)
to \(v_0\):} \texttt{HalfSpace(-1.5,\ -0.866,\ -0.866,\ -1.0)}

\end{tcolorbox}

The computed parameters are:

\begin{itemize}
\tightlist
\item
  \textbf{Edge \(v_0\) to \(v_1\):}
  \texttt{HalfSpace(1.5,\ -0.866,\ -0.866,\ -1.0)}
\item
  \textbf{Edge \(v_1\) to \(v_2\):}
  \texttt{HalfSpace(0.0,\ 1.732,\ -0.866,\ -1.0)}\\
\item
  \textbf{Edge \(v_2\) to \(v_0\):}
  \texttt{HalfSpace(-1.5,\ -0.866,\ -0.866,\ -1.0)}
\end{itemize}

We already verified these work with our visualization shader above!

\subsubsection{Triangle Tiling Shader}\label{triangle-tiling-shader}

Now we can implement the tiling by copying our reflection shader and
just changing the half-spaces:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{vec2} \FunctionTok{reflectInto}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \KeywordTok{if}\OperatorTok{((}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
    \OperatorTok{\}}
    
    \DataTypeTok{vec2}\NormalTok{ normal }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ norm }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{normal}\OperatorTok{);}
\NormalTok{    normal }\OperatorTok{=}\NormalTok{ normal }\OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ signedDist }\OperatorTok{=} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{{-}} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ signedDist }\OperatorTok{*}\NormalTok{ normal}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define the three half{-}spaces for equilateral triangle}
\NormalTok{    HalfSpace hs1 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs2 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.732}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs3 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{({-}}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Fold into the triangle}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ p\_old }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
        
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ p\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by fold count parity}
    \DataTypeTok{float}\NormalTok{ parity }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{parity }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}  \CommentTok{// Light blue}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Darker blue}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Beautiful! You should see an infinite triangle tiling. The alternating
colors show which triangles are orientation-preserving vs
orientation-reversing reflections of the fundamental domain.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Exercise: Visualizing Triangle Structure}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

Want to see the edges and vertices of your triangles? This requires
computing distances to half-spaces and vertices.

\textbf{For edges} (drawing the boundaries):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{distToHalfSpace}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{));}
\OperatorTok{\}}

\CommentTok{// In main rendering:}
\DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ border }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d1}\OperatorTok{,} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d2}\OperatorTok{,}\NormalTok{ d3}\OperatorTok{));}

\KeywordTok{if}\OperatorTok{(}\NormalTok{border }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// White edges}
\end{Highlighting}
\end{Shaded}

\textbf{For vertices} (marking the corners):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Define vertices}
\DataTypeTok{vec2}\NormalTok{ v0 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\DataTypeTok{vec2}\NormalTok{ v1 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.5}\OperatorTok{);}
\DataTypeTok{vec2}\NormalTok{ v2 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.5}\OperatorTok{);}

\CommentTok{// Check distance after folding}
\DataTypeTok{float}\NormalTok{ dv0 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ v0}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ dv1 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ v1}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ dv2 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ v2}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ vertex\_dist }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\NormalTok{dv0}\OperatorTok{,} \BuiltInTok{min}\OperatorTok{(}\NormalTok{dv1}\OperatorTok{,}\NormalTok{ dv2}\OperatorTok{));}

\KeywordTok{if}\OperatorTok{(}\NormalTok{vertex\_dist }\OperatorTok{\textless{}} \FloatTok{0.05}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Red vertices}
\end{Highlighting}
\end{Shaded}

See Appendix E9 for the complete enhanced version!

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Why Does This Algorithm Work? Reflection
Groups}\label{why-does-this-algorithm-work-reflection-groups}

We've implemented the folding algorithm, but \emph{why} does it work?
Why does iteratively reflecting guarantee we reach the fundamental
domain? The answer lies in \textbf{group theory}.

\subsubsection{Reflections Generate a
Group}\label{reflections-generate-a-group}

Each reflection \(r_i\) across a half-space boundary is an
\textbf{isometry} of the Euclidean plane---it preserves distances and
angles. Composing reflections gives us more isometries. The set of all
compositions of our reflections forms a \textbf{group} under
composition:

\begin{itemize}
\tightlist
\item
  \textbf{Identity}: Reflecting twice across the same line returns to
  the original point (\(r_i \circ r_i = \text{id}\))
\item
  \textbf{Closure}: Composing reflections gives another isometry (which
  might be a reflection, rotation, or glide reflection)
\item
  \textbf{Inverses}: Every isometry has an inverse (just reflect again)
\item
  \textbf{Associativity}: Composition is associative
\end{itemize}

This group, generated by reflections across the boundaries of our
fundamental domain, is called a \textbf{reflection group} or
\textbf{Coxeter group}.

\subsubsection{The Fundamental Domain and
Orbit}\label{the-fundamental-domain-and-orbit}

Our fundamental domain \(F\) (the square \([0,1]^2\) or triangle) is a
\textbf{fundamental domain} for the group action. This means:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Every point in the plane is equivalent to exactly one point in \(F\)
  (modulo boundary points)
\item
  The \textbf{orbit} of \(F\) under the group (all images \(g(F)\) for
  \(g\) in the group) tiles the entire plane
\item
  Different tiles \(g(F)\) and \(h(F)\) only overlap on their boundaries
\end{enumerate}

When we start with a point \(p\) outside \(F\), there exists a sequence
of group elements (reflections) that maps \(p\) into \(F\). Our
algorithm finds this sequence!

\subsubsection{Why the Algorithm
Terminates}\label{why-the-algorithm-terminates}

Here's the key insight: each reflection across a boundary of \(F\)
either: - Keeps the point inside \(F\) (if it's already on the correct
side) - Moves the point strictly closer to \(F\) (if it's on the wrong
side)

``Closer'' here means we reduce some discrete measure---like the number
of boundaries we're on the wrong side of. Since this number is finite
and decreases with each reflection, the algorithm must terminate.

Formally, we can define a \textbf{height function} \(h(p)\) that counts
how many half-space boundaries \(p\) violates. Initially
\(h(p) \geq 0\). Each reflection that actually moves the point decreases
\(h(p)\) by at least 1. When \(h(p) = 0\), the point is inside \(F\) and
the algorithm stops.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{The Pattern Across Days}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-important-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-important-color!10!white, bottomrule=.15mm]

This is the same fundamental principle we've seen throughout:

\textbf{Day 2 (Apollonian gasket):} - Group: Iterated circle inversions
- Fundamental domain: The gaps between circles - Algorithm: Invert until
inside the domain

\textbf{Day 3 (Euclidean tilings):} - Group: Reflections across
boundaries - Fundamental domain: The square/triangle - Algorithm:
Reflect until inside the domain

\textbf{Day 3 (Hyperbolic, coming soon):} - Group: Hyperbolic
reflections (same structure!) - Fundamental domain: Hyperbolic triangle
- Algorithm: Reflect until inside the domain (identical code!)

The unifying theme is \textbf{group actions and fundamental domains}.
We're always finding the unique representative of an orbit that lies in
the fundamental domain.

\end{tcolorbox}

\subsubsection{Computational
Implications}\label{computational-implications}

Understanding the group theory gives us insight into the computation:

\textbf{Convergence rate}: For a viewport of size \(V\) and fundamental
domain of size \(F\), we need at most \(O(\log(V/F))\) reflections per
coordinate axis. This is why small iteration limits (20-30) work well.

\textbf{Parallelism}: Each pixel's orbit is independent---perfect for
GPU parallelism. Millions of pixels computing orbits simultaneously with
no communication needed.

\textbf{Threshold choice}: The \texttt{0.0001} threshold for detecting
convergence balances precision and performance. Smaller thresholds catch
more subtle movements but risk floating-point noise; larger thresholds
might terminate early but rarely matter for visualization.

\textbf{Why it's efficient}: Most tiles are ``nearby'' in the
group---they're reached by short sequences of reflections. Only tiles
far from the origin require many reflections, and these appear very
small on screen (contributing few pixels).

This completes our Euclidean foundation. We now understand: 1. The
folding algorithm in concrete examples 2. The half-space abstraction
that makes it general 3. \textbf{Why it works}: reflection groups and
fundamental domains 4. Computational properties: convergence,
parallelism, efficiency

Next, we'll take this exact algorithmic structure into hyperbolic
geometry!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Part 2: Hyperbolic Geometry}\label{part-2-hyperbolic-geometry}

\subsection{Introduction to Hyperbolic
Geometry}\label{introduction-to-hyperbolic-geometry}

Hyperbolic geometry is one of the three classical geometries (Euclidean,
spherical, and hyperbolic), characterized by constant \textbf{negative
curvature}. For over two millennia, mathematicians believed Euclidean
geometry was the only logically consistent geometry---Euclid's parallel
postulate seemed necessary. The discovery of hyperbolic geometry in the
early 19th century revolutionized mathematics.

\subsubsection{Historical Context: The
Discovery}\label{historical-context-the-discovery}

The story of hyperbolic geometry is one of the great dramas in
mathematical history. For centuries, mathematicians tried to prove
Euclid's fifth postulate (the parallel postulate) from the other four
axioms. What if you could have multiple parallel lines through a point?

Three mathematicians independently discovered that this ``impossible''
geometry was actually perfectly consistent:

\textbf{János Bolyai} (1802-1860), a Hungarian mathematician, developed
hyperbolic geometry in the 1820s. His father, a mathematician himself,
warned him: ``For God's sake, I beseech you, give it up. Fear it no less
than sensual passions because it too may take all your time and deprive
you of your health, peace of mind and happiness in life.'' But János
persisted, publishing his work in 1832 as an appendix to his father's
book.

\textbf{Nikolai Lobachevsky} (1792-1856), a Russian mathematician,
published the first account of hyperbolic geometry in 1829. He called it
``imaginary geometry'' and faced considerable resistance from the
mathematical establishment. His work was largely ignored during his
lifetime.

\textbf{Carl Friedrich Gauss} (1777-1855), the ``Prince of
Mathematicians,'' had discovered hyperbolic geometry even earlier but
never published it. In his private correspondence, he revealed he'd been
working on non-Euclidean geometry since the 1790s but feared the
``clamor of the Boeotians'' (his term for mathematical philistines).
When he read Bolyai's work in 1832, he wrote that he could not praise it
``because to praise it would be to praise myself''---he'd discovered the
same results years earlier but kept them private.

The discovery had profound implications: geometry was not a single truth
about space but a family of possible consistent systems. This
philosophical shift influenced everything from Einstein's general
relativity (which uses non-Euclidean geometry for curved spacetime) to
modern physics and mathematics.

\subsubsection{Modern Applications}\label{modern-applications}

Hyperbolic geometry appears throughout modern mathematics and physics:

\begin{itemize}
\tightlist
\item
  \textbf{Complex analysis}: The upper half-plane model is fundamental
  to the theory of modular forms, elliptic curves, and the Riemann
  mapping theorem
\item
  \textbf{Number theory}: The action of \(SL(2,\mathbb{Z})\) on
  \(\mathbb{H}^2\) produces modular forms---functions crucial to the
  proof of Fermat's Last Theorem
\item
  \textbf{Topology}: The study of 3-manifolds and knot theory often
  requires understanding hyperbolic structures
\item
  \textbf{Teichmüller theory}: Moduli spaces of Riemann surfaces have
  natural hyperbolic metrics
\item
  \textbf{Kleinian groups}: Discrete subgroups of hyperbolic isometries
  produce fractal limit sets (like we saw with the Apollonian gasket!)
\item
  \textbf{General relativity}: Anti-de Sitter space has constant
  negative curvature---hyperbolic geometry in spacetime
\item
  \textbf{Machine learning}: Recent work uses hyperbolic embeddings to
  represent hierarchical data efficiently
\end{itemize}

\subsubsection{Key Properties}\label{key-properties-1}

What makes hyperbolic geometry different from Euclidean geometry?

\textbf{Parallel lines}: Given a line and a point not on it, there are
\textbf{infinitely many} lines through the point that don't intersect
the given line (all parallel to it). This is the defining feature that
distinguishes hyperbolic geometry.

\textbf{Triangle angles}: The sum of angles in a triangle is
\textbf{less than} \(\pi\). In fact, the \textbf{area} of a hyperbolic
triangle with angles \(\alpha\), \(\beta\), \(\gamma\) is exactly:
\[\text{Area} = \pi - (\alpha + \beta + \gamma)\] This is the
\textbf{Gauss-Bonnet theorem} for hyperbolic triangles---a beautiful
connection between geometry (angles) and topology (area).

\textbf{Exponential growth}: In Euclidean geometry, the circumference of
a circle grows linearly with radius (\(C = 2\pi r\)). In hyperbolic
geometry, it grows \textbf{exponentially}: \(C \sim e^r\) for large
\(r\). This means hyperbolic space has ``more room'' than Euclidean
space---there's exponentially more area at distance \(r\) from a point.

\textbf{No similarity}: In Euclidean geometry, you can scale any
shape---a small triangle and a large triangle with the same angles are
similar. In hyperbolic geometry, there's an absolute unit of length
built into the curvature. All triangles with angles
\((\pi/2, \pi/3, \pi/7)\) are congruent---there's no ``scaled version.''
This makes hyperbolic geometry richer but more rigid.

These properties create the ``extra room'' that allows much richer
tiling structures than Euclidean geometry.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{The Upper Half-Plane
Model}\label{the-upper-half-plane-model}

We'll work in the \textbf{upper half-plane model} of hyperbolic
geometry, denoted \(\mathbb{H}^2\):

\[\mathbb{H}^2 = \{z = x + iy \in \mathbb{C} : y > 0\}\]

This is just complex numbers with positive imaginary part---the upper
half of the complex plane. The \textbf{real axis} \(\{y = 0\}\) forms
the boundary ``at infinity''---it's not actually part of
\(\mathbb{H}^2\), but represents points infinitely far away in
hyperbolic distance.

\subsubsection{The Hyperbolic Metric}\label{the-hyperbolic-metric}

The \textbf{hyperbolic metric} is what makes \(\mathbb{H}^2\) a
hyperbolic space:

\[ds^2 = \frac{dx^2 + dy^2}{y^2}\]

This gives \(\mathbb{H}^2\) the structure of a complete Riemannian
manifold with constant curvature \(-1\).

\textbf{What does this mean?} The factor \(1/y^2\) is a
\textbf{conformal factor} that scales the Euclidean metric. As
\(y \to 0\) (approaching the boundary), this scaling factor blows
up---distances that look small Euclidean-wise are enormous
hyperbolically. As \(y \to \infty\) (going ``up'' in the upper
half-plane), the scaling factor goes to zero---large Euclidean distances
are actually finite hyperbolically.

The metric is \textbf{conformal} to the Euclidean metric---it preserves
angles but not lengths. If two curves meet at angle \(\theta\) in the
Euclidean sense, they also meet at angle \(\theta\) in the hyperbolic
sense! This is why you can trust your eyes when looking at
pictures---angles are what they appear to be.

\subsubsection{The Distance Formula}\label{the-distance-formula}

Integrating the metric along paths gives the \textbf{hyperbolic
distance} between two points \(z_1 = x_1 + iy_1\) and
\(z_2 = x_2 + iy_2\):

\[d_{\mathbb{H}^2}(z_1, z_2) = \text{arcosh}\left(1 + \frac{|z_1 - z_2|^2}{2y_1 y_2}\right)\]

where \(|z_1 - z_2| = \sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}\) is the usual
Euclidean distance.

Notice the \(1/y_1 y_2\) factor---points near the boundary (\(y\) small)
are very far apart hyperbolically even if they're close Euclidean-wise.

\textbf{Derivation sketch}: For a vertical line from \(z_1 = x + iy_1\)
to \(z_2 = x + iy_2\), the hyperbolic length is:
\[\int_{y_1}^{y_2} \frac{dy}{y} = \log(y_2) - \log(y_1) = \log(y_2/y_1)\]

For a general path, you need to integrate along the geodesic connecting
the points (which might not be a straight Euclidean line), giving the
arcosh formula above.

\subsubsection{Visualizing Hyperbolic
Distance}\label{visualizing-hyperbolic-distance}

Let's make this concrete with an interactive shader. We'll start with
Euclidean distance, then switch to hyperbolic to see the difference.

\textbf{Euclidean distance circles:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}  \CommentTok{// Shift up so we\textquotesingle{}re in y \textgreater{} 0}
    
    \CommentTok{// Mouse position as center (or default)}
    \DataTypeTok{vec2}\NormalTok{ mouse }\OperatorTok{=}\NormalTok{ iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{z} \OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)}\NormalTok{ mouse }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{);}  \CommentTok{// Default if no click}
\NormalTok{    mouse }\OperatorTok{=} \OperatorTok{(}\NormalTok{mouse }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    mouse}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ center }\OperatorTok{=}\NormalTok{ mouse }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Euclidean distance}
    \DataTypeTok{float}\NormalTok{ dist }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{);}
    
    \CommentTok{// Draw a disk of radius 0.5 using two circles}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}  \CommentTok{// Background}
    
    \CommentTok{// Outer circle (slightly larger)}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{+} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Yellow ring}
    \OperatorTok{\}}
    
    \CommentTok{// Inner circle (slightly smaller) {-} "cuts out" interior}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{{-}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.4}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Blue interior}
    \OperatorTok{\}}
    
    \CommentTok{// Draw center point}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.05}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside upper half{-}plane}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Click and drag around---the circle stays the same size everywhere. This
is Euclidean distance: uniform across the plane. Notice how we draw the
boundary: we draw a filled circle at radius \(r + \epsilon\) (outer
edge), then draw another filled circle at radius \(r - \epsilon\) (inner
edge) in a different color. The ring between them is our boundary!

\textbf{Hyperbolic distance circles:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z1}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ z2}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ z1 }\OperatorTok{{-}}\NormalTok{ z2}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ diff2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ z1}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ z2}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ arg }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+}\NormalTok{ diff2 }\OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{log}\OperatorTok{(}\NormalTok{arg }\OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{arg }\OperatorTok{*}\NormalTok{ arg }\OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{));}  \CommentTok{// arccosh(arg)}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Mouse position as center}
    \DataTypeTok{vec2}\NormalTok{ mouse }\OperatorTok{=}\NormalTok{ iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{z} \OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)}\NormalTok{ mouse }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{);}
\NormalTok{    mouse }\OperatorTok{=} \OperatorTok{(}\NormalTok{mouse }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    mouse}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ center }\OperatorTok{=}\NormalTok{ mouse }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Hyperbolic distance}
    \DataTypeTok{float}\NormalTok{ dist }\OperatorTok{=} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ center}\OperatorTok{);}
    
    \CommentTok{// Draw a hyperbolic disk using two "circles"}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}  \CommentTok{// Background}
    
    \CommentTok{// Outer boundary}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{+} \FloatTok{0.05}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Yellow ring}
    \OperatorTok{\}}
    
    \CommentTok{// Inner region}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{{-}} \FloatTok{0.05}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.4}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Blue interior}
    \OperatorTok{\}}
    
    \CommentTok{// Draw center}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ center}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside upper half{-}plane}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now drag the center around! Notice how the ``circle'' changes shape as
you move it. Near the bottom (\(y \to 0\)), the circle appears huge
Euclidean-wise---that's because we're near the boundary where hyperbolic
distances blow up. Higher up (\(y\) large), the circle appears smaller.

This visualization makes the \(1/y^2\) conformal factor visceral:
\textbf{hyperbolic space is compressed near the boundary}.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{The Boundary at Infinity}\label{the-boundary-at-infinity}

The real axis \(\{y = 0\}\) is not part of \(\mathbb{H}^2\), but we can
think of it as the \textbf{boundary at infinity}---points infinitely far
away in hyperbolic distance.

\textbf{Ideal points as equivalence classes}: An \textbf{ideal point} on
the boundary can be defined as an equivalence class of geodesics that
asymptotically approach each other. Two geodesics are equivalent if the
hyperbolic distance between them goes to zero as you go to infinity
along them.

For example, the vertical line \(\{x = 0\}\) and the vertical line
\(\{x = \epsilon\}\) (for small \(\epsilon\)) both approach the point
\(0\) on the real axis. As you go up (\(y \to \infty\)), the hyperbolic
distance between corresponding points goes to zero---they're
asymptotically parallel.

\textbf{Geometric intuition}: In the Poincaré disk model (which we'll
see soon), the boundary at infinity is literally the unit circle
\(|z| = 1\). Points on this circle are infinitely far away from any
interior point, but they still have geometric meaning---they represent
directions or ``points at infinity.''

\textbf{Why this matters}: When we define hyperbolic triangles, we can
have vertices ``at infinity'' on the boundary. These are called
\textbf{ideal vertices} or \textbf{ideal triangles}. For instance, our
\((2,3,\infty)\) triangle has one vertex at the point \(\infty\) in the
upper half-plane (straight up the imaginary axis). The angle at an ideal
vertex is zero---the sides become asymptotically parallel as they
approach the boundary.

The Gauss-Bonnet theorem still works: for a triangle with angles
\(\alpha\), \(\beta\), \(\gamma\), the area is
\(\pi - (\alpha + \beta + \gamma)\). If one angle is zero (ideal
vertex), the area is \(\pi - \alpha - \beta > 0\)---ideal triangles have
finite area!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Geodesics and Reflections}\label{geodesics-and-reflections}

\subsubsection{Geodesics in the Upper
Half-Plane}\label{geodesics-in-the-upper-half-plane}

\textbf{Geodesics} (the ``straight lines'' of hyperbolic
geometry---curves that locally minimize distance) in \(\mathbb{H}^2\)
have exactly two forms:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Vertical lines}: \(\{x = c\}\) for any constant
  \(c \in \mathbb{R}\)
\item
  \textbf{Semicircles}: Centered on the real axis, perpendicular to it
\end{enumerate}

These curves meet the boundary at right angles---this is the
characterizing property of geodesics in this model.

\textbf{Why these are geodesics}: Reflections across these curves are
isometries (they preserve the hyperbolic metric
\(ds^2 = \frac{dx^2+dy^2}{y^2}\)). An isometry's fixed point set is
always a geodesic! So we just need to verify that reflection across
vertical lines and semicircles preserves the metric.

For \textbf{vertical lines}, this is obvious: reflecting across
\(x = c\) sends \((x,y) \mapsto (2c-x, y)\), which preserves both the
Euclidean distance \(dx^2 + dy^2\) and the \(y\)-coordinate, hence
preserves \(\frac{dx^2+dy^2}{y^2}\).

For \textbf{semicircles}, we use circle inversion from Day 2! A
semicircle centered at \((c, 0)\) with radius \(R\) is preserved by the
inversion: \[z \mapsto c + R^2 \frac{z - c}{|z - c|^2}\]

Circle inversion is conformal (preserves angles) and scales distances by
exactly \(1/y^2\) near the boundary---precisely the conformal factor in
the hyperbolic metric! So inversions through semicircles are hyperbolic
isometries. Their fixed point sets (the semicircles themselves) are
therefore geodesics.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-important-color}{\faExclamation}\hspace{0.5em}{Connection to Day 2: Circle Inversion is a Hyperbolic Isometry!}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-important-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-important-color!10!white, bottomrule=.15mm]

This is a profound connection: the circle inversions we used on Day 2
for the Apollonian gasket were actually \textbf{hyperbolic isometries}
all along! The Apollonian gasket lives in hyperbolic space---the gaps
between circles are hyperbolic regions, and the inversions are
reflections across hyperbolic geodesics (semicircles).

When we iterated inversions on Day 2, we were doing exactly what we're
doing today---finding the fundamental domain of a group action! The
Apollonian gasket is a hyperbolic object, just like our triangle
tilings. The same group-theoretic principles apply.

This is why the techniques work across days: we're always working with
group actions, whether we realize it or not. The mathematics unifies
everything.

\end{tcolorbox}

\subsubsection{Implementing Reflections}\label{implementing-reflections}

For \textbf{vertical lines} (like \(x = c\)), reflection is
simple---flip the \(x\)-coordinate:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ x\_pos}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Check if we\textquotesingle{}re on the correct side}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}  \CommentTok{// Already on correct side}
    \OperatorTok{\}}
    
    \CommentTok{// Reflect: (x,y) ↦ (2c {-} x, y)}
\NormalTok{    z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ x\_pos }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

For \textbf{semicircles} (geodesics from point \(p\) to point \(q\) on
the real axis), we use circle inversion. The semicircle has center
\((c, 0)\) where \(c = (p+q)/2\) and radius \(R = |p-q|/2\):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ q}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}  \CommentTok{// Squared distance from center}
    
    \CommentTok{// Check if we\textquotesingle{}re on the correct side}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}  \CommentTok{// Already on correct side}
    \OperatorTok{\}}
    
    \CommentTok{// Circle inversion (from Day 2!)}
    \DataTypeTok{vec2}\NormalTok{ inverted }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ rel }\OperatorTok{/}\NormalTok{ dist2}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ inverted}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Note: We're inverting through a circle in the Euclidean sense (using
Euclidean distance \texttt{dist2}), but this operation is actually a
hyperbolic isometry! The magic is that circle inversion's conformal
properties exactly match the hyperbolic metric's requirements.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Why Two Types of Reflections?}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

In Euclidean geometry, all reflections across lines look the same---just
the orientation changes. Why do we need two different functions in
hyperbolic geometry?

The answer is that we're working in a \textbf{model} of hyperbolic
geometry (the upper half-plane). The vertical lines and semicircles are
the images of geodesics in this model. In the intrinsic hyperbolic
geometry, all reflections across geodesics are the same---there's only
one type of reflection.

But when we represent hyperbolic geometry in the Euclidean upper
half-plane, geodesics appear as two different types of curves (vertical
lines and semicircles), so we need two different formulas. This is an
artifact of the model, not the geometry itself.

In the Poincaré disk model (coming soon), ALL geodesics are circular
arcs perpendicular to the boundary circle, so we'd only need one
reflection function there!

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{The (2,3,∞) Triangle}\label{the-23-triangle}

Let's build our first hyperbolic triangle tiling. The notation
\((p, q, r)\) means the triangle has angles \(\pi/p\), \(\pi/q\), and
\(\pi/r\) at its three vertices. So \((2,3,\infty)\) means angles
\(\pi/2\), \(\pi/3\), and \(0\) (an ideal vertex at infinity).

\textbf{Why this triangle exists in hyperbolic geometry}: The
Gauss-Bonnet theorem tells us the area of a hyperbolic triangle with
angles \(\alpha\), \(\beta\), \(\gamma\) is:
\[\text{Area} = \pi - (\alpha + \beta + \gamma)\]

For a \((2,3,\infty)\) triangle:
\[\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + 0\right) = \pi - \frac{5\pi}{6} = \frac{\pi}{6} > 0\]

So this triangle has finite positive area and can tile the hyperbolic
plane. In Euclidean geometry, \(\pi/2 + \pi/3 = 5\pi/6 < \pi\), but
that's not enough---we'd need the sum to equal \emph{exactly} \(\pi\) to
get zero curvature. Since \(5\pi/6 < \pi\), there's negative curvature
left over, making this a hyperbolic triangle.

\textbf{Configuration}: We'll use a particularly nice setup in the upper
half-plane: - \textbf{Left boundary}: Vertical line at \(x = -1\) -
\textbf{Right boundary}: Vertical line at \(x = 1\)\\
- \textbf{Bottom boundary}: Unit semicircle from \(-1\) to \(1\)
(centered at origin, radius \(1\))

This creates a triangle with: - Two finite vertices at approximately
\((-1, 0)\) and \((1, 0)\) (technically infinitesimally above the real
axis) - One ideal vertex at \(\infty\) (straight up the imaginary axis)
- Angles of \(\pi/2\) at the bottom two vertices (vertical line meets
semicircle at right angles) - Angle of \(\pi/3\) between the two
vertical lines when measured hyperbolically - Angle of \(0\) at the
ideal vertex \(\infty\)

\subsubsection{Implementation}\label{implementation-2}

Here's the complete shader:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ x\_pos}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\NormalTok{    z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ x\_pos }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ q}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
    
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ rel }\OperatorTok{/}\NormalTok{ dist2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Shift to upper half{-}plane (need y \textgreater{} 0)}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Fold into the (2,3,∞) triangle}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ z\_old }\OperatorTok{=}\NormalTok{ z}\OperatorTok{;}
        
        \CommentTok{// Reflect across left vertical line (x = {-}1, want x \textgreater{} {-}1)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// Reflect across right vertical line (x = 1, want x \textless{} 1)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// Reflect across semicircle (from {-}1 to 1, want outside/above)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// If point didn\textquotesingle{}t move, we\textquotesingle{}re inside}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}}\NormalTok{ z\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by fold count parity}
    \DataTypeTok{float}\NormalTok{ parity }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{parity }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}  \CommentTok{// Light blue}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Darker blue}
    \OperatorTok{\}}
    
    \CommentTok{// Darken if below the real axis (outside hyperbolic space)}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see a beautiful hyperbolic tiling! Notice how the triangles
appear to get smaller near the bottom of the screen (approaching the
real axis \(y = 0\))---they're all the same hyperbolic size, but
Euclidean distances compress due to the \(1/y^2\) metric.

The alternating colors show which tiles are orientation-preserving vs
orientation-reversing reflections of the fundamental domain.

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-note-color}{\faInfo}\hspace{0.5em}{Compare to Euclidean}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-note-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-note-color!10!white, bottomrule=.15mm]

Look at the structure of this shader compared to the Euclidean triangle
tiling:

\textbf{Euclidean:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{);}
\NormalTok{p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Hyperbolic:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{z }\OperatorTok{=} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The algorithm is identical! We just have two types of reflection
operations instead of one. This is the power of recognizing the pattern.

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Computational Analysis}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

\textbf{GPU Parallelism}: Just like Days 1 and 2, this algorithm is
embarrassingly parallel. Each pixel computes independently---no
communication, no shared state, perfect for GPU architecture.

\textbf{Convergence}: The folding algorithm works for the same
group-theoretic reasons as the Euclidean case. The three reflections
generate a discrete group of hyperbolic isometries, and our fundamental
triangle is a fundamental domain for this group's action on
\(\mathbb{H}^2\).

\textbf{Precision issues}: Near \(y \to 0\), floating-point precision
degrades. The large conformal factor \(1/y^2\) amplifies small errors in
distance calculations. This is why we darken the region
\(y < 0\)---technically it's not part of the hyperbolic plane, but also
our numerics become unreliable there.

\textbf{Threshold \(0.0001\)}: This convergence threshold balances
precision and performance. Smaller thresholds catch more subtle
movements but risk getting stuck in floating-point noise; larger
thresholds might terminate early. For visualization purposes, \(0.0001\)
is a good sweet spot.

\textbf{Memory efficiency}: Each pixel only needs to store its current
position \texttt{z} (two floats) and an iteration counter (one integer).
No arrays, no history, no complex data structures---just stateless
iteration. This is as memory-efficient as you can get!

\end{tcolorbox}

\begin{tcolorbox}[enhanced jigsaw, toptitle=1mm, title=\textcolor{quarto-callout-tip-color}{\faLightbulb}\hspace{0.5em}{Exercise: Visualizing Hyperbolic Triangle Structure}, rightrule=.15mm, coltitle=black, arc=.35mm, opacitybacktitle=0.6, toprule=.15mm, colframe=quarto-callout-tip-color-frame, breakable, leftrule=.75mm, colback=white, titlerule=0mm, opacityback=0, bottomtitle=1mm, left=2mm, colbacktitle=quarto-callout-tip-color!10!white, bottomrule=.15mm]

Want to see the edges and vertices of your hyperbolic triangles? This
requires computing hyperbolic distances.

\textbf{For hyperbolic distance:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z1}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ z2}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ z1 }\OperatorTok{{-}}\NormalTok{ z2}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ diff2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ z1}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ z2}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ arg }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+}\NormalTok{ diff2 }\OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{log}\OperatorTok{(}\NormalTok{arg }\OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{arg }\OperatorTok{*}\NormalTok{ arg }\OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{For drawing edges} (vertical lines):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Distance to vertical line x = c}
\DataTypeTok{float}\NormalTok{ distToVertical }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ c}\OperatorTok{);}
\KeywordTok{if}\OperatorTok{(}\NormalTok{distToVertical }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{For drawing edges} (semicircular geodesics):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Distance to semicircle from p to q}
\DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
\DataTypeTok{float}\NormalTok{ distToCircle }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{))} \OperatorTok{{-}}\NormalTok{ radius}\OperatorTok{);}
\CommentTok{// Only draw if above real axis}
\KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{0.0} \OperatorTok{\&\&}\NormalTok{ distToCircle }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{For vertices}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Check hyperbolic distance to vertices after folding}
\DataTypeTok{vec2}\NormalTok{ v1 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.01}\OperatorTok{);}  \CommentTok{// Left vertex (slightly above axis)}
\DataTypeTok{vec2}\NormalTok{ v2 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.01}\OperatorTok{);}   \CommentTok{// Right vertex}
\KeywordTok{if}\OperatorTok{(}\FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ v1}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.1} \OperatorTok{||} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ v2}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{    color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Red vertices}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

See Appendix H5 for the complete enhanced implementation!

\end{tcolorbox}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Multiple Models of Hyperbolic
Space}\label{multiple-models-of-hyperbolic-space}

The upper half-plane is just one way to represent hyperbolic geometry.
There are several other models, each with advantages:

\subsubsection{The Poincaré Disk
Model}\label{the-poincaruxe9-disk-model}

The \textbf{Poincaré disk model} represents all of \(\mathbb{H}^2\) as
the interior of the unit disk \(\{z \in \mathbb{C} : |z| < 1\}\). The
boundary circle \(|z| = 1\) represents points at infinity.

\textbf{Geodesics} in this model are: - Diameters of the disk (straight
lines through the origin) - Circular arcs perpendicular to the boundary
circle

The conformal factor here is \(\frac{4}{(1-|z|^2)^2}\), which blows up
as \(|z| \to 1\) (approaching the boundary).

\textbf{Advantages}: - The entire hyperbolic plane fits in a bounded
region (the disk) - All geodesics look similar (circular arcs)---no
distinction between vertical and circular - Visually intuitive for
understanding the full structure at once

\textbf{Disadvantages}: - Harder to compute distances - More complex
reflection formulas

\subsubsection{Converting Between Models: The Cayley
Transform}\label{converting-between-models-the-cayley-transform}

We can convert between the upper half-plane and Poincaré disk using the
\textbf{Cayley transform} (also called the Möbius transformation):

\[w = \frac{z - i}{z + i}\]

This maps: - Upper half-plane \(\{z : \operatorname{Im}(z) > 0\}\) →
Poincaré disk \(\{w : |w| < 1\}\) - Real axis
\(\{z : \operatorname{Im}(z) = 0\}\) → Unit circle \(\{w : |w| = 1\}\) -
Point \(i\) in the upper half-plane → origin \(0\) in the disk

The inverse transform is: \[z = i\frac{1 + w}{1 - w}\]

Here's the implementation:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{a}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ a}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}\NormalTok{ a}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ a}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cdiv}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ a}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ b}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{b}\OperatorTok{,}\NormalTok{ b}\OperatorTok{);}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{a}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ a}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}\NormalTok{ a}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ a}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ b}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{uhpToDisk}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// w = (z {-} i) / (z + i)}
    \DataTypeTok{vec2}\NormalTok{ i }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \KeywordTok{return} \FunctionTok{cdiv}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}}\NormalTok{ i}\OperatorTok{,}\NormalTok{ z }\OperatorTok{+}\NormalTok{ i}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{diskToUhp}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// z = i(1 + w) / (1 {-} w)}
    \DataTypeTok{vec2}\NormalTok{ i }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ one }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \KeywordTok{return} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{i}\OperatorTok{,} \FunctionTok{cdiv}\OperatorTok{(}\NormalTok{one }\OperatorTok{+}\NormalTok{ w}\OperatorTok{,}\NormalTok{ one }\OperatorTok{{-}}\NormalTok{ w}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

To display your tiling in the Poincaré disk:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup for disk}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.5}\OperatorTok{;}  \CommentTok{// Fit disk in viewport}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Convert disk coordinates to upper half{-}plane}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \FunctionTok{diskToUhp}\OperatorTok{(}\NormalTok{uv}\OperatorTok{);}
    
    \CommentTok{// Run your tiling algorithm in UHP}
    \CommentTok{// ... (fold into (2,3,∞) triangle as before)}
    
    \CommentTok{// Color and render}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{The Klein Model}\label{the-klein-model}

The \textbf{Klein model} (also called the \textbf{Beltrami-Klein model}
or \textbf{projective disk model}) is another disk representation. Its
defining feature: \textbf{geodesics are Euclidean straight lines}! This
makes some geometric properties clearer but sacrifices the conformal
property---angles are distorted.

Converting from Poincaré disk to Klein disk:

\[\text{Klein}(w) = \frac{2w}{1 + |w|^2}\]

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{poincareToKlein}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{w}\OperatorTok{,}\NormalTok{ w}\OperatorTok{);}
    \KeywordTok{return} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ w }\OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The inverse:

\[w = \frac{\text{Klein}(w)}{1 + \sqrt{1 - |\text{Klein}(w)|^2}}\]

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{kleinToPoincare}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ k}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ k2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{k}\OperatorTok{,}\NormalTok{ k}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ k2}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ k }\OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{Advantages of Klein}: - Geodesics are straight lines (simplest
to compute) - Great for understanding incidence relationships

\textbf{Disadvantages}: - Not conformal---angles are distorted - Harder
to see hyperbolic distances

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Other Triangle Groups}\label{other-triangle-groups}

The \((2,3,\infty)\) triangle is just the beginning. Many other
hyperbolic triangles can tile the plane! The most famous is the
\((2,3,7)\) triangle.

\subsubsection{\texorpdfstring{The \((2,3,7)\)
Triangle}{The (2,3,7) Triangle}}\label{the-237-triangle}

This triangle has angles \(\pi/2\), \(\pi/3\), and \(\pi/7\). Its area
is:
\[\text{Area} = \pi - \left(\frac{\pi}{2} + \frac{\pi}{3} + \frac{\pi}{7}\right) = \frac{\pi}{42}\]

This is one of the smallest compact hyperbolic triangles! It produces
incredibly dense tilings---the \((2,3,7)\) tiling has a 7-fold symmetry
that creates intricate patterns reminiscent of M.C. Escher's work.

In fact, Escher's famous \emph{Circle Limit} prints (especially Circle
Limit III with the fish) are based on tilings by \((2,3,7)\) and related
triangle groups. The hyperbolic geometry creates the exponential
compression toward the boundary that gives these prints their
distinctive character.

\textbf{Classification of hyperbolic triangles}: Not every combination
\((p,q,r)\) gives a hyperbolic triangle. The Gauss-Bonnet formula tells
us we need: \[\frac{1}{p} + \frac{1}{q} + \frac{1}{r} < 1\]

for a hyperbolic triangle (negative curvature). If the sum equals
exactly \(1\), we get a Euclidean triangle. If the sum is greater than
\(1\), we get a spherical triangle (positive curvature).

\textbf{Examples}: - \((2,3,7)\):
\(\frac{1}{2} + \frac{1}{3} + \frac{1}{7} = \frac{41}{42} < 1\) ✓
Hyperbolic - \((2,3,\infty)\):
\(\frac{1}{2} + \frac{1}{3} + 0 = \frac{5}{6} < 1\) ✓ Hyperbolic -
\((3,3,3)\): \(\frac{1}{3} + \frac{1}{3} + \frac{1}{3} = 1\) ✓ Euclidean
(equilateral triangle) - \((2,3,5)\):
\(\frac{1}{2} + \frac{1}{3} + \frac{1}{5} = \frac{31}{30} > 1\) ✓
Spherical (icosahedron face)

Implementing other triangle groups requires computing where the third
geodesic should be, given the angle constraints. This is non-trivial and
involves hyperbolic trigonometry---we leave this as an advanced homework
exercise!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Summary}\label{summary-2}

Today we learned:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{The folding algorithm}: Iteratively reflect across boundaries
  until reaching the fundamental domain---works in any geometry
\item
  \textbf{Half-space structure}: Boundary + side gives a unified way to
  encode regions in Euclidean geometry
\item
  \textbf{Why it works}: \textbf{Reflection groups} and fundamental
  domains---the group-theoretic perspective that unifies all our
  iterative algorithms across Days 2 and 3
\item
  \textbf{Hyperbolic geometry}: Negative curvature space with two types
  of geodesics (vertical lines and semicircles in the UHP model)
\item
  \textbf{Connection to Day 2}: Circle inversion is a hyperbolic
  isometry! The Apollonian gasket is actually a hyperbolic object
\item
  \textbf{Two reflection functions}: \texttt{reflectIntoVertical} and
  \texttt{reflectIntoCircular} parallel the Euclidean
  \texttt{reflectInto}
\item
  \textbf{Multiple models}: Converting between upper half-plane and
  Poincaré disk using the Cayley transform
\item
  \textbf{Historical context}: The dramatic discovery of hyperbolic
  geometry by Gauss, Bolyai, and Lobachevsky in the 19th century
\item
  \textbf{Computational perspective}: GPU parallelism, convergence
  rates, precision issues, iteration count tuning
\end{enumerate}

\textbf{Key insight}: Clean mathematical abstraction lets us write
geometry-independent algorithms. The folding algorithm stays identical;
only the reflection operations change. This is the power of recognizing
patterns and building flexible abstractions!

\textbf{The universal pattern}: - \textbf{Day 1}: Distance fields and
implicit curves---visualizing mathematics on the GPU - \textbf{Day 2}:
Iterating circle inversions to create the Apollonian gasket---first
group action - \textbf{Day 3 (Euclidean)}: Iterating reflections to
create tilings---reflection groups make it work - \textbf{Day 3
(Hyperbolic)}: Same algorithm, different geometry---circle inversion
reappears as hyperbolic isometry!

The through-line is \textbf{geometric transformations and their groups}.
When we iterate a group action to reach a fundamental domain, we create
tilings, fractals, and beautiful mathematical art.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Homework}\label{homework-8}

\subsection{Required \#0: Understanding Hyperbolic
Distance}\label{required-0-understanding-hyperbolic-distance}

\textbf{Goal}: Build geometric intuition for how hyperbolic distance
works before implementing tilings.

\textbf{Tasks}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Euclidean distance visualization}: Implement the shader
  showing Euclidean distance circles (provided in lecture). Drag the
  center around and observe that circles stay the same size everywhere.
\item
  \textbf{Hyperbolic distance visualization}: Implement the hyperbolic
  version (provided in lecture). Drag the center and observe how the
  ``circle'' changes shape---growing huge near \(y \to 0\) and shrinking
  as \(y\) increases.
\item
  \textbf{Observations}: Write 2-3 sentences describing what you observe
  about how hyperbolic ``circles'' behave compared to Euclidean ones.
  Why does the shape change as you drag the center?
\end{enumerate}

\textbf{Expected output}: Two working shaders demonstrating the
difference between Euclidean and hyperbolic distance.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Required \#1: Euclidean Triangle Tiling with Edges and
Vertices}\label{required-1-euclidean-triangle-tiling-with-edges-and-vertices}

\textbf{Goal}: Create a beautiful Euclidean triangle tiling that clearly
shows the tiling structure.

\textbf{Tasks}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Start with the basic triangle tiling from lecture
\item
  \textbf{Add edge visualization} using distance to half-spaces
\item
  \textbf{Add vertex markers} at the three triangle vertices
\item
  \textbf{Create an attractive color scheme}
\end{enumerate}

\textbf{Expected output}: A clear triangle tiling where you can see
individual triangles, their edges, and vertices. Experiment with colors
to create an aesthetically pleasing result.

See Appendix E9 for reference implementation.

\textbf{Bonus}: Try different triangles! An isosceles right triangle, a
30-60-90 triangle, etc. Just compute new half-spaces for the edges.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Required \#2: Hyperbolic Triangle Tiling with Edges and
Vertices}\label{required-2-hyperbolic-triangle-tiling-with-edges-and-vertices}

\textbf{Goal}: Create a beautiful hyperbolic triangle tiling with
visible structure.

\textbf{Tasks}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Start with the basic \((2,3,\infty)\) tiling from lecture
\item
  \textbf{Implement hyperbolic distance functions} (see hints in
  lecture)
\item
  \textbf{Draw geodesic edges} using hyperbolic distance to geodesics
\item
  \textbf{Draw vertices} using hyperbolic distance to vertex points
\item
  \textbf{Create an attractive color scheme}
\end{enumerate}

\textbf{Expected output}: A clear hyperbolic tiling in the upper
half-plane showing triangle edges and vertices.

See Appendix H5 for complete reference implementation.

\textbf{Bonus}: Display the same tiling in the Poincaré disk model and
compare how edges and vertices appear in the two models.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Required \#3: Model
Conversions}\label{required-3-model-conversions}

\textbf{Goal}: See the same tiling in different representations of
hyperbolic space.

\textbf{Tasks}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Poincaré Disk} (already provided in lecture): Verify it works
  with your tiling code
\item
  \textbf{Klein Model}: Implement the transformation from Poincaré disk
  to Klein disk (see lecture for formula)

  In the Klein model, geodesics become Euclidean straight lines! Display
  your tiling and observe this property.
\item
  \textbf{Comparison}: Show your \((2,3,\infty)\) tiling in both the
  Poincaré disk and Klein model side-by-side. Write a few sentences
  about what you observe.
\end{enumerate}

\textbf{Deliverable}: Screenshots of your tiling in at least two models,
with brief observations.

See Appendix H7 for Klein model reference.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Required \#4: Different Triangle Groups
(Challenge!)}\label{required-4-different-triangle-groups-challenge}

\textbf{Goal}: Explore other hyperbolic tilings by implementing
different triangle groups.

\textbf{The Challenge}: This is the hardest homework problem! Computing
where the third geodesic should be, given angle constraints, requires
hyperbolic trigonometry.

\textbf{Suggested triangles to try}: - \textbf{(2, 3, 7)}: Creates
Escher-like tilings with 7-fold symmetry - \textbf{(2, 4, 6)}: Different
symmetry pattern - \textbf{(3, 3, 3)}: Equilateral hyperbolic triangle

\textbf{Approach}: Use the hyperbolic law of cosines (see lecture for
formula) to compute geodesic positions.

\textbf{Deliverable}: Working tiling for at least one triangle group
other than \((2,3,\infty)\). Include screenshots and document your
approach.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Optional Exercises}\label{optional-exercises}

\textbf{Optional \#1: Unified Abstractions} - Create structs that work
for both Euclidean and hyperbolic geometry

\textbf{Optional \#2: Decorated Tiles} - Add Escher-style patterns
within fundamental domains

\textbf{Optional \#3: Pentagon Tilings} - Right-angled pentagons can
tile hyperbolic space!

See lecture for details on these optional exercises.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Looking Ahead}\label{looking-ahead-2}

We've now seen three days of geometric iteration: - \textbf{Day 1}:
Distance fields and implicit functions - \textbf{Day 2}: Circle
inversion and the Apollonian gasket - \textbf{Day 3}: Reflection groups
in Euclidean and hyperbolic geometry

The common thread: \textbf{group actions on geometric spaces}.
Iteratively applying transformations to reach a desired region, whether
it's the fundamental domain of a tiling or the gap structure of a
fractal.

The techniques you've learned---GPU parallelism, iterative algorithms,
group theory, geometric transformations---apply across a huge landscape
of mathematical visualization!

\bookmarksetup{startatroot}

\chapter{Day 4: Introduction to 3D
Rendering}\label{day-4-introduction-to-3d-rendering-1}

\section{Overview}\label{overview-3}

Today we enter the third dimension! We'll learn how to cast rays from a
camera and test for intersections with 3D objects. We'll start with
analytical methods (solving equations directly) for spheres and tori,
then transition to raymarching with signed distance functions---a more
flexible approach that enables complex procedural scenes.

By the end of today, you'll understand: - How to set up a camera and
generate rays for each pixel - Analytical ray-object intersection for
simple surfaces - Why analytical methods become challenging for complex
geometry - Signed distance functions as an alternative representation -
The raymarching algorithm (sphere tracing) - How to compose multiple
objects and assign materials

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Part 1: Analytical Ray
Tracing}\label{part-1-analytical-ray-tracing}

\subsection{Camera and Ray Setup}\label{camera-and-ray-setup}

\subsubsection{The Rendering Pipeline}\label{the-rendering-pipeline}

For each pixel, we need to: 1. Generate a ray from the camera through
that pixel 2. Find where (if anywhere) the ray intersects scene geometry
3. Compute color based on surface properties and lighting

\subsubsection{Coordinate System}\label{coordinate-system}

We'll use the standard graphics convention: - \textbf{Y-axis} points up
- \textbf{Z-axis} points toward the camera (out of the screen) -
\textbf{X-axis} points right - Right-handed coordinate system

\subsubsection{Pinhole Camera Model}\label{pinhole-camera-model}

Our camera sits at the origin looking down the negative Z-axis. For a
pixel at normalized coordinates \((u, v) \in [-1, 1]^2\), we generate a
ray:

\textbf{Ray origin:} \(\mathbf{o} = (0, 0, 0)\) (camera position)\\
\textbf{Ray direction:} \(\mathbf{d} = \text{normalize}(u, v, -f)\)

where \(f\) is the focal length, related to field of view by:
\(f = 1/\tan(\text{FOV}/2)\).

\subsubsection{Parametric Ray Equation}\label{parametric-ray-equation}

A ray can be written as: \[\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}\]

where \(t \geq 0\) is the parameter. Points along the ray correspond to
different values of \(t\).

\subsubsection{Implementation}\label{implementation-3}

Let's start by visualizing our rays without any intersections:

\textbf{Shader 1: Ray Visualization}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Normalize pixel coordinates to [{-}1, 1]}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
    
    \CommentTok{// Correct for aspect ratio}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Field of view}
    \DataTypeTok{float}\NormalTok{ fov }\OperatorTok{=} \FloatTok{45.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ focalLength }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{/} \BuiltInTok{tan}\OperatorTok{(}\BuiltInTok{radians}\OperatorTok{(}\NormalTok{fov}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}
    
    \CommentTok{// Ray direction (camera at origin, looking down {-}Z)}
    \DataTypeTok{vec3}\NormalTok{ rayDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{focalLength}\OperatorTok{));}
    
    \CommentTok{// Color based on ray direction (visualize the rays)}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=}\NormalTok{ rayDir }\OperatorTok{*} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5}\OperatorTok{;}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see a colorful gradient showing the direction of each ray.
This confirms our camera setup is working!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Ray-Sphere Intersection}\label{ray-sphere-intersection}

\subsubsection{The Sphere Equation}\label{the-sphere-equation}

A sphere of radius \(r\) centered at position \(\mathbf{c}\) is defined
by: \[|\mathbf{p} - \mathbf{c}|^2 = r^2\]

All points \(\mathbf{p}\) satisfying this equation lie on the sphere's
surface.

\subsubsection{Finding the Intersection}\label{finding-the-intersection}

We want to find where our ray
\(\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}\) intersects the sphere.
Substituting the ray equation into the sphere equation:
\[|\mathbf{o} + t\mathbf{d} - \mathbf{c}|^2 = r^2\]

Let \(\mathbf{oc} = \mathbf{o} - \mathbf{c}\) (vector from sphere center
to ray origin). Expanding: \[|\mathbf{oc} + t\mathbf{d}|^2 = r^2\]
\[|\mathbf{oc}|^2 + 2t(\mathbf{oc} \cdot \mathbf{d}) + t^2|\mathbf{d}|^2 = r^2\]

This is a quadratic equation in \(t\): \[at^2 + bt + c = 0\]

where: - \(a = |\mathbf{d}|^2\) (equals 1 if direction is normalized) -
\(b = 2(\mathbf{oc} \cdot \mathbf{d})\) - \(c = |\mathbf{oc}|^2 - r^2\)

The \textbf{discriminant} \(\Delta = b^2 - 4ac\) tells us: -
\(\Delta < 0\): no intersection (ray misses sphere) - \(\Delta = 0\):
one intersection (ray grazes sphere) - \(\Delta > 0\): two intersections
(ray enters and exits)

We want the smaller positive \(t\) (the entry point).

\subsubsection{Implementation}\label{implementation-4}

\textbf{Shader 2: Basic Sphere}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{intersectSphere}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ rayOrigin}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rayDir}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ sphereCenter}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ oc }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{{-}}\NormalTok{ sphereCenter}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rayDir}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{);}  \CommentTok{// Should be 1.0 if rayDir is normalized}
    \DataTypeTok{float}\NormalTok{ b }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{oc}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ c }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{oc}\OperatorTok{,}\NormalTok{ oc}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ discriminant }\OperatorTok{=}\NormalTok{ b }\OperatorTok{*}\NormalTok{ b }\OperatorTok{{-}} \FloatTok{4.0} \OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ c}\OperatorTok{;}
    
    \KeywordTok{if} \OperatorTok{(}\NormalTok{discriminant }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}  \CommentTok{// No intersection}
    \OperatorTok{\}}
    
    \CommentTok{// Return the closer intersection}
    \DataTypeTok{float}\NormalTok{ t1 }\OperatorTok{=} \OperatorTok{({-}}\NormalTok{b }\OperatorTok{{-}} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{discriminant}\OperatorTok{))} \OperatorTok{/} \OperatorTok{(}\FloatTok{2.0} \OperatorTok{*}\NormalTok{ a}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ t2 }\OperatorTok{=} \OperatorTok{({-}}\NormalTok{b }\OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{discriminant}\OperatorTok{))} \OperatorTok{/} \OperatorTok{(}\FloatTok{2.0} \OperatorTok{*}\NormalTok{ a}\OperatorTok{);}
    
    \CommentTok{// Return closest positive t}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{t1 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ t1}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{t2 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ t2}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}  \CommentTok{// Both behind camera}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Setup ray}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ fov }\OperatorTok{=} \FloatTok{45.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ focalLength }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{/} \BuiltInTok{tan}\OperatorTok{(}\BuiltInTok{radians}\OperatorTok{(}\NormalTok{fov}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ rayOrigin }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ rayDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{focalLength}\OperatorTok{));}
    
    \CommentTok{// Sphere parameters}
    \DataTypeTok{vec3}\NormalTok{ sphereCenter }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ sphereRadius }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    
    \CommentTok{// Test intersection}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FunctionTok{intersectSphere}\OperatorTok{(}\NormalTok{rayOrigin}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{,}\NormalTok{ sphereCenter}\OperatorTok{,}\NormalTok{ sphereRadius}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// Hit the sphere}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Red}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
        \CommentTok{// Background}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}  \CommentTok{// Dark blue}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You should see a flat red disk! It looks 2D because we don't have
lighting yet---we can't see the sphere's curvature.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Adding Lighting}\label{adding-lighting}

To see the 3D structure, we need to compute lighting based on the
\textbf{surface normal}.

\subsubsection{Surface Normal}\label{surface-normal}

For a sphere centered at \(\mathbf{c}\), the outward normal at surface
point \(\mathbf{p}\) is:
\[\mathbf{n} = \frac{\mathbf{p} - \mathbf{c}}{r}\]

This is just the vector from center to surface, normalized.

\subsubsection{Diffuse Lighting}\label{diffuse-lighting}

The simplest lighting model: \textbf{Lambertian diffuse shading}.
Surface brightness depends on the angle between the normal
\(\mathbf{n}\) and light direction \(\mathbf{l}\):
\[\text{brightness} = \max(0, \mathbf{n} \cdot \mathbf{l})\]

The \(\max(0, \cdots)\) ensures surfaces facing away from the light
remain dark.

\textbf{Shader 3: Sphere with Lighting}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{intersectSphere}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ rayOrigin}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rayDir}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ sphereCenter}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ oc }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{{-}}\NormalTok{ sphereCenter}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rayDir}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ b }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{oc}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ c }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{oc}\OperatorTok{,}\NormalTok{ oc}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ discriminant }\OperatorTok{=}\NormalTok{ b }\OperatorTok{*}\NormalTok{ b }\OperatorTok{{-}} \FloatTok{4.0} \OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ c}\OperatorTok{;}
    
    \KeywordTok{if} \OperatorTok{(}\NormalTok{discriminant }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ t1 }\OperatorTok{=} \OperatorTok{({-}}\NormalTok{b }\OperatorTok{{-}} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{discriminant}\OperatorTok{))} \OperatorTok{/} \OperatorTok{(}\FloatTok{2.0} \OperatorTok{*}\NormalTok{ a}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ t2 }\OperatorTok{=} \OperatorTok{({-}}\NormalTok{b }\OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{discriminant}\OperatorTok{))} \OperatorTok{/} \OperatorTok{(}\FloatTok{2.0} \OperatorTok{*}\NormalTok{ a}\OperatorTok{);}
    
    \KeywordTok{if} \OperatorTok{(}\NormalTok{t1 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ t1}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{t2 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ t2}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec3} \FunctionTok{sphereNormal}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ hitPoint}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ sphereCenter}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{hitPoint }\OperatorTok{{-}}\NormalTok{ sphereCenter}\OperatorTok{)} \OperatorTok{/}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Setup ray}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ fov }\OperatorTok{=} \FloatTok{45.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ focalLength }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{/} \BuiltInTok{tan}\OperatorTok{(}\BuiltInTok{radians}\OperatorTok{(}\NormalTok{fov}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ rayOrigin }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ rayDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{focalLength}\OperatorTok{));}
    
    \CommentTok{// Sphere}
    \DataTypeTok{vec3}\NormalTok{ sphereCenter }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ sphereRadius }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FunctionTok{intersectSphere}\OperatorTok{(}\NormalTok{rayOrigin}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{,}\NormalTok{ sphereCenter}\OperatorTok{,}\NormalTok{ sphereRadius}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// Hit point}
        \DataTypeTok{vec3}\NormalTok{ hitPoint }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{+}\NormalTok{ t }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{;}
        
        \CommentTok{// Surface normal}
        \DataTypeTok{vec3}\NormalTok{ normal }\OperatorTok{=} \FunctionTok{sphereNormal}\OperatorTok{(}\NormalTok{hitPoint}\OperatorTok{,}\NormalTok{ sphereCenter}\OperatorTok{,}\NormalTok{ sphereRadius}\OperatorTok{);}
        
        \CommentTok{// Light direction (from above and to the right)}
        \DataTypeTok{vec3}\NormalTok{ lightDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{));}
        
        \CommentTok{// Diffuse lighting}
        \DataTypeTok{float}\NormalTok{ diffuse }\OperatorTok{=} \BuiltInTok{max}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{normal}\OperatorTok{,}\NormalTok{ lightDir}\OperatorTok{));}
        
        \CommentTok{// Sphere color}
        \DataTypeTok{vec3}\NormalTok{ sphereColor }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Red}
\NormalTok{        color }\OperatorTok{=}\NormalTok{ sphereColor }\OperatorTok{*}\NormalTok{ diffuse}\OperatorTok{;}
        
        \CommentTok{// Add ambient light so dark side isn\textquotesingle{}t completely black}
\NormalTok{        color }\OperatorTok{+=}\NormalTok{ sphereColor }\OperatorTok{*} \FloatTok{0.1}\OperatorTok{;}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Now the sphere looks 3D! The lighting reveals its curvature. Beautiful!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Ray-Torus Intersection: Where Analytical Gets
Complex}\label{ray-torus-intersection-where-analytical-gets-complex}

\subsubsection{The Torus Equation}\label{the-torus-equation}

A torus with major radius \(R\) (distance from center to tube center)
and minor radius \(r\) (tube thickness) has the implicit equation:
\[\left(\sqrt{x^2 + z^2} - R\right)^2 + y^2 = r^2\]

Or in vector form:
\[\left(|\mathbf{p}_{xz}| - R\right)^2 + p_y^2 = r^2\]

where \(\mathbf{p}_{xz} = (p_x, p_z)\) is the projection onto the
XZ-plane.

\subsubsection{The Challenge}\label{the-challenge}

Substituting our ray equation into this gives a \textbf{quartic
polynomial} (degree 4): \[at^4 + bt^3 + ct^2 + dt + e = 0\]

Unlike quadratics (which have a simple formula), quartic equations
require sophisticated algebraic methods. Here's what solving it actually
looks like:

\textbf{Shader 4: Analytical Torus}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// From Inigo Quilez {-} https://www.shadertoy.com/view/XdSGWy}
\CommentTok{// Analytical quartic solver for torus intersection}
\DataTypeTok{float} \FunctionTok{intersectTorus}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ ro}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rd}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ tor}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ po }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ Ra2 }\OperatorTok{=}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ ra2 }\OperatorTok{=}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ m }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{ro}\OperatorTok{,}\NormalTok{ ro}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ n }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{ro}\OperatorTok{,}\NormalTok{ rd}\OperatorTok{);}
    
    \CommentTok{// Bounding sphere check}
    \DataTypeTok{float}\NormalTok{ h }\OperatorTok{=}\NormalTok{ n}\OperatorTok{*}\NormalTok{n }\OperatorTok{{-}}\NormalTok{ m }\OperatorTok{+} \OperatorTok{(}\NormalTok{tor}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{*} \OperatorTok{(}\NormalTok{tor}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{h }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}
    
    \CommentTok{// Find quartic coefficients}
    \DataTypeTok{float}\NormalTok{ k }\OperatorTok{=} \OperatorTok{(}\NormalTok{m }\OperatorTok{{-}}\NormalTok{ ra2 }\OperatorTok{{-}}\NormalTok{ Ra2}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ k3 }\OperatorTok{=}\NormalTok{ n}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ k2 }\OperatorTok{=}\NormalTok{ n}\OperatorTok{*}\NormalTok{n }\OperatorTok{+}\NormalTok{ Ra2}\OperatorTok{*}\NormalTok{rd}\OperatorTok{.}\FunctionTok{z}\OperatorTok{*}\NormalTok{rd}\OperatorTok{.}\FunctionTok{z} \OperatorTok{+}\NormalTok{ k}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ k1 }\OperatorTok{=}\NormalTok{ k}\OperatorTok{*}\NormalTok{n }\OperatorTok{+}\NormalTok{ Ra2}\OperatorTok{*}\NormalTok{ro}\OperatorTok{.}\FunctionTok{z}\OperatorTok{*}\NormalTok{rd}\OperatorTok{.}\FunctionTok{z}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ k0 }\OperatorTok{=}\NormalTok{ k}\OperatorTok{*}\NormalTok{k }\OperatorTok{+}\NormalTok{ Ra2}\OperatorTok{*}\NormalTok{ro}\OperatorTok{.}\FunctionTok{z}\OperatorTok{*}\NormalTok{ro}\OperatorTok{.}\FunctionTok{z} \OperatorTok{{-}}\NormalTok{ Ra2}\OperatorTok{*}\NormalTok{ra2}\OperatorTok{;}
    
    \CommentTok{// Prevent numerical issues}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{k3}\OperatorTok{*(}\NormalTok{k3}\OperatorTok{*}\NormalTok{k3 }\OperatorTok{{-}}\NormalTok{ k2}\OperatorTok{)} \OperatorTok{+}\NormalTok{ k1}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.01}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        po }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ tmp }\OperatorTok{=}\NormalTok{ k1}\OperatorTok{;}\NormalTok{ k1 }\OperatorTok{=}\NormalTok{ k3}\OperatorTok{;}\NormalTok{ k3 }\OperatorTok{=}\NormalTok{ tmp}\OperatorTok{;}
\NormalTok{        k0 }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{/}\NormalTok{k0}\OperatorTok{;}
\NormalTok{        k1 }\OperatorTok{=}\NormalTok{ k1}\OperatorTok{*}\NormalTok{k0}\OperatorTok{;}
\NormalTok{        k2 }\OperatorTok{=}\NormalTok{ k2}\OperatorTok{*}\NormalTok{k0}\OperatorTok{;}
\NormalTok{        k3 }\OperatorTok{=}\NormalTok{ k3}\OperatorTok{*}\NormalTok{k0}\OperatorTok{;}
    \OperatorTok{\}}
    
    \DataTypeTok{float}\NormalTok{ c2 }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{*}\NormalTok{k2 }\OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{k3}\OperatorTok{*}\NormalTok{k3}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ c1 }\OperatorTok{=}\NormalTok{ k3}\OperatorTok{*(}\NormalTok{k3}\OperatorTok{*}\NormalTok{k3 }\OperatorTok{{-}}\NormalTok{ k2}\OperatorTok{)} \OperatorTok{+}\NormalTok{ k1}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ c0 }\OperatorTok{=}\NormalTok{ k3}\OperatorTok{*(}\NormalTok{k3}\OperatorTok{*({-}}\FloatTok{3.0}\OperatorTok{*}\NormalTok{k3}\OperatorTok{*}\NormalTok{k3 }\OperatorTok{+} \FloatTok{4.0}\OperatorTok{*}\NormalTok{k2}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{8.0}\OperatorTok{*}\NormalTok{k1}\OperatorTok{)} \OperatorTok{+} \FloatTok{4.0}\OperatorTok{*}\NormalTok{k0}\OperatorTok{;}
    
\NormalTok{    c2 }\OperatorTok{/=} \FloatTok{3.0}\OperatorTok{;}
\NormalTok{    c1 }\OperatorTok{*=} \FloatTok{2.0}\OperatorTok{;}
\NormalTok{    c0 }\OperatorTok{/=} \FloatTok{3.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ Q }\OperatorTok{=}\NormalTok{ c2}\OperatorTok{*}\NormalTok{c2 }\OperatorTok{+}\NormalTok{ c0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ R }\OperatorTok{=} \FloatTok{3.0}\OperatorTok{*}\NormalTok{c0}\OperatorTok{*}\NormalTok{c2 }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{*}\NormalTok{c2}\OperatorTok{*}\NormalTok{c2 }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{*}\NormalTok{c1}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ h2 }\OperatorTok{=}\NormalTok{ R}\OperatorTok{*}\NormalTok{R }\OperatorTok{{-}}\NormalTok{ Q}\OperatorTok{*}\NormalTok{Q}\OperatorTok{*}\NormalTok{Q}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ z }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{h2 }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}
    \OperatorTok{\{}
        \CommentTok{// 4 intersections}
        \DataTypeTok{float}\NormalTok{ sQ }\OperatorTok{=} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{Q}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{*}\NormalTok{sQ}\OperatorTok{*}\BuiltInTok{cos}\OperatorTok{(}\BuiltInTok{acos}\OperatorTok{(}\NormalTok{R}\OperatorTok{/(}\NormalTok{sQ}\OperatorTok{*}\NormalTok{Q}\OperatorTok{))} \OperatorTok{/} \FloatTok{3.0}\OperatorTok{);}
    \OperatorTok{\}}
    \KeywordTok{else}
    \OperatorTok{\{}
        \CommentTok{// 2 intersections}
        \DataTypeTok{float}\NormalTok{ sQ }\OperatorTok{=} \BuiltInTok{pow}\OperatorTok{(}\BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{h2}\OperatorTok{)} \OperatorTok{+} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{R}\OperatorTok{),} \FloatTok{1.0}\OperatorTok{/}\FloatTok{3.0}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \BuiltInTok{sign}\OperatorTok{(}\NormalTok{R}\OperatorTok{)*}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{sQ }\OperatorTok{+}\NormalTok{ Q}\OperatorTok{/}\NormalTok{sQ}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    z }\OperatorTok{=}\NormalTok{ c2 }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{c2}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=}\NormalTok{ z}\OperatorTok{*}\NormalTok{z }\OperatorTok{{-}} \FloatTok{3.0}\OperatorTok{*}\NormalTok{c0}\OperatorTok{;}
    
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{d1}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{1.0e{-}4}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{d2 }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}
\NormalTok{        d2 }\OperatorTok{=} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{d2}\OperatorTok{);}
    \OperatorTok{\}}
    \KeywordTok{else}
    \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{d1 }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}
\NormalTok{        d1 }\OperatorTok{=} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{d1}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{);}
\NormalTok{        d2 }\OperatorTok{=}\NormalTok{ c1}\OperatorTok{/}\NormalTok{d1}\OperatorTok{;}
    \OperatorTok{\}}
    
    \DataTypeTok{float}\NormalTok{ result }\OperatorTok{=} \FloatTok{1e20}\OperatorTok{;}
    
\NormalTok{    h2 }\OperatorTok{=}\NormalTok{ d1}\OperatorTok{*}\NormalTok{d1 }\OperatorTok{{-}}\NormalTok{ z }\OperatorTok{+}\NormalTok{ d2}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{h2 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        h2 }\OperatorTok{=} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{h2}\OperatorTok{);}
        \DataTypeTok{float}\NormalTok{ t1 }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{d1 }\OperatorTok{{-}}\NormalTok{ h2 }\OperatorTok{{-}}\NormalTok{ k3}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ t2 }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{d1 }\OperatorTok{+}\NormalTok{ h2 }\OperatorTok{{-}}\NormalTok{ k3}\OperatorTok{;}
\NormalTok{        t1 }\OperatorTok{=} \OperatorTok{(}\NormalTok{po }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \FloatTok{2.0}\OperatorTok{/}\NormalTok{t1 }\OperatorTok{:}\NormalTok{ t1}\OperatorTok{;}
\NormalTok{        t2 }\OperatorTok{=} \OperatorTok{(}\NormalTok{po }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \FloatTok{2.0}\OperatorTok{/}\NormalTok{t2 }\OperatorTok{:}\NormalTok{ t2}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t1 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ result }\OperatorTok{=}\NormalTok{ t1}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t2 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ result }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\NormalTok{result}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    h2 }\OperatorTok{=}\NormalTok{ d1}\OperatorTok{*}\NormalTok{d1 }\OperatorTok{{-}}\NormalTok{ z }\OperatorTok{{-}}\NormalTok{ d2}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{h2 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        h2 }\OperatorTok{=} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{h2}\OperatorTok{);}
        \DataTypeTok{float}\NormalTok{ t1 }\OperatorTok{=}\NormalTok{ d1 }\OperatorTok{{-}}\NormalTok{ h2 }\OperatorTok{{-}}\NormalTok{ k3}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ t2 }\OperatorTok{=}\NormalTok{ d1 }\OperatorTok{+}\NormalTok{ h2 }\OperatorTok{{-}}\NormalTok{ k3}\OperatorTok{;}
\NormalTok{        t1 }\OperatorTok{=} \OperatorTok{(}\NormalTok{po }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \FloatTok{2.0}\OperatorTok{/}\NormalTok{t1 }\OperatorTok{:}\NormalTok{ t1}\OperatorTok{;}
\NormalTok{        t2 }\OperatorTok{=} \OperatorTok{(}\NormalTok{po }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \FloatTok{2.0}\OperatorTok{/}\NormalTok{t2 }\OperatorTok{:}\NormalTok{ t2}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t1 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ result }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\NormalTok{result}\OperatorTok{,}\NormalTok{ t1}\OperatorTok{);}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t2 }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ result }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\NormalTok{result}\OperatorTok{,}\NormalTok{ t2}\OperatorTok{);}
    \OperatorTok{\}}
    
    \KeywordTok{return}\NormalTok{ result}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec3} \FunctionTok{torusNormal}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ pos}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ tor}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{normalize}\OperatorTok{(}\NormalTok{pos }\OperatorTok{*} \OperatorTok{(}\BuiltInTok{dot}\OperatorTok{(}\NormalTok{pos}\OperatorTok{,}\NormalTok{pos}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{y}\OperatorTok{*}\NormalTok{tor}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ tor}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{tor}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,}\FloatTok{1.0}\OperatorTok{,{-}}\FloatTok{1.0}\OperatorTok{)));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Setup ray}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ fov }\OperatorTok{=} \FloatTok{45.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ focalLength }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{/} \BuiltInTok{tan}\OperatorTok{(}\BuiltInTok{radians}\OperatorTok{(}\NormalTok{fov}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ rayOrigin }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ rayDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{focalLength}\OperatorTok{));}
    
    \CommentTok{// Torus parameters}
    \DataTypeTok{vec2}\NormalTok{ torus }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.4}\OperatorTok{);}  \CommentTok{// (major radius, minor radius)}
    \DataTypeTok{vec3}\NormalTok{ torusCenter }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.5}\OperatorTok{);}
    
    \CommentTok{// Adjust ray for torus position}
    \DataTypeTok{vec3}\NormalTok{ ro }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{{-}}\NormalTok{ torusCenter}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FunctionTok{intersectTorus}\OperatorTok{(}\NormalTok{ro}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{,}\NormalTok{ torus}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ hitPoint }\OperatorTok{=}\NormalTok{ ro }\OperatorTok{+}\NormalTok{ t }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{;}
        \DataTypeTok{vec3}\NormalTok{ normal }\OperatorTok{=} \FunctionTok{torusNormal}\OperatorTok{(}\NormalTok{hitPoint}\OperatorTok{,}\NormalTok{ torus}\OperatorTok{);}
        
        \DataTypeTok{vec3}\NormalTok{ lightDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{));}
        \DataTypeTok{float}\NormalTok{ diffuse }\OperatorTok{=} \BuiltInTok{max}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{normal}\OperatorTok{,}\NormalTok{ lightDir}\OperatorTok{));}
        
        \DataTypeTok{vec3}\NormalTok{ torusColor }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Cyan}
\NormalTok{        color }\OperatorTok{=}\NormalTok{ torusColor }\OperatorTok{*}\NormalTok{ diffuse }\OperatorTok{+}\NormalTok{ torusColor }\OperatorTok{*} \FloatTok{0.1}\OperatorTok{;}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Look at that intersection code! Over 80 lines of complex algebra just to
render one torus. And this is still a relatively simple
surface---imagine arbitrary algebraic varieties, or trying to combine
multiple objects with boolean operations.

Analytical methods work beautifully for simple geometry, but we need a
more flexible approach for complex scenes.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Part 2: Signed Distance Functions and
Raymarching}\label{part-2-signed-distance-functions-and-raymarching}

\subsection{Introduction to SDFs}\label{introduction-to-sdfs}

A \textbf{signed distance function} (SDF) gives the distance from any
point in space to the nearest surface:

\[d(\mathbf{p}) = \begin{cases}
> 0 & \text{outside surface} \\
= 0 & \text{on surface} \\
< 0 & \text{inside surface}
\end{cases}\]

Crucially, \(|d(\mathbf{p})|\) is the actual Euclidean distance to the
surface.

\subsubsection{Why SDFs?}\label{why-sdfs}

SDFs have a powerful property: if we're at point \(\mathbf{p}\) and the
surface is distance \(d\) away, we can safely move \(d\) units in
\emph{any} direction without hitting anything. This enables
\textbf{sphere tracing}---we march along the ray taking steps
proportional to the SDF value.

\subsubsection{SDF Examples}\label{sdf-examples}

Let's see SDFs for shapes we've already rendered analytically:

\textbf{Sphere:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{sdSphere}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compare this to our 30+ line analytical intersection! Much simpler.

\textbf{Torus:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{sdTorus}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ majorRadius}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ minorRadius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ q }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ pxz }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{q}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ q}\OperatorTok{.}\FunctionTok{z}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{pxz}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ majorRadius}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{d}\OperatorTok{,}\NormalTok{ q}\OperatorTok{.}\FunctionTok{y}\OperatorTok{))} \OperatorTok{{-}}\NormalTok{ minorRadius}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Again, dramatically simpler than the quartic solver!

\textbf{Other Primitives}

Many more SDFs exist: boxes, cylinders, capsules, cones, pyramids, etc.
See \href{https://iquilezles.org/articles/distfunctions/}{Inigo Quilez's
comprehensive library} for a complete reference. Each SDF is typically
just a few lines of code.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{The Raymarching Algorithm}\label{the-raymarching-algorithm}

\textbf{Sphere tracing} works like this:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Start at the ray origin
\item
  Evaluate the SDF at current position
\item
  March forward along the ray by that distance (safe step!)
\item
  Repeat until:

  \begin{itemize}
  \tightlist
  \item
    Very close to surface (SDF ≈ 0) → hit!
  \item
    Too far away → miss
  \item
    Too many steps → give up
  \end{itemize}
\end{enumerate}

Here's the algorithm:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{sceneSDF}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Define scene geometry (we\textquotesingle{}ll implement this)}
    \KeywordTok{return} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{bool} \FunctionTok{raymarch}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ rayOrigin}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rayDir}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{float}\NormalTok{ hitDist}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{vec3}\NormalTok{ hitPos}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ pos }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{+}\NormalTok{ t }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{pos}\OperatorTok{);}
        
        \CommentTok{// Close enough to surface?}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{d}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.001}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            hitDist }\OperatorTok{=}\NormalTok{ t}\OperatorTok{;}
\NormalTok{            hitPos }\OperatorTok{=}\NormalTok{ pos}\OperatorTok{;}
            \KeywordTok{return} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        
        \CommentTok{// March forward}
\NormalTok{        t }\OperatorTok{+=}\NormalTok{ d}\OperatorTok{;}
        
        \CommentTok{// Too far?}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{100.0}\OperatorTok{)} \OperatorTok{\{}
            \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
    
    \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Normal Estimation via
Gradient}\label{normal-estimation-via-gradient}

For an SDF \(d(\mathbf{p})\), the gradient \(\nabla d\) points
perpendicular to the surface (it's the normal direction). We estimate it
using finite differences:

\[\frac{\partial d}{\partial x} \approx \frac{d(x + \epsilon, y, z) - d(x - \epsilon, y, z)}{2\epsilon}\]

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3} \FunctionTok{estimateNormal}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.001}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ dx }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dy }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dz }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{));}
    \KeywordTok{return} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{dx}\OperatorTok{,}\NormalTok{ dy}\OperatorTok{,}\NormalTok{ dz}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{First Raymarch Shader}\label{first-raymarch-shader}

\textbf{Shader 5: Single Sphere with Raymarching}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{sdSphere}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{sceneSDF}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \FunctionTok{sdSphere}\OperatorTok{(}\NormalTok{p}\OperatorTok{,} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.0}\OperatorTok{),} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec3} \FunctionTok{estimateNormal}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.001}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ dx }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dy }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dz }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{));}
    \KeywordTok{return} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{dx}\OperatorTok{,}\NormalTok{ dy}\OperatorTok{,}\NormalTok{ dz}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{bool} \FunctionTok{raymarch}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ rayOrigin}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rayDir}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{vec3}\NormalTok{ hitPos}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ pos }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{+}\NormalTok{ t }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{pos}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{d}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.001}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            hitPos }\OperatorTok{=}\NormalTok{ pos}\OperatorTok{;}
            \KeywordTok{return} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        
\NormalTok{        t }\OperatorTok{+=}\NormalTok{ d}\OperatorTok{;}
        
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{100.0}\OperatorTok{)} \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
    \OperatorTok{\}}
    
    \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Setup ray}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ fov }\OperatorTok{=} \FloatTok{45.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ focalLength }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{/} \BuiltInTok{tan}\OperatorTok{(}\BuiltInTok{radians}\OperatorTok{(}\NormalTok{fov}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ rayOrigin }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ rayDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{focalLength}\OperatorTok{));}
    
    \CommentTok{// Raymarch}
    \DataTypeTok{vec3}\NormalTok{ hitPos}\OperatorTok{;}
    \DataTypeTok{bool}\NormalTok{ hit }\OperatorTok{=} \FunctionTok{raymarch}\OperatorTok{(}\NormalTok{rayOrigin}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{,}\NormalTok{ hitPos}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{hit}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ normal }\OperatorTok{=} \FunctionTok{estimateNormal}\OperatorTok{(}\NormalTok{hitPos}\OperatorTok{);}
        \DataTypeTok{vec3}\NormalTok{ lightDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{));}
        \DataTypeTok{float}\NormalTok{ diffuse }\OperatorTok{=} \BuiltInTok{max}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{normal}\OperatorTok{,}\NormalTok{ lightDir}\OperatorTok{));}
        
        \DataTypeTok{vec3}\NormalTok{ sphereColor }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
\NormalTok{        color }\OperatorTok{=}\NormalTok{ sphereColor }\OperatorTok{*}\NormalTok{ diffuse }\OperatorTok{+}\NormalTok{ sphereColor }\OperatorTok{*} \FloatTok{0.1}\OperatorTok{;}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Same result as the analytical sphere, but now we have a flexible
framework!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{The Power of SDFs: Instant Shape
Swapping}\label{the-power-of-sdfs-instant-shape-swapping}

Here's where SDFs shine: \textbf{changing shapes is trivial}. Just swap
out one SDF for another!

\textbf{Shader 6: Shapeshifting}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{sdSphere}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{sdTorus}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ majorRadius}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ minorRadius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ q }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ pxz }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{q}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ q}\OperatorTok{.}\FunctionTok{z}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{pxz}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ majorRadius}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{d}\OperatorTok{,}\NormalTok{ q}\OperatorTok{.}\FunctionTok{y}\OperatorTok{))} \OperatorTok{{-}}\NormalTok{ minorRadius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{sdBox}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ halfExtents}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ q }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ halfExtents}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\BuiltInTok{max}\OperatorTok{(}\NormalTok{q}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{))} \OperatorTok{+} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{max}\OperatorTok{(}\NormalTok{q}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,} \BuiltInTok{max}\OperatorTok{(}\NormalTok{q}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}\NormalTok{ q}\OperatorTok{.}\FunctionTok{z}\OperatorTok{)),} \FloatTok{0.0}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{sceneSDF}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// Uncomment ONE of these to see different shapes!}
    \CommentTok{// Everything else stays the same {-} same raymarch, same lighting, same normal calculation}
    
    \KeywordTok{return} \FunctionTok{sdSphere}\OperatorTok{(}\NormalTok{p}\OperatorTok{,} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.0}\OperatorTok{),} \FloatTok{1.0}\OperatorTok{);}
    \CommentTok{//return sdTorus(p, vec3(0.0, 0.0, {-}3.0), 1.0, 0.4);}
    \CommentTok{//return sdBox(p, vec3(0.0, 0.0, {-}3.0), vec3(0.8, 0.8, 0.8));}
    
    \CommentTok{// Try any SDF from https://iquilezles.org/articles/distfunctions/}
\OperatorTok{\}}

\DataTypeTok{vec3} \FunctionTok{estimateNormal}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.001}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ dx }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dy }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dz }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{));}
    \KeywordTok{return} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{dx}\OperatorTok{,}\NormalTok{ dy}\OperatorTok{,}\NormalTok{ dz}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{bool} \FunctionTok{raymarch}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ rayOrigin}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rayDir}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{vec3}\NormalTok{ hitPos}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ pos }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{+}\NormalTok{ t }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{pos}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{d}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.001}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            hitPos }\OperatorTok{=}\NormalTok{ pos}\OperatorTok{;}
            \KeywordTok{return} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        
\NormalTok{        t }\OperatorTok{+=}\NormalTok{ d}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{100.0}\OperatorTok{)} \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
    \OperatorTok{\}}
    
    \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ fov }\OperatorTok{=} \FloatTok{45.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ focalLength }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{/} \BuiltInTok{tan}\OperatorTok{(}\BuiltInTok{radians}\OperatorTok{(}\NormalTok{fov}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ rayOrigin }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ rayDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{focalLength}\OperatorTok{));}
    
    \DataTypeTok{vec3}\NormalTok{ hitPos}\OperatorTok{;}
    \DataTypeTok{bool}\NormalTok{ hit }\OperatorTok{=} \FunctionTok{raymarch}\OperatorTok{(}\NormalTok{rayOrigin}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{,}\NormalTok{ hitPos}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{hit}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ normal }\OperatorTok{=} \FunctionTok{estimateNormal}\OperatorTok{(}\NormalTok{hitPos}\OperatorTok{);}
        \DataTypeTok{vec3}\NormalTok{ lightDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{));}
        \DataTypeTok{float}\NormalTok{ diffuse }\OperatorTok{=} \BuiltInTok{max}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{normal}\OperatorTok{,}\NormalTok{ lightDir}\OperatorTok{));}
        
        \DataTypeTok{vec3}\NormalTok{ objectColor }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Cyan}
\NormalTok{        color }\OperatorTok{=}\NormalTok{ objectColor }\OperatorTok{*}\NormalTok{ diffuse }\OperatorTok{+}\NormalTok{ objectColor }\OperatorTok{*} \FloatTok{0.1}\OperatorTok{;}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Comment/uncomment different SDFs in \texttt{sceneSDF()} to instantly see
different shapes! Try adding more from Quilez's library. The raymarching
algorithm doesn't care what shape you use---it just follows the distance
field.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Composing Multiple
Objects}\label{composing-multiple-objects}

To combine multiple objects, we simply take the \textbf{minimum
distance} to any object. The closest surface wins!

\textbf{Shader 7: Multiple Objects with Materials}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{sdSphere}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{sdTorus}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ majorRadius}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ minorRadius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ q }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ pxz }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{q}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ q}\OperatorTok{.}\FunctionTok{z}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{pxz}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ majorRadius}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{d}\OperatorTok{,}\NormalTok{ q}\OperatorTok{.}\FunctionTok{y}\OperatorTok{))} \OperatorTok{{-}}\NormalTok{ minorRadius}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{sdPlane}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ height}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ height}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Global variable to track which object we hit}
\DataTypeTok{float}\NormalTok{ gMaterialID}\OperatorTok{;}

\DataTypeTok{float} \FunctionTok{sceneSDF}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FloatTok{1e10}\OperatorTok{;}  \CommentTok{// Start with very large distance}
    
    \CommentTok{// Sphere}
    \DataTypeTok{float}\NormalTok{ sphere }\OperatorTok{=} \FunctionTok{sdSphere}\OperatorTok{(}\NormalTok{p}\OperatorTok{,} \DataTypeTok{vec3}\OperatorTok{({-}}\FloatTok{1.2}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.5}\OperatorTok{),} \FloatTok{0.8}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{sphere }\OperatorTok{\textless{}}\NormalTok{ d}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        d }\OperatorTok{=}\NormalTok{ sphere}\OperatorTok{;}
\NormalTok{        gMaterialID }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Torus}
    \DataTypeTok{float}\NormalTok{ torus }\OperatorTok{=} \FunctionTok{sdTorus}\OperatorTok{(}\NormalTok{p}\OperatorTok{,} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.2}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.5}\OperatorTok{),} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{torus }\OperatorTok{\textless{}}\NormalTok{ d}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        d }\OperatorTok{=}\NormalTok{ torus}\OperatorTok{;}
\NormalTok{        gMaterialID }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Ground plane}
    \DataTypeTok{float}\NormalTok{ plane }\OperatorTok{=} \FunctionTok{sdPlane}\OperatorTok{(}\NormalTok{p}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{plane }\OperatorTok{\textless{}}\NormalTok{ d}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        d }\OperatorTok{=}\NormalTok{ plane}\OperatorTok{;}
\NormalTok{        gMaterialID }\OperatorTok{=} \FloatTok{3.0}\OperatorTok{;}
    \OperatorTok{\}}
    
    \KeywordTok{return}\NormalTok{ d}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec3} \FunctionTok{getMaterialColor}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ matID}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{matID }\OperatorTok{\textless{}} \FloatTok{1.5}\OperatorTok{)} \KeywordTok{return} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}      \CommentTok{// Sphere: red}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{matID }\OperatorTok{\textless{}} \FloatTok{2.5}\OperatorTok{)} \KeywordTok{return} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}      \CommentTok{// Torus: cyan}
    \KeywordTok{return} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}                       \CommentTok{// Plane: gray}
\OperatorTok{\}}

\DataTypeTok{vec3} \FunctionTok{estimateNormal}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.001}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ dx }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dy }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dz }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{));}
    \KeywordTok{return} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{dx}\OperatorTok{,}\NormalTok{ dy}\OperatorTok{,}\NormalTok{ dz}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{bool} \FunctionTok{raymarch}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ rayOrigin}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rayDir}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{vec3}\NormalTok{ hitPos}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{float}\NormalTok{ matID}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ pos }\OperatorTok{=}\NormalTok{ rayOrigin }\OperatorTok{+}\NormalTok{ t }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{pos}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{d}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.001}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            hitPos }\OperatorTok{=}\NormalTok{ pos}\OperatorTok{;}
\NormalTok{            matID }\OperatorTok{=}\NormalTok{ gMaterialID}\OperatorTok{;}
            \KeywordTok{return} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        
\NormalTok{        t }\OperatorTok{+=}\NormalTok{ d}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{100.0}\OperatorTok{)} \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
    \OperatorTok{\}}
    
    \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ fov }\OperatorTok{=} \FloatTok{45.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ focalLength }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{/} \BuiltInTok{tan}\OperatorTok{(}\BuiltInTok{radians}\OperatorTok{(}\NormalTok{fov}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ rayOrigin }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ rayDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{focalLength}\OperatorTok{));}
    
    \DataTypeTok{vec3}\NormalTok{ hitPos}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ matID}\OperatorTok{;}
    \DataTypeTok{bool}\NormalTok{ hit }\OperatorTok{=} \FunctionTok{raymarch}\OperatorTok{(}\NormalTok{rayOrigin}\OperatorTok{,}\NormalTok{ rayDir}\OperatorTok{,}\NormalTok{ hitPos}\OperatorTok{,}\NormalTok{ matID}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{hit}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{vec3}\NormalTok{ normal }\OperatorTok{=} \FunctionTok{estimateNormal}\OperatorTok{(}\NormalTok{hitPos}\OperatorTok{);}
        \DataTypeTok{vec3}\NormalTok{ lightDir }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{));}
        \DataTypeTok{float}\NormalTok{ diffuse }\OperatorTok{=} \BuiltInTok{max}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{normal}\OperatorTok{,}\NormalTok{ lightDir}\OperatorTok{));}
        
        \DataTypeTok{vec3}\NormalTok{ objectColor }\OperatorTok{=} \FunctionTok{getMaterialColor}\OperatorTok{(}\NormalTok{matID}\OperatorTok{);}
\NormalTok{        color }\OperatorTok{=}\NormalTok{ objectColor }\OperatorTok{*}\NormalTok{ diffuse }\OperatorTok{+}\NormalTok{ objectColor }\OperatorTok{*} \FloatTok{0.1}\OperatorTok{;}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Three objects with different colors! Adding more objects is
trivial---just add another SDF check in \texttt{sceneSDF()}. Compare
this to analytical methods where combining objects requires
sophisticated CSG (constructive solid geometry) techniques.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Summary}\label{summary-3}

Today we learned two approaches to 3D rendering:

\textbf{Analytical Ray Tracing:} - Solve equations directly for
ray-surface intersection - Exact solutions, very efficient for simple
geometry - Sphere: straightforward quadratic equation - Torus: complex
quartic equation requiring sophisticated algebra - Becomes increasingly
difficult for complex surfaces - Standard in production ray tracers for
well-defined geometry

\textbf{SDF-Based Raymarching:} - Represent surfaces as distance fields
- March along rays using sphere tracing - Simple, uniform code for any
geometry - Easy composition: just take minimum distance -
Flexible---works for procedural, implicit, or arbitrary surfaces -
Slightly slower than analytical, but much more versatile

\textbf{Key Concepts:} - Camera setup and ray generation - Parametric
ray equation: \(\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}\) - Surface
normals for lighting - Diffuse (Lambertian) shading - Signed distance
functions (SDFs) - Sphere tracing algorithm - Normal estimation via
gradient (finite differences) - Material tracking for multiple objects

Tomorrow we'll explore advanced raymarching: domain operations for
infinite repetition, boolean operations for smooth blending, and 3D
fractals!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Homework}\label{homework-9}

\subsection{Required: Algebraic Variety
Rendering}\label{required-algebraic-variety-rendering}

Implement analytical ray tracing for an interesting polynomial implicit
surface.

\textbf{Goal:} Experience the challenges of analytical methods
firsthand, then appreciate SDFs even more!

\textbf{Suggested surfaces:} - \textbf{Degree 3}: Saddle surfaces, cubic
varieties - \textbf{Degree 4}: Klein bottle projections, quartic
surfaces with interesting topology - \textbf{Cassini ovals} in 3D:
\((x^2 + y^2 + z^2)^2 - 2a^2(x^2 - y^2) = b^4 - a^4\)

\textbf{Implementation steps:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Define your implicit function} \(F(x,y,z) = 0\)
\end{enumerate}

Example---a quartic surface:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{implicitFunction}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ r2 }\OperatorTok{*}\NormalTok{ r2 }\OperatorTok{{-}} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \FloatTok{2.0}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{z}\OperatorTok{*}\NormalTok{p}\OperatorTok{.}\FunctionTok{z}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{Implement root finding} (bisection method)
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{intersectImplicit}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ rayOrigin}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ rayDir}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ tMin }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ tMax }\OperatorTok{=} \FloatTok{10.0}\OperatorTok{;}
    
    \CommentTok{// Check for sign change}
    \DataTypeTok{float}\NormalTok{ fMin }\OperatorTok{=} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{rayOrigin }\OperatorTok{+}\NormalTok{ tMin }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ fMax }\OperatorTok{=} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{rayOrigin }\OperatorTok{+}\NormalTok{ tMax }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{fMin }\OperatorTok{*}\NormalTok{ fMax }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}  \CommentTok{// No root}
    
    \CommentTok{// Bisection}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{float}\NormalTok{ tMid }\OperatorTok{=} \OperatorTok{(}\NormalTok{tMin }\OperatorTok{+}\NormalTok{ tMax}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ fMid }\OperatorTok{=} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{rayOrigin }\OperatorTok{+}\NormalTok{ tMid }\OperatorTok{*}\NormalTok{ rayDir}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{fMid}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.001}\OperatorTok{)} \KeywordTok{return}\NormalTok{ tMid}\OperatorTok{;}
        
        \KeywordTok{if}\OperatorTok{(}\NormalTok{fMin }\OperatorTok{*}\NormalTok{ fMid }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            tMax }\OperatorTok{=}\NormalTok{ tMid}\OperatorTok{;}
\NormalTok{            fMax }\OperatorTok{=}\NormalTok{ fMid}\OperatorTok{;}
        \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{            tMin }\OperatorTok{=}\NormalTok{ tMid}\OperatorTok{;}
\NormalTok{            fMin }\OperatorTok{=}\NormalTok{ fMid}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
    
    \KeywordTok{return} \OperatorTok{(}\NormalTok{tMin }\OperatorTok{+}\NormalTok{ tMax}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  \textbf{Compute normal via gradient}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3} \FunctionTok{implicitNormal}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ eps }\OperatorTok{=} \FloatTok{0.001}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ dx }\OperatorTok{=} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dy }\OperatorTok{=} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{,} \DecValTok{0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ dz }\OperatorTok{=} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{p }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{))} \OperatorTok{{-}} \FunctionTok{implicitFunction}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ eps}\OperatorTok{));}
    \KeywordTok{return} \BuiltInTok{normalize}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\NormalTok{dx}\OperatorTok{,}\NormalTok{ dy}\OperatorTok{,}\NormalTok{ dz}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  \textbf{Optimization: Bounding volume} (optional but recommended)
\end{enumerate}

Use a bounding sphere to avoid checking the entire ray:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// First check if ray intersects bounding sphere}
\CommentTok{// Only compute implicit function if inside bounds}
\end{Highlighting}
\end{Shaded}

\textbf{Expected output:} A rendered algebraic surface with proper
lighting showing its geometric features.

\textbf{Reflection question:} After implementing this, compare the
effort to using SDFs. Which approach would you prefer for a complex
scene with many objects?

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{Optional Exercises}\label{optional-exercises-1}

\subsubsection{1. Specular Lighting (Phong
Model)}\label{specular-lighting-phong-model}

Add shiny highlights using the Phong reflection model:

\[\text{specular} = (R \cdot V)^n\]

where \(R\) is reflected light direction, \(V\) is view direction, \(n\)
is shininess.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec3}\NormalTok{ R }\OperatorTok{=} \BuiltInTok{reflect}\OperatorTok{({-}}\NormalTok{lightDir}\OperatorTok{,}\NormalTok{ normal}\OperatorTok{);}  \CommentTok{// Reflected light}
\DataTypeTok{vec3}\NormalTok{ V }\OperatorTok{=} \OperatorTok{{-}}\NormalTok{rayDir}\OperatorTok{;}                      \CommentTok{// View direction}
\DataTypeTok{float}\NormalTok{ spec }\OperatorTok{=} \BuiltInTok{pow}\OperatorTok{(}\BuiltInTok{max}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{R}\OperatorTok{,}\NormalTok{ V}\OperatorTok{)),} \FloatTok{32.0}\OperatorTok{);}
\NormalTok{color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{)} \OperatorTok{*}\NormalTok{ spec }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// White specular highlight}
\end{Highlighting}
\end{Shaded}

Try different shininess values (8, 16, 32, 64, 128) to see the effect!

\subsubsection{2. Camera Movement}\label{camera-movement}

Implement an orbiting camera using time:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ angle }\OperatorTok{=}\NormalTok{ iTime }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{;}
\DataTypeTok{vec3}\NormalTok{ rayOrigin }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{3.0} \OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\NormalTok{angle}\OperatorTok{),} \FloatTok{1.0}\OperatorTok{,} \FloatTok{3.0} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{angle}\OperatorTok{));}

\CommentTok{// Look{-}at matrix}
\DataTypeTok{vec3}\NormalTok{ target }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{3.0}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ forward }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\NormalTok{target }\OperatorTok{{-}}\NormalTok{ rayOrigin}\OperatorTok{);}
\DataTypeTok{vec3}\NormalTok{ right }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\BuiltInTok{cross}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{0}\OperatorTok{),}\NormalTok{ forward}\OperatorTok{));}
\DataTypeTok{vec3}\NormalTok{ up }\OperatorTok{=} \BuiltInTok{cross}\OperatorTok{(}\NormalTok{forward}\OperatorTok{,}\NormalTok{ right}\OperatorTok{);}

\CommentTok{// Transform ray direction}
\DataTypeTok{vec3}\NormalTok{ rd }\OperatorTok{=} \BuiltInTok{normalize}\OperatorTok{(}\NormalTok{uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ right }\OperatorTok{+}\NormalTok{ uv}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ up }\OperatorTok{+}\NormalTok{ focalLength }\OperatorTok{*}\NormalTok{ forward}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{3. Complex SDF Scene}\label{complex-sdf-scene}

Create a scene with 5+ objects using different SDFs from
\href{https://iquilezles.org/articles/distfunctions/}{Quilez's library}:
- Mix primitives: spheres, boxes, cylinders, tori, cones - Position them
creatively - Use different materials - Add interesting lighting

\subsubsection{4. Soft Shadows (Preview of Day
5)}\label{soft-shadows-preview-of-day-5}

Cast rays from the surface toward the light to check for occlusion:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{softShadow}\OperatorTok{(}\DataTypeTok{vec3}\NormalTok{ pos}\OperatorTok{,} \DataTypeTok{vec3}\NormalTok{ lightDir}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \FloatTok{0.01}\OperatorTok{;}  \CommentTok{// Start slightly above surface}
    \DataTypeTok{float}\NormalTok{ shadow }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FunctionTok{sceneSDF}\OperatorTok{(}\NormalTok{pos }\OperatorTok{+}\NormalTok{ lightDir }\OperatorTok{*}\NormalTok{ t}\OperatorTok{);}
\NormalTok{        shadow }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\NormalTok{shadow}\OperatorTok{,} \FloatTok{8.0} \OperatorTok{*}\NormalTok{ d }\OperatorTok{/}\NormalTok{ t}\OperatorTok{);}  \CommentTok{// Penumbra factor}
\NormalTok{        t }\OperatorTok{+=}\NormalTok{ d}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{t }\OperatorTok{\textgreater{}} \FloatTok{10.0} \OperatorTok{||}\NormalTok{ d }\OperatorTok{\textless{}} \FloatTok{0.001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
    \OperatorTok{\}}
    
    \KeywordTok{return} \BuiltInTok{clamp}\OperatorTok{(}\NormalTok{shadow}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Apply this to your diffuse lighting for more realistic shadows!

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Looking Ahead to Day 5}\label{looking-ahead-to-day-5}

Tomorrow we'll explore advanced raymarching techniques that would be
nearly impossible with analytical methods:

\begin{itemize}
\tightlist
\item
  \textbf{Domain operations}: Infinite repetition, symmetry, twisting
\item
  \textbf{Boolean operations}: Union, intersection, smooth blending
\item
  \textbf{3D fractals}: Menger sponge, Mandelbulb via iterated
  transformations
\item
  \textbf{Advanced lighting}: Ambient occlusion, global illumination
\end{itemize}

Make sure you're comfortable with: - The raymarching algorithm (it's the
foundation) - How SDFs compose (taking minimum/maximum) - Normal
estimation via gradients - The material tracking pattern we developed

See you tomorrow!

\bookmarksetup{startatroot}

\chapter{Day 5a}\label{day-5a}

\bookmarksetup{startatroot}

\chapter{Day 5bs}\label{day-5bs}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{part}{Appendices}
\appendix

\chapter{Appendix: Complete Shader Code for Day
1}\label{appendix-complete-shader-code-for-day-1}

This appendix provides complete, standalone Shadertoy code for each
shader program presented in Day 1. Each listing includes all necessary
setup and can be copied directly into Shadertoy
(https://www.shadertoy.com/new) and run immediately.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A1. Basic Red Screen}\label{a1.-basic-red-screen}

The simplest possible shader - every pixel is red.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A2. Animated Color (Pulsing
Red)}\label{a2.-animated-color-pulsing-red}

Using \texttt{iTime} to animate the red channel.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ red }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{red}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A3. Coordinate
Visualization}\label{a3.-coordinate-visualization}

Visualizing the coordinate system by mapping position to color.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Map x coordinate to red, y to green}
    \DataTypeTok{vec2}\NormalTok{ color\_rg }\OperatorTok{=}\NormalTok{ p }\OperatorTok{*} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Remap to [0, 1]}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color\_rg}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A4. Half-Plane Coloring (Ternary
Operator)}\label{a4.-half-plane-coloring-ternary-operator}

Dividing the plane into two regions based on a linear function.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ L }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}  \CommentTok{// The function L(x,y) = x}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{L }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A5. Half-Plane with Step
Function}\label{a5.-half-plane-with-step-function}

Same as above but using \texttt{step()} and \texttt{mix()}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ s }\OperatorTok{=} \BuiltInTok{step}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}  \CommentTok{// 0 on left, 1 on right}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{),}\NormalTok{ s}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A6. Arbitrary Half-Plane}\label{a6.-arbitrary-half-plane}

Dividing along an arbitrary line \(ax + by + c = 0\).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{,}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ L }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{L }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A7. Filled Circle}\label{a7.-filled-circle}

Using distance from origin to create a disk.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A8. Distance-Based Coloring (Radial
Gradient)}\label{a8.-distance-based-coloring-radial-gradient}

Using distance value itself to create a gradient.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ intensity }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ d }\OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}  \CommentTok{// Fades from 1 at center to 0 at distance 2}
\NormalTok{    intensity }\OperatorTok{=} \BuiltInTok{clamp}\OperatorTok{(}\NormalTok{intensity}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Keep it in [0, 1]}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{intensity}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A9. Circle Outline (Hard
Edge)}\label{a9.-circle-outline-hard-edge}

Drawing just the boundary of a circle with hard threshold.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.05}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ circle\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{d }\OperatorTok{{-}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{circle\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A10. Circle Outline (Smooth with
Smoothstep)}\label{a10.-circle-outline-smooth-with-smoothstep}

Anti-aliased circle outline using \texttt{smoothstep()}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.05}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ circle\_mask }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{{-}} \BuiltInTok{smoothstep}\OperatorTok{(}\NormalTok{r }\OperatorTok{{-}}\NormalTok{ thickness}\OperatorTok{,}\NormalTok{ r }\OperatorTok{+}\NormalTok{ thickness}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{circle\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A11. Grid of Circles}\label{a11.-grid-of-circles}

Using \texttt{mod()} to create repeating circles.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ spacing}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Draw a circle in each cell}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.3}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A12. Grid with Alternating
Background}\label{a12.-grid-with-alternating-background}

Creating a checkerboard pattern behind the circles.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{/}\NormalTok{ spacing}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ spacing}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Checkerboard background}
    \DataTypeTok{float}\NormalTok{ checker }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ cell\_id}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ bg\_color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{),}\NormalTok{ checker}\OperatorTok{);}
    
    \CommentTok{// Circle in each cell}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.3}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ circle\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?}\NormalTok{ circle\_color }\OperatorTok{:}\NormalTok{ bg\_color}\OperatorTok{;}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A13. Complete Grid Pattern}\label{a13.-complete-grid-pattern}

Full example combining grid cells, checkerboard, and circles.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{/}\NormalTok{ spacing}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ spacing}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Checkerboard background}
    \DataTypeTok{float}\NormalTok{ checker }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ cell\_id}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ bg\_color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{),}\NormalTok{ checker}\OperatorTok{);}
    
    \CommentTok{// Circle in each cell}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.3}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ circle\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?}\NormalTok{ circle\_color }\OperatorTok{:}\NormalTok{ bg\_color}\OperatorTok{;}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A14. Implicit Curve:
Parabola}\label{a14.-implicit-curve-parabola}

Drawing a parabola using the implicit equation \(y = x^2\).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ curve\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A15. Implicit Curve: Circle}\label{a15.-implicit-curve-circle}

Drawing a circle using the implicit equation \(x^2 + y^2 = r^2\).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}  \CommentTok{// dot(p,p) = x² + y²}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ curve\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A16. Implicit Curve:
Hyperbola}\label{a16.-implicit-curve-hyperbola}

Drawing a hyperbola \(xy = 1\).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ curve\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A17. Implicit Curve:
Ellipse}\label{a17.-implicit-curve-ellipse}

Drawing an ellipse \(\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1\).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{)} \OperatorTok{/} \OperatorTok{(}\NormalTok{a }\OperatorTok{*}\NormalTok{ a}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/} \OperatorTok{(}\NormalTok{b }\OperatorTok{*}\NormalTok{ b}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ curve\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A18. Parabola Graphing Calculator (Homework
Template)}\label{a18.-parabola-graphing-calculator-homework-template}

Template for the required homework assignment.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Define parameters}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ b }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \CommentTok{// Background}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{);}
    
    \CommentTok{// }\AlertTok{TODO}\CommentTok{: Draw x{-}axis (|y| \textless{} thickness)}
    \CommentTok{// }\AlertTok{TODO}\CommentTok{: Draw y{-}axis (|x| \textless{} thickness)}
    \CommentTok{// }\AlertTok{TODO}\CommentTok{: Draw parabola (|y {-} (ax² + bx + c)| \textless{} thickness)}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A19. Parabola Graphing Calculator (Complete
Solution)}\label{a19.-parabola-graphing-calculator-complete-solution}

Complete implementation of the required homework.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Define parameters}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ b }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ c }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    
    \CommentTok{// Background}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{);}
    
    \CommentTok{// Axes}
    \DataTypeTok{float}\NormalTok{ axis\_thickness }\OperatorTok{=} \FloatTok{0.02}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ x\_axis\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ axis\_thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ y\_axis\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ axis\_thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ axis\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    
    \CommentTok{// Parabola: F(x,y) = y {-} (ax² + bx + c) = 0}
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \OperatorTok{(}\NormalTok{a }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ c}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ curve\_thickness }\OperatorTok{=} \FloatTok{0.08}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ parabola\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ curve\_thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ parabola\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
    \CommentTok{// Combine (axes behind parabola)}
\NormalTok{    color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color}\OperatorTok{,}\NormalTok{ axis\_color}\OperatorTok{,} \BuiltInTok{max}\OperatorTok{(}\NormalTok{x\_axis\_mask}\OperatorTok{,}\NormalTok{ y\_axis\_mask}\OperatorTok{));}
\NormalTok{    color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color}\OperatorTok{,}\NormalTok{ parabola\_color}\OperatorTok{,}\NormalTok{ parabola\_mask}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A20. Animated Curve Family:
Circle}\label{a20.-animated-curve-family-circle}

Animating through different circle radii.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Animated radius}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{);}
    
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ r }\OperatorTok{*}\NormalTok{ r}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.08}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ curve\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A21. Animated Curve Family: Rotating
Ellipse}\label{a21.-animated-curve-family-rotating-ellipse}

Ellipse that rotates over time.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Rotation angle from time}
    \DataTypeTok{float}\NormalTok{ theta }\OperatorTok{=}\NormalTok{ iTime }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{;}
    
    \CommentTok{// Rotate coordinates}
    \DataTypeTok{vec2}\NormalTok{ p\_rot }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\NormalTok{theta}\OperatorTok{)} \OperatorTok{+}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{theta}\OperatorTok{),}
        \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{theta}\OperatorTok{)} \OperatorTok{+}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\NormalTok{theta}\OperatorTok{)}
    \OperatorTok{);}
    
    \CommentTok{// Ellipse in rotated coordinates}
    \DataTypeTok{float}\NormalTok{ a }\OperatorTok{=} \FloatTok{2.0}\OperatorTok{,}\NormalTok{ b }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ F }\OperatorTok{=} \OperatorTok{(}\NormalTok{p\_rot}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ p\_rot}\OperatorTok{.}\FunctionTok{x}\OperatorTok{)} \OperatorTok{/} \OperatorTok{(}\NormalTok{a }\OperatorTok{*}\NormalTok{ a}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{p\_rot}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ p\_rot}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/} \OperatorTok{(}\NormalTok{b }\OperatorTok{*}\NormalTok{ b}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ thickness }\OperatorTok{=} \FloatTok{0.08}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ curve\_mask }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{F}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ thickness }\OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ curve\_mask}\OperatorTok{);}
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A22. Beautiful Tiling: Geometric
Pattern}\label{a22.-beautiful-tiling-geometric-pattern}

Example of a custom tiling pattern using circles and symmetry.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{/}\NormalTok{ spacing}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ spacing}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Use symmetry within each cell}
\NormalTok{    cell\_p }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}  \CommentTok{// 4{-}fold symmetry}
    
    \CommentTok{// Multiple circles at different positions}
    \DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.4}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{));}
    \DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.4}\OperatorTok{));}
    
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.15}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ mask }\OperatorTok{=} \OperatorTok{(}\NormalTok{d1 }\OperatorTok{\textless{}}\NormalTok{ r }\OperatorTok{||}\NormalTok{ d2 }\OperatorTok{\textless{}}\NormalTok{ r }\OperatorTok{||}\NormalTok{ d3 }\OperatorTok{\textless{}}\NormalTok{ r}\OperatorTok{)} \OperatorTok{?} \FloatTok{1.0} \OperatorTok{:} \FloatTok{0.0}\OperatorTok{;}
    
    \CommentTok{// Vary color by cell position}
    \DataTypeTok{float}\NormalTok{ checker }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ cell\_id}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color1 }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.4}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color2 }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.6}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.4}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ bg }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color1}\OperatorTok{,}\NormalTok{ color2}\OperatorTok{,}\NormalTok{ checker}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ circle\_color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{bg}\OperatorTok{,}\NormalTok{ circle\_color}\OperatorTok{,}\NormalTok{ mask}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A23. Beautiful Tiling: Distance-Based
Animation}\label{a23.-beautiful-tiling-distance-based-animation}

Pattern that pulses based on time and distance.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{/}\NormalTok{ spacing}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{,}\NormalTok{ spacing}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ spacing}\OperatorTok{/}\FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Distance from cell center}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_p}\OperatorTok{);}
    
    \CommentTok{// Distance from origin (in cell coordinates)}
    \DataTypeTok{float}\NormalTok{ cell\_dist }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{cell\_id}\OperatorTok{);}
    
    \CommentTok{// Animated radius that propagates outward}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.3} \OperatorTok{+} \FloatTok{0.1} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ cell\_dist }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{);}
    
    \DataTypeTok{float}\NormalTok{ mask }\OperatorTok{=} \BuiltInTok{smoothstep}\OperatorTok{(}\NormalTok{r }\OperatorTok{+} \FloatTok{0.05}\OperatorTok{,}\NormalTok{ r }\OperatorTok{{-}} \FloatTok{0.05}\OperatorTok{,}\NormalTok{ d}\OperatorTok{);}
    
    \CommentTok{// Color based on cell distance}
    \DataTypeTok{vec3}\NormalTok{ color1 }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color2 }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.8}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{,} \FloatTok{0.4}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \BuiltInTok{fract}\OperatorTok{(}\NormalTok{cell\_dist }\OperatorTok{*} \FloatTok{0.2}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ circle\_color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color1}\OperatorTok{,}\NormalTok{ color2}\OperatorTok{,}\NormalTok{ t}\OperatorTok{);}
    
    \DataTypeTok{vec3}\NormalTok{ bg }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{bg}\OperatorTok{,}\NormalTok{ circle\_color}\OperatorTok{,}\NormalTok{ mask}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Notes on Using These
Shaders}\label{notes-on-using-these-shaders}

\subsection{Getting Started}\label{getting-started}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Go to https://www.shadertoy.com/new
\item
  Delete the default code
\item
  Copy and paste any of the above listings
\item
  Click the play button (▶) or press Alt+Enter
\end{enumerate}

\subsection{Coordinate System}\label{coordinate-system-1}

All shaders (except A1 and A2) use the standard coordinate
transformation:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}  \CommentTok{// Normalize to [0,1]}
\NormalTok{uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}                          \CommentTok{// Center at origin}
\NormalTok{uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;} \CommentTok{// Aspect ratio correction}
\DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}                      \CommentTok{// Scale viewing window}
\end{Highlighting}
\end{Shaded}

This gives you coordinates centered at the origin with equal scaling in
x and y.

\subsection{Modifying Parameters}\label{modifying-parameters}

\textbf{Coordinate scaling:} - Change \texttt{uv\ *\ 4.0} to zoom in/out
(smaller number = zoom in)

\textbf{Colors:} - Modify \texttt{vec3(r,\ g,\ b)} values (each in range
{[}0, 1{]}) - Red: \texttt{vec3(1.0,\ 0.0,\ 0.0)} - Green:
\texttt{vec3(0.0,\ 1.0,\ 0.0)} - Blue: \texttt{vec3(0.0,\ 0.0,\ 1.0)} -
Yellow: \texttt{vec3(1.0,\ 1.0,\ 0.0)} - Cyan:
\texttt{vec3(0.0,\ 1.0,\ 1.0)} - Magenta: \texttt{vec3(1.0,\ 0.0,\ 1.0)}

\textbf{Distance and thickness:} - \texttt{thickness} parameters control
line width - Larger thickness = thicker lines/curves

\textbf{Grid patterns:} - \texttt{spacing} controls grid cell size -
Smaller spacing = more cells

\textbf{Animation:} - Use \texttt{iTime} for time-based animation -
\texttt{sin(iTime)} oscillates between -1 and 1 -
\texttt{0.5\ +\ 0.5\ *\ sin(iTime)} oscillates between 0 and 1

\subsection{Common Modifications to
Try}\label{common-modifications-to-try}

\textbf{Make circles pulse:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.3} \OperatorTok{+} \FloatTok{0.1} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Make grid spacing animate:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float}\NormalTok{ spacing }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+} \FloatTok{0.3} \OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{iTime }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\textbf{Add mouse interaction:}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2}\NormalTok{ mouse }\OperatorTok{=}\NormalTok{ iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{mouse }\OperatorTok{=}\NormalTok{ mouse }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{mouse}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
\CommentTok{// Use mouse position to control parameters}
\end{Highlighting}
\end{Shaded}

\textbf{Combine techniques:} - Put implicit curves on a grid using
\texttt{mod()} - Add animation to any parameter with \texttt{iTime} -
Use distance fields to create smooth transitions

\subsection{Troubleshooting}\label{troubleshooting}

\textbf{Shader won't compile:} - Check for missing semicolons - Make
sure all numbers are floats: \texttt{1.0} not \texttt{1} - Verify
parentheses and braces are balanced

\textbf{Nothing shows up:} - Check your coordinate scaling - might be
zoomed too far in/out - Verify colors are in {[}0, 1{]} range - Make
sure alpha channel is 1.0: \texttt{vec4(color,\ 1.0)}

\textbf{Circles look like ellipses:} - Make sure you include the aspect
ratio correction: \texttt{uv.x\ *=\ iResolution.x\ /\ iResolution.y;}

\subsection{Next Steps}\label{next-steps}

Once you're comfortable with these basics: - Combine multiple techniques
in one shader - Create your own implicit curves - Design custom tiling
patterns - Add animation and interactivity - Experiment with color
palettes and smooth transitions

The goal is to understand how coordinate transformations, distance
functions, and conditionals work together to create mathematical
visualizations on the GPU!

\chapter{Appendix: Complete Shader Code for Day
2}\label{appendix-complete-shader-code-for-day-2}

This appendix provides complete, standalone Shadertoy code for each
shader program presented in Day 2. Each listing includes all necessary
helper functions and can be copied directly into Shadertoy
(https://www.shadertoy.com/new) and run immediately.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A1. Basic Mandelbrot Set
(Grayscale)}\label{a1.-basic-mandelbrot-set-grayscale}

This is the simplest Mandelbrot renderer, showing just the escape-time
iteration count in grayscale.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Complex number operations}
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Scale to view the Mandelbrot set}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.5}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}=} \FloatTok{0.5}\OperatorTok{;}
    
    \CommentTok{// Mandelbrot iteration}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Grayscale coloring}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A2. Mandelbrot Set with Smooth
Coloring}\label{a2.-mandelbrot-set-with-smooth-coloring}

This adds smooth coloring and a cosine-based color palette for much
better visual quality.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Complex number operations}
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Cosine{-}based color palette}
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Scale to view the Mandelbrot set}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.5}\OperatorTok{;}
\NormalTok{    c}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}=} \FloatTok{0.5}\OperatorTok{;}
    
    \CommentTok{// Mandelbrot iteration}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Smooth coloring}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
        \CommentTok{// Smooth iteration count}
        \DataTypeTok{float}\NormalTok{ log\_zn }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{))} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ nu }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\NormalTok{log\_zn }\OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{))} \OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{);}
        \DataTypeTok{float}\NormalTok{ smooth\_iter }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{+} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ nu}\OperatorTok{;}
        
        \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=}\NormalTok{ smooth\_iter }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
\NormalTok{        color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
        \CommentTok{// Inside the set: black}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A3. Julia Set Explorer}\label{a3.-julia-set-explorer}

Template for Julia set implementation. Students fill in the iteration
code based on Mandelbrot.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Complex number operations}
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Cosine{-}based color palette}
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.0}\OperatorTok{;}
    
    \CommentTok{// Fix c to an interesting value}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.27015}\OperatorTok{);}
    
    \CommentTok{// HOMEWORK: Initialize z from pixel position}
    \CommentTok{// HOMEWORK: Iterate z\_\{n+1\} = z\_n\^{}2 + c}
    \CommentTok{// HOMEWORK: Use smooth coloring like Mandelbrot}
    
    \CommentTok{// Placeholder color (replace with your implementation)}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{A3b. Julia Set (Complete
Solution)}\label{a3b.-julia-set-complete-solution}

Here's a complete working Julia set for reference:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Complex number operations}
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Cosine{-}based color palette}
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.0}\OperatorTok{;}
    
    \CommentTok{// Fix c to an interesting value}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.27015}\OperatorTok{);}
    
    \CommentTok{// Initialize z from pixel position (key difference from Mandelbrot!)}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
    
    \CommentTok{// Julia set iteration}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Smooth coloring}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{float}\NormalTok{ log\_zn }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{))} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ nu }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\NormalTok{log\_zn }\OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{))} \OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{);}
        \DataTypeTok{float}\NormalTok{ smooth\_iter }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{+} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ nu}\OperatorTok{;}
        
        \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=}\NormalTok{ smooth\_iter }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
\NormalTok{        color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{A3c. Julia Set with Mouse
Control}\label{a3c.-julia-set-with-mouse-control}

For interactive exploration of parameter space:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Complex number operations}
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Cosine{-}based color palette}
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.0}\OperatorTok{;}
    
    \CommentTok{// c controlled by mouse position}
    \DataTypeTok{vec2}\NormalTok{ mouse\_uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    mouse\_uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=}\NormalTok{ mouse\_uv }\OperatorTok{*} \FloatTok{3.0}\OperatorTok{;}
    
    \CommentTok{// Fallback if mouse hasn\textquotesingle{}t been clicked}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{z} \OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        c }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.27015}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Initialize z from pixel position}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
    
    \CommentTok{// Julia set iteration}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Smooth coloring}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{float}\NormalTok{ log\_zn }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{))} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ nu }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\NormalTok{log\_zn }\OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{))} \OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{);}
        \DataTypeTok{float}\NormalTok{ smooth\_iter }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{+} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ nu}\OperatorTok{;}
        
        \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=}\NormalTok{ smooth\_iter }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
\NormalTok{        color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{A3d. Julia Set with
Animation}\label{a3d.-julia-set-with-animation}

Animating through parameter space:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Complex number operations}
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Cosine{-}based color palette}
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{3.0}\OperatorTok{;}
    
    \CommentTok{// Animate c around a circle in parameter space}
    \DataTypeTok{float}\NormalTok{ angle }\OperatorTok{=}\NormalTok{ iTime }\OperatorTok{*} \FloatTok{0.3}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \FloatTok{0.7885}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{radius }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\NormalTok{angle}\OperatorTok{),}\NormalTok{ radius }\OperatorTok{*} \BuiltInTok{sin}\OperatorTok{(}\NormalTok{angle}\OperatorTok{));}
    
    \CommentTok{// Initialize z from pixel position}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
    
    \CommentTok{// Julia set iteration}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{100}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Smooth coloring}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{)} \OperatorTok{\{}
        \DataTypeTok{float}\NormalTok{ log\_zn }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{))} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
        \DataTypeTok{float}\NormalTok{ nu }\OperatorTok{=} \BuiltInTok{log}\OperatorTok{(}\NormalTok{log\_zn }\OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{))} \OperatorTok{/} \BuiltInTok{log}\OperatorTok{(}\FloatTok{2.0}\OperatorTok{);}
        \DataTypeTok{float}\NormalTok{ smooth\_iter }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{+} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ nu}\OperatorTok{;}
        
        \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=}\NormalTok{ smooth\_iter }\OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
\NormalTok{        color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A4. Circle Inversion
Visualization}\label{a4.-circle-inversion-visualization}

Visualizes circle inversion by showing how it deforms a grid.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Circle inversion function}
\DataTypeTok{vec2} \FunctionTok{invertCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
    
    \CommentTok{// Handle center (would be division by zero)}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{r2 }\OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1000.0}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ center }\OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ diff }\OperatorTok{/}\NormalTok{ r2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Inversion circle}
    \DataTypeTok{vec2}\NormalTok{ circleCenter }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ circleRadius }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    
    \CommentTok{// Apply inversion}
    \DataTypeTok{vec2}\NormalTok{ p\_inverted }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ circleCenter}\OperatorTok{,}\NormalTok{ circleRadius}\OperatorTok{);}
    
    \CommentTok{// Draw a grid in the inverted space}
    \DataTypeTok{vec2}\NormalTok{ grid }\OperatorTok{=} \BuiltInTok{fract}\OperatorTok{(}\NormalTok{p\_inverted }\OperatorTok{*} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ gridLine }\OperatorTok{=} \BuiltInTok{step}\OperatorTok{(}\FloatTok{0.95}\OperatorTok{,} \BuiltInTok{max}\OperatorTok{(}\NormalTok{grid}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ grid}\OperatorTok{.}\FunctionTok{y}\OperatorTok{));}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{gridLine}\OperatorTok{);}
    
    \CommentTok{// Draw the inversion circle itself (for reference)}
    \DataTypeTok{float}\NormalTok{ circDist }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ circleRadius}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{circDist }\OperatorTok{\textless{}} \FloatTok{0.05}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A5. Apollonian Gasket}\label{a5.-apollonian-gasket}

Complete Apollonian gasket implementation with iteration coloring.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Circle struct}
\KeywordTok{struct}\NormalTok{ Circle }\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\};}

\CommentTok{// Circle inversion}
\DataTypeTok{vec2} \FunctionTok{invertCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{r2 }\OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1000.0}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ center }\OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ diff }\OperatorTok{/}\NormalTok{ r2}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Setup four mutually tangent circles (three inner + one outer)}
\DataTypeTok{void} \FunctionTok{setupApollonianCircles}\OperatorTok{(}\DataTypeTok{out}\NormalTok{ Circle c1}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c2}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c3}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle outer}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Radius of each inner circle}
    \CommentTok{// For three circles to be mutually tangent: distance between centers = 2r}
    \CommentTok{// Centers form equilateral triangle with circumradius = 2r/sqrt(3)}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ r }\OperatorTok{/} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{);}  \CommentTok{// ≈ 0.577 for r = 0.5}
    
    \CommentTok{// Three inner circles}
\NormalTok{    c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ d}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}  \CommentTok{// 0.866 ≈ sqrt(3)/2}
\NormalTok{    c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{d }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
    
    \CommentTok{// Outer circle tangent to all three, centered at origin}
    \DataTypeTok{float}\NormalTok{ R }\OperatorTok{=}\NormalTok{ d }\OperatorTok{+}\NormalTok{ r}\OperatorTok{;}  \CommentTok{// ≈ 1.077 for r = 0.5}
\NormalTok{    outer }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ R}\OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Iterate inversions through four circles (three inner + one outer)}
\DataTypeTok{vec2} \FunctionTok{iterateApollonian}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c1}\OperatorTok{,}\NormalTok{ Circle c2}\OperatorTok{,}\NormalTok{ Circle c3}\OperatorTok{,}\NormalTok{ Circle outer}\OperatorTok{,}
                       \DataTypeTok{int}\NormalTok{ maxIter}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{int}\NormalTok{ finalIter}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{int}\NormalTok{ lastCircle}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ maxIter}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{bool}\NormalTok{ moved }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
        
        \CommentTok{// Check the three inner circles}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}} 
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        \CommentTok{// Check if outside the outer circle}
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textgreater{}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        
        \KeywordTok{if}\OperatorTok{(!}\NormalTok{moved}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            finalIter }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
            \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
    
\NormalTok{    finalIter }\OperatorTok{=}\NormalTok{ maxIter}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Cosine{-}based color palette}
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Setup circles}
\NormalTok{    Circle c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{;}
    \FunctionTok{setupApollonianCircles}\OperatorTok{(}\NormalTok{c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{);}
    
    \CommentTok{// Iterate}
    \DataTypeTok{int}\NormalTok{ maxIter }\OperatorTok{=} \DecValTok{50}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ finalIter}\OperatorTok{,}\NormalTok{ lastCircle}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ final\_p }\OperatorTok{=} \FunctionTok{iterateApollonian}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{,}\NormalTok{ maxIter}\OperatorTok{,}\NormalTok{ finalIter}\OperatorTok{,}\NormalTok{ lastCircle}\OperatorTok{);}
    
    \CommentTok{// Color by iteration count}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{finalIter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{maxIter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{palette}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    
    \CommentTok{// Draw all four circles for reference}
    \DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d\_outer }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{min}\OperatorTok{(}\NormalTok{d1}\OperatorTok{,} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d2}\OperatorTok{,}\NormalTok{ d3}\OperatorTok{)),}\NormalTok{ d\_outer}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{A5b. Apollonian Gasket (Basin
Coloring)}\label{a5b.-apollonian-gasket-basin-coloring}

Alternative coloring showing which circle's basin each point falls into:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Circle struct}
\KeywordTok{struct}\NormalTok{ Circle }\OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{;}
\OperatorTok{\};}

\CommentTok{// Circle inversion}
\DataTypeTok{vec2} \FunctionTok{invertCircle}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ center}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ r2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{r2 }\OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1000.0}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ center }\OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ diff }\OperatorTok{/}\NormalTok{ r2}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Setup four mutually tangent circles (three inner + one outer)}
\DataTypeTok{void} \FunctionTok{setupApollonianCircles}\OperatorTok{(}\DataTypeTok{out}\NormalTok{ Circle c1}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c2}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle c3}\OperatorTok{,} \DataTypeTok{out}\NormalTok{ Circle outer}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ r }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Radius of each inner circle}
    \CommentTok{// For three circles to be mutually tangent: distance between centers = 2r}
    \CommentTok{// Centers form equilateral triangle with circumradius = 2r/sqrt(3)}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ r }\OperatorTok{/} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{3.0}\OperatorTok{);}  \CommentTok{// ≈ 0.577 for r = 0.5}
    
    \CommentTok{// Three inner circles}
\NormalTok{    c1 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,}\NormalTok{ d}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
\NormalTok{    c2 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}  \CommentTok{// 0.866 ≈ sqrt(3)/2}
\NormalTok{    c3 }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{d }\OperatorTok{*} \FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\NormalTok{d }\OperatorTok{*} \FloatTok{0.5}\OperatorTok{),}\NormalTok{ r}\OperatorTok{);}
    
    \CommentTok{// Outer circle tangent to all three, centered at origin}
    \DataTypeTok{float}\NormalTok{ R }\OperatorTok{=}\NormalTok{ d }\OperatorTok{+}\NormalTok{ r}\OperatorTok{;}  \CommentTok{// ≈ 1.077 for r = 0.5}
\NormalTok{    outer }\OperatorTok{=} \FunctionTok{Circle}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{),}\NormalTok{ R}\OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Iterate inversions through four circles (three inner + one outer)}
\DataTypeTok{vec2} \FunctionTok{iterateApollonian}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ Circle c1}\OperatorTok{,}\NormalTok{ Circle c2}\OperatorTok{,}\NormalTok{ Circle c3}\OperatorTok{,}\NormalTok{ Circle outer}\OperatorTok{,}
                       \DataTypeTok{int}\NormalTok{ maxIter}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{int}\NormalTok{ finalIter}\OperatorTok{,} \DataTypeTok{out} \DataTypeTok{int}\NormalTok{ lastCircle}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ maxIter}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{bool}\NormalTok{ moved }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
        
        \CommentTok{// Check the three inner circles}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}} 
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textless{}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{2}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        \CommentTok{// Check if outside the outer circle}
        \KeywordTok{else} \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{\textgreater{}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            p }\OperatorTok{=} \FunctionTok{invertCircle}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
\NormalTok{            lastCircle }\OperatorTok{=} \DecValTok{3}\OperatorTok{;}
\NormalTok{            moved }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \OperatorTok{\}}
        
        \KeywordTok{if}\OperatorTok{(!}\NormalTok{moved}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{            finalIter }\OperatorTok{=}\NormalTok{ i}\OperatorTok{;}
            \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
    
\NormalTok{    finalIter }\OperatorTok{=}\NormalTok{ maxIter}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
\OperatorTok{\}}


\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Setup circles}
\NormalTok{    Circle c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{;}
    \FunctionTok{setupApollonianCircles}\OperatorTok{(}\NormalTok{c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{);}
    
    \CommentTok{// Iterate}
    \DataTypeTok{int}\NormalTok{ maxIter }\OperatorTok{=} \DecValTok{50}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ finalIter}\OperatorTok{,}\NormalTok{ lastCircle}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ final\_p }\OperatorTok{=} \FunctionTok{iterateApollonian}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ c1}\OperatorTok{,}\NormalTok{ c2}\OperatorTok{,}\NormalTok{ c3}\OperatorTok{,}\NormalTok{ outer}\OperatorTok{,}\NormalTok{ maxIter}\OperatorTok{,}\NormalTok{ finalIter}\OperatorTok{,}\NormalTok{ lastCircle}\OperatorTok{);}
    
    \CommentTok{// Color by which circle we last hit}
    \DataTypeTok{vec3}\NormalTok{ colors}\OperatorTok{[}\DecValTok{4}\OperatorTok{];}
\NormalTok{    colors}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Circle 1: Red}
\NormalTok{    colors}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Circle 2: Green}
\NormalTok{    colors}\OperatorTok{[}\DecValTok{2}\OperatorTok{]} \OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Circle 3: Blue}
\NormalTok{    colors}\OperatorTok{[}\DecValTok{3}\OperatorTok{]} \OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Outer circle: Yellow}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=}\NormalTok{ colors}\OperatorTok{[}\NormalTok{lastCircle}\OperatorTok{];}
    
    \CommentTok{// Draw all four circles for reference}
    \DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c1}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c2}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ c3}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d\_outer }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{center}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ outer}\OperatorTok{.}\FunctionTok{radius}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{min}\OperatorTok{(}\NormalTok{d1}\OperatorTok{,} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d2}\OperatorTok{,}\NormalTok{ d3}\OperatorTok{)),}\NormalTok{ d\_outer}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{A6. Grid of Julia Sets (Optional
Homework)}\label{a6.-grid-of-julia-sets-optional-homework}

Shows many Julia sets in a grid, revealing the Mandelbrot set structure.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Complex number operations}
\DataTypeTok{float} \FunctionTok{cabs2}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{cmul}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,}
\NormalTok{        z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}
    \OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Cosine{-}based color palette}
\DataTypeTok{vec3} \FunctionTok{palette}\OperatorTok{(}\DataTypeTok{float}\NormalTok{ t}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec3}\NormalTok{ a }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ b }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ c }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ d }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{);}
    
    \KeywordTok{return}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\NormalTok{c }\OperatorTok{*}\NormalTok{ t }\OperatorTok{+}\NormalTok{ d}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
    
    \CommentTok{// Divide screen into grid cells}
    \DataTypeTok{float}\NormalTok{ grid\_size }\OperatorTok{=} \FloatTok{50.0}\OperatorTok{;}  \CommentTok{// 8×8 grid}
    \DataTypeTok{vec2}\NormalTok{ cell\_id }\OperatorTok{=} \BuiltInTok{floor}\OperatorTok{(}\NormalTok{p }\OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ cell\_p }\OperatorTok{=} \BuiltInTok{fract}\OperatorTok{(}\NormalTok{p }\OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{;}
\NormalTok{    cell\_p }\OperatorTok{*=} \FloatTok{4.0}\OperatorTok{;}  \CommentTok{// Local coordinates within cell}
    
    \CommentTok{// Map cell\_id to parameter c}
    \DataTypeTok{vec2}\NormalTok{ c }\OperatorTok{=} \OperatorTok{(}\NormalTok{cell\_id }\OperatorTok{/}\NormalTok{ grid\_size}\OperatorTok{)} \OperatorTok{*} \FloatTok{3.0} \OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{2.5}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
\NormalTok{    c}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}=} \FloatTok{0.5}\OperatorTok{;}  \CommentTok{// Center on Mandelbrot set}
    
    \CommentTok{// Run Julia set iteration}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ cell\_p}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ max\_iter }\OperatorTok{=} \DecValTok{50}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ iter}\OperatorTok{;}
    
    \KeywordTok{for}\OperatorTok{(}\NormalTok{iter }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ iter }\OperatorTok{\textless{}}\NormalTok{ max\_iter}\OperatorTok{;}\NormalTok{ iter}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\FunctionTok{cabs2}\OperatorTok{(}\NormalTok{z}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{4.0}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{cmul}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ z}\OperatorTok{)} \OperatorTok{+}\NormalTok{ c}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Color}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{iter}\OperatorTok{)} \OperatorTok{/} \DataTypeTok{float}\OperatorTok{(}\NormalTok{max\_iter}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\NormalTok{t}\OperatorTok{);}
    
    \CommentTok{// Draw grid lines}
    \DataTypeTok{vec2}\NormalTok{ grid\_edge }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{fract}\OperatorTok{(}\NormalTok{p }\OperatorTok{*}\NormalTok{ grid\_size }\OperatorTok{/} \FloatTok{4.0}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{max}\OperatorTok{(}\NormalTok{grid\_edge}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ grid\_edge}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{0.48}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Notes on Using These
Shaders}\label{notes-on-using-these-shaders-1}

\subsection{Getting Started}\label{getting-started-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Go to https://www.shadertoy.com/new
\item
  Delete the default code
\item
  Copy and paste any of the above listings
\item
  Click the play button (▶) or press Alt+Enter
\end{enumerate}

\subsection{Modifying Parameters}\label{modifying-parameters-1}

Each shader has parameters you can adjust at the top of
\texttt{mainImage()}:

\textbf{Mandelbrot/Julia:} - \texttt{max\_iter} - More iterations reveal
finer detail (try 200) - Color scale factor in \texttt{uv\ *\ 3.5} -
Zoom in/out - Offset \texttt{c.x\ -=\ 0.5} - Pan the view

\textbf{Julia specific:} - \texttt{vec2\ c\ =\ ...} - Change the
parameter to see different Julia sets - Try values from the homework
section

\textbf{Circle Inversion:} - \texttt{circleCenter} - Move the inversion
circle - \texttt{circleRadius} - Change the size - Grid frequency in
\texttt{p\_inverted\ *\ 2.0} - Denser or sparser grid

\textbf{Apollonian Gasket:} - \texttt{maxIter} - More iterations show
deeper nesting - \texttt{R} and \texttt{r} in setup function - Change
circle sizes - Color palette parameters in \texttt{palette()} function

\subsection{Performance Tips}\label{performance-tips}

If a shader runs slowly: - Reduce \texttt{max\_iter} (try 50 instead of
100) - Lower the resolution (bottom right resolution dropdown in
Shadertoy) - Some computers may struggle with smooth coloring - remove
it for speed

\subsection{Exploring Further}\label{exploring-further}

All of these shaders are starting points! Try: - Combining techniques
(Julia set with Apollonian coloring scheme) - Animating parameters with
\texttt{iTime} - Adding mouse interaction with \texttt{iMouse} -
Creating your own color palettes - Experimenting with different circle
configurations

The goal is to understand how simple iterative processes create complex
fractals, and how to implement them efficiently on the GPU!

\chapter{Appendix: Complete Shader Code for Day
3}\label{appendix-complete-shader-code-for-day-3}

This appendix provides complete, standalone Shadertoy code for each
shader program presented in Day 3. Each listing includes all necessary
helper functions and can be copied directly into Shadertoy
(https://www.shadertoy.com/new) and run immediately.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Part 1: Euclidean Tilings}\label{part-1-euclidean-tilings}

\subsection{E1. Strip Tiling (Basic)}\label{e1.-strip-tiling-basic}

Simple horizontal strip tiling showing the folding algorithm in one
dimension.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Standard coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Fold into the strip [0, 1]}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Draw something in the fundamental domain}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Dark background}
    
    \CommentTok{// A circle in the strip}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Yellow circle}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E2. Square Tiling (Basic)}\label{e2.-square-tiling-basic}

2D square tiling extending the folding algorithm to both dimensions.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Fold into the square [0,1] × [0,1]}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Draw something in the fundamental domain}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.2}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    
    \CommentTok{// Circle at center}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E3. Square Tiling with Fold
Count}\label{e3.-square-tiling-with-fold-count}

Square tiling colored by the number of reflections needed to reach the
fundamental domain.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Fold into the square [0,1] × [0,1]}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ p\_old }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
        
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \OperatorTok{{-}}\NormalTok{p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
        \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{{-}}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
        
        \CommentTok{// If point didn\textquotesingle{}t move, we\textquotesingle{}re done}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ p\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color based on fold count}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{)} \OperatorTok{/} \FloatTok{8.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{)} \OperatorTok{*}\NormalTok{ t }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{)));}
    
    \CommentTok{// Draw something in the fundamental domain}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.3}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \BuiltInTok{mix}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{),} \BuiltInTok{smoothstep}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{,}\NormalTok{ d}\OperatorTok{));}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E4a. Single Half-Space
Visualization}\label{e4a.-single-half-space-visualization}

Visualizes one side of a line (a half-space).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define a half{-}space: x \textless{} 1 (left side of vertical line at x=1)}
\NormalTok{    HalfSpace hs }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Color based on whether we\textquotesingle{}re inside}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E4b. Single Half-Space with Boundary
Line}\label{e4b.-single-half-space-with-boundary-line}

Same as E4a but with the boundary line drawn.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{distToHalfSpace}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define a half{-}space: x \textless{} 1}
\NormalTok{    HalfSpace hs }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Color based on whether we\textquotesingle{}re inside}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{)} \OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
    \CommentTok{// Draw the boundary line}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// White boundary}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E5a. Four Half-Spaces (Additive
Coloring)}\label{e5a.-four-half-spaces-additive-coloring}

Intersecting four half-spaces to create a square using additive
coloring.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define the four half{-}spaces for [0,1] × [0,1]}
\NormalTok{    HalfSpace left   }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// x \textgreater{} 0}
\NormalTok{    HalfSpace right  }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// x \textless{} 1}
\NormalTok{    HalfSpace bottom }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// y \textgreater{} 0}
\NormalTok{    HalfSpace top    }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// y \textless{} 1}
    
    \CommentTok{// Additive coloring {-} each half{-}space adds brightness}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ left}\OperatorTok{))}\NormalTok{   color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ right}\OperatorTok{))}\NormalTok{  color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ bottom}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ top}\OperatorTok{))}\NormalTok{    color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E5b. Four Half-Spaces with
Boundaries}\label{e5b.-four-half-spaces-with-boundaries}

Enhanced version with binary coloring and boundary lines.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{distToHalfSpace}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define the four half{-}spaces for [0,1] × [0,1]}
\NormalTok{    HalfSpace left   }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// x \textgreater{} 0}
\NormalTok{    HalfSpace right  }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// x \textless{} 1}
\NormalTok{    HalfSpace bottom }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// y \textgreater{} 0}
\NormalTok{    HalfSpace top    }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,}  \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// y \textless{} 1}
    
    \CommentTok{// Binary coloring: inside domain or not}
    \DataTypeTok{bool}\NormalTok{ in\_square }\OperatorTok{=} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ left}\OperatorTok{)} \OperatorTok{\&\&} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ right}\OperatorTok{)} \OperatorTok{\&\&} 
                     \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ bottom}\OperatorTok{)} \OperatorTok{\&\&} \FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ top}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=}\NormalTok{ in\_square }\OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.4}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
    \CommentTok{// Draw boundaries}
    \DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ left}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ right}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ bottom}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d4 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ top}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{min}\OperatorTok{(}\NormalTok{d1}\OperatorTok{,}\NormalTok{ d2}\OperatorTok{),} \BuiltInTok{min}\OperatorTok{(}\NormalTok{d3}\OperatorTok{,}\NormalTok{ d4}\OperatorTok{));}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// White boundaries}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E6. Three Half-Spaces for Triangle
(Additive)}\label{e6.-three-half-spaces-for-triangle-additive}

Visualizing three half-spaces defining an equilateral triangle.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{bool} \FunctionTok{inside}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \KeywordTok{return} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define three half{-}spaces for equilateral triangle}
\NormalTok{    HalfSpace hs1 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs2 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.732}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs3 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{({-}}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Additive coloring}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{inside}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{))}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E7. Euclidean Triangle Tiling
(Basic)}\label{e7.-euclidean-triangle-tiling-basic}

Full triangle tiling using half-space reflections.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{vec2} \FunctionTok{reflectInto}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \KeywordTok{if}\OperatorTok{((}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
    \OperatorTok{\}}
    
    \DataTypeTok{vec2}\NormalTok{ normal }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ norm }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{normal}\OperatorTok{);}
\NormalTok{    normal }\OperatorTok{=}\NormalTok{ normal }\OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ signedDist }\OperatorTok{=} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{{-}} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ signedDist }\OperatorTok{*}\NormalTok{ normal}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define three half{-}spaces for equilateral triangle}
\NormalTok{    HalfSpace hs1 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs2 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.732}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs3 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{({-}}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Fold into triangle}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Simple coloring}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{);}
    
    \CommentTok{// Draw a circle in fundamental domain}
    \DataTypeTok{float}\NormalTok{ d }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.3}\OperatorTok{));}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d }\OperatorTok{\textless{}} \FloatTok{0.2}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E8. Euclidean Triangle Tiling with Fold
Count}\label{e8.-euclidean-triangle-tiling-with-fold-count}

Triangle tiling colored by reflection count with convergence check.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{vec2} \FunctionTok{reflectInto}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \KeywordTok{if}\OperatorTok{((}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
    \OperatorTok{\}}
    
    \DataTypeTok{vec2}\NormalTok{ normal }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ norm }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{normal}\OperatorTok{);}
\NormalTok{    normal }\OperatorTok{=}\NormalTok{ normal }\OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ signedDist }\OperatorTok{=} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{{-}} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ signedDist }\OperatorTok{*}\NormalTok{ normal}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define three half{-}spaces for equilateral triangle}
\NormalTok{    HalfSpace hs1 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs2 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.732}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs3 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{({-}}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Fold into triangle with iteration count}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ p\_old }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
        
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ p\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by fold count}
    \DataTypeTok{float}\NormalTok{ t }\OperatorTok{=} \DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{)} \OperatorTok{/} \FloatTok{10.0}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{+} \FloatTok{0.5} \OperatorTok{*} \BuiltInTok{cos}\OperatorTok{(}\FloatTok{6.28318} \OperatorTok{*} \OperatorTok{(}\DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{)} \OperatorTok{*}\NormalTok{ t }\OperatorTok{+} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.33}\OperatorTok{,} \FloatTok{0.67}\OperatorTok{)));}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{E9. Euclidean Triangle Tiling with Edges and
Vertices}\label{e9.-euclidean-triangle-tiling-with-edges-and-vertices}

Complete triangle tiling with visible structure (reference
implementation for homework).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ HalfSpace }\OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ a}\OperatorTok{,}\NormalTok{ b}\OperatorTok{,}\NormalTok{ c}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side}\OperatorTok{;}
\OperatorTok{\};}

\DataTypeTok{vec2} \FunctionTok{reflectInto}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ value }\OperatorTok{=}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \KeywordTok{if}\OperatorTok{((}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{*}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{side} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ p}\OperatorTok{;}
    \OperatorTok{\}}
    
    \DataTypeTok{vec2}\NormalTok{ normal }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ norm }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{normal}\OperatorTok{);}
\NormalTok{    normal }\OperatorTok{=}\NormalTok{ normal }\OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    
    \DataTypeTok{float}\NormalTok{ signedDist }\OperatorTok{=} \OperatorTok{(}\NormalTok{value }\OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/}\NormalTok{ norm}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{{-}} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ signedDist }\OperatorTok{*}\NormalTok{ normal}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{distToHalfSpace}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{,}\NormalTok{ HalfSpace hs}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{return} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b} \OperatorTok{*}\NormalTok{ p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{c}\OperatorTok{)} \OperatorTok{/} \BuiltInTok{length}\OperatorTok{(}\DataTypeTok{vec2}\OperatorTok{(}\NormalTok{hs}\OperatorTok{.}\FunctionTok{a}\OperatorTok{,}\NormalTok{ hs}\OperatorTok{.}\FunctionTok{b}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}
    
    \CommentTok{// Define three half{-}spaces for equilateral triangle}
\NormalTok{    HalfSpace hs1 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs2 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.732}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{    HalfSpace hs3 }\OperatorTok{=} \FunctionTok{HalfSpace}\OperatorTok{({-}}\FloatTok{1.5}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.866}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
    
    \CommentTok{// Fold into triangle with parity tracking}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{20}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ p\_old }\OperatorTok{=}\NormalTok{ p}\OperatorTok{;}
        
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{);}
\NormalTok{        p }\OperatorTok{=} \FunctionTok{reflectInto}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ p\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by parity (alternating pattern)}
    \DataTypeTok{float}\NormalTok{ parity }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{parity }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}  \CommentTok{// Light blue}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Darker blue}
    \OperatorTok{\}}
    
    \CommentTok{// Draw edges}
    \DataTypeTok{float}\NormalTok{ d1 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs1}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d2 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs2}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d3 }\OperatorTok{=} \FunctionTok{distToHalfSpace}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ hs3}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d\_edge }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{min}\OperatorTok{(}\NormalTok{d1}\OperatorTok{,}\NormalTok{ d2}\OperatorTok{),}\NormalTok{ d3}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d\_edge }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}  \CommentTok{// White edges}
    \OperatorTok{\}}
    
    \CommentTok{// Draw vertices (approximate positions)}
    \DataTypeTok{vec2}\NormalTok{ v1 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{0.577}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.333}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ v2 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.577}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{0.333}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ v3 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.667}\OperatorTok{);}
    
    \DataTypeTok{float}\NormalTok{ d\_v1 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ v1}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d\_v2 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ v2}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d\_v3 }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ v3}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ d\_vert }\OperatorTok{=} \BuiltInTok{min}\OperatorTok{(}\BuiltInTok{min}\OperatorTok{(}\NormalTok{d\_v1}\OperatorTok{,}\NormalTok{ d\_v2}\OperatorTok{),}\NormalTok{ d\_v3}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{d\_vert }\OperatorTok{\textless{}} \FloatTok{0.08}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Red vertices}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Part 2: Hyperbolic Tilings}\label{part-2-hyperbolic-tilings}

\subsection{H1. Euclidean Distance Visualization (For
Comparison)}\label{h1.-euclidean-distance-visualization-for-comparison}

Shows standard Euclidean distance circles for comparison with
hyperbolic.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}  \CommentTok{// Shift up so we\textquotesingle{}re in y \textgreater{} 0}
    
    \CommentTok{// Mouse position as center (or default)}
    \DataTypeTok{vec2}\NormalTok{ mouse }\OperatorTok{=}\NormalTok{ iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{z} \OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)}\NormalTok{ mouse }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{);}  \CommentTok{// Default if no click}
\NormalTok{    mouse }\OperatorTok{=} \OperatorTok{(}\NormalTok{mouse }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    mouse}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ center }\OperatorTok{=}\NormalTok{ mouse }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Euclidean distance}
    \DataTypeTok{float}\NormalTok{ dist }\OperatorTok{=} \BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{);}
    
    \CommentTok{// Draw a disk of radius 0.5 using two circles}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}  \CommentTok{// Background}
    
    \CommentTok{// Outer circle (slightly larger)}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{+} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Yellow ring}
    \OperatorTok{\}}
    
    \CommentTok{// Inner circle (slightly smaller) {-} "cuts out" interior}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{{-}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.4}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Blue interior}
    \OperatorTok{\}}
    
    \CommentTok{// Draw center point}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ center}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.05}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside upper half{-}plane}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H2. Hyperbolic Distance
Visualization}\label{h2.-hyperbolic-distance-visualization}

Shows hyperbolic distance ``circles'' in the upper half-plane model.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{float} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z1}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ z2}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ z1 }\OperatorTok{{-}}\NormalTok{ z2}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ diff2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ z1}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ z2}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ arg }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+}\NormalTok{ diff2 }\OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{log}\OperatorTok{(}\NormalTok{arg }\OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{arg }\OperatorTok{*}\NormalTok{ arg }\OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{));}  \CommentTok{// arccosh(arg)}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ p }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Mouse position as center}
    \DataTypeTok{vec2}\NormalTok{ mouse }\OperatorTok{=}\NormalTok{ iMouse}\OperatorTok{.}\FunctionTok{xy} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{iMouse}\OperatorTok{.}\FunctionTok{z} \OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)}\NormalTok{ mouse }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{);}
\NormalTok{    mouse }\OperatorTok{=} \OperatorTok{(}\NormalTok{mouse }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    mouse}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ center }\OperatorTok{=}\NormalTok{ mouse }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Hyperbolic distance}
    \DataTypeTok{float}\NormalTok{ dist }\OperatorTok{=} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ center}\OperatorTok{);}
    
    \CommentTok{// Draw a hyperbolic disk using two "circles"}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \FloatTok{0.5}\OperatorTok{;}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}  \CommentTok{// Background}
    
    \CommentTok{// Outer boundary}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{+} \FloatTok{0.05}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.3}\OperatorTok{);}  \CommentTok{// Yellow ring}
    \OperatorTok{\}}
    
    \CommentTok{// Inner region}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{dist }\OperatorTok{\textless{}}\NormalTok{ radius }\OperatorTok{{-}} \FloatTok{0.05}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.4}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Blue interior}
    \OperatorTok{\}}
    
    \CommentTok{// Draw center}
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ center}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.1}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside upper half{-}plane}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{p}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H3a. Single Vertical Geodesic
Half-Space}\label{h3a.-single-vertical-geodesic-half-space}

Visualizes one side of a vertical geodesic (hyperbolic ``line'').

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Vertical geodesic at x = 0, showing right side (x \textgreater{} 0)}
    \DataTypeTok{float}\NormalTok{ x\_pos }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ side }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}  \CommentTok{// side = {-}1.0 means x \textgreater{} x\_pos}
    
    \CommentTok{// Check which side we\textquotesingle{}re on}
    \DataTypeTok{bool}\NormalTok{ on\_right\_side }\OperatorTok{=} \OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=}\NormalTok{ on\_right\_side }\OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
    \CommentTok{// Draw the geodesic (vertical line)}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside upper half{-}plane}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H3b. Single Circular Geodesic
Half-Space}\label{h3b.-single-circular-geodesic-half-space}

Visualizes one side of a semicircular geodesic.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Semicircular geodesic from p to q on real axis}
    \DataTypeTok{float}\NormalTok{ p }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ q }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    
    \CommentTok{// Distance from center}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    
    \CommentTok{// side = 1.0 means outside the circle}
    \DataTypeTok{float}\NormalTok{ side }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{bool}\NormalTok{ outside\_circle }\OperatorTok{=} \OperatorTok{(}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{;}
    
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=}\NormalTok{ outside\_circle }\OperatorTok{?} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.3}\OperatorTok{,} \FloatTok{0.5}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.1}\OperatorTok{,} \FloatTok{0.1}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{);}
    
    \CommentTok{// Draw the geodesic (semicircle)}
    \DataTypeTok{float}\NormalTok{ dist\_to\_circle }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{rel}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{0.0} \OperatorTok{\&\&}\NormalTok{ dist\_to\_circle }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside upper half{-}plane}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H3c. Three Geodesics Additively Colored (Building the
Triangle)}\label{h3c.-three-geodesics-additively-colored-building-the-triangle}

Shows the three geodesics of the (2,3,∞) triangle using additive
coloring.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Three geodesics of (2,3,∞) triangle}
    \CommentTok{// Left vertical line: x = {-}1, want x \textgreater{} {-}1}
    \DataTypeTok{bool}\NormalTok{ inside\_left }\OperatorTok{=} \OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \OperatorTok{({-}}\FloatTok{1.0}\OperatorTok{))} \OperatorTok{*} \OperatorTok{({-}}\FloatTok{1.0}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
    
    \CommentTok{// Right vertical line: x = 1, want x \textless{} 1}
    \DataTypeTok{bool}\NormalTok{ inside\_right }\OperatorTok{=} \OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{)} \OperatorTok{*} \FloatTok{1.0} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{;}
    
    \CommentTok{// Semicircle from {-}1 to 1, want outside (above)}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \FloatTok{0.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \FloatTok{1.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    \DataTypeTok{bool}\NormalTok{ inside\_circle }\OperatorTok{=} \OperatorTok{(}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*} \FloatTok{1.0} \OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{;}
    
    \CommentTok{// Additive coloring}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{);}
    
    \KeywordTok{if}\OperatorTok{(}\NormalTok{inside\_left}\OperatorTok{)}\NormalTok{   color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{inside\_right}\OperatorTok{)}\NormalTok{  color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{inside\_circle}\OperatorTok{)}\NormalTok{ color }\OperatorTok{+=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.15}\OperatorTok{,} \FloatTok{0.2}\OperatorTok{,} \FloatTok{0.25}\OperatorTok{);}
    
    \CommentTok{// Draw the three geodesics}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \OperatorTok{({-}}\FloatTok{1.0}\OperatorTok{))} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Left line}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}     \CommentTok{// Right line}
    
    \DataTypeTok{float}\NormalTok{ dist\_to\_circle }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{rel}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ radius}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{0.0} \OperatorTok{\&\&}\NormalTok{ dist\_to\_circle }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{);}  \CommentTok{// Semicircle}
    
    \CommentTok{// Darken outside upper half{-}plane}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H4. Basic (2,3,∞) Triangle
Tiling}\label{h4.-basic-23-triangle-tiling}

Complete hyperbolic triangle tiling with simple coloring.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ x\_pos}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\NormalTok{    z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ x\_pos }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ q}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
    
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ rel }\OperatorTok{/}\NormalTok{ dist2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Shift to upper half{-}plane (need y \textgreater{} 0)}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Fold into the (2,3,∞) triangle}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ z\_old }\OperatorTok{=}\NormalTok{ z}\OperatorTok{;}
        
        \CommentTok{// Reflect across left vertical line (x = {-}1, want x \textgreater{} {-}1)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// Reflect across right vertical line (x = 1, want x \textless{} 1)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// Reflect across semicircle (from {-}1 to 1, want outside/above)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// If point didn\textquotesingle{}t move, we\textquotesingle{}re inside}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}}\NormalTok{ z\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Simple coloring}
    \DataTypeTok{vec3}\NormalTok{ color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.6}\OperatorTok{,} \FloatTok{0.7}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}
    
    \CommentTok{// Darken if below the real axis (outside hyperbolic space)}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H5. (2,3,∞) Triangle Tiling with Fold
Count}\label{h5.-23-triangle-tiling-with-fold-count}

Hyperbolic tiling colored by iteration count showing alternating
pattern.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ x\_pos}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\NormalTok{    z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ x\_pos }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ q}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
    
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ rel }\OperatorTok{/}\NormalTok{ dist2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Shift to upper half{-}plane (need y \textgreater{} 0)}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Fold into the (2,3,∞) triangle}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ z\_old }\OperatorTok{=}\NormalTok{ z}\OperatorTok{;}
        
        \CommentTok{// Reflect across left vertical line (x = {-}1, want x \textgreater{} {-}1)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// Reflect across right vertical line (x = 1, want x \textless{} 1)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// Reflect across semicircle (from {-}1 to 1, want outside/above)}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \CommentTok{// If point didn\textquotesingle{}t move, we\textquotesingle{}re inside}
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}}\NormalTok{ z\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by fold count parity}
    \DataTypeTok{float}\NormalTok{ parity }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{parity }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}  \CommentTok{// Light blue}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Darker blue}
    \OperatorTok{\}}
    
    \CommentTok{// Darken if below the real axis (outside hyperbolic space)}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H6. (2,3,∞) Triangle Tiling with Edges and
Vertices}\label{h6.-23-triangle-tiling-with-edges-and-vertices}

Complete hyperbolic tiling with visible structure (reference for
homework).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ x\_pos}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\NormalTok{    z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ x\_pos }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ q}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
    
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ rel }\OperatorTok{/}\NormalTok{ dist2}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{float} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z1}\OperatorTok{,} \DataTypeTok{vec2}\NormalTok{ z2}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ diff }\OperatorTok{=}\NormalTok{ z1 }\OperatorTok{{-}}\NormalTok{ z2}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ diff2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{diff}\OperatorTok{,}\NormalTok{ diff}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ z1}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ z2}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ arg }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+}\NormalTok{ diff2 }\OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
    \KeywordTok{return} \BuiltInTok{log}\OperatorTok{(}\NormalTok{arg }\OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\NormalTok{arg }\OperatorTok{*}\NormalTok{ arg }\OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{));}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{4.0}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    
    \CommentTok{// Shift to upper half{-}plane (need y \textgreater{} 0)}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=}\NormalTok{ uv }\OperatorTok{+} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{1.5}\OperatorTok{);}
    
    \CommentTok{// Fold into the (2,3,∞) triangle}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ z\_old }\OperatorTok{=}\NormalTok{ z}\OperatorTok{;}
        
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}}\NormalTok{ z\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by fold count parity}
    \DataTypeTok{float}\NormalTok{ parity }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{parity }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}  \CommentTok{// Light blue}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Darker blue}
    \OperatorTok{\}}
    
    \CommentTok{// Draw geodesic edges}
    \CommentTok{// Left vertical line (x = {-}1)}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \OperatorTok{({-}}\FloatTok{1.0}\OperatorTok{))} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Right vertical line (x = 1)}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Semicircle from {-}1 to 1}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist\_to\_circle }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{rel}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textgreater{}} \FloatTok{0.0} \OperatorTok{\&\&}\NormalTok{ dist\_to\_circle }\OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
    \OperatorTok{\}}
    
    \CommentTok{// Draw vertices using hyperbolic distance}
    \DataTypeTok{vec2}\NormalTok{ v1 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.01}\OperatorTok{);}  \CommentTok{// Left vertex (slightly above axis)}
    \DataTypeTok{vec2}\NormalTok{ v2 }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.01}\OperatorTok{);}   \CommentTok{// Right vertex}
    
    \KeywordTok{if}\OperatorTok{(}\FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ v1}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.15} \OperatorTok{||} \FunctionTok{hyperbolicDistance}\OperatorTok{(}\NormalTok{z}\OperatorTok{,}\NormalTok{ v2}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.15}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Red vertices}
    \OperatorTok{\}}
    
    \CommentTok{// Darken if below the real axis}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H7. Poincaré Disk Model}\label{h7.-poincaruxe9-disk-model}

Same (2,3,∞) tiling displayed in the Poincaré disk using the Cayley
transform.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ x\_pos}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\NormalTok{    z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ x\_pos }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ q}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
    
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ rel }\OperatorTok{/}\NormalTok{ dist2}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Cayley transform: Poincaré disk {-}\textgreater{} Upper half{-}plane}
\DataTypeTok{vec2} \FunctionTok{cayleyDiskToUHP}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// z = i(1{-}w)/(1+w)}
    \DataTypeTok{vec2}\NormalTok{ numer }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}  \CommentTok{// i(1{-}w) = i {-} iw}
    \DataTypeTok{vec2}\NormalTok{ denom }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0} \OperatorTok{+}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}    \CommentTok{// 1 + w}
    
    \DataTypeTok{float}\NormalTok{ denom\_mag2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{denom}\OperatorTok{,}\NormalTok{ denom}\OperatorTok{);}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
        \OperatorTok{(}\NormalTok{numer}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ numer}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom\_mag2}\OperatorTok{,}
        \OperatorTok{(}\NormalTok{numer}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ numer}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom\_mag2}
    \OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Inverse Cayley: Upper half{-}plane {-}\textgreater{} Poincaré disk}
\DataTypeTok{vec2} \FunctionTok{cayleyUHPToDisk}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{)} \OperatorTok{\{}
    \CommentTok{// w = (z{-}i)/(z+i)}
    \DataTypeTok{vec2}\NormalTok{ numer }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{);}    \CommentTok{// z {-} i}
    \DataTypeTok{vec2}\NormalTok{ denom }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ z}\OperatorTok{.}\FunctionTok{y} \OperatorTok{+} \FloatTok{1.0}\OperatorTok{);}    \CommentTok{// z + i}
    
    \DataTypeTok{float}\NormalTok{ denom\_mag2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{denom}\OperatorTok{,}\NormalTok{ denom}\OperatorTok{);}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
        \OperatorTok{(}\NormalTok{numer}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ numer}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom\_mag2}\OperatorTok{,}
        \OperatorTok{(}\NormalTok{numer}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ numer}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom\_mag2}
    \OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup for Poincaré disk}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ w }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}  \CommentTok{// Point in Poincaré disk}
    
    \CommentTok{// Convert to upper half{-}plane}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \FunctionTok{cayleyDiskToUHP}\OperatorTok{(}\NormalTok{w}\OperatorTok{);}
    
    \CommentTok{// Fold into the (2,3,∞) triangle (in UHP)}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ z\_old }\OperatorTok{=}\NormalTok{ z}\OperatorTok{;}
        
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}}\NormalTok{ z\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by fold count parity}
    \DataTypeTok{float}\NormalTok{ parity }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{parity }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}  \CommentTok{// Light blue}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Darker blue}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside unit disk}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{w}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Draw boundary circle}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{w}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Yellow boundary}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{H8. Klein Disk Model}\label{h8.-klein-disk-model}

Same tiling in the Klein model where geodesics appear as straight lines.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{vec2} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ x\_pos}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ x\_pos}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textless{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\NormalTok{    z}\OperatorTok{.}\FunctionTok{x} \OperatorTok{=} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ x\_pos }\OperatorTok{{-}}\NormalTok{ z}\OperatorTok{.}\FunctionTok{x}\OperatorTok{;}
    \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{vec2} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ z}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ p}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ q}\OperatorTok{,} \DataTypeTok{float}\NormalTok{ side}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ center }\OperatorTok{=} \OperatorTok{(}\NormalTok{p }\OperatorTok{+}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{float}\NormalTok{ radius }\OperatorTok{=} \BuiltInTok{abs}\OperatorTok{(}\NormalTok{p }\OperatorTok{{-}}\NormalTok{ q}\OperatorTok{)} \OperatorTok{/} \FloatTok{2.0}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ rel }\OperatorTok{=}\NormalTok{ z }\OperatorTok{{-}} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ dist2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{rel}\OperatorTok{,}\NormalTok{ rel}\OperatorTok{);}
    \KeywordTok{if}\OperatorTok{((}\NormalTok{dist2 }\OperatorTok{{-}}\NormalTok{ radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ side }\OperatorTok{\textgreater{}} \FloatTok{0.0}\OperatorTok{)} \KeywordTok{return}\NormalTok{ z}\OperatorTok{;}
    
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}\NormalTok{center}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{)} \OperatorTok{+} \OperatorTok{(}\NormalTok{radius }\OperatorTok{*}\NormalTok{ radius}\OperatorTok{)} \OperatorTok{*}\NormalTok{ rel }\OperatorTok{/}\NormalTok{ dist2}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Poincaré disk {-}\textgreater{} Klein disk}
\DataTypeTok{vec2} \FunctionTok{poincareToKlein}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ w\_mag2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{w}\OperatorTok{,}\NormalTok{ w}\OperatorTok{);}
    \KeywordTok{return} \FloatTok{2.0} \OperatorTok{*}\NormalTok{ w }\OperatorTok{/} \OperatorTok{(}\FloatTok{1.0} \OperatorTok{+}\NormalTok{ w\_mag2}\OperatorTok{);}
\OperatorTok{\}}

\CommentTok{// Klein disk {-}\textgreater{} Poincaré disk}
\DataTypeTok{vec2} \FunctionTok{kleinToPoincare}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ p}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{float}\NormalTok{ p\_mag2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ p}\OperatorTok{);}
    \DataTypeTok{float}\NormalTok{ denom }\OperatorTok{=} \FloatTok{1.0} \OperatorTok{+} \BuiltInTok{sqrt}\OperatorTok{(}\FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ p\_mag2}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ p }\OperatorTok{/}\NormalTok{ denom}\OperatorTok{;}
\OperatorTok{\}}

\CommentTok{// Cayley transform: Poincaré disk {-}\textgreater{} Upper half{-}plane}
\DataTypeTok{vec2} \FunctionTok{cayleyDiskToUHP}\OperatorTok{(}\DataTypeTok{vec2}\NormalTok{ w}\OperatorTok{)} \OperatorTok{\{}
    \DataTypeTok{vec2}\NormalTok{ numer }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{({-}}\NormalTok{w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{,} \FloatTok{1.0} \OperatorTok{{-}}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ denom }\OperatorTok{=} \DataTypeTok{vec2}\OperatorTok{(}\FloatTok{1.0} \OperatorTok{+}\NormalTok{ w}\OperatorTok{.}\FunctionTok{x}\OperatorTok{,}\NormalTok{ w}\OperatorTok{.}\FunctionTok{y}\OperatorTok{);}
    
    \DataTypeTok{float}\NormalTok{ denom\_mag2 }\OperatorTok{=} \BuiltInTok{dot}\OperatorTok{(}\NormalTok{denom}\OperatorTok{,}\NormalTok{ denom}\OperatorTok{);}
    \KeywordTok{return} \DataTypeTok{vec2}\OperatorTok{(}
        \OperatorTok{(}\NormalTok{numer}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{x} \OperatorTok{+}\NormalTok{ numer}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom\_mag2}\OperatorTok{,}
        \OperatorTok{(}\NormalTok{numer}\OperatorTok{.}\FunctionTok{y} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{x} \OperatorTok{{-}}\NormalTok{ numer}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*}\NormalTok{ denom}\OperatorTok{.}\FunctionTok{y}\OperatorTok{)} \OperatorTok{/}\NormalTok{ denom\_mag2}
    \OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{void} \FunctionTok{mainImage}\OperatorTok{(}\DataTypeTok{out} \DataTypeTok{vec4}\NormalTok{ fragColor}\OperatorTok{,} \DataTypeTok{in} \DataTypeTok{vec2}\NormalTok{ fragCoord}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// Coordinate setup for Klein disk}
    \DataTypeTok{vec2}\NormalTok{ uv }\OperatorTok{=}\NormalTok{ fragCoord }\OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{xy}\OperatorTok{;}
\NormalTok{    uv }\OperatorTok{=} \OperatorTok{(}\NormalTok{uv }\OperatorTok{{-}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{*} \FloatTok{2.5}\OperatorTok{;}
\NormalTok{    uv}\OperatorTok{.}\FunctionTok{x} \OperatorTok{*=}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{x} \OperatorTok{/}\NormalTok{ iResolution}\OperatorTok{.}\FunctionTok{y}\OperatorTok{;}
    \DataTypeTok{vec2}\NormalTok{ k }\OperatorTok{=}\NormalTok{ uv}\OperatorTok{;}  \CommentTok{// Point in Klein disk}
    
    \CommentTok{// Convert Klein {-}\textgreater{} Poincaré {-}\textgreater{} Upper half{-}plane}
    \DataTypeTok{vec2}\NormalTok{ w }\OperatorTok{=} \FunctionTok{kleinToPoincare}\OperatorTok{(}\NormalTok{k}\OperatorTok{);}
    \DataTypeTok{vec2}\NormalTok{ z }\OperatorTok{=} \FunctionTok{cayleyDiskToUHP}\OperatorTok{(}\NormalTok{w}\OperatorTok{);}
    
    \CommentTok{// Fold into the (2,3,∞) triangle (in UHP)}
    \DataTypeTok{int}\NormalTok{ foldCount }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \KeywordTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{50}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)} \OperatorTok{\{}
        \DataTypeTok{vec2}\NormalTok{ z\_old }\OperatorTok{=}\NormalTok{ z}\OperatorTok{;}
        
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoVertical}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\NormalTok{        z }\OperatorTok{=} \FunctionTok{reflectIntoCircular}\OperatorTok{(}\NormalTok{z}\OperatorTok{,} \OperatorTok{{-}}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
        
        \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{z }\OperatorTok{{-}}\NormalTok{ z\_old}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.0001}\OperatorTok{)} \KeywordTok{break}\OperatorTok{;}
\NormalTok{        foldCount}\OperatorTok{++;}
    \OperatorTok{\}}
    
    \CommentTok{// Color by fold count parity}
    \DataTypeTok{float}\NormalTok{ parity }\OperatorTok{=} \BuiltInTok{mod}\OperatorTok{(}\DataTypeTok{float}\OperatorTok{(}\NormalTok{foldCount}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}
    \DataTypeTok{vec3}\NormalTok{ color}\OperatorTok{;}
    \KeywordTok{if}\OperatorTok{(}\NormalTok{parity }\OperatorTok{\textless{}} \FloatTok{0.5}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.7}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{,} \FloatTok{0.9}\OperatorTok{);}  \CommentTok{// Light blue}
    \OperatorTok{\}} \KeywordTok{else} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{0.5}\OperatorTok{,} \FloatTok{0.6}\OperatorTok{,} \FloatTok{0.8}\OperatorTok{);}  \CommentTok{// Darker blue}
    \OperatorTok{\}}
    
    \CommentTok{// Darken outside unit disk}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{k}\OperatorTok{)} \OperatorTok{\textgreater{}} \FloatTok{1.0}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{*=} \FloatTok{0.3}\OperatorTok{;}
    \OperatorTok{\}}
    
    \CommentTok{// Draw boundary circle}
    \KeywordTok{if}\OperatorTok{(}\BuiltInTok{abs}\OperatorTok{(}\BuiltInTok{length}\OperatorTok{(}\NormalTok{k}\OperatorTok{)} \OperatorTok{{-}} \FloatTok{1.0}\OperatorTok{)} \OperatorTok{\textless{}} \FloatTok{0.02}\OperatorTok{)} \OperatorTok{\{}
\NormalTok{        color }\OperatorTok{=} \DataTypeTok{vec3}\OperatorTok{(}\FloatTok{1.0}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{,} \FloatTok{0.0}\OperatorTok{);}  \CommentTok{// Yellow boundary}
    \OperatorTok{\}}
    
\NormalTok{    fragColor }\OperatorTok{=} \DataTypeTok{vec4}\OperatorTok{(}\NormalTok{color}\OperatorTok{,} \FloatTok{1.0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{Notes on Using These
Shaders}\label{notes-on-using-these-shaders-2}

\subsection{Getting Started}\label{getting-started-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Go to https://www.shadertoy.com/new
\item
  Delete the default code
\item
  Copy and paste any of the above listings
\item
  Click the play button (▶) or press Alt+Enter
\end{enumerate}

\subsection{Modifying Parameters}\label{modifying-parameters-2}

\textbf{Euclidean Tilings:} - Adjust fold iteration count (20 is
conservative, 10 often sufficient) - Change fundamental domain by
modifying half-space parameters - Experiment with different shapes
(triangles, pentagons, hexagons) - Try different color palettes

\textbf{Hyperbolic Tilings:} - Mouse interaction in H1/H2 (click and
drag to move center) - Adjust the shift in
\texttt{z\ =\ uv\ +\ vec2(0.0,\ 1.5)} to change visible region -
Increase iteration count (50) for more precision near boundaries - Try
different triangle configurations (requires computing new geodesics)

\subsection{Performance Tips}\label{performance-tips-1}

If a shader runs slowly: - Reduce iteration count - Lower resolution in
Shadertoy settings - Simplify edge/vertex drawing code

\subsection{Exploring Further}\label{exploring-further-1}

\textbf{Euclidean extensions:} - Implement other regular tilings
(hexagons, pentagons) - Add animations by making half-spaces
time-dependent - Create compound patterns with multiple fundamental
domains

\textbf{Hyperbolic extensions:} - Implement (2,3,7) or (2,4,6) triangles
- Decorate fundamental domains with patterns (Escher-style) - Explore
pentagon tilings - Animate between different models

\subsection{Key Observations}\label{key-observations}

\textbf{Euclidean vs Hyperbolic:} Compare E7 and H4 - notice how the
algorithm structure is identical but the reflection operations differ.
This demonstrates the power of mathematical abstraction!

\textbf{Model Comparisons:} Run H4 (upper half-plane), H7 (Poincaré
disk), and H8 (Klein disk) side by side. The same mathematical object
looks dramatically different depending on the model, but the underlying
hyperbolic geometry is identical.

\textbf{Edge Behavior:} In H6, notice how triangle edges near the
boundary (y → 0) appear more compressed. This visualizes the 1/y²
conformal factor in the hyperbolic metric.

\chapter{GLSL}\label{glsl}


\backmatter


\end{document}
