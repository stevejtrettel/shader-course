# Outline {.unnumbered}


## Course Overview

This mini-course introduces shader programming as a tool for mathematical illustration and exploration. Shaders are programs that run in parallel on the GPU, making them exceptionally fast for visualization tasks. We'll learn to write code that "reads like mathematics" using Shadertoy, a beginner-friendly web-based platform that handles all the low-level programming complexities.

**Format:** Five days, each with one hour of lecture and approximately 1.5 hours of required homework, additional hours of optional homework (for those looking to really develop some of the skills, either during the course or after)

**Prerequisites:** Strong foundation in undergraduate mathematics; no prior experience with shaders or GLSL required

## Day 1: Introduction to Shader Programming

### Learning Objectives

- Understand the mathematical model of shader programming (function from pixels to colors)
- Learn basic GLSL syntax and conventions
- Master coordinate system setup and distance calculations
- Create simple geometric shapes and patterns

### In-Class Content

#### Mathematical Introduction
- What is a shader? Framing as a function: `color = f(x, y, time, ...)`
- Why GPUs? Parallelism means computing ALL pixels simultaneously
- Shadertoy overview: available uniforms (`iResolution`, `iTime`, `iMouse`)

#### First Shader: Solid Colors
- Basic shader structure: `void mainImage(out vec4 fragColor, in vec2 fragCoord)`
- Setting `fragColor = vec4(1.0, 0.0, 0.0, 1.0)` for a red screen
- GLSL syntax basics: semicolons, vector types, swizzling
- Animating colors with `iTime`

#### Coordinate System Setup
- Converting `fragCoord` to centered, normalized coordinates
- Standard boilerplate for coordinate transformation
- Handling aspect ratio correctly

#### Half-Plane Coloring
- Boolean expressions: `x < 0.0`
- Conditional coloring with ternary operator or `step()` function
- Generalizing to arbitrary lines: `ax + by < 0`

#### Circles and Distance Fields
- Computing distance to center with `length(p)`
- Filled circle: `length(p) < radius`
- Circle outline: `abs(length(p) - radius) < thickness`
- Optional: Color gradients based on distance

#### Grids and Repetition
- Using `mod(p, spacing)` to create repeating cells
- Creating a grid of circles
- Alternating patterns with `mod(floor(p), 2.0)`

### Homework

#### Required: Parabola Graphing Calculator
Create a shader that draws a parabola with customizable coefficients:
- Draw x and y axes (thick lines at x=0 and y=0)
- Define variables: `float a = 1.0; float b = 0.0; float c = 0.0;`
- Plot the curve `y = ax² + bx + c` as a thick tube
- Should handle any hardcoded values of a, b, c

#### Optional #1: Animated Curve Family
- Use `iTime` to vary parameters and animate a family of curves
- Suggestions: elliptic fibration, Lissajous curves, morphing shapes

#### Optional #2: Beautiful Tiling Pattern
- Design a pattern within a fundamental square
- Use `mod()` to tile it across the screen
- Focus on aesthetic appeal and mathematical structure







## Day 2: Complex Dynamics and Euclidean Geometry

### Learning Objectives

- Implement complex number arithmetic in GLSL
- Understand and render the Mandelbrot and Julia sets
- Create geometric tilings using mathematical transformations
- Learn to use structs for organizing data

### In-Class Content

#### Complex Numbers in GLSL
- Representing complex numbers as `vec2`
- Implementing complex multiplication
- Complex addition, conjugation, and magnitude

#### The Mandelbrot Set
- Mathematical definition: iterating `z → z² + c` with `z₀ = 0`
- Escape-time algorithm
- Coloring schemes based on iteration count
- Discussing convergence and divergence

#### Julia Sets
- Fixing `c` and varying initial `z`
- Relationship to Mandelbrot set
- Creating visually interesting Julia sets

#### Introduction to Structs
- Defining struct types in GLSL
- Use case: organizing geometric data
- Example: storing triangle vertices or transformation data

#### Euclidean Triangle Tiling
- Fundamental domain for triangular tiling
- Reflection across edges to create periodic patterns
- Symmetry groups and transformations


### Homework

#### Required: Circle Inversion
- Implement circle inversion as an operation on the plane
- For a circle of radius `R` centered at origin: `p' = R² * p / |p|²`
- For a circle centered at `c` with radius `R`: translate, invert, translate back
- Visualize by applying inversion to a grid or pattern
- Demonstrate that circles through the inversion center become lines, and vice versa

#### Optional #1: Apollonian Gasket
- Use your circle inversion implementation
- Start with three mutually tangent circles
- Repeatedly invert through each circle
- Color by iteration count or which circle was inverted through
- Explore the fractal structure created by nested circles


---

## Day 3: Fractals and Hyperbolic Geometry

### Learning Objectives

- Extend folding techniques to box fractals
- Understand hyperbolic geometry models and their properties
- Implement computations in the upper half-plane model
- Create hyperbolic tilings using inversions and Möbius transformations
- Convert between different models of hyperbolic geometry

### In-Class Content

#### Review: Sierpinski Triangle via Folding
- Generating fractals through iterated reflections
- Using `abs()` for geometric folding
- Scaling and iteration
- Coloring by iteration depth or distance

#### Introduction to Hyperbolic Geometry
- Why hyperbolic space? Negative curvature vs. Euclidean geometry
- Three primary models: Poincaré disk, upper half-plane, and band model
- How models are related via Möbius transformations
- Properties: geodesics, distance, angle measurement

#### Computations in the Upper Half-Plane Model
- Definition: points `{z : Im(z) > 0}`
- Geodesics: vertical lines and semicircles perpendicular to real axis
- Distance formula in the upper half-plane
- Möbius transformations as isometries: `z → (az + b)/(cz + d)` with `ad - bc = 1`
- Matrix representation of transformations

#### Hyperbolic Triangle Tiling
- Setting up a hyperbolic triangle (angles sum to < π)
- Computing geodesics as circular arcs
- Implementing circle inversion for reflections across geodesics
- Folding points into fundamental domain
- Iterating to create the full tiling
- Coloring by domain or iteration behavior

#### Drawing in Different Models
- Converting between Poincaré disk and upper half-plane
- Möbius transformation: `w = i(1-z)/(1+z)` (disk to half-plane)
- Band model via additional Möbius transformation
- Visualizing the same tiling in multiple models simultaneously


### Homework

#### Required: Sierpinski Carpet
- Implement the 2D Sierpinski carpet using box folding
- Use `abs()` to create 4-fold symmetry
- Scale by 3 at each iteration, removing middle square
- Color by iteration depth or distance
- Experiment with different iteration counts

#### Required: Model Conversion and Möbius Transformation
- Convert your hyperbolic tiling from upper half-plane to Poincaré disk (or vice versa)
- Apply a Möbius transformation to your tiling (choose your own or use a suggested one)
- Render both the original and transformed tiling
- Observe how the transformation affects the visual appearance

#### Optional: Advanced Explorations
1. **Another Triangle Group:** Implement a different hyperbolic triangle group (e.g., (2,3,7), (2,4,6))
2. **Klein Model:** Convert to Klein model via Cayley transform
3. **Conformal Art:** Use complex analysis to map to creative domains
4. **Decorated Tiles:** Create Escher-style decorated tiles



## Day 4: Introduction to 3D Rendering

### Learning Objectives

- Understand ray setup and camera models
- Implement analytical ray-object intersection
- Learn the raymarching algorithm and signed distance functions
- Apply basic lighting models (diffuse shading)

### In-Class Content

#### Ray Setup and Camera Model
- Defining ray origin and direction from pixel coordinates
- Simple camera model: position, look-at, up vector
- Field of view and perspective projection

#### Analytical Ray-Sphere Intersection
- Deriving the intersection equation (quadratic)
- Solving for intersection parameter `t`
- Computing surface normal at intersection point
- Rendering the sphere with flat color

#### Ray-Torus Intersection
- Implicit equation for a torus
- Computing gradient for surface normal
- Discussion: analytical methods become complex quickly

#### Motivation for Raymarching
- Combining multiple objects is difficult with analytical methods
- Boolean operations (union, intersection) are hard
- Arbitrary implicit surfaces require root-finding

#### Signed Distance Functions (SDFs)
- Mathematical definition: minimum distance to surface
- SDFs for basic primitives: sphere, box, plane, torus, cylinder
- Properties: Lipschitz continuity and safe marching

#### The Raymarching Algorithm
- Sphere tracing: march along ray by the distance to nearest surface
- Stopping conditions: hit surface, max iterations, or exit bounds
- Estimating normals via gradient of the SDF

#### Basic Lighting
- Computing surface normal from SDF gradient
- Diffuse shading: dot product with light direction
- Simple Lambertian lighting model

### Homework

#### Required: Algebraic Variety Rendering
- Choose a polynomial implicit surface (degree 3 or 4)
- Implement root-finding algorithm (bisection, Newton's method, etc.)
- Use gradient for directional derivative to estimate distance
- Optimization: use sphere bounding box (outside sphere → return sphere SDF, inside → compute polynomial distance)

#### Optional: Advanced Lighting and Transformations
1. **Specular Lighting:** Implement Phong or Blinn-Phong model
2. **Transformations:** Use rotation matrices to orient objects in the scene
3. **Complex Scene:** Combine multiple transformed objects with analytical intersections

---

## Day 5: Choose Your Adventure

The final day will be determined based on pacing, student interest, and energy levels. Most likely we will actually use the day to slow down as previous topics or questions took more time.  If we do have the available time for new content, then there will be two choices for the class:

### Option A: Advanced Raymarching Techniques

#### Learning Objectives
- Master domain operations for efficient complex scenes
- Understand and apply boolean operations on SDFs
- Create 3D fractals via iterated folding
- Build sophisticated mathematical visualizations

#### In-Class Content

##### Domain Operations
- **Repetition:** Using `mod(p, spacing)` for infinite grids of objects
- **Symmetry:** Using `abs()` for mirror planes
- **Polar repetition:** Radial patterns around an axis
- **Computational advantage:** Zero cost for infinite complexity

##### Boolean Operations on SDFs
- **Union:** `min(d1, d2)`
- **Intersection:** `max(d1, d2)`
- **Subtraction:** `max(d1, -d2)`
- **Smooth minimum:** `smin()` for organic blending
- Building complex shapes from primitive combinations

##### The Menger Sponge
- Box folding in 3D with axis-aligned planes
- Iterated subdivision pattern
- Scaling and repetition
- Connection to Day 2's Sierpinski carpet

##### Advanced Examples
- Architectural structures via boolean operations
- Infinite repeated patterns via domain operations
- Combining techniques for rich scenes

#### Projects (not homework, as class is over!)

##### Creative Scene Building
- Build a complex scene using domain operations and boolean combinations
- Experiment with different SDFs and transformations
- Focus on mathematical or aesthetic interest

##### Sierpinski Tetrahedron
- Implement 3D Sierpinski tetrahedron via folding
- Reflect across four planes (non-axis-aligned)
- Connection to Day 2's triangle folding in higher dimension

---

### Option B: Buffers and Temporal Dynamics

#### Learning Objectives
- Understand buffer-based computation in Shadertoy
- Implement differential operators (Laplacian)
- Solve partial differential equations on the GPU
- Create dynamic, evolving mathematical systems

#### In-Class Content

##### Introduction to Buffers
- Reading from previous frame: `texture(iChannel0, uv)`
- Multi-pass rendering in Shadertoy
- Simple example: reading buffer and applying conditional coloring (bright → yellow, dark → blue)

##### Edge Detection and the Laplacian
- Discrete Laplacian stencil (5-point or 9-point)
- Sampling neighboring pixels
- Visualizing edges in imagery
- Introduction to spatial derivatives on discrete grids

##### The Heat Equation
- Mathematical formulation: `u_t = α∇²u`
- Applying the Laplacian stencil for diffusion
- Time-stepping: `u_new = u_old + dt * α * laplacian(u_old)`
- Initial conditions: heat distribution in a fractal or Julia set
- Watching the pattern blur and diffuse

##### Boundary Conditions
- Zero boundary conditions (edges set to 0)
- Avoiding wrap-around artifacts
- Discussion of periodic boundaries (if time)

##### Timestep Stability
- CFL condition (briefly mentioned)
- Providing a stable `dt` value
- Warning: don't make timestep too large!

#### Projects

#####  Interactive Heat Equation or Reaction-Diffusion
1. **Interactive Heat Source:** Add heat at mouse position, watch it diffuse
2. **Gray-Scott Reaction-Diffusion:** Implement pattern formation (spots, stripes, etc.) - store U and V in different color channels

##### Wave Equation
- Requires two buffers (current and previous state)
- Implement `u_tt = c²∇²u`
- Initial conditions: pluck a "string" or create a disturbance
- Watch waves propagate and reflect

---

<!-- ## Resources and References

### Shadertoy
- Main site: https://www.shadertoy.com
- Example shaders to explore
- Community forum for questions

### GLSL References
- OpenGL Shading Language specification
- Shadertoy-specific uniforms and functions
- Common mathematical functions

### Mathematical Background
- Complex dynamics and fractals
- Hyperbolic geometry and tilings
- Signed distance functions and implicit surfaces
- Numerical PDE methods

### Further Exploration
- Advanced rendering techniques (path tracing, global illumination)
- Non-Euclidean ray tracing
- GPU computing for scientific visualization
 -->
