# Day 3: Geometric Tilings in Euclidean and Hyperbolic Space

## Overview

Today we explore geometric tilings through reflection operations. We'll start with triangle tilings in Euclidean space, then venture into hyperbolic geometry where the same techniques produce dramatically different patterns. We'll work primarily in the upper half-plane model, learning to compute with geodesics and the hyperbolic metric, then transform our work into the Poincaré disk for visualization.

By the end of today, you'll understand how reflection-based tiling algorithms work across different geometries, and have working implementations of both Euclidean and hyperbolic tilings.

---

## Euclidean Triangle Tiling

### The Fundamental Domain

An equilateral triangle tiles the Euclidean plane. Given an equilateral triangle, we can:
1. Reflect across its three edges
2. Repeat this process on the resulting triangles
3. Fill the entire plane with copies of the original triangle

This is a **tiling by reflection**: the entire plane is covered by reflected copies of our fundamental domain.

### Setting Up the Triangle

Let's work with an equilateral triangle with vertices at:
$$v_0 = (0, 1), \quad v_1 = \left(-\frac{\sqrt{3}}{2}, -\frac{1}{2}\right), \quad v_2 = \left(\frac{\sqrt{3}}{2}, -\frac{1}{2}\right)$$

This triangle has side length $\sqrt{3}$ and is centered at the origin.

```glsl
// Define triangle vertices
vec2 v0 = vec2(0.0, 1.0);
vec2 v1 = vec2(-0.866, -0.5);  // -sqrt(3)/2 ≈ -0.866
vec2 v2 = vec2(0.866, -0.5);
```

### Reflection Across a Line

To reflect a point $p$ across a line through the origin with unit normal $\mathbf{n}$, we use:
$$p' = p - 2(\mathbf{n} \cdot p)\mathbf{n}$$

For a line through two points (an edge of our triangle), we:
1. Compute the edge direction
2. Find the perpendicular (normal to the edge)
3. Check which side of the line we're on
4. Reflect if necessary

**Implementation for one edge:**

```glsl
vec2 reflectAcrossEdge(vec2 p, vec2 v0, vec2 v1) {
    // Edge direction
    vec2 edge = v1 - v0;
    
    // Normal to edge (perpendicular, pointing outward)
    vec2 normal = normalize(vec2(-edge.y, edge.x));
    
    // Signed distance to line
    float dist = dot(p - v0, normal);
    
    // Reflect if on the wrong side (dist < 0)
    if(dist < 0.0) {
        p = p - 2.0 * dist * normal;
    }
    
    return p;
}
```

### Iterative Folding into the Triangle

We repeatedly reflect $p$ across the three edges until it lands inside the fundamental domain:

```glsl
vec2 foldToTriangle(vec2 p, int maxIter, out int foldCount) {
    foldCount = 0;
    
    vec2 v0 = vec2(0.0, 1.0);
    vec2 v1 = vec2(-0.866, -0.5);
    vec2 v2 = vec2(0.866, -0.5);
    
    for(int i = 0; i < maxIter; i++) {
        vec2 p_old = p;
        
        // Reflect across each edge if necessary
        p = reflectAcrossEdge(p, v0, v1);
        p = reflectAcrossEdge(p, v1, v2);
        p = reflectAcrossEdge(p, v2, v0);
        
        // Check if we're done (no more reflections)
        if(length(p - p_old) < 0.0001) break;
        
        foldCount++;
    }
    
    return p;
}
```

### Visualization: Euclidean Tiling

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 4.0;
    uv.x *= iResolution.x / iResolution.y;
    vec2 p = uv;
    
    // Fold to fundamental domain
    int foldCount;
    vec2 p_folded = foldToTriangle(p, 20, foldCount);
    
    // Color based on fold count
    float t = float(foldCount) / 10.0;
    vec3 color = palette(t);  // Use palette function from Day 2
    
    fragColor = vec4(color, 1.0);
}
```

The result: a beautiful triangular tiling of the plane, colored by how many reflections were needed to reach the fundamental domain!

---

## Hyperbolic Geometry: Models and Metrics

### The Upper Half-Plane Model

The upper half-plane model $\mathbb{H}^2$ consists of complex numbers with positive imaginary part:
$$\mathbb{H}^2 = \{z \in \mathbb{C} : \text{Im}(z) > 0\}$$

The hyperbolic metric is:
$$ds^2 = \frac{dx^2 + dy^2}{y^2} = \frac{|dz|^2}{(\text{Im}(z))^2}$$

This metric "blows up" as we approach the real axis (the boundary at infinity), making the geometry shrink near $y = 0$.

### Geodesics in the Upper Half-Plane

Geodesics (hyperbolic "straight lines") in $\mathbb{H}^2$ are:
1. Vertical lines $\{x = c\}$ for constant $c$
2. Semicircles centered on the real axis, perpendicular to it

For a semicircle of radius $R$ centered at $(c, 0)$, the equation is:
$$(x - c)^2 + y^2 = R^2, \quad y > 0$$

### Hyperbolic Distance

The distance between two points $z, w \in \mathbb{H}^2$ is:
$$d(z, w) = \text{arcosh}\left(1 + \frac{|z - w|^2}{2 \cdot \text{Im}(z) \cdot \text{Im}(w)}\right)$$

In GLSL:
```glsl
float hyperbolicDistance(vec2 z, vec2 w) {
    float diff2 = dot(z - w, z - w);  // |z - w|²
    float denom = 2.0 * z.y * w.y;    // 2·Im(z)·Im(w)
    float arg = 1.0 + diff2 / denom;
    return log(arg + sqrt(arg * arg - 1.0));  // acosh(x) = log(x + sqrt(x²-1))
}
```

### The Poincaré Disk Model

The Poincaré disk model consists of the interior of the unit disk:
$$\mathbb{D}^2 = \{z \in \mathbb{C} : |z| < 1\}$$

The metric is:
$$ds^2 = \frac{4(dx^2 + dy^2)}{(1 - |z|^2)^2}$$

Geodesics are circular arcs perpendicular to the unit circle (or diameters).

### Converting Between Models

The Cayley transform maps the upper half-plane to the disk:
$$w = \frac{z - i}{z + i}$$

The inverse is:
$$z = i\frac{1 + w}{1 - w}$$

In GLSL (using complex arithmetic from Day 2):
```glsl
vec2 uhpToDisk(vec2 z) {
    // w = (z - i) / (z + i)
    vec2 numerator = z - vec2(0.0, 1.0);      // z - i
    vec2 denominator = z + vec2(0.0, 1.0);    // z + i
    return cdiv(numerator, denominator);
}

vec2 diskToUHP(vec2 w) {
    // z = i(1 + w) / (1 - w)
    vec2 numerator = vec2(0.0, 1.0) + w;      // i + iw  
    numerator = vec2(-numerator.y, numerator.x);  // Multiply by i
    vec2 denominator = vec2(1.0, 0.0) - w;    // 1 - w
    return cdiv(numerator, denominator);
}
```

---

## The (2,3,∞) Triangle in the Upper Half-Plane

### Triangle Setup

For our first hyperbolic tiling, we'll use a triangle with particularly nice edges in the upper half-plane:
- **Bottom edge**: Unit semicircle centered at origin (equation: $x^2 + y^2 = 1$, $y > 0$)
- **Left edge**: Vertical geodesic at $x = -1$
- **Right edge**: Vertical geodesic at $x = 1$

This creates a hyperbolic triangle with one ideal vertex (at infinity on the $y$-axis) and two finite vertices.

```glsl
struct Geodesic {
    int type;  // 0 = vertical line, 1 = semicircle
    vec2 data;  // For vertical: (x_pos, unused), for semicircle: (center_x, radius)
};

void setupTriangle(out Geodesic g1, out Geodesic g2, out Geodesic g3) {
    g1.type = 1;  // Semicircle
    g1.data = vec2(0.0, 1.0);  // Center at origin, radius 1
    
    g2.type = 0;  // Vertical line
    g2.data = vec2(-1.0, 0.0);  // At x = -1
    
    g3.type = 0;  // Vertical line
    g3.data = vec2(1.0, 0.0);  // At x = 1
}
```

### Checking if a Point is in the Triangle

```glsl
bool inTriangle(vec2 p) {
    // Above the semicircle: x² + y² > 1
    bool aboveSemicircle = dot(p, p) > 1.0;
    
    // Between vertical lines: -1 < x < 1
    bool betweenLines = (p.x > -1.0) && (p.x < 1.0);
    
    return aboveSemicircle && betweenLines;
}
```

### Reflection Across Geodesics

**Reflection across a vertical line $x = c$:**
$$\text{reflect}(x + iy) = (2c - x) + iy$$

```glsl
vec2 reflectVertical(vec2 p, float c) {
    return vec2(2.0 * c - p.x, p.y);
}
```

**Reflection across a semicircle (circle inversion from yesterday!):**
For a circle of radius $R$ centered at $(c_x, 0)$:

```glsl
vec2 reflectCircle(vec2 p, vec2 center, float radius) {
    vec2 diff = p - center;
    float r2 = dot(diff, diff);
    return center + (radius * radius) * diff / r2;
}
```

### Folding into the Fundamental Domain

```glsl
vec2 foldToHyperbolicTriangle(vec2 p, int maxIter, out int foldCount) {
    foldCount = 0;
    
    for(int i = 0; i < maxIter; i++) {
        bool folded = false;
        
        // Reflect across left vertical line if needed
        if(p.x < -1.0) {
            p = reflectVertical(p, -1.0);
            folded = true;
        }
        
        // Reflect across right vertical line if needed
        if(p.x > 1.0) {
            p = reflectVertical(p, 1.0);
            folded = true;
        }
        
        // Reflect across semicircle if needed
        if(dot(p, p) < 1.0) {
            p = reflectCircle(p, vec2(0.0, 0.0), 1.0);
            folded = true;
        }
        
        if(folded) foldCount++;
        else break;  // In fundamental domain
    }
    
    return p;
}
```

### Visualization: Hyperbolic Tiling

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup - map to upper half-plane
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 4.0;
    uv.x *= iResolution.x / iResolution.y;
    
    // Shift up so y > 0
    vec2 p = uv + vec2(0.0, 1.5);
    
    // Fold to fundamental domain
    int foldCount;
    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);
    
    // Color based on fold count
    float t = float(foldCount) / 10.0;
    vec3 color = palette(t);
    
    // Highlight fundamental domain
    if(inTriangle(p_folded)) {
        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The result: a beautiful hyperbolic tiling! Notice how the triangles appear to shrink near the real axis—they're all the same hyperbolic size, but Euclidean distances compress.

---

## Visualizing in the Poincaré Disk

Now we'll see the same tiling in a different model by converting coordinates.

### By Precomposition

```glsl
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    // Coordinate setup - map to disk
    vec2 uv = fragCoord / iResolution.xy;
    uv = (uv - 0.5) * 2.0;
    uv.x *= iResolution.x / iResolution.y;
    
    // Only render inside unit disk
    if(length(uv) >= 1.0) {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    
    // Convert disk coordinates to upper half-plane
    vec2 p = diskToUHP(uv);
    
    // Now do all computations in UHP
    int foldCount;
    vec2 p_folded = foldToHyperbolicTriangle(p, 20, foldCount);
    
    // Color based on fold count
    float t = float(foldCount) / 10.0;
    vec3 color = palette(t);
    
    if(inTriangle(p_folded)) {
        color = mix(color, vec3(1.0, 1.0, 1.0), 0.3);
    }
    
    fragColor = vec4(color, 1.0);
}
```

The tiling now appears in the Poincaré disk—the same mathematical object displayed in a different model!

---

## Summary

Today we covered:

1. **Euclidean triangle tiling**: Using reflections to tile the plane with equilateral triangles
2. **Hyperbolic geometry models**: Upper half-plane and Poincaré disk, with metrics and geodesics
3. **Coordinate transformations**: Cayley transform connecting the two models
4. **Hyperbolic triangle tiling**: Using reflections (including circle inversion) to tile hyperbolic space
5. **Multiple representations**: Same tiling visualized in different models

Key insights:
- **Reflection-based tilings work in any geometry** with the appropriate reflection operations
- **Circle inversion** (from Day 2) is fundamental to hyperbolic geometry
- **The same mathematical object looks different** in different models
- **Geodesics replace straight lines** as the fundamental "straight" paths

The algorithmic structure is identical across geometries—only the reflection operations change!

---

## Homework

### Required: Drawing Geodesics and Hyperbolic Disks

Implement visualization of basic hyperbolic objects to understand the geometry.

**Part 1: Draw several geodesics in the upper half-plane**

Vertical lines are easy:
```glsl
// Distance to vertical line x = c
float distToVertical = abs(p.x - c);
if(distToVertical < thickness) color = geodesicColor;
```

Semicircular geodesics require the implicit equation:
```glsl
// Semicircle: (x - cx)² + y² = R², with y > 0
float distToSemicircle = abs(sqrt((p.x - cx) * (p.x - cx) + p.y * p.y) - R);
if(distToSemicircle < thickness && p.y > 0.0) color = geodesicColor;
```

Draw several of each type to visualize the geodesic structure.

**Part 2: Draw hyperbolic disks**

A hyperbolic disk of radius $r$ centered at $z_0$ is the set:
$$\{z : d_{\text{hyp}}(z, z_0) < r\}$$

```glsl
float d = hyperbolicDistance(p, center);
if(d < radius) color = diskColor;
```

Draw several disks at different locations and with the same hyperbolic radius. Observe how they appear smaller (in Euclidean sense) near the boundary—this demonstrates the metric's behavior.

**Part 3: Visualize metric distortion**

Create a grid of hyperbolic disks of equal hyperbolic radius. Watch how their Euclidean sizes vary across the half-plane.

**Optional enhancement:** Repeat in Poincaré disk model by precomposition.

### Required: Drawing Triangle Edges and Vertices

Enhance your hyperbolic tiling by drawing the triangle boundaries.

**Task:**
For each point, compute the distance to the three geodesics forming your triangle boundary. If the distance is below a threshold, color it as an edge.

**Implementation hints:**
```glsl
// Distance to vertical line
float d1 = abs(p.x - (-1.0));
float d2 = abs(p.x - 1.0);

// Distance to semicircle (already have this from Part 1)
float d3 = abs(length(p) - 1.0);

float edgeThickness = 0.05;
bool onEdge = (d1 < edgeThickness) || (d2 < edgeThickness) || (d3 < edgeThickness);

if(onEdge) color = vec3(1.0, 1.0, 1.0);  // White edges
```

For vertices, compute Euclidean distance to the three vertex positions and draw small circles.

**Expected output:** Your tiling with clearly visible triangle boundaries, making the tessellation structure explicit.

### Required: Model Conversion and Möbius Transformation

Work with different representations of hyperbolic space.

**Part 1: Convert your tiling to Poincaré disk**

You already have the transformation functions. Create a shader that displays your hyperbolic tiling in the disk model and compare the visual appearance.

**Part 2: Apply a Möbius transformation**

A Möbius transformation has the form:
$$z \mapsto \frac{az + b}{cz + d}, \quad ad - bc = 1$$

These are isometries of hyperbolic space—they permute the tiles but preserve the geometry.

```glsl
vec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {
    vec2 num = cadd(cmul(a, z), b);
    vec2 den = cadd(cmul(c, z), d);
    return cdiv(num, den);
}
```

Try some interesting transformations:
- Translation: $z \mapsto z + 1$ (in complex plane, not hyperbolic translation!)
- Scaling: $z \mapsto 2z$
- Rotation: $z \mapsto e^{i\theta} z$

Apply to your tiling:
```glsl
// Before folding:
p = mobius(p, vec2(2.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(1.0, 0.0));
```

Watch how the tiling transforms!

### Optional: Advanced Hyperbolic Explorations

Choose one or more:

#### 1. Different Triangle Groups

Implement different hyperbolic triangle groups. The $(p, q, r)$ notation indicates angles $\pi/p$, $\pi/q$, $\pi/r$ at the three vertices.

Famous examples:
- $(2, 3, 7)$: Creates Escher-like tilings
- $(2, 4, 6)$: Different symmetry structure
- $(3, 3, 3)$: Equilateral hyperbolic triangle

Each requires setting up different geodesics for the triangle edges.

#### 2. Klein Model

The Klein model represents hyperbolic space where geodesics are Euclidean straight lines (but angles are distorted).

Convert from Poincaré disk to Klein: 
$$w = \frac{2z}{1 + |z|^2}$$

Visualize your tiling in this model and observe how geodesics become straight!

#### 3. Decorated Tiles

Add patterns inside each triangle (like Escher's Circle Limit prints). Use barycentric coordinates or distance from edges to create decorations within the fundamental domain.

#### 4. Conformal Mapping Art

Use complex analysis to map the disk to other regions (strips, annuli, etc.) and visualize hyperbolic geometry in exotic coordinate systems.

---

## Looking Ahead

Tomorrow we move to 3D! We'll learn raymarching and signed distance functions to render implicit surfaces. The geometric intuition from reflections and distance computations will carry over, but now in three dimensions with lighting and shading.

Make sure you're comfortable with:
- Reflection operations (these generalize to 3D)
- Distance computations (both Euclidean and hyperbolic)
- Iterative algorithms for geometric structures
- Working with different coordinate systems/models

See you tomorrow!
